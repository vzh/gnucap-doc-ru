# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-10-25 14:28+0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title ======
#: manual.txt:1
#, no-wrap
msgid "Gnucap manual"
msgstr ""

#. type: Plain text
#: manual.txt:4
msgid "This is a draft of the manual for the development version of gnucap."
msgstr ""

#. type: Plain text
#: manual.txt:6
msgid "It attempts to describe the latest development release."
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Introduction]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Commands]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Languages]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Howto|How to]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Compatibility]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Tech|Tech notes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid ""
"[[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Building and "
"Installation]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Examples]]\n"
msgstr ""

#. type: Title ======
#: manual/commands.txt:1 manual/languages/spectre.txt:94 manual/languages/verilog.txt:120 about/plugins/commands.txt:3 spectre.txt:66
#, no-wrap
msgid "Commands"
msgstr ""

#. type: Plain text
#: manual/commands.txt:4
msgid ""
"Gnucap commands are defined by plugins.  This section defines all commands "
"supplied in the main tarball."
msgstr ""

#. type: Plain text
#: manual/commands.txt:6
msgid ""
"Your installation may not have all of these commands, and may have others in "
"addition to these.  It depends on which plugins you have installed."
msgstr ""

#. type: Title =====
#: manual/commands.txt:7
#, no-wrap
msgid "\"Simulation\" or \"analysis\" commands"
msgstr ""

#. type: Plain text
#: manual/commands.txt:10
msgid "These commands are the core simulation commands."
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid ""
"[[gnucap:manual:commands:ac]] Performs a small signal AC (frequency domain) "
"analysis. Sweeps frequency.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid ""
"[[gnucap:manual:commands:dc]] Performs a nonlinear DC analysis, for "
"determining transfer characteristics. Sweeps DC input or component values.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid ""
"[[gnucap:manual:commands:fourier]] Transient analysis, with results in "
"frequency domain.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid ""
"[[gnucap:manual:commands:op]] Performs a nonlinear DC analysis, for "
"determining quiescent operating conditions. Sweeps temperature.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid ""
"[[gnucap:manual:commands:transient]] Performs a nonlinear transient (time "
"domain) analysis. Sweeps time.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:17 user/command_plugins.txt:9
#, no-wrap
msgid "\"Data\" commands"
msgstr ""

#. type: Plain text
#: manual/commands.txt:20
msgid "These commands manipulate the circuit."
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid ""
"[[gnucap:manual:commands:build]] Build a new circuit or change an existing "
"one.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid ""
"[[gnucap:manual:commands:delete|clear]] Delete the entire circuit, titles, "
"etc.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:delete]] Delete a part, or group of parts.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid ""
"[[gnucap:manual:commands:edit]] Edit the circuit description using your "
"editor.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid ""
"[[gnucap:manual:commands:fault|fault,unfault]] Temporarily change a "
"component.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:list]] List the circuit on the display.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid ""
"[[gnucap:manual:commands:alter|alter, modify]] Change a value, node, "
"etc. For very simple changes.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:29 user/command_plugins.txt:24
#, no-wrap
msgid "\"Parameter\" and \"Measure\" commands"
msgstr ""

#. type: Plain text
#: manual/commands.txt:32
msgid "These commands work with parameters."
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:parameter]] Set or view parameters.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid ""
"[[gnucap:manual:commands:measure]] Make (post) measurements on your "
"circuit.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:eval]] Evaluate parameters.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:37
#, no-wrap
msgid "\"Probe\" commands"
msgstr ""

#. type: Plain text
#: manual/commands.txt:40
msgid "These commands set up probes for later use."
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid ""
"[[gnucap:manual:commands:alarm]] Select points in the circuit to check "
"against limits.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid ""
"[[gnucap:manual:commands:plot|plot, iplot]] Select points in the circuit "
"(and their range) to plot.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid ""
"[[gnucap:manual:commands:print|print, iprint, probe]] Select points in the "
"circuit to print as table.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid ""
"[[gnucap:manual:commands:store]] Select points in the circuit to store for "
"post-processing.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:46 user/command_plugins.txt:32
#, no-wrap
msgid "\"File\" commands"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid ""
"[[gnucap:manual:commands:include]] Include a file from disk. Add it the what "
"is already in memory.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:lib]] Include parts of a library file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:load|load, unload]] Load a plugin.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid ""
"[[gnucap:manual:commands:get]] Get a circuit from a disk file. Deletes old "
"one first for a fresh start. (deprecated)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:save]] Save the circuit in a file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:log]] Create a log file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid ""
"[[gnucap:manual:commands:outfile|>]] Send a copy of the screen output to a "
"file.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:57 user/command_plugins.txt:45
#, no-wrap
msgid "\"Other\" commands"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid ""
"[[gnucap:manual:commands:end]] Perform analyses in queue. New circuit "
"follows. (Implemented incorrectly.)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid "[[gnucap:manual:commands:exit|exit, quit]] Exits the program.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid ""
"[[gnucap:manual:commands:options]] View and set system options. (Same as "
"set.)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:temp]] Set or view temperature.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:width]] Set output width.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid ""
"[[gnucap:manual:commands:sweep]] Sweep a component. (Loop function.) "
"(deprecated)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid ""
"[[gnucap:manual:commands:generator]] View and set the transient analysis "
"function generator.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid ""
"[[gnucap:manual:commands:freeze|freeze, unfreeze]] Mark this time point, so "
"transient analysis will restart here.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:chdir]] Change current directory.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:pause]] Wait for key hit in batch mode.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:status]] Display resource usage, etc.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid ""
"[[gnucap:manual:commands:title]] View and create the heading line for "
"printouts and files.\n"
msgstr ""

#. type: Title ======
#: manual/commands/ac.txt:1
#, no-wrap
msgid "\"ac\" command"
msgstr ""

#. type: Title =====
#: manual/commands/ac.txt:3 manual/commands/alarm.txt:3 manual/commands/alter.txt:3 manual/commands/build.txt:3 manual/commands/chdir.txt:3 manual/commands/dc.txt:3 manual/commands/delete.txt:3 manual/commands/edit.txt:3 manual/commands/eval.txt:3 manual/commands/exit.txt:4 manual/commands/fault.txt:3 manual/commands/fourier.txt:3 manual/commands/freeze.txt:3 manual/commands/generator.txt:3 manual/commands/get.txt:3 manual/commands/include.txt:3 manual/commands/lib.txt:3 manual/commands/list.txt:3 manual/commands/load.txt:3 manual/commands/log.txt:3 manual/commands/measure.txt:3 manual/commands/op.txt:3 manual/commands/options.txt:3 manual/commands/options.txt:11 manual/commands/outfile.txt:3 manual/commands/parameter.txt:3 manual/commands/pause.txt:3 manual/commands/plot.txt:3 manual/commands/print.txt:3 manual/commands/save.txt:3 manual/commands/status.txt:3 manual/commands/store.txt:3 manual/commands/sweep.txt:3 manual/commands/temp.txt:3 manual/commands/title.txt:3 manual/commands/transient.txt:3 manual/commands/width.txt:3 manual/devices/basic/complex.txt:7 manual/devices/basic/exp.txt:8 manual/devices/basic/fit.txt:6 manual/devices/basic/generator.txt:7 manual/devices/basic/poly.txt:8 manual/devices/basic/posy.txt:8 manual/devices/basic/pulse.txt:8 manual/devices/basic/sffm.txt:8 manual/devices/basic/sin.txt:8 manual/devices/basic/tanh.txt:8 manual/devices/capacitor.txt:32 manual/devices/lossless_transmission_line.txt:7 manual/devices/mutual_inductance.txt:7 manual/devices/switches.txt:26 manual/measure/at.txt:3 manual/measure/cross.txt:3 manual/measure/mean.txt:3 manual/measure/minmax.txt:3 manual/measure/slope.txt:3 manual/measure/integrate.txt:3
#, no-wrap
msgid "Purpose"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:6
msgid "Performs a small signal, steady state, AC analysis. Sweeps frequency."
msgstr ""

#. type: Title =====
#: manual/commands/ac.txt:7 manual/commands/alarm.txt:7 manual/commands/alter.txt:7 manual/commands/build.txt:7 manual/commands/chdir.txt:7 manual/commands/dc.txt:7 manual/commands/delete.txt:7 manual/commands/edit.txt:7 manual/commands/eval.txt:7 manual/commands/exit.txt:8 manual/commands/fault.txt:7 manual/commands/fourier.txt:7 manual/commands/freeze.txt:7 manual/commands/generator.txt:7 manual/commands/get.txt:8 manual/commands/include.txt:7 manual/commands/lib.txt:7 manual/commands/list.txt:7 manual/commands/load.txt:7 manual/commands/log.txt:7 manual/commands/measure.txt:7 manual/commands/op.txt:7 manual/commands/options.txt:7 manual/commands/outfile.txt:7 manual/commands/parameter.txt:7 manual/commands/pause.txt:7 manual/commands/plot.txt:7 manual/commands/print.txt:7 manual/commands/save.txt:7 manual/commands/status.txt:7 manual/commands/store.txt:7 manual/commands/sweep.txt:7 manual/commands/temp.txt:7 manual/commands/title.txt:7 manual/commands/transient.txt:7 manual/commands/width.txt:7 manual/devices/basic/complex.txt:3 manual/devices/basic/exp.txt:3 manual/devices/basic/fit.txt:2 manual/devices/basic/generator.txt:3 manual/devices/basic/poly.txt:3 manual/devices/basic/posy.txt:3 manual/devices/basic/pulse.txt:3 manual/devices/basic/sffm.txt:3 manual/devices/basic/sin.txt:3 manual/devices/basic/tanh.txt:3 manual/devices/lossless_transmission_line.txt:3 manual/devices/mutual_inductance.txt:3 manual/devices/switches.txt:4 manual/measure/at.txt:7 manual/measure/cross.txt:7 manual/measure/mean.txt:9 manual/measure/minmax.txt:7 manual/measure/slope.txt:7 manual/measure/integrate.txt:7
#, no-wrap
msgid "Syntax"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:10
#, no-wrap
msgid "  ac {//options// ...} //start stop stepsize// {//options// ...}\n"
msgstr ""

#. type: Title =====
#: manual/commands/ac.txt:11 manual/commands/alarm.txt:14 manual/commands/alter.txt:12 manual/commands/build.txt:11 manual/commands/chdir.txt:12 manual/commands/dc.txt:12 manual/commands/delete.txt:14 manual/commands/edit.txt:12 manual/commands/eval.txt:11 manual/commands/exit.txt:13 manual/commands/fault.txt:12 manual/commands/fourier.txt:13 manual/commands/freeze.txt:12 manual/commands/generator.txt:11 manual/commands/get.txt:12 manual/commands/include.txt:11 manual/commands/lib.txt:12 manual/commands/list.txt:12 manual/commands/load.txt:13 manual/commands/log.txt:13 manual/commands/measure.txt:10 manual/commands/op.txt:11 manual/commands/options.txt:15 manual/commands/outfile.txt:13 manual/commands/parameter.txt:14 manual/commands/pause.txt:15 manual/commands/plot.txt:18 manual/commands/print.txt:15 manual/commands/save.txt:11 manual/commands/status.txt:12 manual/commands/store.txt:15 manual/commands/sweep.txt:11 manual/commands/temp.txt:12 manual/commands/title.txt:12 manual/commands/transient.txt:11 manual/commands/width.txt:11 manual/devices/basic/complex.txt:11 manual/devices/basic/exp.txt:11 manual/devices/basic/fit.txt:11 manual/devices/basic/generator.txt:12 manual/devices/basic/poly.txt:12 manual/devices/basic/posy.txt:13 manual/devices/basic/pulse.txt:12 manual/devices/basic/sffm.txt:12 manual/devices/basic/sin.txt:12 manual/devices/basic/tanh.txt:12 manual/devices/capacitor.txt:35 manual/devices/lossless_transmission_line.txt:11 manual/devices/mutual_inductance.txt:11 manual/measure/mean.txt:22 manual/measure/slope.txt:23 manual/measure/integrate.txt:18
#, no-wrap
msgid "Comments"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:14
msgid ""
"The \"ac\" command does a linear analysis about an operating point. It is "
"absolutely necessary to do an \"op\" analysis first on any nonlinear "
"circuit. Not doing this is the equivalent of testing it with the power off."
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:16
msgid ""
"Three parameters are normally needed for an AC analysis: start frequency, "
"stop frequency and step size, in this order. If all of these are omitted, "
"the values from the most recent AC analysis are used."
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:18
msgid "If only one frequency is specified, a single point analysis will be done."
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:20
msgid ""
"If only a new step size is specified, the old start and stop are kept and "
"only the step size is changed. This is indicated by a keyword: by, times, "
"decade or octave, or a symbol: + or *."
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:22
msgid ""
"If the start frequency is zero, the program will still do an AC "
"analysis. The actual frequency can be considered to be the limit as the "
"frequency approaches zero. It is, therefore, still possible to have a "
"non-zero phase angle, but delays are not shown because they may be infinite."
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:24
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command. This is different from Spice."
msgstr ""

#. type: Title =====
#: manual/commands/ac.txt:25 manual/commands/dc.txt:28 manual/commands/fourier.txt:36 manual/commands/op.txt:23 manual/commands/transient.txt:23
#, no-wrap
msgid "Options"
msgstr ""

#. type: Title ====
#: manual/commands/ac.txt:27 manual/commands/dc.txt:30 manual/commands/fourier.txt:38 manual/commands/op.txt:25 manual/commands/transient.txt:25
#, no-wrap
msgid "Sweep control"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:36
#, no-wrap
msgid ""
"|start //frequency//   |Sweep start //frequency//.  |\n"
"|stop //frequency//    |Sweep stop //frequency//.  |\n"
"|+ //stepsize//        |Linear sweep. Add //stepsize// to get the next "
"step. Same as by.  |\n"
"|* //multiplier//      |Log sweep. Multiply by //multiplier// to get the "
"next step.  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next "
"step. Same as +.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|octave //steps//      |Log sweep. Use //steps// steps per octave.  |\n"
"|times //multiplier//  |Log sweep. Multiply by //multiplier// to get the "
"next step.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/ac.txt:37 manual/commands/dc.txt:39 manual/commands/fourier.txt:44 manual/commands/op.txt:34 manual/commands/transient.txt:31
#, no-wrap
msgid "Input / Output"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:43 manual/commands/dc.txt:45 manual/commands/fourier.txt:50 manual/commands/op.txt:40 manual/commands/transient.txt:37
#, no-wrap
msgid ""
"|> //file//   |Send results of analysis to file.  |\n"
"|>> //file//  |Append results to file.  |\n"
"|noplot       |Suppress plotting.  |\n"
"|plot         |Graphic output, when plotting is normally off.  |\n"
"|quiet        |Suppress console output.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/ac.txt:44 manual/commands/dc.txt:51 manual/commands/fourier.txt:58 manual/commands/op.txt:41 manual/commands/transient.txt:44
#, no-wrap
msgid "Other"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:47
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to "
"the temperature from the options command. This does not apply to nonlinear "
"components, which will inherit the temperature from the operating point "
"analysis.|\n"
"|temperature //degrees//  |Temperature, degrees C. This does not apply to "
"nonlinear components, which will inherit the temperature from the operating "
"point analysis.|\n"
msgstr ""

#. type: Title =====
#: manual/commands/ac.txt:48 manual/commands/alarm.txt:33 manual/commands/chdir.txt:18 manual/commands/dc.txt:55 manual/commands/delete.txt:24 manual/commands/edit.txt:22 manual/commands/eval.txt:15 manual/commands/fourier.txt:64 manual/commands/freeze.txt:18 manual/commands/generator.txt:42 manual/commands/get.txt:22 manual/commands/include.txt:19 manual/commands/list.txt:22 manual/commands/load.txt:29 manual/commands/log.txt:25 manual/commands/measure.txt:40 manual/commands/op.txt:50 manual/commands/outfile.txt:21 manual/commands/parameter.txt:30 manual/commands/pause.txt:21 manual/commands/plot.txt:45 manual/commands/print.txt:33 manual/commands/save.txt:19 manual/commands/store.txt:27 manual/commands/title.txt:18 manual/commands/transient.txt:50 manual/devices/basic/inline_behavioral_modeling.txt:79 manual/measure/at.txt:22 manual/measure/cross.txt:34 manual/measure/mean.txt:30 manual/measure/minmax.txt:21 manual/measure/slope.txt:29 manual/measure/integrate.txt:22
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: manual/commands/ac.txt:69
#, no-wrap
msgid ""
"  ac 10m\n"
"A single point AC analysis at 10 mHz.\n"
"  ac 1000 3000 100\n"
"Sweep from 1000 Hz to 3000 Hz in 100 Hz steps.\n"
"  ac start=1000 stop=3000 step=100\n"
"Same as the last one.\n"
"  ac 1000 3000 Octave\n"
"Sweep from 1000 Hz to 3000 Hz in octave steps. Since the sweep cannot end at "
"3000 Hz, in this case, the last step will really be 4000 Hz.\n"
"  ac by 250\n"
"Keep the same limits as before, but use 250 Hz steps. In this case, it means "
"to sweep from 1000 to 3000 Hz, because that it what it was the last time.\n"
"  ac 5000 1000 -250\n"
"You can sweep downward, if you want. Remember that the increment would be "
"negative.\n"
"  ac 20 20k *2\n"
"Double the frequency to get the next step.\n"
"  ac 20k 20 *.5\n"
"You can do a log sweep downward, too. A multiplier of less than one moves it "
"down.\n"
"  ac\n"
"Do the same AC sweep again.\n"
"  ac >afile\n"
"Save the results in the file ''afile''. The file will look just like the "
"screen. It will have all probe points. It will be a plot, if plotting is "
"enabled.\n"
msgstr ""

#. type: Title ======
#: manual/commands/alarm.txt:1
#, no-wrap
msgid "\"alarm\" command"
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:6
msgid "Select points in the circuit to check against user defined limits."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:13
#, no-wrap
msgid ""
"  alarm\n"
"  alarm mode points ... ...\n"
"  alarm mode + points ... ...\n"
"  alarm mode - points ... ...\n"
"  alarm mode clear\n"
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:17
msgid ""
"The `alarm' command selects points in the circuit to check against "
"limits. There is no output unless the limits are exceeded. If the limits are "
"exceeded a the value is printed."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:19 manual/commands/plot.txt:23 manual/commands/print.txt:20
msgid "There are separate lists of probe points for each type of analysis."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:21
msgid "To list the points, use the bare command `alarm'."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:26 manual/commands/plot.txt:30
#, no-wrap
msgid ""
"Syntax for each point is:\n"
"  parameter(node)(limits)\n"
"  parameter(componentlabel)(limits)\n"
"  parameter(index)(limits)\n"
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:28 manual/commands/plot.txt:32
msgid "Some require a dummy index."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:30 manual/commands/plot.txt:34
msgid "For more information on the data available see the print command."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or "
"-. alarm ac + v(3) adds v(3) to the existing set of AC probes. alarm ac - "
"q(c5) removes q(c5) from the list. You can use the wildcard characters * and "
"? when deleting."
msgstr ""

#. type: Plain text
#: manual/commands/alarm.txt:46
#, no-wrap
msgid ""
"  alarm ac vm(12)(0,5) vm(13)(-5,5)\n"
"Check magnitude of the voltage at node 12 against a range of 0 to 5, and "
"node 13 against a range of -5 to 5 for AC analysis. Print a warning when the "
"limits are exceeded.\n"
"  alarm op id(m*)(-100n,100n)\n"
"Check current in all mosfets. In op analysis, print a warning for any that "
"are outside the range of -100 to +100 nanoamps. The range goes both positive "
"and negative so it is valid for both N and P channel fets.\n"
"  alarm tran v(r83)(0,5) p(r83)(0,1u)\n"
"Check the voltage and power of R83 in the next transient analysis. The "
"voltage range is 0 to 5. The power range is 0 to 1 microwatt. Print a "
"warning when the range is exceeded.\n"
"  alarm\n"
"List all the probes for all modes.\n"
"  alarm dc\n"
"Display the DC alarm list.\n"
"  alarm ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/alter.txt:1
#, no-wrap
msgid "\"alter\", \"modify\" commands"
msgstr ""

#. type: Plain text
#: manual/commands/alter.txt:6
msgid "Quickly change a component value."
msgstr ""

#. type: Plain text
#: manual/commands/alter.txt:11
#, no-wrap
msgid ""
"  alter  partlabel=value ...\n"
"  modify partlabel=value ...\n"
msgstr ""

#. type: Plain text
#: manual/commands/alter.txt:15
msgid ""
"This command quickly changes the value of a component. It is restricted to "
"simply changing the value."
msgstr ""

#. type: Plain text
#: manual/commands/alter.txt:17
msgid ""
"If several components have the same label or if wildcard characters are "
"used, all are changed."
msgstr ""

#. type: Title ====
#: manual/commands/alter.txt:18 manual/commands/fault.txt:24 manual/commands/sweep.txt:31 manual/devices/basic/complex.txt:22 manual/devices/basic/fit.txt:73 manual/devices/basic/posy.txt:48 manual/devices/basic/tanh.txt:36 manual/howto/expressions.txt:13 manual/tech/plugins/coding.txt:25
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: manual/commands/alter.txt:25
#, no-wrap
msgid ""
"  modify R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  modify C12=220p L1=1u\n"
"C12 is 220 pf and L1 is 1 uH.\n"
"  modify R*=22k\n"
"All resistors are now 22k.\n"
msgstr ""

#. type: Title ======
#: manual/commands/build.txt:1
#, no-wrap
msgid "\"build\" command"
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:6
msgid "Builds a new circuit, with Spice syntax."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:10
#, no-wrap
msgid "  build\n"
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:14
msgid ""
"\"Build\" lets you enter the circuit from the keyboard. The prompt changes "
"to > to show that the program is in the build mode."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:16
msgid "At this point, type in the circuit components in Spice netlist format."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:18
msgid ""
"Component labels must be unique. If not, the old one is modified according "
"to the new data, keeping old values where no new ones were specified."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:20
msgid "Components are added to the end of the list."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:22
msgid ""
"Components being changed or replaced do not change their location in the "
"list."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:24
msgid ""
"If it is necessary to start over, \"delete all\" or \"clear\" will erase the "
"entire circuit in memory."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:26
msgid "To exit this mode, enter a blank line."
msgstr ""

#. type: Plain text
#: manual/commands/build.txt:27
msgid ""
"This command is deprecated, and may be removed in a future release.  You can "
"use the command \"spice\" instead."
msgstr ""

#. type: Title ======
#: manual/commands/chdir.txt:1
#, no-wrap
msgid "\"chdir\" command"
msgstr ""

#. type: Plain text
#: manual/commands/chdir.txt:6
msgid "Changes or displays the current directory name."
msgstr ""

#. type: Plain text
#: manual/commands/chdir.txt:11
#, no-wrap
msgid ""
"  chdir {path}\n"
"  cd {path}\n"
msgstr ""

#. type: Plain text
#: manual/commands/chdir.txt:15
msgid ""
"Change the current directory to that specified by path. See your system "
"manual for complete syntax."
msgstr ""

#. type: Plain text
#: manual/commands/chdir.txt:17
msgid "If no argument is given the current directory is displayed."
msgstr ""

#. type: Plain text
#: manual/commands/chdir.txt:23
#, no-wrap
msgid ""
"  cd ../ckt\n"
"Change the current working directory to ../ckt.\n"
"  cd\n"
"Show the current working directory name.\n"
msgstr ""

#. type: Title ======
#: manual/commands/dc.txt:1
#, no-wrap
msgid "\"dc\" command"
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, and sweeps the signal input, "
"or a component value."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:11
#, no-wrap
msgid ""
"  dc start stop stepsize {options ...}\n"
"  dc label start stop stepsize {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:15 manual/commands/fourier.txt:20
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:17
msgid ""
"If there are numeric arguments, without a part label, they represent a ramp "
"from the generator function. They are the start value, stop value and step "
"size, in order. They are saved between commands, so no arguments will repeat "
"the previous sweep."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:19
msgid ""
"A single parameter represents a single input voltage. Two parameters "
"instruct the computer to analyze for those two points only."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:21
msgid ""
"In some cases, you will get one more step outside the specified range of "
"inputs due to internal rounding errors. The last input may be beyond the end "
"point."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:23
msgid ""
"This command also sets up a movable operating point for subsequent AC "
"analysis, which can be helpful in distortion analysis."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:25
msgid ""
"The program will sweep any simple component, including resistors, "
"capacitors, and controlled sources. SPICE sweeps only fixed sources (types V "
"and I)."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:27
msgid "This command will sweep up to 4 components, nested."
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:38 manual/commands/op.txt:33
#, no-wrap
msgid ""
"|* //multiplier//      |Log sweep. Multiply the input by //multiplier// to "
"get the next step. Do not pass zero volts!!  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next "
"step.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|times //multiplier//  |Log sweep. Multiply the input by multiplier to get "
"the next step. Do not pass zero volts!!  |\n"
"|continue              |Use the last step of a OP, DC or Transient analysis "
"as the first guess.  |\n"
"|loop                  |Repeat the sweep, backwards.  |\n"
"|reverse               |Sweep in the opposite direction.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:50 manual/commands/op.txt:49
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:54 manual/commands/op.txt:44
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to "
"the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/dc.txt:70
#, no-wrap
msgid ""
"  dc 1\n"
"Do a single point DC signal simulation, with `1 volt' input.\n"
"  dc -10 15 1\n"
"Sweep the circuit input from -10 to +15 in steps of 1. (usually volts.) Do a "
"DC transfer simulation at each step.\n"
"  dc\n"
"With no parameters, it uses the same ones as the last time. In this case, "
"from -10 to 15 in 1 volt steps.\n"
"  dc V13 -10 15 1\n"
"Sweep the \"value\" of the component \"V13\" from -10 to +15 in steps of "
"1. Do a DC transfer simulation at each step.\n"
"  dc 20 0 -2\n"
"You can sweep downward, by asking for a negative increment. Sometimes, this "
"will result in better convergence, or even different results! (For example, "
"in the case of a bi-stable circuit.)\n"
"  dc -2 2 .1 loop\n"
"After the sweep, do it again in the opposite direction. In this case, the "
"sweep is -2 to +2 in steps of .1. After it gets to +2, it will go back, and "
"sweep from +2 to -2 in steps of -.1. The plot will be superimposed on the up "
"sweep. This way, you can see hysteresis in the circuit.\n"
"  dc temperature=75\n"
"Simulate at 75 degrees, this time. Since we didn't specify new sweep "
"parameters, do the same as last time. (Without the loop.)\n"
msgstr ""

#. type: Title ======
#: manual/commands/delete.txt:1
#, no-wrap
msgid "\"delete\" command"
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:6
msgid "Remove a line, or a group of lines, from the circuit description."
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:11
#, no-wrap
msgid ""
"  delete label ...\n"
"  delete all\n"
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:13
#, no-wrap
msgid "  clear\n"
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:17
msgid ""
"To delete a part, by label, enter the label. (Example `DEL R15'.) Wildcards "
"`*' and `?' are allowed, in which case, all that match are deleted."
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:19
msgid ""
"To delete the entire circuit, the entire word ALL must be entered. (Example "
"`DEL ALL'.)"
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:21
msgid ""
"After deleting anything, there is usually no way to get it back, but if a "
"fault had been applied (see fault command) restore may have surprising "
"results."
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:23
msgid "\"clear\" is similar to, but a little more drastic than delete all."
msgstr ""

#. type: Plain text
#: manual/commands/delete.txt:36
#, no-wrap
msgid ""
"  delete all\n"
"Delete the entire circuit, but save the title.\n"
"  delete R12\n"
"Delete R12.\n"
"  delete R12 C3\n"
"Delete R12 and C3.\n"
"  delete R*\n"
"Delete all resistors. (Also, any models and subcircuits starting with R.)\n"
"  clear\n"
"Clear out everything to start over.\n"
msgstr ""

#. type: Title ======
#: manual/commands/edit.txt:1
#, no-wrap
msgid "\"edit\" command"
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:6
msgid "Use your editor to change the circuit."
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:11
#, no-wrap
msgid ""
"  edit\n"
"  edit file\n"
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:15
msgid ""
"The edit command runs your editor on a copy of the circuit in memory, then "
"reloads it."
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:17
msgid "Edit file runs your editor on the specified file."
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:19
msgid ""
"If you are only changing a component value, the modify command may be easier "
"to use."
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:21
msgid ""
"The program uses the EDITOR environment variable to find the editor to "
"use. The command fails if there is no EDITOR defined."
msgstr ""

#. type: Plain text
#: manual/commands/edit.txt:27
#, no-wrap
msgid ""
"  edit\n"
"Brings up your editor on the circuit.\n"
"  edit foo\n"
"Edits the file foo in your current directory.\n"
msgstr ""

#. type: Plain text
#: manual/commands/end.txt:2
msgid "\"end\" command"
msgstr ""

#. type: Plain text
#: manual/commands/end.txt:4
msgid ""
"When run in batch mode from the shell, the END command cleans up and exits "
"the program."
msgstr ""

#. type: Plain text
#: manual/commands/end.txt:6
msgid ""
"In script mode (< command) it ends the script and returns to the program "
"prompt."
msgstr ""

#. type: Plain text
#: manual/commands/end.txt:7
msgid "In interactive mode it exits the program."
msgstr ""

#. type: Title ======
#: manual/commands/eval.txt:1
#, no-wrap
msgid "\"eval\" command"
msgstr ""

#. type: Plain text
#: manual/commands/eval.txt:6
msgid "Check and evaluate an expression."
msgstr ""

#. type: Plain text
#: manual/commands/eval.txt:10
#, no-wrap
msgid "  eval expression\n"
msgstr ""

#. type: Plain text
#: manual/commands/eval.txt:14
msgid "The eval command evaluates an expression and prints the result as a number."
msgstr ""

#. type: Plain text
#: manual/commands/eval.txt:28
#, no-wrap
msgid ""
"  gnucap> param a={b+c+7}\n"
"  gnucap> eval a\n"
"  parameter b+c+7 has no value\n"
"  parameter b+c+7 has no value\n"
"  a= NA\n"
"  gnucap> param b=c+3\n"
"  gnucap> param c=4\n"
"  gnucap> eval a\n"
"  a= 18.\n"
"  gnucap> eval b+c\n"
"  (b + c)= 11.\n"
"  gnucap>\n"
msgstr ""

#. type: Title ======
#: manual/commands/exit.txt:1
#, no-wrap
msgid "\"exit\", \"quit\" commands"
msgstr ""

#. type: Plain text
#: manual/commands/exit.txt:7
#, no-wrap
msgid " Terminates the program.\n"
msgstr ""

#. type: Plain text
#: manual/commands/exit.txt:12
#, no-wrap
msgid ""
"  exit\n"
"  quit\n"
msgstr ""

#. type: Plain text
#: manual/commands/exit.txt:15
msgid "Be sure you have saved everything you want to!"
msgstr ""

#. type: Title ======
#: manual/commands/fault.txt:1
#, no-wrap
msgid "\"fault\" command"
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:6
msgid "Temporarily change a component value."
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:11
#, no-wrap
msgid ""
"  fault partlabel=value ...\n"
"  unfault\n"
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:15
msgid ""
"This command quickly changes the value of a component, usually with the "
"intention that you will not want to save it."
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:17
msgid ""
"If you apply this command to a nonlinear or otherwise strange part, it "
"becomes ordinary and linear until the fault is removed."
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:19
msgid "It is an error to fault a model call."
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:21
msgid ""
"If several components have the same label, the fault value applies to all of "
"them. (They will all have the same value.)"
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:23
msgid "The unfault command restores the old values."
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:30
#, no-wrap
msgid ""
"  fault R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  unfault\n"
"Clears all faults. In this case, R66 has its old value again.\n"
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:35
#, no-wrap
msgid ""
"unfault can bring on surprises. Consider this sequence ...\n"
"  V1   1   0    ac  1\n"
"  C3   1   2    1u\n"
"  R4   2   0    10k\n"
msgstr ""

#. type: Plain text
#: manual/commands/fault.txt:43
#, no-wrap
msgid ""
"  fault C3=100p\n"
"C3 is 100 picofarads, for now.\n"
"  modify C3=220p\n"
"C3 is 220 pf, for now. It will be restored.\n"
"  modify R4=1k\n"
"R4 is 1k. It will not be restored.\n"
"  unfault\n"
"C3 back to 1 uf, but R4 still 1k.\n"
msgstr ""

#. type: Title ======
#: manual/commands/fourier.txt:1
#, no-wrap
msgid "\"fourier\" command"
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:6
msgid ""
"Performs a nonlinear time domain (transient) analysis, but displays the "
"results in the frequency domain."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:10
#, no-wrap
msgid "  fourier start stop stepsize {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:12
msgid "Start, stop, and stepsize are frequencies."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:16
msgid ""
"This command is slightly different and more flexible than the SPICE "
"counterpart. SPICE always gives you the fundamental and 9 harmonics. Gnucap "
"will do the same if you only specify one frequency. SPICE has the probes on "
"the same line. Gnucap requires you to specify the probes with the print "
"command."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:18
msgid ""
"SPICE uses the last piece of a transient that was already done. Gnucap does "
"its own transient analysis, continuing from where the most recent one left "
"off, and choosing the step size to match the Fourier Transform to be "
"done. Because of this the Gnucap Fourier analysis is much more accurate than "
"SPICE."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:22
msgid ""
"Three parameters are normally needed for a Fourier analysis: start "
"frequency, stop frequency and step size, in this order."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:24
msgid ""
"If the start frequency is omitted it is assumed to be 0. The two remaining "
"parameters are stop and step, such that stop > step."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:26
msgid ""
"If only one frequency is specified, it is assumed to be step size, which is "
"equivalent to the fundamental frequency. The start frequency is zero and the "
"stop frequency is set according the harmonics option (from the options "
"command. The default is 9 harmonics."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:28
msgid ""
"If two frequencies are specified, they are stop and step. The order doesn't "
"matter since stop is always larger than step."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:30
msgid ""
"This command does a nonlinear time domain analysis, then performs a Fourier "
"transform on the data to get the frequency data. The transient analysis "
"parameters (start, stop, step) are determined by the program as necessary to "
"produce the desired spectral results. The internal time steps are selected "
"to match the Fourier points, so there is no interpolation done."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:32
msgid ""
"The underlying transient analysis begins where the previous one left off. If "
"you specify the \"cold\" option, it begins at time = 0. Often repeating a "
"run will improve the accuracy by giving more time for initial transients to "
"settle out."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:34
msgid "See also: [[gnucap:manual:commands:transient|Transient command]]."
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:43 manual/commands/transient.txt:30
#, no-wrap
msgid ""
"|dtmax time      |The maximum internal time step.  (Default = stepsize/skip)  "
"|\n"
"|dtmin time      |The minimum internal time step. (Default = option dtmin) "
"Time cannot be resolved closer than this.  |\n"
"|dtratio number  |The minimum internal time step, as a ratio. (Default = "
"option dtratio) This is the maximum number of internal time steps for every "
"requested step.  |\n"
"|skip count      |Force at least count internal transient time steps for "
"each one displayed. If the output is a table or ASCII plot, the extra steps "
"are hidden, unless the trace option specifies to print them.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:57 manual/commands/transient.txt:44
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace alltime     |Show all accepted internal time steps.  |\n"
"|trace rejected    |Show all internal time steps including rejected steps.  "
"|\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:63
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to "
"the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from "
"power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC "
"analysis. Instead, use the values specified with the IC = options on the "
"various elements, and set everything else to zero.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/fourier.txt:75
#, no-wrap
msgid ""
"  fourier 1Meg\n"
"Analyze the spectrum assuming a fundamental frequency of 1 mHz. Use the "
"harmonics option to determine how many harmonics (usually 9) to display.\n"
"  fourier 40 20K 20\n"
"Analyze the spectrum from 40 Hz to 20 kHz in 20 Hz steps. This will result "
"in a transient analysis with 25 micro-second steps. (1 / 40k). It will run "
"for .05 second. (1 / 20).\n"
"  fourier 0 20K 20\n"
"Similar to the previous example, but show the DC and 20 Hz terms, also.\n"
"  fourier\n"
"No parameters mean use the same ones as the last time. In this case: from 0 "
"to 20 kHz, in 20 Hz steps.\n"
"  fourier skip 10\n"
"Do 10 transient steps internally for every step that is used. In this case "
"it means to internally step at 2.5 micro-second, or 10 steps for every one "
"actually used.\n"
msgstr ""

#. type: Title ======
#: manual/commands/freeze.txt:1
#, no-wrap
msgid "\"freeze, unfreeze\" commands"
msgstr ""

#. type: Plain text
#: manual/commands/freeze.txt:6
msgid "\"Freeze\" to a point in time.  Remember circuit voltages and currents."
msgstr ""

#. type: Plain text
#: manual/commands/freeze.txt:11
#, no-wrap
msgid ""
"  freeze\n"
"  unfreeze\n"
msgstr ""

#. type: Plain text
#: manual/commands/freeze.txt:15
msgid ""
"After the freeze command, the transient and fourier analysis will continue "
"from the values that were kept by the freeze command, instead of progressing "
"every time."
msgstr ""

#. type: Plain text
#: manual/commands/freeze.txt:17
msgid ""
"This allows reruns from the same starting point, which may be at any time, "
"not necessarily 0."
msgstr ""

#. type: Plain text
#: manual/commands/freeze.txt:35
#, no-wrap
msgid ""
"  transient 0 1 .01\n"
"A transient analysis starting at zero, running until 1 second, with step "
"size .01 seconds. After this run, the clock is at 1 second.\n"
"  freeze\n"
"Remember the time, voltages, currents, etc.\n"
"  transient\n"
"Another transient analysis. It continues from 1 second, to 2 seconds. (It "
"spans 1 second, as before.) This command was not affected by the freeze "
"command.\n"
"  transient\n"
"This will do exactly the same as the last one. From 1 second to 2 "
"seconds. If it were not for freeze, it would have started from 2 seconds.\n"
"  transient 1.5 .001\n"
"Try again with smaller steps. Again, it starts at 1 second.\n"
"  unfreeze\n"
"Release the effect of freeze.\n"
"  transient\n"
"Exactly the same as the last time, as if we didn't unfreeze. (1 to 1.5 "
"seconds.)\n"
"  transient\n"
"This one continues from where the last one left off: at 1.5 seconds. From "
"now on, time will move forward.\n"
msgstr ""

#. type: Title ======
#: manual/commands/generator.txt:1
#, no-wrap
msgid "\"generator\" command"
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:6
msgid ""
"Sets up an input waveform for transient and Fourier analysis. Emulates a "
"laboratory type function generator."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:10
#, no-wrap
msgid "  generator {option-name=value ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:14
msgid ""
"This command sets up a singal source that is conceptually separate from the "
"circuit. To use it, make the value of a component \"generator(1)\", or "
"substitute a scale factor for the parameter."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:16
msgid ""
"The SPICE style input functions also work, but are considered to be part of "
"the circuit, instead of part of the test equipment."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:18
msgid ""
"The parameters available are designed to emulate the controls on a function "
"generator. There are actually two generators here: sine wave and pulse. If "
"both are on (by setting non-zero parameters) the sine wave is modulated by "
"the pulse, but either can be used alone."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:20
msgid ""
"Unless you change it, it is a unit-step function at time 0. The purpose of "
"the command is to change it."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:22
msgid ""
"This command does not affect AC or DC analysis in any way. It is only for "
"transient and Fourier analysis. In AC analysis, the input signal is always a "
"sine wave at the analysis frequency."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:24
msgid ""
"Typical usage is the name of the control followed by its value, or just "
"plain Generator to display the present values."
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:26
msgid ""
"The actual time when switching takes place is ambiguous by one time step. If "
"precise time switching is necessary, use the Skip option on the transient "
"analysis command, to force more resolution. This ambiguity can usually be "
"avoided by specifying finite rise and fall times."
msgstr ""

#. type: Title =====
#: manual/commands/generator.txt:27 manual/commands/options.txt:25 manual/devices/basic/exp.txt:33 manual/devices/basic/fit.txt:50 manual/devices/basic/poly.txt:27 manual/devices/basic/posy.txt:40 manual/devices/basic/pulse.txt:43 manual/devices/basic/sffm.txt:26 manual/devices/basic/sin.txt:44 manual/devices/basic/tanh.txt:27 manual/measure/at.txt:10 manual/measure/cross.txt:10 manual/measure/mean.txt:15 manual/measure/minmax.txt:11 manual/measure/slope.txt:11 manual/tech/plugins/devices/parameters.txt:3 manual/measure/integrate.txt:11
#, no-wrap
msgid "Parameters"
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:41
#, no-wrap
msgid ""
"|frequency  |The frequency of the sine wave generator for a transient "
"analysis. The sine wave is modulated by the pulse generator. A frequency of "
"zero puts the pulse generator on line directly.  |\n"
"|amplitude  |The overall amplitude of the pulse and sine wave. A scale "
"factor. It applies to everything except the offset and initial values.  |\n"
"|phase      |The phase of the sine wave, at the instant it is first turned "
"on.  |\n"
"|max        |The amplitude of the pulse, when it is `on'. (During the width "
"time) If the sine wave is on (frequency not zero) this is the amplitude of "
"the sine wave during the first part of the period. The max is scaled by "
"amplitude.  |\n"
"|min        |The amplitude of the pulse, when it is `off'. (After it falls, "
"but before the next period begins.) Although we have called these min and "
"max, there is no requirement that max be larger than min. If the sine wave "
"is on, this is its amplitude during the second part of the period. The min "
"is scaled by amplitude.  |\n"
"|offset     |The DC offset applied to the entire signal, at all times after "
"the initial delay. The offset is not scaled by amplitude.  |\n"
"|initial    |The initial value of the pulse generator output. It will have "
"this value starting at time 0, until delay time has elapsed. It will never "
"return to this value, unless you restart at time 0.  |\n"
"|rise       |The rise time, or the time it takes to go from min to max, or "
"for the first rise, initial to max. The rise is linear.  |\n"
"|fall       |The fall time. (The time required to go from max back to min.)  "
"|\n"
"|delay      |The waiting time before the first rise.  |\n"
"|width      |The length of time the output of the generator has the value "
"max. A width of zero means that the output remains high for the remainder of "
"the period. If you really want a width of zero, use a very small number, "
"less than the step size.  |\n"
"|period     |The time for repetition of the pulse. It must be greater than "
"the sum of rise + fall + width. A period of zero means that the signal is "
"not periodic and so will not repeat.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:57
#, no-wrap
msgid ""
"The generator command ...\n"
"  gen\n"
"Display the present settings.\n"
"  gen freq=1k\n"
"Sets the sine wave to 1 kHz. All other parameters are as they were before.\n"
"  gen freq=0\n"
"Turns off the sine wave, leaving only the pulse.\n"
"  gen ampl=0\n"
"Sets the amplitude to zero, which means the circuit has no input, except for "
"possibly a DC offset.\n"
"  gen period=.001 freq=1Meg\n"
"Sets the period back to 1 millisecond. Applies 1 mHz modulation to the "
"pulse, resulting in a pulsed sine wave. In this case, a 100 microsecond 10 "
"volt burst, repeating every millisecond. Between bursts, you will get 2.5 "
"volts, with reversed phase. The old values, in this case from 2 lines back "
"(above) are kept. (Ampl 5 Rise 10u Fall 10u ...)\n"
"  gen freq=60 phase=90 delay=.1\n"
"The sine wave frequency is 60 Hertz. Its phase is 90 degrees when it turns "
"on, at time .1 seconds. It turns on sharply at the peak.\n"
msgstr ""

#. type: Plain text
#: manual/commands/generator.txt:64
#, no-wrap
msgid ""
"A component using it ...\n"
"  V12 1 0 generator(1)\n"
"Use the generator as the circuit input through this voltage source. The DC "
"and AC values are 0.\n"
"  V12 1 0 tran generator(1) ac 10 dc 5\n"
"Same as before, except that the AC value is 10 and DC value is 5.\n"
"  Rinput 1 0 tran generator(1)\n"
"Unlike SPICE, the functions can be used on other components. The resistance "
"varies in time according to the \"generator\".\n"
msgstr ""

#. type: Title ======
#: manual/commands/get.txt:1
#, no-wrap
msgid "\"get\" command"
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:7
msgid ""
"Gets an existing circuit file, but does not run it, after clearing "
"memory. Start over.  Set up for interactive operation."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:11
#, no-wrap
msgid "  get filename\n"
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:15
msgid ""
"The first comment line of the file being read is taken as the `title'. See "
"the title command."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:17
msgid ""
"Comments in the circuit file are stored, unless they start with *+ in which "
"case they are thrown away."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:19
msgid ""
"`Dot cards' are set up, but not executed. This means that variables and "
"options are changed, but simulation commands are not actually done. As an "
"example, the options command is actually performed, since it only sets up "
"variables. The ac card is not performed, but its parameters are stored, so "
"that a plain ac command will perform the analysis specified in the file."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:21
msgid "Any circuit already in memory will be erased before loading the new circuit."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:29
#, no-wrap
msgid ""
"  get amp.ckt\n"
"Get the circuit file amp.ckt from the current directory.\n"
"  get /usr/foo/ckt/amp.ckt\n"
"Get the file amp.ckt from the /usr/foo/ckt directory.\n"
"  get npn.mod\n"
"Get the file npn.mod.\n"
msgstr ""

#. type: Title ======
#: manual/commands/include.txt:1
#, no-wrap
msgid "\"include\" command"
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:6
msgid "Include a file, directly, as is."
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:10
#, no-wrap
msgid "  include filename\n"
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:14
msgid "The file is included as is."
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:16
msgid ""
"If you are running interactive, it is as if you typed in what is in the "
"file."
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:18
msgid ""
"If you are running in a batch mode, or including a file from another file, "
"it is as if you did a copy and paste into that file."
msgstr ""

#. type: Plain text
#: manual/commands/include.txt:22
#, no-wrap
msgid ""
"  include npn.mod\n"
"Include the file npn.mod.\n"
msgstr ""

#. type: Title ======
#: manual/commands/lib.txt:1
#, no-wrap
msgid "\"lib\" command"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:6
msgid "Selective \"library\" include, and mark sections of a library."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:11
#, no-wrap
msgid ""
"  lib section-name\n"
"  lib file-name section-name\n"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:15
msgid "This command takes two forms:"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:17
msgid ""
"The first form is to mark a section of a file, with a name, so it can be "
"selectively included.  The section ends with a line \".endl\"."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:26
#, no-wrap
msgid ""
"  .lib high\n"
"  R1 (1 2) 10k\n"
"  R2 (2 0) 10k\n"
"  .endl\n"
"  .lib low\n"
"  R1 (1 2) 1k\n"
"  R2 (2 0) 1k\n"
"  .endl\n"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:28
msgid ""
"The second form has two arguments.  It is a special case of \"include\", "
"that only includes matching sections of the file."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:30
#, no-wrap
msgid "  .lib libfile high\n"
msgstr ""

#. type: Title ======
#: manual/commands/list.txt:1
#, no-wrap
msgid "\"list\" command"
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:6
msgid "Lists the circuit in memory."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:11
#, no-wrap
msgid ""
"  list {label ...}\n"
"  list {label - label}\n"
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:15
msgid "Plain list will list the whole circuit on the console."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:17
msgid ""
"List with a component label asks for that one only. Wildcards are supported: "
"? matches any character, once. * matches zero or more of any character."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:19
msgid "For several components, list them."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:21
msgid "For a range, specify two labels separated by a dash."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:31
#, no-wrap
msgid ""
"  list\n"
"List the entire circuit to the console.\n"
"  list R11\n"
"Show the component R11.\n"
"  list D12 - C5\n"
"List the part of the netlist from M12 to C5, inclusive. D12 must be before "
"C5 in the list.\n"
"  list D* C*\n"
"List all diodes and capacitors.\n"
msgstr ""

#. type: Title ======
#: manual/commands/load.txt:1
#, no-wrap
msgid "\"load\" and \"unload\" commands"
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:6
msgid "Load and unload plugins."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:12
#, no-wrap
msgid ""
"  load public-model.so\n"
"  load ./my-model.so\n"
"  unload ./my-model.so\n"
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:16
msgid ""
"The load command loads a compiled plugin module.  Plugins can be used to "
"arbitrarily extend gnucap.  You can add models, commands, functions, "
"measurements, and anything else."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:21
#, no-wrap
msgid ""
"Warning messages such as:\n"
"  M: already installed, replacing\n"
"  stashing as M:0\n"
"are harmless, and only indicate that something that was already installed is "
"hidden by loading the plugin.\n"
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:24
msgid ""
"Plugins are shared-object files in a format that is determined by the "
"system.  Plugins must be compiled with the same compiler and same headers "
"that compiled the main executable."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:26
msgid ""
"It is intended to maintain source compatibility between stable releases of "
"gnucap, but no guarantee is made about binary compatibility."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:28
msgid ""
"The load command must be available as a built-in command, because without "
"it, you cannot load any plugins.  It is possible to override it with a "
"plugin."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:35
#, no-wrap
msgid ""
"  load ./bsim463.so\n"
"Load the plugin from the current directory.\n"
"  load bsim463.so\n"
"Load it from the public area, as defined by LD_LIBRARY_PATH.\n"
msgstr ""

#. type: Title ======
#: manual/commands/log.txt:1
#, no-wrap
msgid "\"log\" command"
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:6
msgid "Saves a copy of your keyboard entries in a file."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:12
#, no-wrap
msgid ""
"  log file\n"
"  log >> file\n"
"  log\n"
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:16
msgid ""
"The `>>' option appends to an existing file, if it exists, otherwise it "
"creates one."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:18
msgid ""
"Files can be nested. If you open one while another is already open, both "
"will contain all the information."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:20
msgid ""
"A bare log closes the file. Because of this, the last line of this file is "
"always log. Ordinarily, this will not be of any consequence, but if a log "
"file is open when you use this file as command input, this will close it. If "
"more than one log file is open, they will be closed in the reverse of the "
"order in which they were opened, maintaining nesting."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:22
msgid "See also: `>' and `<' commands."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:24
msgid ""
"The file is an exact copy of what you type, so it is suitable for gnucap "
"<file from the shell. It is NOT suitable for the < command in gnucap or the "
"Spice-like mode gnucap file without <."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:34
#, no-wrap
msgid ""
"  log today\n"
"Save the commands in a file today in the current directory. If today already "
"exists, the old one is gone.\n"
"  log >> doit\n"
"Save the commands in a file doit. If doit already exists, it is kept, and "
"the new data is added to the end.\n"
"  log runit.bat\n"
"Use the file runit.bat.\n"
"  log\n"
"Close the file. Stop saving.\n"
msgstr ""

#. type: Title ====
#: manual/commands/measure.txt:1 manual/tech/plugins/parameter_functions_and_measurements.txt:9
#, no-wrap
msgid "\"measure\" command"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:6
msgid "Make measurements on a circuit, based on stored data."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:10
#, no-wrap
msgid "  measure param-name = measurefunction(args)\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:13
msgid ""
"The \"measure\" command sets parameters, like the \"parameter\" command, but "
"the value after a measure is a number."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:15
msgid ""
"It is used to make measurements on a circuit, such as slew rate, crossings, "
"or average value."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:17
msgid ""
"Before using a \"measure\" command, you need to store the data for the probe "
"points you might want to measure.  This is done with the "
"[[gnucap:manual:commands:store]] command.  If you don't specify, no data is "
"stored."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:19
msgid ""
"Then you need to do some kind of analysis, such as "
"[[gnucap:manual:commands:transient]] or [[gnucap:manual:commands:ac]]."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:21
msgid ""
"For better accuracy of measurements, it is best to specify the option "
"\"trace all\" on a transient command."
msgstr ""

#. type: Title =====
#: manual/commands/measure.txt:22 manual/measure/at.txt:16 manual/measure/cross.txt:28
#, no-wrap
msgid "Diagnostics"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:25
msgid "The message \"no match\" means that the probe you selected was not stored."
msgstr ""

#. type: Title =====
#: manual/commands/measure.txt:28 manual/howto/measure.txt:1 about/plugins/measurements.txt:3
#, no-wrap
msgid "Measurements"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:31 manual/howto/measure.txt:4 manual/howto/measurements.txt:4
msgid ""
"\"Point\" here refers to time, frequency, or whatever is the independent "
"\"x\" value."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:40 manual/howto/measure.txt:13
#, no-wrap
msgid ""
"|[[gnucap:manual:measure:at]]     |The value of a wave at a point, or its "
"derivative.  |\n"
"|[[gnucap:manual:measure:mean|average]]\\\\ [[gnucap:manual:measure:mean]]              "
"|Average or mean value.  |\n"
"|[[gnucap:manual:measure:cross]]  |Find crossings.  |\n"
"|[[gnucap:manual:measure:mean|integrate]]\\\\ "
"[[gnucap:manual:measure:mean|area]]  |The area under the curve.  |\n"
"|[[gnucap:manual:measure:minmax|max]]    |Maximum value, or its point.  |\n"
"|[[gnucap:manual:measure:minmax|min]]    |Minimum value, or its point.  |\n"
"|[[gnucap:manual:measure:mean|rms]]    |The RMS value.  |\n"
"|[[gnucap:manual:measure:slope|slewrate]]\\\\ "
"[[gnucap:manual:measure:slope]]\\\\ [[gnucap:manual:measure:slope|ddt]]  "
"|Slew rate or slope.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:46
#, no-wrap
msgid ""
"Before making measurements, you need to store the data to measure:\n"
"  gnucap> store tran v(*) id(m*) gm(m*)\n"
"Then do the analysis\n"
"  gnucap> transient 0 100u 1u trace all\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:48
msgid "Now you are ready to measure:"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:56
#, no-wrap
msgid ""
"  gnucap> measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  gnucap> measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  gnucap> param period = {t2-t1}\n"
"  gnucap> param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated "
"whenever t1 or t2 changes.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:61
#, no-wrap
msgid ""
"  gnucap> measure meanvalue = mean(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the mean value of v(out) over one cycle.\n"
"  gnucap> measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:64
#, no-wrap
msgid ""
"  gnucap> measure area = integrate(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the area under the curve of v(out) over one cycle.  The area might be "
"zero.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:67
#, no-wrap
msgid ""
"  gnucap> measure rms = rms(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the RMS value of v(out) over one cycle.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:70
#, no-wrap
msgid ""
"  gnucap> measure rmsin = rms(probe=\"bar(in)\")\n"
"  no match: bar(in)\n"
"You didn't store the probe \"bar(in)\".\n"
msgstr ""

#. type: Title ======
#: manual/commands/op.txt:1
#, no-wrap
msgid "\"op\" command"
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, with no input. If a "
"temperature range is given, it sweeps the temperature."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:10
#, no-wrap
msgid "  op start stop stepsize {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:14
msgid ""
"There are substantial extensions beyond the capabilities of the SPICE op "
"command."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:16
msgid ""
"If there are numeric arguments, they represent a temperature sweep. They are "
"the start and stop temperatures in degrees Celsius, and the step size, in "
"order. They are saved between commands, so no arguments will repeat the "
"previous sweep."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:18
msgid ""
"This command will use the op probe set, instead of automatically printing "
"all nodes and source currents, so you must do \"print op ....\" before "
"running op. We did it this way because we believe that printing everything "
"all the time is usually unnecessary clutter. All of the information "
"available from SPICE and more is available here. See the print command and "
"the device descriptions for more details."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:20
msgid ""
"A single parameter represents a single temperature. Two parameters instruct "
"the computer to analyze for those two points only."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:22
msgid ""
"This command also sets up the quiescent point for subsequent AC analysis. It "
"is necessary to do this for nonlinear circuits. The last step in the sweep "
"determines the quiescent point for the AC analysis."
msgstr ""

#. type: Plain text
#: manual/commands/op.txt:63
#, no-wrap
msgid ""
"  op 27\n"
"Do a DC operating point simulation at temperature 27 degrees Celsius.\n"
"  op -50 200 25\n"
"Sweep the temperature from -50 to 200 in 25 degree steps. Do a DC operating "
"point simulation at each step.\n"
"  op\n"
"With no parameters, it uses the same ones as the last time. In this case, "
"from -50 to 200 in 25 degree steps.\n"
"  op 200 -50 -25\n"
"You can sweep downward, by asking for a negative increment.\n"
"  op temperature=75\n"
" Simulate at 75 degrees, this time. This isn't remembered for next time.\n"
"  op\n"
"Since the last time used the temperature option, go back one more to find "
"what the sweep parameters were. In this case, downward from 200 to -50 in 25 "
"degree steps.\n"
msgstr ""

#. type: Title ======
#: manual/commands/options.txt:1
#, no-wrap
msgid "\"options\" command"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:6 manual/commands/options.txt:14
msgid "Sets options, iteration parameters, global data."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:10
#, no-wrap
msgid ""
"  options\n"
"  options option-name value ...\n"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:18
msgid "Typical usage is the name of the item to set followed by the value."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:20
msgid "The bare command `options' displays the values."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:22
msgid ""
"These options control the simulation by specifying how to handle marginal "
"circumstances, how long to wait for convergence, etc."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:24
msgid "Most of the SPICE options are supported, more have been added."
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:26
#, no-wrap
msgid "i/o"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:40
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|acct         |false    |Turns on accounting. When enabled, print the CPU "
"time used after each command, and a summary on exit in batch more.  |\n"
"|list         |false    |Turns on echo input.  |\n"
"|clobber      |true     |Allow clobber of files.  |\n"
"|out          |9999     |Output width.  Sets the output print width for "
"tables and character graphics.  |\n"
"|ydivisions   |4.       |Y axis divisions. Sets the number of divisions on "
"the Y axis for ASCII plotting.  |\n"
"|phase        |degrees  |In AC analysis, print phase in \"degrees\", "
"\"+degrees\", \"-degrees\" or \"radians\".\\\\  \"degrees\" wraps phase to "
"the range of -180 to +180.\\\\  \"+degrees\" wraps phase to the range of 0 "
"to +360.\\\\  \"-degrees\" wraps phase to the range of -360 to 0.  |\n"
"|harmonics    |9        |Harmonics in Fourier analysis. The number of "
"harmonics to display in a Fourier analysis, unless specified otherwise.  |\n"
"|edit         |true     |Enable command line editing.  |\n"
"|language     |acs      |Simulation language selection.  As supplied, the "
"supported values are \"acs\", \"spice\", \"spectre\", and \"verilog\".  |\n"
"|insensitive  |         |Case sensitivity.  Whether it is true or false by "
"default depends on the language.  |\n"
"|units        |spice    |Floating point units.  Supported values are "
"\"spice\" and \"si\".  |\n"
"|recursion    |20       |Limit recursion in expresion evaluation to x "
"levels.  The purpose is to trap infinite recursion in user expressions.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:42
#, no-wrap
msgid "accuracy, i/o"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:48
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|numdgt       |5        |Number of significant digits to print for analysis "
"results.  It is silently limited to 3 to 20.  |\n"
"|floor        |1.E-21   |Effective zero value.  Results values less than "
"floor are shown as zero. Other small numbers are rounded to the nearest "
"floor.  |\n"
"|vfloor       |1.f      |Effective zero value for voltage probes.  Results "
"values less than vfloor are shown as zero. Other small numbers are rounded "
"to the nearest vfloor.  |\n"
"|roundofftol  |100.f    |Numeric rounding tolerance.  Some internal "
"calculations can result in cancellations, with a result near zero even "
"though the operands are large. The number is converted to zero if it is less "
"than roundofftol*theoperand.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:49
#, no-wrap
msgid "accuracy, tolerances"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:61
#, no-wrap
msgid ""
"^key         ^default  ^description  ^\n"
"|gmin        |1.p      |Minimum conductance allowed by the program.  Every "
"node must have a net minimum conductance of GMIN to ground. If effective "
"open circuits are found during the solution process (leading to a singular "
"matrix) a conductance of GMIN is forced to ground, after printing an \"open "
"circuit\" error message.  |\n"
"|short       |10.u    |Resistance of voltage source or short. Sets the "
"default resistance of voltage sources. In some cases, inductors are replaced "
"by resistors, if so, this is the value. It is also the resistance used to "
"replace short circuits anywhere they are not allowed and the program finds "
"one.  |\n"
"|reltol      |0.001    |Relative error tolerance allowed.  If the ratio of "
"successive values in iteration are within RELTOL of one, this value is "
"considered to have converged.  |\n"
"|abstol      |1.p      |Absolute error tolerance allowed.  If successive "
"values in iteration are within ABSTOL of each other, this value is "
"considered to have converged.  |\n"
"|vntol       |1.u      |Absolute voltage error required to force model "
"re-evaluation.  If the voltage at the terminals of a model is within VNTOL "
"of the previous iteration, the model is not re-evaluated. The old values are "
"used directly.  |\n"
"|trtol       |7.       |Transient error tolerance.  This parameter is an "
"estimate of the factor by which the program overestimates the actual "
"truncation error.  For critical applications, it should be set to 1.  |\n"
"|chgtol      |10.f     |Charge tolerance.  It is used in step size control "
"in transient analysis.  |\n"
"|pivtol      |100.f    |Pivot tolerance.  Sets a threshold for printing an "
"\"open circuit\" warning.  |\n"
"|bypasstol   |0.1      |Tolerance multiplier for evaluation bypass "
"checking.  |\n"
"|loadtol     |0.1      |Tolerance multiplier for matrix load bypass "
"checking.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:62
#, no-wrap
msgid "accuracy, algorithms"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:75
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|method        |trap     |Differentiation method.  Incorrectly called "
"integration method in SPICE. Possible values are euler, gear, and trap.  "
"|\n"
"|bypass        |true     |Bypass model evaluation if appropriate. If the "
"last two iterations indicate that an element is converged or dormant, do not "
"evaluate it but use its old values directly.  |\n"
"|incmode       |true     |Incrementally update the matrix. Instead of "
"rebuilding the matrix on every iteration, keep as much of the old matrix as "
"possible and make incremental changes.  |\n"
"|lcbypass      |true     |Bypass evaluation of linear inductors and "
"capacitors when possible. When set, they are evaluated only on the first "
"iteration of a time step.  |\n"
"|lubypass      |true     |Bypass parts of LU decomposition if "
"appropriate. If only a few elements of the matrix were changed solve only "
"those parts of the LU matrix that depend on them.  |\n"
"|fbbypass      |true     |Skip matrix solution the last iteration. In "
"theory, it reduces accuracy slightly, but specified tolerances will still be "
"met. Time saving can be significant.  |\n"
"|traceload     |true     |Use a queue to only load changed elements to the "
"matrix. This results in faster loading and has no known drawbacks.  |\n"
"|order         |auto     |Equation ordering.  Determines how external node "
"numbers are mapped to internal numbers. The values are forward, reverse, and "
"auto.  |\n"
"|mode          |mixed    |Simulation mode selection.  Values are analog, "
"digital, and mixed. In analog mode, logic elements (type U) are replaced by "
"their subcircuits as if they were type X. In digital mode, logic elements "
"are simulated as digital regardless of whether the signals are proper or "
"not, as in traditional mixed-mode simulation. In mixed mode, logic elements "
"may be simulated as analog or digital depending on the signals present.  |\n"
"|transits      |2        |Mixed mode transition count.  Sets the number of "
"good transitions for a supposedly digital signal to be accepted as "
"digital.  |\n"
"|quitconvfail  |false    |Quit on convergence failure in transient "
"analysis. Do not adjust time step, just stop.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:75
#, no-wrap
msgid "iteration limiting and heuristics"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:91
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|itl1          |100      |DC iteration limit.  Sets the maximum number of "
"iterations in a DC, OP, or initial transient analysis allowed before "
"stopping and reporting that it did not converge.  |\n"
"|itl2          |50       |DC transfer curve iteration limit.  SPICE option "
"accepted but not implemented. Use itl1 instead.  |\n"
"|itl3          |6        |Lower transient iteration limit.  If the number of "
"iterations is more than itl3 the step size is limited by "
"trstephold. Otherwise, it can grow by trstepgrow.  |\n"
"|itl4          |20       |Upper transient iteration limit.  Sets the maximum "
"number of iterations on a step in transient analysis. If the circuit fails "
"to converge in this many iterations the step size is reduced (by option "
"trstepshrink), time is backed up, and the calculation is repeated.  |\n"
"|itl5          |0        |Transient analysis total iteration limit.  SPICE "
"option accepted but not implemented. Actual behavior is the same as itl5 = "
"0, in SPICE, which omits this test.  |\n"
"|itl6          |5000     |Homotopy iteration limit.  Sets the maximum number "
"of iterations to allow for homotopy methods of recovering from a convergence "
"failure.  Setting itl6 to 0 disables homotopy.  |\n"
"|itl7          |1        |Worst case analysis iteration limit.  Sets the "
"maximum number of iterations for the individual element trials in a DC or "
"bias worst case analysis. If more iterations than this are necessary, the "
"program silently goes on to the next step, as if nothing was wrong, which is "
"usually the case.  |\n"
"|itl8          |99       |Convergence diagnostic iteration threshold.  If "
"the iteration count on a step exceeds itl8 diagnostic messages are printed "
"in an attempt to aid the user in solving the convergence problem.  |\n"
"|itermin       |1        |Number of extra iterations after convergence.  "
"After convergence tolerances are met, do itermin extra iterations to be "
"sure. This provides protection against false indication of "
"convergence. Setting itermin = 0 is equivalent to SPICE, with improved "
"simulation speed.  |\n"
"|vmin          |-5.      |Initial negative node voltage limit.  All node "
"voltages may be limited to x to aid in convergence and prevent numeric "
"overflow. This is intended as a convergence aid only. It may or may not "
"help. This number is used as a starting point. It is adjusted as the "
"simulation progresses.  |\n"
"|vmax          |5.       |Initial positive node voltage limit.  All node "
"voltages may be limited to +x to aid in convergence and prevent numeric "
"overflow. This is intended as a convergence aid only. It may or may not "
"help. This number is used as a starting point. It is adjusted as the "
"simulation progresses.  |\n"
"|dampmax       |1.       |Normal Newton damping factor.  Sets the damping "
"factor for iteration by damped Newton's method, used when all is well. It "
"must be between 0 and 1, as close to 1 as possible and still achieve "
"convergence. The useful range is from .9 to 1. Setting dampmax too low will "
"probably cause convergence to a nonsense result.  |\n"
"|dampmin       |0.5      |Newton damping factor in problem cases.  Sets the "
"damping factor for iteration by damped Newton's method, used when there are "
"problems. It must be between 0 and 1, and is usually set somewhat less than "
"dampmax. The useful range is from .5 to .9. Setting it lower than .5 may "
"cause convergence to a nonsense result. Aside from that, a lower value (but "
"less than dampmax) tends to improve robustness at the expense of convergence "
"speed.  |\n"
"|dampstrategy  |0        |Damping strategy.  The actual damping factor to "
"use is determined by heuristics. Normally the damping factor is dampmax. It "
"is reduced to dampmin when certain conditions occur, then it drifts back up "
"on subsequent iterations.  The strategy used is determined by the sum of the "
"following factors:\\\\  1: initial step: Use dampmin on the second "
"iteration.\\\\  2: range:  Use dampmin if an iteration voltage would be out "
"of range (vmin, vmax).\\\\  4: device limiting:  Use dampmin when device "
"based voltage or current limiting limits.  (If supported by the device.)\\\\  "
"10: device region:  Use dampmin when a device passes a region boundary (If "
"supported by the device.)\\\\  20:  device reverse:  Use dampmin when a "
"device is reversed.  (If supported by the device.)  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:93
#, no-wrap
msgid "time step control"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:105
#, no-wrap
msgid ""
"^key           ^default     ^description  ^\n"
"|dtmin         |1.p         |Minimum time step.  The smallest internal time "
"step in transient analysis. The transient command dtmin option and the "
"dtratio option override it if it is bigger.  |\n"
"|dtratio       |1.G         |The ratio between minimum and maximum time "
"step.  |\n"
"|trstepgrow    |1.E+99      |The maximum internal step size growth in "
"transient analysis. Default = 1e99, which allows arbitrary changes in step "
"size.  |\n"
"|trstephold    |1.E+99      |The maximum internal step size growth in "
"transient analysis, when the iteration count exceeds itl3 but still "
"converges.   |\n"
"|trstepshrink  |2.          |The amount to decrease the transient step size "
"by when convergence fails.  |\n"
"|trreject      |0.5         |Transient error rejection threshold.  Controls "
"how bad the truncation error must be to reject a time step. A value of .5 "
"means that if the step reqested is smaller than .5 times the step size used, "
"the current step will be rejected. If the new step is .8 times the old step "
"size it will be adjusted but the step just calculated will not be rejected.  "
"|\n"
"|trsteporder   |3           |Control time steps according to \"trsteporder\" "
"order interpolation.  Supported values are 1, 2, 3.  |\n"
"|trstepcoef1   |0.25        |Coefficient used in order 1 step control  |\n"
"|trstepcoef2   |0.04166667  |Coefficient used in order 2 step control  |\n"
"|trstepcoef3   |0.00520833  |Coefficient used in order 3 step control  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:106
#, no-wrap
msgid "circuit environment"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:115
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|tnom         |27.      |Nominal temperature, Celsius.  All components have "
"their nominal value at this temperature.  |\n"
"|temperature  |27.      |Simulation temperature.  Sets the ambient "
"temperature, in degrees Celsius. This is the temperature at which the "
"simulation takes place, unless changed by some other command.  |\n"
"|rstray       |true     |Include series resistance in device models. This "
"creates internal nodes and results in a significant speed and memory "
"penalty. It also makes convergence characteristics worse.  |\n"
"|cstray       |true     |Include capacitance in device models. This may "
"create internal nodes and result in a significant speed and memory "
"penalty. It also may make convergence characteristics worse.  |\n"
"|defl         |100.u    |MOSFET default channel length in meters.  |\n"
"|defw         |100.u    |MOSFET default channel width in meters.  |\n"
"|defad        |0.       |MOSFET default drain diffusion area in square "
"meters.  |\n"
"|defas        |0.       |MOSFET default source diffusion area in square "
"meters.  |\n"
msgstr ""

#. type: Title ======
#: manual/commands/outfile.txt:1
#, no-wrap
msgid "\">\" command"
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:6
msgid "Saves a copy of all program output (except help) in a file."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:12
#, no-wrap
msgid ""
"  > file\n"
"  >> file\n"
"  >\n"
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:16
msgid ""
"''>'' creates a new file for this output. If the file already exists, the "
"old one is lost, and replaced by the new one."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:18
msgid ""
"''>''''>'' appends to an existing file, if it exists, otherwise it creates "
"one."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:20
msgid "A bare ''>'' closes the file."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:28
#, no-wrap
msgid ""
"  > run1\n"
"Save everything in a file run1 in the current directory. If run1 already "
"exists, the old one is gone.\n"
"  >> allof\n"
"Save everything in a file allof. If allof already exists, it is kept, and "
"the new data is added to the end.\n"
"  >\n"
"Close the file. Stop saving.\n"
msgstr ""

#. type: Title ====
#: manual/commands/parameter.txt:1 manual/tech/plugins/parameter_functions_and_measurements.txt:17
#, no-wrap
msgid "\"parameter\" command"
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:6
msgid "Set and view parameters."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:13
#, no-wrap
msgid ""
"  param\n"
"  parameter\n"
"  param param-name value ...\n"
"  parameter param-name value ...\n"
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:17
msgid "The bare command param lists all defined parameters and their values."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:19
msgid ""
"The value may be a number, the name of another parameter, or an "
"expression. If it is another parameter, eventually it must resolve to a "
"number. This depth can be set by the option recursion which has a default "
"value of 20. The depth is limited to prevent infinite recursion."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:21
msgid ""
"All component values, numeric lists such as in PWL, component and model "
"parameters can be numbers or expressions.  Numeric arguments to most "
"commands can also be parameters or expressions."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:23
msgid ""
"If the same parameter is set more than once, the most recent one "
"prevails. All instances of the parameter will take the new value."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:25
msgid ""
"When a parameter name is used as a value, it may be enclosed by quotes or "
"curly braces."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:27
msgid ""
"Parameter expressions use late evaluation and dynamic scoping, like a "
"functional language."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:29
msgid ""
"For more information on parameter expressions, look "
"[[gnucap:manual:howto:expressions|here]]."
msgstr ""

#. type: Plain text
#: manual/commands/parameter.txt:68
#, no-wrap
msgid ""
"Suppose we have this circuit:\n"
"  .model small npn (bf=beta)\n"
"  Vpower (vcc 0) dc vcc\n"
"  Vin    (in  0) generator\n"
"  Q1 (c b e) small\n"
"  Rc (vcc c) rc\n"
"  Re (e 0) re\n"
"  Rb1 (vcc b) rb1\n"
"  Rb2 (b 0)   rb2\n"
"If I try to simulate it now, it will not be very useful. We need to give our "
"circuit some values:\n"
"  gnucap> param vcc=10 beta=100 rc=10k re=1k rb1=100k rb2=rc\n"
"Let's see what it does:\n"
"  gnucap> print op v(nodes)\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.8941   8.3513   0.16652  0.       10.\n"
"What happens if I change beta?\n"
"  gnucap> param beta=200\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.90128  8.2822   0.17264  0.       10.\n"
"Not much changes. Let's try to lower v(''''c). About 6 should be better.\n"
"  gnucap> param rb1=68k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.2602   4.9866   0.50385  0.       10.\n"
"Too low, try again:\n"
"  gnucap> param rb1=82k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.0724   6.7437   0.32726  0.       10.\n"
"Too high...\n"
"  gnucap> param rb1=75k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.1586   5.9433   0.4077   0.       10.\n"
"Close enough.\n"
msgstr ""

#. type: Title ======
#: manual/commands/pause.txt:1
#, no-wrap
msgid "\"pause\" command"
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:6
msgid "Suspend batch mode. Wait for the user to hit a key."
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:10
#, no-wrap
msgid "  pause comment\n"
msgstr ""

#. type: Title ======
#: manual/commands/pause.txt:11 manual/commands/plot.txt:14 manual/languages/spectre.txt:120 manual/languages/verilog.txt:132 spectre.txt:92
#, no-wrap
msgid "Status"
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:14
msgid "This command does not work on all systems, due to buffering of console i/o."
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:18
msgid ""
"Prints Continue? and waits for a key hit. Type `n', `N', escape or control-c "
"to terminate the batch mode. Type anything else to continue."
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:20
msgid "Any comment is ignored."
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:25
#, no-wrap
msgid ""
"  pause Try more gain\n"
"  pause\n"
"These both work the same. Ask to continue, wait for a key hit, then go on.\n"
msgstr ""

#. type: Title ======
#: manual/commands/plot.txt:1
#, no-wrap
msgid "\"plot\" command"
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:6
msgid "Select points in the circuit for graphic output. Select graphic output."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:13
#, no-wrap
msgid ""
"  plot\n"
"  plot mode points ... ...\n"
"  plot mode + points ... ...\n"
"  plot mode - points ... ...\n"
"  plot mode CLEAR\n"
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:17
msgid ""
"The plotting leaves something to be desired. Only two signals can be plotted "
"at a time. The output file is corrupt when plotting is on."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:21
msgid ""
"The `plot' command selects where to look at the circuit, or where to hook "
"the oscilloscope probe."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:25
msgid "To list the probe points, use the bare command `plot'."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:36
msgid ""
"You must set the scaling. If you do not, the default range is fixed at -5 to "
"5. Gnucap cannot auto-scale because it generates the plot during simulation, "
"so the necessary information is not available yet. Spice can auto-scale only "
"because it waits for the simulation to complete before producing any output."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:38
msgid ""
"Plot uses the same variables as print. See the print command for a list of "
"what is available."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:40 manual/commands/print.txt:30
msgid ""
"The options plot and noplot on any analysis command turn plotting on and off "
"a single run. The plot command turns plotting on and tabular output off. The "
"print command turns plotting off and tabular output on."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:42
msgid ""
"You can add to or delete from an existing list by prefixing with + or "
"-. plot ac + v(3) adds v(3) to the existing set of AC probes. plot ac - "
"q(c5) removes q(c5) from the list. You can use the wildcard characters * and "
"? when deleting."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:44
msgid "Plotting is limited to 2 items."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:58
#, no-wrap
msgid ""
"  plot ac vm(12)(0,5) vm(13)(-5,5)\n"
"The magnitude of the voltage at node 12 with a range of 0 to 5, and node 13 "
"with a range of -5 to 5 for AC analysis.\n"
"  plot dc v(r26)\n"
"The voltage across R26 for DC analysis. Since there is no range, default "
"values will be used.\n"
"  plot tran v(r83)(0,5) p(r83)(0,1u)\n"
"Plot the voltage and power of R83 in the next transient analysis. The "
"voltage scale is 0 to 5. The power scale is 0 to 1 microwatt.\n"
"  plot\n"
"List all the probes for all modes.\n"
"  plot dc\n"
"Display the DC plot list.\n"
"  plot ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/print.txt:1
#, no-wrap
msgid "\"print\" command"
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:6
msgid "Select points in the circuit for tabular output. Select tabular output."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:14
#, no-wrap
msgid ""
"  print\n"
"  print mode points ... ...\n"
"  print mode + points ... ...\n"
"  print mode - points ... ...\n"
"  print mode CLEAR\n"
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:18
msgid ""
"The `print' command selects where to look at the circuit, or where to hook "
"the voltmeter (ammeter, watt meter, ohm meter, etc.) probe."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:22
msgid "To list the probe points, use the bare command `print'."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:24
msgid ""
"On start-up, probes are not set. You must do the command `print op v(nodes)' "
"or put `.print op v(nodes)' in the circuit file to get any output from the "
"op command."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:26
msgid ""
"Syntax for each point is parameter(node), parameter(componentlabel), or "
"parameter(index). Some require a dummy index."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:28
msgid ""
"If the component does not exist, you will get an error message. If the "
"component exists but the parameter is not valid for that type, there will be "
"no error message but the value printed will be obviously bogus."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or "
"-. print ac + v(3) adds v(3) to the existing set of AC probes. print ac - "
"q(c5) removes q(c5) from the list. You can use the wildcard characters * and "
"? when deleting."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:50
#, no-wrap
msgid ""
"  print ac v(12) v(13) v(14)\n"
"The voltage at nodes 12, 13, and 14 for AC analysis.\n"
"  print dc v(r26)\n"
"The voltage across R26, for DC analysis.\n"
"  print tran v(r83) p(r83)\n"
"Voltage and power of R83, for transient analysis.\n"
"  print dc i(c8) p(r5) z(r5)\n"
"The current through C8, power dissipated in R5, and the impedance seen "
"looking into the circuit across R5.\n"
"  print op v(nodes)\n"
"The voltage at all nodes for the op command.\n"
"  print\n"
"List all the probes, for all modes.\n"
"  print op\n"
"Display the OP probe list.\n"
"  print ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/save.txt:1
#, no-wrap
msgid "\"save\" command"
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:6
msgid "Saves the circuit to a file."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:10
#, no-wrap
msgid "  save filename {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:14
msgid "The file is in an ASCII format, so the list may be used as part of a report."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:16
msgid ""
"The format used depends on the \"language\" option, which could use a plugin "
"to provide any format.  \"Spice\", \"Spectre\" and \"Verilog\" formats are "
"supported in the standard installation."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:18
msgid "You can save a part of a circuit. See the list command for more details."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:28
#, no-wrap
msgid ""
"  save works.ckt\n"
"Save the circuit in the file works.ckt, in the current directory.\n"
"  save\n"
"Save the circuit. Since you did not specify a file name, it will ask for "
"one.\n"
"  save partof.ckt R*\n"
"Save a partial circuit, just the resistors, to the file partof.ckt. (See the "
"List command.)\n"
"  save /client/sim/ckt/no33\n"
"You can specify a path name.\n"
msgstr ""

#. type: Title ======
#: manual/commands/status.txt:1
#, no-wrap
msgid "\"status\" command"
msgstr ""

#. type: Plain text
#: manual/commands/status.txt:6
msgid "Shows information on how the system resources are being utilized."
msgstr ""

#. type: Plain text
#: manual/commands/status.txt:11
#, no-wrap
msgid ""
"  status\n"
"  status notime\n"
msgstr ""

#. type: Plain text
#: manual/commands/status.txt:14
msgid "The notime option omits times but prints everything else."
msgstr ""

#. type: Title ======
#: manual/commands/store.txt:1
#, no-wrap
msgid "\"store\" command"
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:6
msgid "Select points in the circuit to store for postprocessing."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:14
#, no-wrap
msgid ""
"  store\n"
"  store mode points ... ...\n"
"  store mode + points ... ...\n"
"  store mode - points ... ...\n"
"  store mode CLEAR\n"
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:18
msgid ""
"The \"store\" command selects probes to store for postprocessing, such as "
"measures."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:20
msgid "There are separate lists of points for each type of analysis."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:22
msgid "To list the points, use the bare command \"store\"."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:24
msgid ""
"On start-up, probes are not set. You must do the command \"store op "
"v(nodes)\", \"store tran v(nodes)\" or whatever you want, to store any data "
"for post-processing."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:26
msgid ""
"You can add to or delete from an existing list by prefixing with + or "
"-. store ac + v(3) adds v(3) to the existing set of AC probes. store ac - "
"q(c5) removes q(c5) from the list. You can use the wildcard characters * and "
"? when deleting."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:40
#, no-wrap
msgid ""
"  store ac v(nodes)\n"
"The voltage at all nodes for AC analysis.\n"
"  store dc v(nodes) id(M*)\n"
"The voltage at all nodes and the parameter \"id\" on all devices witl labels "
"starting with \"M\", for DC analysis.\n"
"  store tran v(*) p(*)\n"
"All parameters named \"v\", which probably means all node voltages and the "
"most common voltage for all devices.  All parameters named \"p\", which is "
"usually power.\n"
"  store\n"
"List all probes stored, for all modes.\n"
"  store op\n"
"Display the OP store list.\n"
"  store ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/sweep.txt:1
#, no-wrap
msgid "\"sweep\" command"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:6
msgid ""
"Sweep a component (or group of components) over a range. Set up a loop for "
"iteration."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:10
#, no-wrap
msgid "  sweep {stepcount} partlabel=range ...\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:14
msgid "This command is considered obsolete, but the replacement is not working yet."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:16
msgid ""
"This command begins a loop which will sweep a component or group of "
"components."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:18
msgid ""
"When this command is given, the only apparent actions will be a change in "
"the prompt from `gnucap>' to `>>>', and some disk action."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:20
msgid ""
"The different prompt means that commands are not executed immediately, but "
"are stored in a temporary file."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:22
msgid ""
"The bare command will repeat the same command sequence as the last time "
"sweep was run, and not prompt for anything else."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:24
msgid ""
"Additional components can be swept at the same time by entering a `FAult' "
"command at the `>>>' prompt. The `fault' behaves differently here: It "
"accepts a range, which is the sweep limits."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:26
msgid ""
"The `go' command will end the entry sequence, and make it all happen. After "
"this, the values are restored. (Also, all faults are restored, as if by the "
"`restore' command.)"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:28
msgid ""
"All commands can be used in this mode. Of course, some of them are not "
"really useful (quit) because they work as usual."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:30
msgid ""
"Only linear, ordinary parts can be swept. (No semiconductor devices, or "
"elements using behavioral modeling.) The tolerance remains unchanged. If you "
"attempt to sweep a nonlinear or otherwise strange part, it becomes ordinary "
"and linear during the sweep."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:38
#, no-wrap
msgid ""
"  gnucap> sweep  5   R14=1,100k   R15=100k,1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
"This sequence of commands says to simultaneously sweep R14 and R15 in 5 "
"steps, in opposite directions, list the circuit and do an AC analysis for "
"each step.\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:58
#, no-wrap
msgid ""
"Assuming the circuit was:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
"The result of this sequence would be:\n"
"  R14  1   0   1\n"
"  R15  2   0   100k\n"
"an AC analysis\n"
"  R14  1   0   25.75k\n"
"  R15  2   0   75.25k\n"
"an AC analysis\n"
"  R14  1   0   50.5k\n"
"  R15  2   0   50.5k\n"
"an AC analysis\n"
"  R14  1   0   75.25k\n"
"  R15  2   0   25.75k\n"
"an AC analysis\n"
"  R14  1   0   100k\n"
"  R15  2   0   1\n"
"an AC analysis\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:62
#, no-wrap
msgid ""
"After all this is done, the circuit is restored, so list would show:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:69
#, no-wrap
msgid ""
"You could accomplish the same thing by entering fault commands at the `>>>' "
"prompt.\n"
"  gnucap>sweep  5\n"
"  >>>fault  R14=1, 100k\n"
"  >>>fault  R15=100k, 1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
msgstr ""

#. type: Title ======
#: manual/commands/temp.txt:1
#, no-wrap
msgid "\"temperature\" command"
msgstr ""

#. type: Plain text
#: manual/commands/temp.txt:6
msgid "Views and sets the temperature, with SPICE compatible syntax."
msgstr ""

#. type: Plain text
#: manual/commands/temp.txt:11
#, no-wrap
msgid ""
"  temperature\n"
"  temperature value\n"
msgstr ""

#. type: Plain text
#: manual/commands/temp.txt:15
msgid "With no value, it prints the temperature."
msgstr ""

#. type: Plain text
#: manual/commands/temp.txt:17
msgid "With a value, it is equivalent to .option temperature=value."
msgstr ""

#. type: Plain text
#: manual/commands/temp.txt:19
msgid "The real purpose of this command is Spice compatibility."
msgstr ""

#. type: Title ======
#: manual/commands/title.txt:1
#, no-wrap
msgid "\"title\" command"
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:6
msgid "View and create the heading line for printouts and files."
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:11
#, no-wrap
msgid ""
"  title\n"
"  title a line of text\n"
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:15
msgid ""
"There is a header line at the beginning of every file, to help you identify "
"it in the future. This command sets up what it says. It also sets up a "
"heading for printouts and graphs."
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:17
msgid ""
"When you use the `get' command to bring in a new circuit, it replaces the "
"title with the one in the file. The `title' command lets you change it, for "
"the next time it is written out."
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:23
#, no-wrap
msgid ""
"  title This is a test.\n"
"Sets the file heading to `This is a test.' In the future, all files written "
"will have `This is a test.' as their first line.\n"
"  title\n"
"Displays the file heading. In this case, it prints `This is a test.'\n"
msgstr ""

#. type: Title ======
#: manual/commands/transient.txt:1
#, no-wrap
msgid "\"transient\" command"
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:6
msgid "Performs a nonlinear time domain (transient) analysis."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:11
#, no-wrap
msgid ""
"  transient start stop stepsize {options ...}\n"
"  transient stepsize stop start {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:14
msgid ""
"The probes to look at must have been previously selected by the print or "
"plot command."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:16
msgid ""
"Three parameters are normally needed for a Transient analysis: start time, "
"stop time and step size, in this order. The SPICE order (step size, stop, "
"start) is also acceptable. An optional fourth parameter is the maximum "
"internal time step."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:18
msgid ""
"If all of these are omitted, the simulation will continue from where the "
"most recent one left off, with the same step size, unless the circuit "
"topology has been changed. It will run for the same length of time as the "
"previous run."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:20
msgid ""
"Do not use a step size too large as this will result in errors in the "
"results. If you suspect that the results are not accurate, try a larger "
"argument to skip. This will force a smaller internal step size. If the "
"results are close to the same, they can be trusted. If not, try a still "
"larger skip argument until they appear to match close enough."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:22
msgid ""
"The most obvious error of this type is aliasing. You must select sample "
"frequency at least twice the highest signal frequency that exists anywhere "
"in the circuit. This frequency can be very high, when you use the default "
"step function as input. The signal generator does not have any filtering."
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:49
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to "
"the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from "
"power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC "
"analysis. Instead, use the values specified with the IC = options on the "
"various elements, and set everything else to zero.  In most cases, UIC is "
"not recommended.  Improper use of UIC causes more problems than it solves.  "
"It is the way it is for Spice compatibility.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/transient.txt:61
#, no-wrap
msgid ""
"  transient 0 100u 10n\n"
"Start at time 0, stop after 100 micro-seconds. Simulate using 10 nanosecond "
"steps.\n"
"  transient\n"
"No parameters mean to continue from the last run. In this case it means to "
"step from 100 us to 200 us in 10 ns steps. (The same step size and run "
"length, but offset to start where the last one stopped.\n"
"  transient skip 10\n"
"Do 10 extra steps internally for every step that would be done otherwise. In "
"this case it means to internally step at 1 nanosecond. If the output is in "
"tabular form, the extra steps are hidden.\n"
"  transient 0\n"
"Start over at time = 0. Keep the same step size and run length.\n"
"  transient >arun\n"
"Save the results of this run in the file \"arun\".\n"
msgstr ""

#. type: Title ======
#: manual/commands/width.txt:1
#, no-wrap
msgid "\"width\" command"
msgstr ""

#. type: Plain text
#: manual/commands/width.txt:6
msgid "Set input and output width."
msgstr ""

#. type: Plain text
#: manual/commands/width.txt:10
#, no-wrap
msgid "  width {IN=value} {OUT=value}\n"
msgstr ""

#. type: Plain text
#: manual/commands/width.txt:13
msgid ""
"The `width' command is the same as the `options' command. It is provided for "
"SPICE compatibility. SPICE uses width to set two parameters: in and out, "
"which we set with the options command."
msgstr ""

#. type: Title ======
#: manual/compatibility.txt:1 manual/compatibility/subcircuit_with_parameters.txt:1
#, no-wrap
msgid "Compatibility"
msgstr ""

#. type: Plain text
#: manual/compatibility.txt:4
msgid ""
"This section documents compatibility issues, including syntax and feature "
"differences compared to other simulators.  In some cases, a workaround is "
"suggested.  In almost all cases, there are plans to provide exact "
"compatibility in the future."
msgstr ""

#. type: Bullet: '  * '
#: manual/compatibility.txt:5
#, no-wrap
msgid ""
"[[.:compatibility:subcircuit with parameters|subcircuit with parameters, "
"Pspice, LTspice]]\n"
msgstr ""

#. type: Title =====
#: manual/compatibility/subcircuit_with_parameters.txt:2
#, no-wrap
msgid "Subcircuit with parameters"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:5
msgid ""
"Some simulators (LTspice, Pspice) accept a syntax for subcircuits that is "
"incompatible with gnucap."
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:7
msgid "The Gnucap syntax is compatible with other simulators such as Hspice."
msgstr ""

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:7
#, no-wrap
msgid "Subcircuit instantiation syntax"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:10 manual/compatibility/subcircuit_with_parameters.txt:25
msgid "LTspice syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:13
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack params: ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance params: ( r=1 xl=10 xc=2 length=1 zfactor=1 "
")\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:16
msgid ""
"The key ''params:'' should be omitted.  Parentheses are optional.\\\\ Gnucap "
"syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:19
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack vr=10  vi=1  on=1 vfactor=1.732\n"
"  Ximp v1r v1i 0 0  impedance r=1 xl=10 xc=2 length=1 zfactor=1\n"
msgstr ""

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid "Subcircuit declaration syntax"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:27
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i params: on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:33
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + params:\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:36
msgid ""
"The key params: should be omitted.  It is not necessary to declare "
"parameters, but you may do it for documentation or to specify default "
"values.  Parameters can be on the same line or in .param statements on "
"following lines.\\\\ Gnucap syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:38
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:43
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:45
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i (on = 1 r = 100 xl = 0)\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:48
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:54
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Title ======
#: manual/devices.txt:1
#, no-wrap
msgid "Devices"
msgstr ""

#. type: Plain text
#: manual/devices.txt:4
msgid ""
"Gnucap devices are defined by plugins. This section defines all commands "
"supplied in the main tarball, and also the optional \"models\" tarballs."
msgstr ""

#. type: Plain text
#: manual/devices.txt:6
msgid ""
"Your installation may not have all of these, and may have others in addition "
"to these. It depends on which plugins you have installed."
msgstr ""

#. type: Plain text
#: manual/devices.txt:8
msgid ""
"The main tarball contains simple models, including most models that are "
"included with Spice-2g6, and some that are in Spice-3.  This should be "
"adequate for beginning academic work and most hobby work.  The other "
"tarballs contain specific models from a variety of sources.  Some are exact "
"industry standard models.  Some are from other simulators and are provided "
"for compatibility.  Some are new research oriented models.  Some are of "
"primarily historical interest."
msgstr ""

#. type: Plain text
#: manual/devices.txt:10
msgid ""
"The Gnucap plugin system allows anyone to develop new models and add them, "
"without recompiling or reinstalling the main simulator.  There are several "
"options for doing this, including a model compiler and a wrapper that allows "
"the use of unmodified Spice C models."
msgstr ""

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:basic|Basic passive devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:other|Other \"spice\" devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:semi|Semiconductor devices]]\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic.txt:1
#, no-wrap
msgid "Basic passive devices"
msgstr ""

#. type: Plain text
#: manual/devices/basic.txt:4
msgid ""
"Gnucap includes the usual basic Spice devices, and some others that are "
"found in commercial versions of Spice."
msgstr ""

#. type: Plain text
#: manual/devices/basic.txt:6
msgid ""
"All of them are designed as plugins, but are included in the base "
"distribution and loaded by default."
msgstr ""

#. type: Plain text
#: manual/devices/basic.txt:8
msgid ""
"All of them can be extended by simple behavioral expressions, in some cases "
"beyond what is available in any Spice."
msgstr ""

#. type: Plain text
#: manual/devices/basic.txt:10
msgid "All of them have extended probes, more than any Spice."
msgstr ""

#. type: Title ====
#: manual/devices/basic.txt:11
#, no-wrap
msgid "The basic devices"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "capacitor (C)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "inductor (L)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "resistor (R)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed voltage source (V)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed current source (I)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled voltage source (E)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled current source (G)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled voltage source (H)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled current source (F)\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic.txt:22
#, no-wrap
msgid "Less common basic devices"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "admittance (Y)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled resistor\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled capacitor\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled admittance\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "trans-capacitor\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic.txt:30
#, no-wrap
msgid "More info"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:basic syntax]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:inline behavioral modeling]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:spice-style models]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:probes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:capacitor|.]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/basic_syntax.txt:1
#, no-wrap
msgid "Basic device syntax"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:4
msgid ""
"This page applies to the simple \"Spice\" basic devices, and some extended "
"forms of them."
msgstr ""

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:4 manual/devices/capacitor.txt:5
#, no-wrap
msgid "Spice format"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:7 manual/devices/basic/basic_syntax.txt:57 manual/devices/basic/basic_syntax.txt:71
msgid "The format for simple devices is:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:9
#, no-wrap
msgid "  label  (connections)  value\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:11
msgid "Parentheses around the connections are optional."
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:13 manual/devices/basic/basic_syntax.txt:61 manual/devices/basic/basic_syntax.txt:77
msgid "Examples:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:18
#, no-wrap
msgid ""
"  Vin     (in 0)   10\n"
"  Lseries (in out) .01\n"
"  Cshunt  (out 0)  100u\n"
"  Rload   (out 0)  100\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:20
msgid "The first letter of the label determines the type:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:30
#, no-wrap
msgid ""
"^2 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        "
"^\n"
"|C      |capacitor                         |capacitance q/v   |Cxxxx (p n) "
"capacitance       |\n"
"|L      |inductor                          |inductance flux/i |Lxxxx (p n) "
"inductance        |\n"
"|R      |resistor                          |resistance v/i    |Rxxxx (p n) "
"resistance        |\n"
"|Y      |admittance                        |admittance i/v    |Yxxxx (p n) "
"admittance        |\n"
"|V      |fixed voltage source              |DC voltage        |Vxxxx (p n) "
"voltage           |\n"
"|I      |fixed current source              |DC current        |Ixxxx (sink "
"src) current      |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:37
#, no-wrap
msgid ""
"^4 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        "
"^\n"
"|E      |voltage controlled voltage source |gain vout/vin     |Exxxx (p n ps "
"ns) gain        |\n"
"|G      |voltage controlled current source |gm   iout/vin     |Gxxxx (sink "
"src ps ns) gm     |\n"
"|H      |current controlled voltage source |rm   vout/iin     |Hxxxx (p n "
"control) gain      |\n"
"|F      |current controlled current source |gain iout/iin     |Fxxxx (sink "
"src control) gain |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:44
#, no-wrap
msgid ""
"^devices with special syntax ^^^^\n"
"^letter ^type                              ^value             ^syntax                        "
"^\n"
"|G      |voltage controlled resistor       |R/vc              |Gxxxx (p n ps "
"ns) vcr value   |\n"
"|G      |voltage controlled admittance     |Y/vc              |Gxxxx (p n ps "
"ns) vcg value   |\n"
"|G      |voltage controlled capacitor      |C/vc              |Gxxxx (p n ps "
"ns) vccap value |\n"
"|C      |trans-capacitor                   |Qout/vin          |Cxxxx (p n ps "
"ns) tcap value  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:53
#, no-wrap
msgid ""
"^Port names ^^\n"
"|p       |positive node or positive output        |\n"
"|n       |negative node or negative output        |\n"
"|sink    |current sink or current sink output     |\n"
"|source  |current source or current source output |\n"
"|ps      |positive input or control voltage node  |\n"
"|ns      |negative input or control voltage node  |\n"
"|control |current probe controlling element       |\n"
msgstr ""

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:54 manual/devices/capacitor.txt:11
#, no-wrap
msgid "Spectre format"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:59
#, no-wrap
msgid "  label  (connections)  type  parameter=value\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:66
#, no-wrap
msgid ""
"  Vin     (in 0)   vsource   dc=10\n"
"  Lseries (in out) inductor  l=.01\n"
"  Cshunt  (out 0)  capacitor c=100u\n"
"  Rload   (out 0)  resistor  r=100\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:68
msgid ""
"The device type is determined by the type field.  The first letter of the "
"label doesn't matter."
msgstr ""

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:68 manual/devices/capacitor.txt:17
#, no-wrap
msgid "Verilog format"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:75
#, no-wrap
msgid ""
"  type #(.parameter(value)) label (connections);\n"
"or\n"
"  type #(value) label (connections);\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:82
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (.p(in), .n(0));\n"
"  inductor  #(.l(.01))  Lseries (.p(in), .n(out));\n"
"  capacitor #(.c(100u)) Cshunt  (.p(out), .n(0));\n"
"  resistor  #(.r(100))  Rload   (.p(out), .n(0));\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:87
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (in, 0);\n"
"  inductor  #(.l(.01))  Lseries (in, out);\n"
"  capacitor #(.c(100u)) Cshunt  (out, 0);\n"
"  resistor  #(.r(100))  Rload   (out, 0);\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:91
#, no-wrap
msgid ""
"  vsource   #(10)   Vin     (in, 0);\n"
"  inductor  #(.01)  Lseries (in, out);\n"
"  capacitor #(100u) Cshunt  (out, 0);\n"
"  resistor  #(100)  Rload   (out, 0);\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/complex.txt:1
#, no-wrap
msgid "\"complex\" Complex value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:6
#, no-wrap
msgid "  complex ( realpart imaginarypart options )\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:10
msgid "Complex component value, using a real and imaginary part.  AC only."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:15
msgid ""
"Strictly, this adds no functionality over the polar option on any function, "
"except notational convenience."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:18
msgid ""
"It is only meaningful in AC analysis.  Others take the real part and ignore "
"the imaginary part.  No warning is issued."
msgstr ""

#. type: Title =====
#: manual/devices/basic/complex.txt:18 manual/devices/basic/exp.txt:43 manual/devices/basic/fit.txt:67 manual/devices/basic/poly.txt:33 manual/devices/basic/pulse.txt:52 manual/devices/basic/sffm.txt:37 manual/devices/basic/sin.txt:55 manual/devices/basic/tanh.txt:32 manual/devices/lossless_transmission_line.txt:41
#, no-wrap
msgid "Step control"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:21
msgid ""
"This function does have any role in time step control.  The notion of "
"complex values does not work in transient analysis."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:26
#, no-wrap
msgid ""
"  V12 (2 0) complex(1,2)\n"
"A voltage source with a value of 1 + j2 volts.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:28
#, no-wrap
msgid ""
"  R12 (2 4) complex(50,-10)\n"
"A \"resistor\" with a value of 50 - j10 ohms.\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/exp.txt:1
#, no-wrap
msgid "\"exp\" Exponential time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:7
#, no-wrap
msgid ""
"  exp (args)\n"
"  exp (iv pv td1 tau1 td2 tau2 period)\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:11
msgid "The component value is an exponential function of time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:14
msgid ""
"For voltage and current sources, this is the same as the Spice \"exp\" "
"function, with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:16 manual/devices/basic/sin.txt:24
msgid "The shape of the waveform is described by the following algorithm:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:28
#, no-wrap
msgid ""
"<code>\n"
"ev = _iv;\n"
"for (reltime=time; reltime>=0; reltime-=_period){\n"
"  if (reltime > _td1){\n"
"    ev += (_pv - _iv) * (1. - Exp(-(reltime-_td1)/_tau1));\n"
"  }\n"
"  if (reltime > _td2){\n"
"    ev += (_iv - _pv) * (1. - Exp(-(reltime-_td2)/_tau2));\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:30 manual/devices/basic/pulse.txt:40 manual/devices/basic/sffm.txt:22 manual/devices/basic/sin.txt:39
msgid "For other components, it gives a time dependent value."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:33 manual/devices/basic/pulse.txt:43 manual/devices/basic/sffm.txt:24 manual/devices/basic/sin.txt:42
msgid ""
"As an extension beyond Spice, you may specify the parameters as name=value "
"pairs in any order."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:42
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)             |\n"
"|pv      |Pulsed value.  (required)              |\n"
"|td1     |Rise time delay.  (Default = 0.)       |\n"
"|tau1    |Rise time constant.  (Default = 0.)    |\n"
"|td2     |Fall time delay.  (Default = 0.)       |\n"
"|tau2    |Fall time constant.  (Default = 0.)    |\n"
"|period  |Repeat period.  (Default = infinity.)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:46
msgid ""
"This function influences time step control through both smoothness control "
"and analog events."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:48
msgid ""
"The time step is limited by the active time constant, either tau1 or tau2, "
"depending on whether it is rising or falling."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:50
msgid ""
"The corners in as exp waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""

#. type: Title ======
#: manual/devices/basic/fit.txt:1
#, no-wrap
msgid "\"fit\" Fit a curve   \"pwl\" Piece-wise linear"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:6
#, no-wrap
msgid ""
"  fit x1,y1 x2,y2 ... args\n"
"  pwl x1,y1 x2,y2 ... args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:9
msgid "FIT fits a set of data using piecewise polynomials, or splines."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:11
msgid ""
"PWL is a a special case of FIT, it defines a piecewise linear transfer "
"function or time dependent value."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:14
msgid "The \"fit\" function fits a set of piecewise polynomials to a set of data."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:16
msgid ""
"The \"pwl\" function is a special case of \"fit\", forcing \"order\" to 1.  "
"It is designed for Spice compatibility."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:18 manual/devices/basic/posy.txt:23
msgid "For fixed sources, it defines voltage or current as a function of time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:20
msgid "The meaning of the //x// and //y// values depends on the component type:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:36
#, no-wrap
msgid ""
"^component          ^X        ^Y            ^\n"
"|C (capacitor)      |voltage  |charge       |\n"
"|E (VCVS)           |voltage  |voltage      |\n"
"|F (CCCS)           |current  |current      |\n"
"|G (VCCS)           |voltage  |current      |\n"
"|H (CCVS)           |current  |voltage      |\n"
"|I (current source) |time     |current      |\n"
"|L (inductor)       |current  |flux         |\n"
"|R (resistor)       |current  |voltage      |\n"
"|V (voltage source) |time     |voltage      |\n"
"|Y (admittance)     |voltage  |current      |\n"
"|VCCAP              |voltage  |capacitance  |\n"
"|VCG                |voltage  |conductance  |\n"
"|VCR                |voltage  |resistance   |\n"
"|trans-capacitor    |voltage  |charge       |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:39
msgid "The values of //x// must be in increasing order."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:43
msgid ""
"For \"fit\" if //order// is 1, it is the same as \"pwl\".  If //order// is "
"3, it will use cubic splines.  The result and its first two derivatives are "
"continuous."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:49
msgid ""
"Outside the specified range, it uses linear extrapolation.  The behavior "
"depends on the parameters //below// and //above//.  The value of //below// "
"or //above// is the derivative to use, which is a resistance for resistors, "
"voltage gain for a VCVS, and so on.  If it is not specified, the value is "
"automatically determined."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:53
msgid "These parameters apply to the \"fit\" function only, not \"pwl\"."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:57
#, no-wrap
msgid ""
"|order  |The order of the polynomial to fit, within the supplied data.  "
"(Default = 3) Legal values are 0, 1, 2, and 3, only.  For \"pwl\" a value of "
"1 is assumed.  |\n"
"|below  |The value of the derivative to use below or before the specified "
"range.  |\n"
"|above  |The value of the derivative to use above or after the specified "
"range.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:59
msgid ""
"For \"fit\" only, the properties are determined by the value of //order//.  "
"For \"pwl\", order is assumed to be 1."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:61
msgid ""
"If \"above\" or \"below\" are not specified, out of range behavior is "
"determined as follows:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:66
#, no-wrap
msgid ""
"|Order = 3\\\\ cubic_splines  |The default is to use \"natural\" splines, "
"which sets the second derivative to zero at the boundary.  If a value of "
"//below// or //above// is specified, \"clamped\" splines will be used.  In "
"any case, there will be a smooth transition at the boundaries.  When using "
"\"clamped\" splines, the second derivative may have a discontinuity at the "
"boundaries.  |\n"
"|Order = 2\\\\ quadratic_splines  |By default, the derivative at the upper "
"end is determined by the slope of the last segment.  This is also the "
"derivative above the range.  Below the range, the derivative determined at "
"the lower bound is used.  It is recommended that only one of //below// and "
"//above// be specified.  If both are specified, the splines are determined "
"using //above//, and there will be a discontinuity in the derivative at the "
"lower bound.  |\n"
"|Order = 1\\\\ piecewise_linear  |For first order (linear) interpolation, "
"the default slope outside the range is the extension of the slope in the end "
"segments.  The parameters //below// and //above// have no effect inside the "
"range.  |\n"
"|Order = 0\\\\ piecewise_constant  |The resulting value is constant over the "
"interval, and hasdiscontinuities at the specified points.  The parameters "
"//below// and //above// are ignored.  The slope is always 0.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:70
msgid ""
"The \"pwl\" function participates in time step control only if the device is "
"a fixed source.  In this case, the corners in are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:72
msgid ""
"For devices that are not fixed sources, the fit or pwl describes a nonlinear "
"transfer function.  Finding the corresponding times requires analysis of "
"\"cross\" events, which is more difficult and not done yet.  This is "
"considered to be a deficiency, and may be addressed in the future."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:83
#, no-wrap
msgid ""
"  C1 (2 0) fit (-5,-5u 0,0 1,1u 4,2u 5,2u) order=1\n"
"This \"capacitor\" stores 5 microcoulombs at -5 volts (negative,\n"
"corresponding to the negative voltage, as expected).  The charge\n"
"varies linearly to 0 at 0 volts, acting like a 1 microfarad capacitor.\n"
"(C = dq/dv).  This continues to 1 volt.  The 0,0 point could have been\n"
"left out.  The charge increases only to 2 microcoulombs at 4 volts,\n"
"for an incremental capacitance of 1u/3 or .3333 microfarads.  The same\n"
"charge at 5 volts indicates that it saturates at 2 microcoulombs.  For\n"
"negative voltages, the slope continues.\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/generator.txt:1
#, no-wrap
msgid "\"generator\" Signal Generator time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:6
#, no-wrap
msgid "  generator  scale\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:11
msgid ""
"The component \"value\" is dependent on a \"signal generator\", manipulated "
"by the \"generator\" command."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:18
msgid ""
"For transient analysis, the \"value\" is determined by a signal generator, "
"which is considered to be external to the circuit and part of the test "
"bench.  See the \"generator\" command for more information."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:20
msgid "For AC analysis, the value here is the amplitude."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:25
msgid ""
"Strictly, all of the functionality and more is available through the "
"Spice-like behavioral modeling functions, but this one provides a user "
"interface closer to the function generator that an analog designer would use "
"on a real bench.  It is mainly used for interactive operation."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:27
msgid ""
"It also provides backward compatibility with predecessors to Gnucap, which "
"used a different netlist format."
msgstr ""

#. type: Title ======
#: manual/devices/basic/inline_behavioral_modeling.txt:1
#, no-wrap
msgid "Device behavioral expressions"
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:2 manual/tech/plugins/coding.txt:9
#, no-wrap
msgid "Basics"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:5
msgid ""
"All simple components can have a behavioral description, with syntax "
"designed as an extension of the Spice time dependent sources.  They are not "
"necessarily physically realizable, but provide useful modeling capability.  "
"Some only work on particular types of analysis, or over a small range of "
"values.  Some can be used together, some cannot."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:7
msgid ""
"As of July 2009, these functions only work with Spice or ACS syntax.  They "
"do not work with Verilog or Spectre syntax."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:9
msgid ""
"All simple components are considered to have simple transformations.  A "
"function returns one parameter as a function of one other, as an extension "
"of their linear behavior.  For behavioral modeling or nonlinear values, "
"replace the constant times input by an arbitrary function."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:19
#, no-wrap
msgid ""
"^Type        ^Linear                              ^Nonlinear                            "
"^\n"
"|Capacitor   |q = C v                             |q = f(v)                             "
"|\n"
"|Inductor    | = L i                             | = f(i)                             "
"|\n"
"|Resistor    |v = I r                             |v = f(i)                             "
"|\n"
"|Admittance  |i = Y v                             |i = f(v)                             "
"|\n"
"|VCVS        |v<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = "
"f(v<sub>in</sub>)  |\n"
"|VCCS        |i<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = "
"f(v<sub>in</sub>)  |\n"
"|CCVS        |v<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = "
"f(i<sub>in</sub>)  |\n"
"|CCCS        |i<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = "
"f(i<sub>in</sub>)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:21
msgid ""
"Gnucap also has some other simple components, which are compatible with some "
"versions of Spice that also have them:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:26
#, no-wrap
msgid ""
"|voltage controlled resistor    |R = k v<sub>c</sub>                 |R = "
"f(v<sub>c</sub>)   |\n"
"|voltage controlled capacitor   |C = k v<sub>c</sub>                 |C = "
"f(v<sub>c</sub>)   |\n"
"|voltage controlled admittance  |Y = k v<sub>c</sub>                 |Y = "
"f(v<sub>c</sub>)   |\n"
"|trans-capacitor                |q<sub>out</sub> = k v<sub>in</sub>  |q = "
"f(v<sub>in</sub>)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:28
msgid "Sources are defined as functions of time:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:31
#, no-wrap
msgid ""
"|Voltage source  |v = f(t)  |\n"
"|Current source  |i = f(t)  |\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:32
#, no-wrap
msgid "Verilog and Spectre syntax workaround"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:35
msgid ""
"These functions do not fit with the style of Verilog or Spectre, so they "
"don't work with that syntax.  As a workaround, you can build a subcircuit "
"with Spice syntax, then call it as a component in any syntax."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:42
#, no-wrap
msgid ""
"<code>\n"
"spice\n"
".subckt vsin (p n)\n"
"Vsrc (p n) sin {offset} {amplitude} {frequency} {delay} {damping}\n"
".ends\n"
"verilog\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:45
msgid "vsin #(.frequency(1K)) vinput (in, 0); </code>"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:47
#, no-wrap
msgid "Conditionals"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:50
msgid ""
"Gnucap behavioral modeling conditionals are an extension of the \"AC\" and "
"\"DC\" Spice source parameters."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:55
#, no-wrap
msgid ""
"The extensions ...\n"
"  * There are more choices, including an \"else\".\n"
"  * They apply to all elements (primitive components).\n"
"  * Each section can contain functions and options.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:57
msgid "The following are available:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:65
#, no-wrap
msgid ""
"|AC    |AC analysis only.         |\n"
"|DC    |DC (steady state) value.  |\n"
"|OP    |OP analysis.              |\n"
"|TRAN  |Transient analysis.       |\n"
"|FOUR  |Fourier analysis only.    |\n"
"|ELSE  |Anything not listed.      |\n"
"|ALL   |Anything not listed.      |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:67
msgid ""
"A value or function with no conditional keyword is equivalent to \"ALL\".  "
"For SPICE compatibility, use only \"DC\", \"AC\", or nothing."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:69
msgid ""
"They are interpreted like a \"switch\" statement.  In case of a conflict, "
"the last one applies.  A set of precedence rules applies when some keys are "
"missing.  It is SPICE compatible to the extent the features overlap."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:71
msgid "The following table describes the precedence rules:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:78
#, no-wrap
msgid ""
"|OP analysis                  |OP, DC, ALL, TRAN, 0        |\n"
"|DC analysis                  |DC, ALL, OP, TRAN, 0        |\n"
"|Transient analysis           |TRAN, ALL, DC, OP, 0        |\n"
"|Fourier analysis             |FOUR, TRAN, ALL, DC, OP, 0  |\n"
"|AC analysis, fixed sources   |AC, 0                       |\n"
"|AC analysis, other elements  |AC, ALL, 0                  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:83
#, no-wrap
msgid ""
"  V12 (1 0) AC 1 DC 3\n"
"This voltage source has a value of 1 for AC analysis, 3 for DC.  OP, "
"Transient, and Fourier inherit the DC value.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:86
#, no-wrap
msgid ""
"  R44 (2 3) OP 1 ELSE 1g\n"
"This resistor has a value of 1 ohm for the \"OP\" analysis, 1 gig-ohm for "
"anything else.  This might be useful as the feedback resistor on an op-amp.  "
"Set it to 1 ohm to set the operating point, then 1 gig to measure its open "
"loop characteristics, hiding the fact that the op-amp would probably "
"saturate if it was really left open loop.\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:87 manual/howto/expressions.txt:56
#, no-wrap
msgid "Functions"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:90
msgid ""
"Gnucap behavioral modeling functions are an extension of the Spice source "
"time dependent values."
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:90
#, no-wrap
msgid "The extensions"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They apply to all elements (primitive components).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid ""
"All accept either Spice compatible order dependent parameters, or easier "
"keyword=value notation.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "The syntax is identical for all supported components.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They work a little different, depending on the type of device:\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:101
#, no-wrap
msgid ""
"|Fixed sources  |Time dependent functions are voltage or current as a "
"function of time. They are mostly Spice compatible, with extensions.\\\\ "
"Nonlinear transfer functions use time as the independent variable.  Some may "
"not make sense, but they are there anyway.  |\n"
"|Capacitors and inductors  |Time dependent functions are capacitance or "
"inductance as a function of time.  They are voltage/current conserving, not "
"charge/flux conserving.\\\\ Nonlinear transfer functions are charge or flux "
"as a function of input (voltage or current).  Charge and flux are conserved, "
"and can be probed.  |\n"
"|Resistors and conductances  |Time dependent functions are resistance or "
"conductance as a function of time.\\\\ Nonlinear transfer functions are "
"current or voltage as a function of input (voltage or current).  Resistors "
"define voltage as a function of current.  Conductances define current as a "
"function of voltage.  |\n"
"|Controlled sources  |Time dependent functions are gain (v/v, "
"transconductance, etc) function of time.\\\\ Nonlinear transfer functions "
"are output (voltage or current) as a function of input (voltage or "
"current).  |\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:101
#, no-wrap
msgid "Available functions"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:complex]]  Complex (re, im) value.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:exp]] Spice Exp source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit]] Fit a curve with splines.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:generator]] Value from Generator command.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:poly]] Polynomial (Spice style).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:posy]] Posynomial (Like poly, non-integer powers).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:pulse]] Spice Pulse source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit|pwl]] Piece-wise linear.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sffm]] Spice Frequency Modulation (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sin]] Spice Sin source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:tanh]] Hyperbolic tangent transfer function.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:117
msgid ""
"In addition, you may name a \"function\" defined by a \".model\" statement.  "
"The following \".model\" types may be used here:"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:table]] Fit a curve with splines.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:cap]] Spice semiconductor \"capacitor\" model.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:res]] Spice semiconductor \"resistor\" model.\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:122
#, no-wrap
msgid "Parameters that apply to all functions"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:125
msgid ""
"These parameters are available with all functions.  Some may not make sense "
"in some cases, but they are available anyway."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:138
#, no-wrap
msgid ""
"|Bandwidth  |AC analysis bandwidth.  (Default = infinity.)  The transfer "
"function is frequency dependent, with a 3 DB point at this frequency.  There "
"is frequency dependent phase shift ranging from 0 degrees at low frequencies "
"to 90 degrees at high frequencies.  The phase shift is 45 degrees at the "
"specified frequency.  AC ANALYSIS ONLY.  |\n"
"|Delay  |AC analysis delay.  (Default = 0.) The signal is delayed by x "
"seconds, effectively by a frequency dependent phase shift.  AC ANALYSIS "
"ONLY.  |\n"
"|Phase  |AC analysis phase.  (Default = 0.)  A fixed phase shift is "
"applied.  This is primarily intended for sources, but applies to all "
"elements.  AC ANALYSIS ONLY.  |\n"
"|IOffset  |Input offset.  (Default = 0.)  A DC offset is added to the "
"\"input\" of the element, before evaluating the function.  |\n"
"|OOffset  |Output offset.  (Default = 0.)  A DC offset is added to the "
"\"output\" of the element, after evaluating the function.  |\n"
"|Scale  |Transfer function scale factor.  (Default = 1.)  The transfer "
"function is multiplied by a constant.  |\n"
"|TNOM  |Nominal temperature.  (Default = .option TNOM) The nominal values "
"apply at this temperature.  |\n"
"|TEMP  |Actual temperature.  (Default = current global simulation "
"temperature.  This is the actual device temperature.  |\n"
"|DTEMP  |Temperature rise over ambient.  (Default = 0.)  The actual device "
"temperature is the global simulation temperature plus \"dtemp\".  |\n"
"|TC1  |First order temperature coefficient.  (Default = 0.)  |\n"
"|TC2  |Second order temperature coefficient.  (Default = 0.)  |\n"
"|IC   |Initial condition.  An initial value, to force at time=0.  The actual "
"parameter applied depends on the component.  (Capacitor voltage, inductor "
"current.  All others ignore it.)  You must use the \"UIC\" option for it to "
"be used.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:141
msgid "Temperature adjustments and scaling use the following formula:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:143
#, no-wrap
msgid "  value *= _scale * (1 + _tc1*tempdiff + _tc2*tempdiff*tempdiff)\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:144
msgid "where ''tempdiff'' is ''t - _tnom''."
msgstr ""

#. type: Title ======
#: manual/devices/basic/poly.txt:1
#, no-wrap
msgid "\"poly\" Polynomial nonlinear transfer function"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:7
#, no-wrap
msgid ""
"  poly  c0 c1 c2 c3 ...\n"
"  poly  c0 c1 c2 c3 ... args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:11
msgid "Defines a transfer function by a one dimensional polynomial."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:19
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current.  If you have "
"the coefficients defining capacitance or inductance, prepending a \"0\" to "
"the list will turn it into the correct form for Gnucap."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:22
msgid ""
"For fixed sources, it defines voltage or current as a polynomial function of "
"time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:24 manual/devices/basic/posy.txt:31
msgid "The transfer function is defined by:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:26
#, no-wrap
msgid "  out = c0 + (c1*in) + (c2*in^2) + ....\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:32
#, no-wrap
msgid ""
"|min  |Minimum output value (clipping).  (Default = -infinity)  |\n"
"|max  |Maximum output value (clipping).  (Default = infinity)  |\n"
"|abs  |Absolute value, truth value.  (Default = false).  If set to true, the "
"result will be always positive.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:36
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise."
msgstr ""

#. type: Title ======
#: manual/devices/basic/posy.txt:1
#, no-wrap
msgid "\"posy\" Polynomial with non-integer powers"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:7
#, no-wrap
msgid ""
"  posy  c1,p1 c2,p2 ...\n"
"  posy  c1,p1 c2,p2 ... args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:12
msgid ""
"Defines a transfer function by a one dimensional ``posynomial'', like a "
"polynomial, except that the powers are arbitrary, and usually non-integer."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:16
msgid "There is no corresponding capability in any SPICE that I know of."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:20 manual/devices/basic/tanh.txt:20
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:29
msgid ""
"Normal use of this function required positive input (voltage or current).  "
"The result is zero if the input is negative.  Raising a negative number to a "
"non-integer power would produce a complex result, which implies a non-causal "
"result, which cannot be represented in a traditional transient analysis."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:39
#, no-wrap
msgid ""
"<code>\n"
"if (in >= 0){\n"
"  out = (c1*in^p1) + (c2*in^p2) + ....\n"
"}else{\n"
"  out = 0.\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:47
#, no-wrap
msgid ""
"|min   |Minimum output value (clipping).  (Default  = -infinity)  |\n"
"|max   |Maximum output value (clipping).  (Default  = infinity)  |\n"
"|abs   |Absolute value, truth value.  (Default = false).  If set to true, "
"the result will be always positive.  |\n"
"|odd   |Make odd function, truth value.  (Default = false).  If set to true, "
"negative values of x will be evaluated as out = -f(-x), giving odd "
"symmetry.  |\n"
"|even  |Make even function, truth value.  (Default = false).  If set to "
"true, negative values of x will be evaluated as out = f(-x), giving even "
"symmetry.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:51
#, no-wrap
msgid ""
"  E1 (2 0 1 0) posy(1 .5)\n"
"The output of E1 is the square root of its input.\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic/probes.txt:1 manual/devices/lossless_transmission_line.txt:37 manual/howto/probes.txt:1 manual/tech/plugins/devices/probes.txt:3
#, no-wrap
msgid "Probes"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:2
#, no-wrap
msgid "All basic elements"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:5 manual/howto/probes.txt:50
msgid ""
"Most two node elements (capacitors, inductors, resistors, sources) and four "
"terminal elements (controlled sources) have at least the following "
"parameters available. Others are available for some elements."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:7 manual/howto/probes.txt:52
msgid ""
"Some of these probes do not work for all devices, or all analysis.  It will "
"print \"??\" as the value when it doesn't work."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:34
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second "
"port.  |\n"
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for "
"four terminal devices. The first node in the net list is assumed positive.  "
"|\n"
"|vin       |Input voltage.  The voltage across the input terminals. For "
"two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, "
"out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power "
"indicates that the part is supplying power. Its value is the same as (PD - "
"PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always "
"positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is "
"always positive and does not consider its own dissipation.  |\n"
"|input     |The input of the device. It is the current through a resistor "
"or inductor, the voltage across a capacitor or admittance, etc. It is the "
"value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is "
"the voltage across a resistor, the charge stored in a capacitor, the flux in "
"an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is "
"also the effective value of the part, in its units. If the part is ordinary, "
"it will just show its value, but if it is time variant or nonlinear, it "
"shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is "
"constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp "
"is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|z         |Circuit impedance seen by this device, with this device not "
"counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this "
"device.  Prints a meaningless number in transient analysis.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the "
"present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|errortime |Suggestion of next time point based on truncation or "
"interpolation error.  |\n"
"|eventtime |Suggestion of next time point based on movable events.  |\n"
"|timefuture |Suggestion of next time point, the sooner of errortime and "
"eventtime.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:37 manual/howto/probes.txt:89
msgid ""
"AC power probes:\\\\ In addition to those listed here, you can add a suffix "
"(M, P, R, I and DB) for magnitude, phase, real part, imaginary part, and "
"decibels, to any valid probe. Negative phase is capacitive. Positive phase "
"is inductive."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:42 manual/howto/probes.txt:93
#, no-wrap
msgid ""
"|p   |Real power.  Watts.  |\n"
"|pi  |Reactive (imaginary) power, VAR.  |\n"
"|pm  |Volt amps.  Complex power.  |\n"
"|pp  |Power phase.  Angle between voltage and current.  |\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:42
#, no-wrap
msgid "Capacitors"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:51
#, no-wrap
msgid ""
"|method |A number corresponding to what differentiation method is now being "
"used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = "
"Gear, 4 = trapeuler |\n"
"|q\\\\ qcap\\\\ charge |The charge stored in this capacitor, in "
"Coulombs. |\n"
"|c\\\\ capacitance |The effective capacitance of this device. For a fixed "
"capacitor, it be its value. For a nonlinear capacitor, it is the effective "
"capacitance at this time, or q/v. |\n"
"|dcdt |The time derivative of capacitance. For a linear capacitor it will be "
"zero. |\n"
"|dc |The change in capacitance compared to the previous sample. Its primary "
"use is in debugging models and numerical problems. For a linear capacitor it "
"will be zero. |\n"
"|dqdt |The time derivative of charge. Hopefully this is the same as current, "
"but it is calculated a different way and can be used as an accuracy "
"check. |\n"
"|dq |The change in charge compared to the previous sample. Its primary use "
"is in debugging models and numerical problems. |\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:52
#, no-wrap
msgid "Inductors"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:60
#, no-wrap
msgid ""
"|method |A number corresponding to what differentiation method is now being "
"used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = "
"Gear, 4 = trapeuler |\n"
"|flux |The flux linkages stored in this inductor, in Weber-turns. |\n"
"|L\\\\ inductance |The effective inductance of this device. For a fixed "
"inductor, it be its value. For a nonlinear inductor, it is the effective "
"inductance at this time, or /v. |\n"
"|dldt |The time derivative of inductance. For a linear inductor it will be "
"zero. |\n"
"|dl |The change in inductance compared to the previous sample. Its primary "
"use is in debugging models and numerical problems. For a linear inductor it "
"will be zero. |\n"
"|dfdt |The time derivative of flux. Hopefully this is the same as voltage, "
"but it is calculated a different way and can be used as an accuracy "
"check. |\n"
"|dflux |The change in flux linkages compared to the previous sample. Its "
"primary use is in debugging models and numerical problems. |\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/pulse.txt:1
#, no-wrap
msgid "\"pulse\" Pulsed time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:7
#, no-wrap
msgid ""
"  pulse args\n"
"  pulse iv pv delay rise fall width period\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:11
msgid "The component value is a pulsed function of time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice \"pulse\" "
"function, with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:17
msgid "The shape of a single pulse is described by the following algorithm:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:38
#, no-wrap
msgid ""
"<code>\n"
"if (time > _delay+_rise+_width+_fall){\n"
"  // past pulse\n"
"  ev = _iv;\n"
"}else if (time > _delay+_rise+_width){\n"
"  // falling\n"
"  interp=(time-(_delay+_rise+_width))/_fall;\n"
"  ev = _pv + interp * (_iv - _pv);\n"
"}else if (time > _delay+_rise){\n"
"  // pulsed value\n"
"  ev = _pv;\n"
"}else if (time > _delay){\n"
"  // rising\n"
"  interp = (time - _delay) / _rise;\n"
"  ev = _iv + interp * (_pv - _iv);\n"
"}else{\n"
"  // initial value\n"
"  ev = _iv;\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:52
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)  |\n"
"|pv      |Pulsed value.  (required)  |\n"
"|delay   |Rise time delay, seconds.  (Default = 0.)  |\n"
"|rise    |Rise time, seconds.  (Default = 0.)  |\n"
"|fall    |Fall time, seconds.  (Default = 0.)  |\n"
"|width   |Pulse width, seconds.  (Default = 0.)  |\n"
"|period  |Repeat period, seconds.  (Default = infinity.)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:55
msgid ""
"The corners in a pulse waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""

#. type: Title ======
#: manual/devices/basic/sffm.txt:1
#, no-wrap
msgid "\"sffm\" Frequency Modulation time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:7
#, no-wrap
msgid ""
"  sffm args\n"
"  sffm offset amplitude carrier modindex signal\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:11
msgid "The component value is a sinusoid, frequency modulated by another sinusoid."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SFFM "
"function, with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:17
msgid "The shape of the waveform is described by the following equations:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:20
#, no-wrap
msgid ""
"  mod = (_modindex * sin(2*PI*_signal*time));\n"
"  ev = _offset + _amplitude * sin(2*PI*_carrier*time + mod);\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:26 manual/devices/basic/sin.txt:44
msgid ""
"The non-Spice parameters (samples, zero, peak) assist in time step control.  "
"The defaults are usually appropriate."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:36
#, no-wrap
msgid ""
"|offset     |Output offset.  (Default = 0.)  |\n"
"|amplitude  |Amplitude.  (Default = 1.)  |\n"
"|carrier    |Carrier frequency, Hz.  (required)  |\n"
"|modindex   |Modulation index.  (required)  |\n"
"|signal     |Signal frequency.  (required)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  "
"(Default = true)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = "
"true)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:40
msgid ""
"The ability to accurately determine instantaneous frequency is important, so "
"SFFM plays a significant role in time step control.  When using SFFM, "
"frequency is always changing, which can make step control difficult."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:42
msgid ""
"By default, both zero crossings and peaks are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times.  This means, by default, there will be at "
"least 4 time steps per cycle, synchronized with zero crossings and peaks."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:44
msgid ""
"There is also, a smoothness requirement, controlled by the parameter "
"\"samples\".  By default, there will be at least 4 samples per cycle.  This "
"is independent of the placement of samples at zeros and peaks, but usually "
"does not add samples."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:46
msgid ""
"If exact timing is not critical, you can often improve run speed by setting "
"\"zero\" or \"peak\" or both to false.  Doing this allows the time stepping "
"to be more consistent, which is usually faster even if the number of steps "
"is not reduced."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:47 manual/devices/basic/sin.txt:66
msgid ""
"If you need improved waveform smoothness, you can do this by increasing "
"\"samples\"."
msgstr ""

#. type: Title ======
#: manual/devices/basic/sin.txt:1
#, no-wrap
msgid "\"sin\" Sinusoidal time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:7
#, no-wrap
msgid ""
"  sin args\n"
"  sin offset amplitude frequency delay damping\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:11
msgid ""
"The component value is a sinusoidal function of time, with optional "
"exponential decay."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SIN function, "
"with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:17
msgid "It generates either a steady sinusoid, or a damped sinusoid."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:22
msgid ""
"If //delay// and //damping// are both zero, you get a steady sine wave at "
"the specified //frequency//.  Otherwise, you get a damped pulsed sine wave, "
"starting after //delay// and damping out with a time constant of 1/damping."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:37
#, no-wrap
msgid ""
"<code>\n"
"reltime = time - _delay\n"
"if (reltime > 0.) {\n"
"  ev = _amplitude * sin(2*PI*_freq*reltime);\n"
"  if (_damping != 0.){\n"
"    ev *= exp(-reltime*_damping);\n"
"  }\n"
"  ev += _offset;\n"
"}else{\n"
"  ev = _offset;\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:54
#, no-wrap
msgid ""
"|offset     |DC offset.  (Default = 0.)  |\n"
"|amplitude  |Peak amplitude.  (Default = 1.)  |\n"
"|frequency  |Frequency, Hz.  (required)  |\n"
"|delay      |Turn on delay, seconds.  (Default = 0.)  |\n"
"|damping    |Damping factor, 1/seconds.  (Default = 0.)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  "
"(Default = false)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = "
"false)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:58
msgid ""
"For SIN, frequency is constant, so the default settings give preference to "
"waveform smoothness over timing."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:60
msgid ""
"There is a smoothness requirement, controlled by the parameter \"samples\".  "
"By default, there will be at least 4 samples per cycle.  This is independent "
"of the placement of samples at zeros and peaks, but usually does not add "
"samples."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:62
msgid ""
"If you set the parameters \"zero\" and \"peak\" to true, both zero crossings "
"and peaks are considered to be analog events.  The transient analysis will "
"attempt to control timing accuracy of these analog events.  If it is "
"reasonable, a time step should be scheduled at these times exactly.  In any "
"case, there should be a time step within option::dtmin of these times. These "
"steps are forced regardless of steps required for smoothness."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:64
msgid ""
"\"Zero\" and \"peak\" are false by default, which allows time stepping to be "
"more consistent, improving run speed."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:68
msgid "If you need timing accuracy, set \"zero\" and/or \"peak\" to true."
msgstr ""

#. type: Title ======
#: manual/devices/basic/tanh.txt:1
#, no-wrap
msgid "\"tanh\" Hyperbolic tangent transfer function"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:7
#, no-wrap
msgid ""
"  tanh gain limit\n"
"  tanh args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:11
msgid "Defines a hyperbolic tangent, or soft limiting, transfer function."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:16
msgid ""
"There is no corresponding capability in any SPICE that I know of, but you "
"can get close with POLY."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:23
msgid ""
"For fixed sources, it defines voltage or current as a function of time, "
"which is probably not useful."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:27
msgid ""
"This function describes a hyperbolic tangent transfer function similar to "
"what you get with a single stage push-pull amplifier, or a simple CMOS "
"inverter acting as an amplifier."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:31
#, no-wrap
msgid ""
"|gain   |The small signal gain at 0 bias.  (Required)  |\n"
"|limit  |Maximum output value (soft clipping).  (Required)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:35
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise.  This is considered to be a deficiency, and may "
"be addressed in the future."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:42
#, no-wrap
msgid ""
"  E1 (2 0 1 0) tanh gain=-10 limit=2 ioffset=2.5 ooffset=2.5\n"
"This gain block has a small signal gain of -10.  The input is\n"
"centered around 2.5 volts.  The output is also centered at 2.5 volts.\n"
"It \"clips\" softly at 2 volts above and below the output center, or\n"
"at .5 volts (2.5 - 2) and 4.5 volts (2.5 + 2).\n"
msgstr ""

#. type: Title ======
#: manual/devices/capacitor.txt:1
#, no-wrap
msgid "Capacitor, advanced"
msgstr ""

#. type: Title =====
#: manual/devices/capacitor.txt:3
#, no-wrap
msgid "Syntax: instance"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:10
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n value\n"
"  Cxxxxxxx n+ n expression\n"
"  Cxxxxxxx n+ n value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n model {L=length} {W=width} {TEMP=temperature} "
"{IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:16
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n capacitor C=value\n"
"  Cxxxxxxx n+ n capacitor expression\n"
"  Cxxxxxxx n+ n capacitor C=value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n model {L=length} {W=width} {TEMP=temperature} "
"{IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:23
#, no-wrap
msgid ""
"  capacitor #(.c(value))\n"
"  Cxxxxxxx n+ n value\n"
"  Cxxxxxxx n+ n expression\n"
"  Cxxxxxxx n+ n value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n model {L=length} {W=width} {TEMP=temperature} "
"{IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:31
#, no-wrap
msgid ""
"  .capacitor label n+ n expression\n"
"Model (optional)\n"
".model mname C {args}\n"
" .model mname TABLE {args}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:35
msgid "Capacitor, or general charge storage element."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:38
msgid ""
"N+ and n are the positive and negative element nodes, respectively. Value "
"is the capacitance in Farads."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:40
msgid ""
"The (optional) initial condition is the initial (time = 0) value of the "
"capacitor voltage (in Volts). Note that the initial conditions (if any) "
"apply only if the UIC option is specified on the transient command."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:43
msgid ""
"You may specify the value in any of these forms: A simple value. This is the "
"capacitance in Farads."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:45
msgid ""
"An expression, as described in the behavioral modeling chapter. The "
"expression can specify the charge as a function of voltage, or the "
"capacitance as a function of time."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:47
msgid ""
"A model, as described in the behavioral modeling chapter. The table model "
"describes a table of charge vs. voltage."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:48
msgid ""
"A model, which calculates the capacitance as a function of length and width, "
"referencing a .model statement of type C. This is compatible with the "
"Spice-3 semiconductor capacitor."
msgstr ""

#. type: Title ======
#: manual/devices/lossless_transmission_line.txt:1
#, no-wrap
msgid "Transmission Line"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:6
#, no-wrap
msgid "  Txxxxxxx (n1+ n1- n2+ n2-) args\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:10
msgid "Lossless transmission line."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:14
msgid ""
"n1+ and n1- are the nodes at one end.  n2+ and n2- are the nodes at the "
"other end."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:21
msgid ""
"The parameters TD, Freq, and NL determine the length of the line.  Either "
"{\\tt TD} or {\\tt Freq} and {\\tt NL} must be specified.  If only {\\tt "
"Freq} is specified, {\\tt NL} is assumed to be .25.  The other will be "
"calculated based on the one you specify.  If you specify too many "
"parameters, {\\tt Freq} and {\\tt NL} dominate, and a warning is issued."
msgstr ""

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:21
#, no-wrap
msgid "Element Parameters"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:26
#, no-wrap
msgid ""
"Many parameters are offered.  You should not specify them all.\n"
"^Parameters that always work.  ^^\n"
"|len  |Length multiplier.  (Default = 1) The effective length, regardless of "
"its method of calculation is multiplied by this number.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:32
#, no-wrap
msgid ""
"^Direct specification of electrical characteristics.  ^^\n"
"|z0    |Characteristic impedance.  If not specified, it is calculated by "
"sqrt(L/C).  If neither //z0// nor //L// and //C// are specified, the default "
"value is 50 Ohms.  |\n"
"|td    |Time delay.  If not specified, it will be calculated, either by "
"nl/freq or by sqrt(L*C).  |\n"
"|freq  |Frequency for //nl//.  |\n"
"|nl    |Number of wavelengths at //freq//.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:36
#, no-wrap
msgid ""
"^Physical parameters  ^^\n"
"|L  |Inductance per unit length.  This value is used only if //z0// and "
"//td// are both not specified.  |\n"
"|C  |Capacitance per unit length.  This value is used only if //z0// and "
"//td// are both not specified.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:40
msgid "The standard probes for all basic elements are all available."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:44
msgid ""
"Transient time steps are limited to be no larger than the delay of the "
"transmission line.  Aside from this, there is no attempt to synchronize, "
"because synchronization would result in a significant run speed penalty."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:46
msgid "There is significant room for improvement, if there is demand for it."
msgstr ""

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:47 manual/devices/switches.txt:83
#, no-wrap
msgid "Convergence"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:50
msgid ""
"Transmission lines are linear devices, so it would seem they would not be a "
"factor in convergence."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:51
msgid ""
"Transmission lines can be used to decouple problem circuits.  If a circuit "
"is having convergence problems, sometimes inserting a short transmission "
"line in an appropriate place can solve the problem by adding a small delay.  "
"Parts of circuits separated by transmission lines are considered to be "
"separate circuits.  Convergence problems in one part do not influence the "
"other part."
msgstr ""

#. type: Title ======
#: manual/devices/mutual_inductance.txt:1
#, no-wrap
msgid "Coupled (Mutual) Inductors"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:6
#, no-wrap
msgid "  Kxxxxxxx Lyyyyyyy Lzzzzzzz value\n"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:10
msgid "Coupled mutual inductance."
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:14
msgid ""
"K couples two inductors.  The value is the coefficient of coupling.  Using "
"the dot convention, place a dot on the first node of each inductor."
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:16
msgid ""
"The coefficient of coupling is given by K = m[i][j] / sqrt(L[i] L[j]).  K is "
"always positive and less than 1."
msgstr ""

#. type: Title =====
#: manual/devices/mutual_inductance.txt:17
#, no-wrap
msgid "Bugs"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:20
msgid ""
"This version of mutual inductance is only supported in Spice syntax, because "
"the connections are inductors.  If you are using any other syntax, you can "
"make a Spice subcircuit containing the entire transformer."
msgstr ""

#. type: Title ======
#: manual/devices/other.txt:1
#, no-wrap
msgid "Other \"spice\" devices"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:mutual inductance]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:switches]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:Lossless transmission line]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/semi.txt:1
#, no-wrap
msgid "Semiconductor devices"
msgstr ""

#. type: Plain text
#: manual/devices/semi.txt:4
msgid "Gnucap supports both native and industry standard semiconductor devices."
msgstr ""

#. type: Plain text
#: manual/devices/semi.txt:6
msgid ""
"Native models are optimized models compiled with the \"gnucap-modelgen\" "
"model compiler.  A BJT, diode, and several MOSFET models are available as "
"native models."
msgstr ""

#. type: Plain text
#: manual/devices/semi.txt:8
msgid ""
"C-models designed for Spice can also be used as plugins.  Several variants "
"of spice models are supported, including 3e, 3f, NGspice, and Jspice.  "
"Usually, the models can be used without any modifications."
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:diode]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:bjt]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:jfet]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:mosfet]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:mesfet]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/semi/bjt.txt:1 manual/devices/semi/diode.txt:1
#, no-wrap
msgid "Semiconductor models"
msgstr ""

#. type: Title =====
#: manual/devices/semi/bjt.txt:3
#, no-wrap
msgid "BJT's"
msgstr ""

#. type: Title ====
#: manual/devices/semi/bjt.txt:5 manual/devices/semi/diode.txt:5
#, no-wrap
msgid "Native models"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi/bjt.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man076.html|bjt]]\n"
msgstr ""

#. type: Title ====
#: manual/devices/semi/bjt.txt:8 manual/devices/semi/diode.txt:9
#, no-wrap
msgid "Spice models"
msgstr ""

#. type: Plain text
#: manual/devices/semi/bjt.txt:11 manual/devices/semi/diode.txt:12
msgid "Several Spice diode models are available.  They are not documented here."
msgstr ""

#. type: Plain text
#: manual/devices/semi/bjt.txt:18
#, no-wrap
msgid ""
"^Gnucap tarball      ^Name  ^Level  ^Origin        ^Status              "
"^Comments             ^\n"
"|models-spice3f5     |bjt   |       |Spice 3f5     |+++++ supported     |The "
"standard model   |\n"
"|models-jspice3-2.5  |bjt   |       |Jspice 3-2.5  |+++-  inconsistent  |Not "
"recommended      |\n"
"|models-ngspice17    |bjt   |1      |NGspice-17    |++++  works         "
"|similar to standard  |\n"
"|models-ngspice17    |bjt2  |2      |NGspice-17    |+++   works         "
"|similar to standard  |\n"
"|models-ngspice17    |vbic  |4      |NGspice-17    |++++  works         "
"|Colin McAndrew's VBIC model  |\n"
msgstr ""

#. type: Title =====
#: manual/devices/semi/diode.txt:3
#, no-wrap
msgid "Diodes"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi/diode.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man063.html|diode]]\n"
msgstr ""

#. type: Plain text
#: manual/devices/semi/diode.txt:17
#, no-wrap
msgid ""
"^Gnucap tarball      ^Origin        ^Status           ^Comments  ^\n"
"|models-spice3f5     |Spice 3f5     |+++++ supported  |The standard model  "
"|\n"
"|models-ngspice17    |NGspice-17    |+++++ supported  |Enhanced, with some "
"additional parameters  |\n"
"|models-jspice3-2.5  |Jspice 3-2.5  |+++++ supported  |The standard model  "
"|\n"
msgstr ""

#. type: Title ======
#: manual/devices/switches.txt:2
#, no-wrap
msgid "Switches"
msgstr ""

#. type: Title ==
#: manual/devices/switches.txt:6
#, no-wrap
msgid "Voltage controlled switch"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:9
msgid "Device:"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:11
#, no-wrap
msgid "  Sxxxxxxx (n+ n- nc+ nc-) modelname ic\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:13 manual/devices/switches.txt:23
msgid "Model (required):"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:15
#, no-wrap
msgid "  .model modelname SW args\n"
msgstr ""

#. type: Title ==
#: manual/devices/switches.txt:17
#, no-wrap
msgid "Current controlled switch"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:21
#, no-wrap
msgid ""
"Device:\n"
"  Wxxxxxxx (n+ n- ce) modelname ic\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:25
#, no-wrap
msgid "  .model modelname CSW args\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:29
msgid "Voltage or current controlled switch."
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:30
#, no-wrap
msgid "Comments ======"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:33
msgid "//N+// and //n-// are the positive and negative element nodes, respectively."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:35
msgid ""
"For voltage controlled switch, //Nc+// and //nc-// are the controlling "
"nodes."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:37
msgid "For current controlled switch, //ce// is the name of a controlling element."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:39
msgid "//Modelname// is the model name."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:42
msgid ""
"A switch is a resistor between //n+// and //n-//.  The value of the resistor "
"is determined by the state of the switch."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:47
#, no-wrap
msgid ""
"^control                 ^resistance  ^\n"
"|vc > von\\\\  ic > ion    |Ron         |\n"
"|vc < voff\\\\  ic < ioff  |Roff        |\n"
"|otherwise               |no change   |\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:51
msgid ""
"You may specify ''ON'' or ''OFF'' to indicate the initial state of the "
"switch when the controlling voltage is in the hysteresis region."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:53
msgid "The parameters //ron// and //roff// must have finite positive values."
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:53
#, no-wrap
msgid "Model Parameters"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:62
#, no-wrap
msgid ""
"^Voltage controlled switch  ^^\n"
"|vt    |Threshold voltage.  (Default = 0.)         |\n"
"|vh    |Hysteresis voltage.  (Default = 0.)        |\n"
"|von   |On control voltage.  (Default = vt + vh)   |\n"
"|voff  |Off control voltage.  (Default = vt - vh)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:70
#, no-wrap
msgid ""
"^Current controlled switch  ^^\n"
"|it    |Threshold current.  (Default = 0.)         |\n"
"|ih    |Hysteresis current.  (Default = 0.)        |\n"
"|ion   |On control current.  (Default = it + ih)   |\n"
"|ioff  |Off control current.  (Default = it - ih)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:71
#, no-wrap
msgid "Time step control"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:76
msgid ""
"A change of state is considered to be an analog event.  An input crossing a "
"threshold is a \"cross event\".  Cross events will generate extra time steps "
"so the switch timing is accurate."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:79
msgid ""
"A switch can be used anywhere in a circuit to improve timing accuracy by "
"sensing cross events."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:82
msgid ""
"Switches also influence time step control as resistors, which control "
"smoothness by curve fitting."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:85
msgid ""
"Switches are linear devices that do not iterate unless there is a state "
"change."
msgstr ""

#. type: Title ======
#: manual/examples.txt:1
#, no-wrap
msgid "Examples, tutorial"
msgstr ""

#. type: Title =====
#: manual/examples.txt:2
#, no-wrap
msgid "Hosted here"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Hello world]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Resistors and sources]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Things that can go wrong]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Nonlinear devices -- diodes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid ""
"[[gnucap:manual:examples:Multiplying two voltages using diode "
"nonlinearity]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Using the generator in transient analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Experimentally finding model parameters]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Simple Power supply]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Phase shift oscillator]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:FM spectrum analysis]]\n"
msgstr ""

#. type: Title =====
#: manual/examples.txt:14
#, no-wrap
msgid "Hosted elsewhere"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, no-wrap
msgid ""
"[[http://www.johannes-bauer.com/electronics/]] "
"[[http://www.johannes-bauer.com/electronics/|gEDA and Gnucap, getting "
"started, by Johannes Bauer]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, no-wrap
msgid "[[http://geekwentfreak.wordpress.com/2009/12/11/spice-gschem-gnetlist-gnucap-gwave-gspiceui-linux/]]\n"
msgstr ""

#. type: Title ======
#: manual/examples/experimentally_finding_model_parameters.txt:1
#, no-wrap
msgid "Experimentally finding model parameters"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:4
msgid ""
"Sometimes you need to determine model parameters, based on having no real "
"information."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:6
msgid ""
"In this example, we find the parameter \"IS\" of a diode, based on its "
"forward voltage."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:8
msgid "We would like to have a diode..."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:10
#, no-wrap
msgid "  D2 (a k) 1n4004\n"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:12
msgid "Now you need a model statement ..."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:14
#, no-wrap
msgid "  .model 1n4004 d (a whole bunch of parameters)\n"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:17
msgid ""
"You could do a web search for a detailed model, but usually you can just do "
"some experimenting.."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:21
msgid ""
"If you are at the stage where you are asking about this, the detail will "
"only confuse you, most likely of the worst kind of confusion, where you "
"don't realize it."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:24
msgid ""
"Most of the time, the only parameter you need for a diode is saturation "
"current, which of course isn't in the data sheet."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:26
msgid "ok .. so how do I figure that out??"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:29
msgid ""
"Well ...  Look at the specs, or measure it.  Let's say we found that the "
"forward voltage at 1 amp is .7 volts."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:31
msgid "Use the simulator to build a test circuit .."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:34
#, no-wrap
msgid ""
"  I1 (0 1) dc 1\n"
"  D1 (1 0) my_diode\n"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:37
#, no-wrap
msgid ""
"You need a model statement ..\n"
"  .model my_diode d (is=something)\n"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:39
msgid "but I don't know what the value of something is."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:41
msgid "With gnucap .. try this......."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:85
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >i1 (0 1) dc 1\n"
"  >d1 (1 0) my_diode\n"
"  >.model my_diode d is=something\n"
"  >                   ******** blank line to exit build mode\n"
"  gnucap> probe  op  v(1)\n"
"  parameter something has no value\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.83376                    **** using default IS\n"
"  gnucap> param something=1u\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.35733\n"
"  gnucap> param something=1n\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.53599\n"
"  gnucap> param something=1p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.71465\n"
"  gnucap> param something=2p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69673\n"
"  gnucap> param something=1.5p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70417\n"
"  gnucap> param something=1.8p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69945\n"
"  gnucap> param something=1.7p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70093\n"
"  gnucap> param something=1.75p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70018\n"
"  gnucap> exit\n"
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:89
msgid "There ..  close enough ,,, Now use the value 1.75p for IS."
msgstr ""

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:91
#, no-wrap
msgid ""
"Here's your model statement:\n"
"  .model my_diode d is=1.75p\n"
msgstr ""

#. type: Title ======
#: manual/examples/fm_spectrum_analysis.txt:1
#, no-wrap
msgid "FM spectrum analysis"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:4
msgid ""
"In this demo, we will look at the spectrum of a frequency modulated signal, "
"with the intent of exploring the effect of overmodulation on bandwidth."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:6
msgid ""
"The circuit is simple, just a voltage source, with a Spice-style \"SFFM\" "
"waveform.  We will use parameters to tinker with the signal, and the Fourier "
"command to display the spectrum.  You could calculate the spectrum using "
"Bessel functions, but we will look at it with simulation."
msgstr ""

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:6 manual/examples/phase_shift_oscillator.txt:56
#, no-wrap
msgid "Setting up"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:9
msgid "First, the circuit.  Enter it with the \"build\" command:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:14
#, no-wrap
msgid ""
"  gnucap> build\n"
"  > v1 ( 1 0 ) sffm (carrier={carrier} modindex={mod/signal} "
"signal={signal})\n"
"  >       **** blank line exits build mode\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:16
msgid "Now, set up the parameters:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:20
#, no-wrap
msgid ""
"  gnucap> param carrier=10Meg\n"
"  gnucap> param signal=10K\n"
"  gnucap> param mod=75K\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:22
msgid ""
"This sets up a signal of 10 KHz with the usual maximum deviation of 75 KHz.  "
"This is not overmodulated.  I chose a carrier frequency of 10 MHz for "
"convenience.  100 MHz would be more realistic but would take longer to run.  "
"It doesn't really matter, and 10 MHz is close to the usual intermediate "
"frequency of 10.7 MHz."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:24
msgid "Now, set up the sweep parameters:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:28
#, no-wrap
msgid ""
"  gnucap> param start={carrier-2*(mod+signal)}\n"
"  gnucap> param stop={carrier+2*(mod+signal)}\n"
"  gnucap> param step={signal}\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:30
msgid ""
"Carson's rule estimates the bandwidth to be 2*(mod+signal), so we will cover "
"a range of twice that, in steps equal to the modulating frequency.  If you "
"look at the Bessel functions, you will see that this is corresponds to the "
"actual signal."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:32
msgid "Now, set up a probe:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:34
#, no-wrap
msgid "  gnucap> probe fourier v(1)\n"
msgstr ""

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:35
#, no-wrap
msgid "The first run"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:38
msgid "Try one .. look at the spectrum:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:40
#, no-wrap
msgid "  gnucap> fourier {start} {stop} {step}\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:42
msgid ""
"You will see the time points of a transient run, then the spectrum over the "
"range you asked for."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:83
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.83Meg    7.2578u   -102.78   93.604  20.494u    -93.77 -179.033\n"
" 9.84Meg    31.322u    -90.08  -86.484  88.446u    -81.07    0.879\n"
" 9.85Meg    126.38u    -77.97   93.428  356.88u    -68.95 -179.209\n"
" 9.86Meg    474.21u    -66.48  -86.660  0.0013391  -57.46    0.703\n"
" 9.87Meg    0.001644   -55.68   93.252  0.0046423  -46.67 -179.385\n"
" 9.88Meg    0.005225   -45.64  -86.836  0.014754   -36.62    0.527\n"
" 9.89Meg    0.015076   -36.43   93.076  0.042571   -27.42 -179.561\n"
" 9.9Meg     0.038998   -28.18  -87.012  0.11012    -19.16    0.352\n"
" 9.91Meg    0.088919   -21.02   92.900  0.25108    -12.00 -179.736\n"
" 9.92Meg    0.17441    -15.17  -87.188  0.49248     -6.15    0.176\n"
" 9.93Meg    0.28315    -10.96   92.725  0.79954     -1.94 -179.912\n"
" 9.94Meg    0.35414     -9.02  -87.363  1.           0.00   -0.000\n"
" 9.95Meg    0.28347    -10.95   92.549  0.80046     -1.93  179.912\n"
" 9.96Meg    0.023825   -32.46  -87.539  0.067275   -23.44   -0.176\n"
" 9.97Meg    0.25806    -11.77  -87.627  0.7287      -2.75   -0.264\n"
" 9.98Meg    0.23027    -12.76   92.285  0.65023     -3.74  179.648\n"
" 9.99Meg    0.13525    -17.38   92.197  0.38191     -8.36  179.561\n"
" 10.Meg     0.26634    -11.49  -87.891  0.75207     -2.47   -0.527\n"
" 10.01Meg   0.13525    -17.38  -87.979  0.38191     -8.36   -0.615\n"
" 10.02Meg   0.23027    -12.76   91.934  0.65023     -3.74  179.297\n"
" 10.03Meg   0.25806    -11.77   91.846  0.7287      -2.75  179.209\n"
" 10.04Meg   0.023825   -32.46  -88.242  0.067275   -23.44   -0.879\n"
" 10.05Meg   0.28347    -10.95  -88.330  0.80046     -1.93   -0.967\n"
" 10.06Meg   0.35414     -9.02  -88.418  1.          -0.00   -1.055\n"
" 10.07Meg   0.28315    -10.96  -88.506  0.79954     -1.94   -1.143\n"
" 10.08Meg   0.17441    -15.17  -88.594  0.49248     -6.15   -1.230\n"
" 10.09Meg   0.088919   -21.02  -88.682  0.25108    -12.00   -1.318\n"
" 10.1Meg    0.038998   -28.18  -88.770  0.11012    -19.16   -1.406\n"
" 10.11Meg   0.015076   -36.43  -88.857  0.042571   -27.42   -1.494\n"
" 10.12Meg   0.005225   -45.64  -88.945  0.014754   -36.62   -1.582\n"
" 10.13Meg   0.001644   -55.68  -89.033  0.0046423  -46.67   -1.670\n"
" 10.14Meg   474.22u    -66.48  -89.121  0.0013391  -57.46   -1.758\n"
" 10.15Meg   126.38u    -77.97  -89.209  356.88u    -68.95   -1.846\n"
" 10.16Meg   31.323u    -90.08  -89.297  88.447u    -81.07   -1.934\n"
" 10.17Meg   7.2581u   -102.78  -89.385  20.495u    -93.77   -2.021\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:85
msgid ""
"As a quick check ..  For a modulation index of 7.5, the fourth sideband "
"should have a null, or close to it.  It does."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:87
msgid ""
"Another quick check .. Carson's rule says the bandwidth should be about "
"2*(mod+signal) or 2*(10K+75K), or 85K on each side.  It's pretty close.  It "
"looks like the real bandwidth is probably a little more."
msgstr ""

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:87
#, no-wrap
msgid "Now experiment"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:90
msgid ""
"Let's try a modulating frequency of 50 KHz, roughly the top of the stereo "
"subcarrier."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:98
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=50k\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.0025    -0.99968\n"
" 0.0025     0.8\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:116
#, no-wrap
msgid ""
"<code>\n"
" 0.0025199  0.76861\n"
" 0.00252   -0.99968\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.75Meg    0.0017994  -54.90   94.307  0.0032251  -49.83    1.758\n"
" 9.8Meg     0.011768   -38.59  -86.133  0.021092   -33.52 -178.682\n"
" 9.85Meg    0.060964   -24.30   93.428  0.10927    -19.23    0.879\n"
" 9.9Meg     0.23209    -12.69  -87.012  0.41598     -7.62 -179.561\n"
" 9.95Meg    0.55794     -5.07   92.549  1.           0.00    0.000\n"
" 10.Meg     0.51183     -5.82  -87.891  0.91736     -0.75  179.561\n"
" 10.05Meg   0.55794     -5.07  -88.330  1.          -0.00  179.121\n"
" 10.1Meg    0.23209    -12.69  -88.770  0.41598     -7.62  178.682\n"
" 10.15Meg   0.060964   -24.30  -89.209  0.10927    -19.23  178.242\n"
" 10.2Meg    0.011768   -38.59  -89.648  0.021092   -33.52  177.803\n"
" 10.25Meg   0.0017994  -54.90  -90.088  0.0032251  -49.83  177.363\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:118
msgid ""
"Mod index is 1.5, so the spectrum is simpler, Carson's rule predicts "
"50K+75K, or 125K each side.  Again, it seems the real signal takes more "
"space.  Check the Bessel functions, from a graph ...  about .55, .55, .2 ..  "
"it matches as well as I read the graph."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:120
msgid "The signal is really pretty wide.  Try half of the deviation .."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:127
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param mod=37.5K\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.00252   -0.99952\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:142
#, no-wrap
msgid ""
"<code>\n"
" 0.0025399  0.75896\n"
" 0.00254   -0.99952\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.85Meg    0.0084844  -41.43   93.428  0.0098171  -40.16 -178.682\n"
" 9.9Meg     0.067074   -23.47  -87.012  0.07761    -22.20    0.879\n"
" 9.95Meg    0.34924     -9.14   92.549  0.4041      -7.87 -179.561\n"
" 10.Meg     0.86424     -1.27  -87.891  1.           0.00   -0.000\n"
" 10.05Meg   0.34924     -9.14  -88.330  0.4041      -7.87   -0.439\n"
" 10.1Meg    0.067074   -23.47  -88.770  0.07761    -22.20   -0.879\n"
" 10.15Meg   0.0084844  -41.43  -89.209  0.0098171  -40.16   -1.318\n"
" 10.2Meg    801.07u    -61.93  -89.648  926.9u     -60.66   -1.758\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:144
msgid ""
"So now you see why the FCC limit on deviation is lower for higher modulation "
"frequencies."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:146
msgid "Let's try overmodulating."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:152
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=10K\n"
"gnucap> param mod=150K\n"
"gnucap> fourier\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:222
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.68Meg    6.6294n   -163.57    0.001  23.786n   -152.47 -179.999\n"
" 9.69Meg    26.707n   -151.47  180.000  95.822n   -140.37   -0.000\n"
" 9.7Meg     103.74n   -139.68    0.000  372.23n   -128.58 -180.000\n"
" 9.71Meg    388.29n   -128.22  180.000  1.3931u   -117.12   -0.000\n"
" 9.72Meg    1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 9.73Meg    4.8295u   -106.32  180.000  17.328u    -95.23   -0.000\n"
" 9.74Meg    15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 9.75Meg    50.597u    -85.92  180.000  181.54u    -74.82   -0.000\n"
" 9.76Meg    152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 9.77Meg    437.95u    -67.17  180.000  0.0015713  -56.07   -0.000\n"
" 9.78Meg    0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 9.79Meg    0.0030538  -50.30  180.000  0.010957   -39.21   -0.000\n"
" 9.8Meg     0.0073602  -42.66   -0.000  0.026408   -31.57 -180.000\n"
" 9.81Meg    0.016574   -35.61  180.000  0.059464   -24.51    0.000\n"
" 9.82Meg    0.034626   -29.21   -0.000  0.12423    -18.12 -180.000\n"
" 9.83Meg    0.066529   -23.54  180.000  0.2387     -12.44    0.000\n"
" 9.84Meg    0.11617    -18.70   -0.000  0.41682     -7.60 -180.000\n"
" 9.85Meg    0.18131    -14.83  180.000  0.65051     -3.73    0.000\n"
" 9.86Meg    0.24644    -12.17   -0.000  0.8842      -1.07 -180.000\n"
" 9.87Meg    0.27871    -11.10  180.000  1.           0.00    0.000\n"
" 9.88Meg    0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 9.89Meg    0.09995    -20.00  180.000  0.35861     -8.91   -0.000\n"
" 9.9Meg     0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 9.91Meg    0.22005    -13.15   -0.000  0.7895      -2.05  180.000\n"
" 9.92Meg    0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 9.93Meg    0.034464   -29.25  180.000  0.12365    -18.16   -0.000\n"
" 9.94Meg    0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 9.95Meg    0.13046    -17.69  180.000  0.46806     -6.59   -0.000\n"
" 9.96Meg    0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 9.97Meg    0.19402    -14.24   -0.000  0.69612     -3.15  180.000\n"
" 9.98Meg    0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 9.99Meg    0.2051     -13.76  180.000  0.73589     -2.66   -0.000\n"
" 10.Meg     0.014224   -36.94  180.000  0.051036   -25.84   -0.000\n"
" 10.01Meg   0.2051     -13.76   -0.000  0.73589     -2.66  180.000\n"
" 10.02Meg   0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 10.03Meg   0.19402    -14.24  180.000  0.69612     -3.15   -0.000\n"
" 10.04Meg   0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 10.05Meg   0.13046    -17.69   -0.000  0.46806     -6.59  180.000\n"
" 10.06Meg   0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 10.07Meg   0.034464   -29.25   -0.000  0.12365    -18.16  180.000\n"
" 10.08Meg   0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 10.09Meg   0.22005    -13.15  180.000  0.7895      -2.05   -0.000\n"
" 10.1Meg    0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 10.11Meg   0.09995    -20.00   -0.000  0.35861     -8.91  180.000\n"
" 10.12Meg   0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 10.13Meg   0.27871    -11.10   -0.000  1.          -0.00  180.000\n"
" 10.14Meg   0.24644    -12.17   -0.000  0.8842      -1.07  180.000\n"
" 10.15Meg   0.18131    -14.83   -0.000  0.65051     -3.73  180.000\n"
" 10.16Meg   0.11617    -18.70   -0.000  0.41682     -7.60  180.000\n"
" 10.17Meg   0.066529   -23.54   -0.000  0.2387     -12.44  180.000\n"
" 10.18Meg   0.034626   -29.21   -0.000  0.12423    -18.12  180.000\n"
" 10.19Meg   0.016574   -35.61   -0.000  0.059464   -24.51  180.000\n"
" 10.2Meg    0.0073602  -42.66   -0.000  0.026408   -31.57  180.000\n"
" 10.21Meg   0.0030538  -50.30   -0.000  0.010957   -39.21  180.000\n"
" 10.22Meg   0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 10.23Meg   437.95u    -67.17   -0.000  0.0015713  -56.07 -180.000\n"
" 10.24Meg   152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 10.25Meg   50.597u    -85.92    0.000  181.54u    -74.82 -180.000\n"
" 10.26Meg   15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 10.27Meg   4.8295u   -106.32    0.000  17.328u    -95.23 -180.000\n"
" 10.28Meg   1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 10.29Meg   388.29n   -128.22    0.000  1.3932u   -117.12 -180.000\n"
" 10.3Meg    103.75n   -139.68    0.000  372.26n   -128.58 -180.000\n"
" 10.31Meg   26.712n   -151.47    0.000  95.838n   -140.37 -180.000\n"
" 10.32Meg   6.6384n   -163.56    0.001  23.818n   -152.46 -179.999\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:224
msgid "As expected, the bandwidth is a a little more than 2*160k."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:226
msgid "That's enough for now."
msgstr ""

#. type: Title ======
#: manual/examples/hello_world.txt:1
#, no-wrap
msgid "Hello world"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:4
msgid "Copyright 1999 Telford Tendys (with mods by Albert Davis)"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:12
msgid ""
"This is not an alternative to reading the manual. The manual is very nicely "
"presented in LaTeX and you should print it out and keep it handy when "
"working. This document is organised starting from easy and working towards "
"difficult and presumes that you have some idea of what electrical circuits "
"are but don't know much about simulators.  The manual is organised in "
"alphabetical order and in groups of concepts and it presumes that you know "
"SPICE already."
msgstr ""

#. type: Title =====
#: manual/examples/hello_world.txt:13
#, no-wrap
msgid "The basic concept of a nodal analysis"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:20
msgid ""
"Using nodes is one way to describe a lumped element circuit.  Lumped "
"elements are used because there is no consideration of what is occurring "
"inside a given component, only what is happening on the terminals of the "
"component. For example, this analysis makes no attempt to find the voltage "
"in the middle of a resistor, only at the ends of the resistor."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:27
msgid ""
"The whole circuit model consists of \"nodes\" and \"components\".  A node is "
"(electrically speaking) a single point, it has exactly one voltage value at "
"any given time value. A component will connect to two or more nodes (usually "
"two) and represents some method by which the voltages at those nodes affect "
"one another. Describing which components connect to which nodes will "
"completely describe the structure of the circuit."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:33
msgid ""
"One additional concept is a \"branch\". The current though a branch is the "
"amount of current flowing from a node into a component that connects to that "
"node. Some branch currents (such as the current through a voltage source)  "
"are explicitly calculated, others (such as the current through a resistor) "
"are implicitly calculated as a result of calculating the node voltages."
msgstr ""

#. type: Title =====
#: manual/examples/hello_world.txt:33
#, no-wrap
msgid "The basic concept of a circuit file"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:39
msgid ""
"Tradition has it that Gnucap input files have the extension "
"\"''.ckt''\". The format is similar to that used by version 2 of the SPICE "
"simulator; it is a line oriented format with items separated by "
"whitespace. The overall file structure is:"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid ""
"Header line (first line of the file) usually contains the name of the "
"circuit.  It should be marked as a comment.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "blank lines do nothing\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid ""
"comment lines are any line beginning with a star \"''*''\".  These can be "
"anywhere in the file except the header line.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid ""
"component lines begin with a letter and represent some component that is in "
"the circuit. The order that components are listed does not matter because "
"the topology is described by the nodes that the components are connected "
"to.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid ""
"continuation lines begin with a plus \"''+''\" and continue the previous "
"line so that long lines can be written neatly.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid ""
"command lines begin with a dot \"''.''\" and are not considered to be part "
"of the circuit, they cause the simulator to execute some analysis or change "
"some options. They are also used to delimit special parts of the file such "
"as subcircuits.\n"
msgstr ""

#. type: Title =====
#: manual/examples/hello_world.txt:47
#, no-wrap
msgid "Building a simple circuit"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:50
msgid "The \"build\" command lets you enter a circuit from the keyboard."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:56
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >Vsupply 0 2 10\n"
"  >R1 0 2 1k\n"
"  >\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:58
msgid "A blank line exits the build mode."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:60
msgid "See what you have with the \"list\" command."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:65
#, no-wrap
msgid ""
"  gnucap> list\n"
"  Vsupply ( 0 2 )  DC  10.\n"
"  R1 ( 0 2 )  1.K\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:67
msgid "Do a quick check of the voltages:"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:73
#, no-wrap
msgid ""
"  gnucap> probe op v(nodes)\n"
"  gnucap> op\n"
"  #           v(2)\n"
"   27.       -10.\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:75
msgid "You can save it to a file now:"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid ""
"  gnucap> save eg1.ckt\n"
"  gnucap>\n"
msgstr ""

#. type: Title =====
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid "The simplest possible circuit file"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:83
#, no-wrap
msgid ""
"  #RESISTOR DRIVEN BY VOLTAGE SOURCE\n"
"  Vsupply 0 2 10\n"
"  R1 0 2 1k\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:91
msgid ""
"This file defines a circuit containing two nodes and two components.  The "
"components have the names \"Vsupply\" and \"R1\", the first letter of the "
"component name tells what that component is so \"Vsupply\" is a voltage "
"source and \"R1\" is a resistor. Each component has a value, the voltage "
"source is 10 volts and the resistor is 1000 ohms. The nodes have the numbers "
"\"0\" and \"2\". Note that there is no node \"1\" but this doesn't matter, "
"not every node number needs to be used."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:93 manual/examples/phase_shift_oscillator.txt:59
msgid "Run it interactively ..."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:107
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2009.02.02 RCS 26.109\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get eg1.ckt\n"
"  '\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:111
msgid ""
"From the interactive mode it is possible to exercise the circuit model, "
"firstly by putting a probe on the node that needs measuring (using the print "
"statement) then by starting the simulation:"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:117
#, no-wrap
msgid ""
"  gnucap> print dc v(2)\n"
"  gnucap> dc\n"
"  #           v(2)\n"
"   0.        -10.\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:132
msgid ""
"Needless to say, \"dc\" is a steady state direct current analysis and the "
"\"print\" command used here is saying, \"when you do a DC analysis, tell me "
"the voltage at node 2\". The result should be -10 volts. At first glance, it "
"might seem like it should be 10 volts... but (same as SPICE)  the voltage "
"sources are listed with their positive terminal first, then their negative "
"terminal. Node 0 is the ground node (or reference node) which is always 0 "
"volts so node 2 is at -10 volts. Wiring \"Vsupply\" the other way around "
"would change the answer to 10 volts. Things get trickier when dealing with "
"current sources where the node at the tail end of the current source arrow "
"is listed first (and called \"+\") and the pointy head end of the arrow is "
"listed second (and called \"-\"). Although this convention may seem "
"disorienting to someone who was brought up testing their circuits with "
"batteries or a bench power supply and poking their meter probes into things, "
"it is a well established SPICE convention and probably never going to "
"change."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:136
msgid ""
"However, the voltage of the node may not be the answer required. What about "
"the current going through the source? We can move our probe to look at "
"current instead:"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:142
#, no-wrap
msgid ""
"  gnucap> print dc i(R1) i(Vsupply)\n"
"  gnucap> dc\n"
"  #           i(R1)      i(Vsupply)\n"
"   0.         0.01      -0.01\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:157
msgid ""
"Now we can see 10 milliamps going through both components, note the sign "
"convention when probing current; once more this is something that you must "
"simply learn, you might draw diagrams of the main components and mark the "
"important conventions of [+] terminal, [-] terminal and current flow.  You "
"might also realise that this convention does have its own logical "
"consistency which makes it easier to remember. For example, consider a "
"resistor: the terminal called [+] is listed first and the internal current "
"flow is positive when current flows into the [+] terminal, through the "
"resistor and out of the [-] terminal. In the case of a resistor this sounds "
"quite sensible because the [+] terminal WOULD be more positive when the "
"current flows in this manner. The sources merely maintain the same "
"convention as is applied to a resistor, what is important to remember is "
"that [+] and [-] terminals are just names that provide a sign convention "
"they don't insist that one terminal is a higher voltage than the other."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:161
msgid ""
"This example should provide enough information for analysis of any network "
"of voltage sources and resistors and for inspection of any current or "
"voltage in such a circuit. The power and resistance of each component can be "
"measured:"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:167
#, no-wrap
msgid ""
"  gnucap> print dc p(R1) p(Vsupply) r(R1) r(Vsupply)\n"
"  gnucap> dc\n"
"  #           p(R1)      p(Vsupply) r(R1)      r(Vsupply)\n"
"   0.         0.1       -0.1        1.K        Inf\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:173
msgid ""
"Note that the supply shows negative power to it is putting power into the "
"system while the resistor shows positive power meaning that it is taking "
"power out of the system. Also notice that the resistance measurement will "
"attempt to find the resistance of the source without error but the resulting "
"value is huge (this seems wrong, I would expect it to be zero)."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:175
msgid "All done, for now."
msgstr ""

#. type: Plain text
#: manual/examples/hello_world.txt:177
#, no-wrap
msgid ""
"  gnucap> quit\n"
"  $$$$$$$\n"
msgstr ""

#. type: Title ======
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:1
#, no-wrap
msgid "Multiplying Two Voltages Using Diode Nonlinearity"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:11
msgid ""
"The above example shows diode voltage drop behaviour but the diode can also "
"be used as an exponential function. In this example, a group of diodes are "
"used to construct a voltage multiplier. Most circuit components add and "
"subtract voltages and currents but multiplication is a bit special.  What is "
"done in this circuit is to use the exponential behaviour of the diodes to "
"take the logarithm of two input voltages, then add those up and use another "
"diode to find the exponential of the sum. This works in the same way as a "
"slide rule does."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:13
msgid "eg7.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:16
#, no-wrap
msgid ""
"<code>\n"
"MULTILPLY TWO NUMBERS\n"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:37
#, no-wrap
msgid ""
".subckt multiplier 1 2 3\n"
"*                        1 = input A (voltage)\n"
"*                        2 = input B (voltage)\n"
"*                        3 = output  (voltage)\n"
"* Note that there are scaling factors on inputs and output to keep\n"
"* diodes in the exponential region.\n"
".model dexp D EG=0 CJ=0 FC=0 gparallel=0\n"
"G1 0 4 1 0 1e-3\n"
"D1 4 0 dexp\n"
"G2 0 5 2 0 1e-3\n"
"D2 5 0 dexp\n"
"I3 0 6 1\n"
"D3 6 0 dexp\n"
"E1 7 0 4 0 1\n"
"E2 8 7 5 0 1\n"
"E3 8 9 6 0 1\n"
"V1 9 10 0\n"
"D4 10 0 dexp\n"
"H1 3 0 V1 1e6\n"
".ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:42
msgid "V1 1 0 0 V2 2 0 0.5 X1 1 2 3 multiplier R1 3 0 1"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:52
msgid ""
".options vmin=-1e5 vmax=1e5 .print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1.E3)  "
".!rm eg7_1.dat eg7_2.dat eg7_3.dat .dc v1 0 1 0.01 > eg7_1.dat .modify "
"V2=100 .dc v1 0 1 0.01 > eg7_2.dat .dc v1 0 1000 1 > eg7_3.dat .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:60
msgid ""
"This example does not attempt to go beyond the multiplication of two "
"numbers, using the DC sweep to test a few ranges of the inputs.  The output "
"files can be plotted to check the linearity of the outputs.  If you wanted "
"to build a real circuit to perform analog multiplication, you would need "
"something a lot more complex than the above example because the dependent "
"voltage and current sources used in this example would not be possible to "
"construct in a real circuit."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:65
msgid ""
"Even with those ideal simulator components available, this example will "
"still only multiply correctly within a limited range. Using it outside that "
"range requires adjustment of the input and output scaling factors so that "
"the diodes themselves stay close to exponential functions."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:74
msgid ""
"This example introduces the concept of a subcircuit which is like a macro "
"facility for circuit simulation. The subcircuit is contained between the "
"\".subckt\" and \".ends\" lines and nodes within the subcircuit can use "
"their own numbering, independent of the outside world. The subcircuit gets a "
"name (in this case \"multiplier\") and the component \"X1\" becomes an "
"instance of that subcircuit. Note the way that probes can be put on devices "
"inside the subcircuit, for example \"X1.E1\" refers to the sub-component "
"named \"E1\" inside the subcircuit \"X1\"."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:80
msgid ""
"Another new command here is \".modify\". In this example, we want to test "
"the multiplier on a few DC sweeps but want to change the value of \"V2\" "
"between the sweeps. This allows a single batch run to test multiple "
"possibilities, or it can also be used interactively to trim a component "
"value into the value that gives the desired operating point."
msgstr ""

#. type: Title ======
#: manual/examples/nonlinear_devices_--_diodes.txt:1
#, no-wrap
msgid "Nonlinear Devices -- Diodes"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:11
msgid ""
"All of the previous circuits have been linear. This is to say that all the "
"devices (voltage sources, current sources, dependent source and resistors) "
"are linear devices and the overall \"shape\" of the problem does not change "
"as the values of the system are scaled up or down.  For example, if a "
"circuit is solved once, then after that all of the voltage sources in the "
"circuit are doubled, the circuit doesn't need to be solved a second time "
"because all the node voltages will merely be double those of the first "
"solution. Try it yourself if you disbelieve."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:18
msgid ""
"Linear circuits also obey the principle of \"superposition\" which is to say "
"that the circuit can be solved for each source separately and then all of "
"those solutions can be added up to get the solution of a circuit containing "
"many sources. A textbook in basic circuit theory will explain superposition "
"in linear circuits and you can try working through the textbook examples on "
"the simulator using what has been explained so far."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:22
msgid ""
"At this point, we take the step into nonlinear circuits which do NOT obey "
"superposition and do NOT scale. The most elementary nonlinear component is a "
"diode."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:24
msgid "eg6.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:27
#, no-wrap
msgid ""
"<code>\n"
"DIODE CASCADE\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:29
msgid ".model 1N414 D IS=2e-14"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:37
#, no-wrap
msgid ""
"Vcc  1   0   5\n"
"Dx   1  10   1N414\n"
"Dy  10  20   1N414\n"
"Dz  20  30   1N414\n"
"Rd1 10   0   1k\n"
"Rd2 20   0   1k\n"
"Rd3 30   0   1k\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:42
msgid ".print dc v(10) v(20) v(30)  .dc Vcc 0 5 0.5 >eg6.dat .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:45
msgid "You can run this example and look at the results like so:"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:51
#, no-wrap
msgid ""
"\tgnucap -b eg6.ckt\n"
"\tgnuplot\n"
"\tset style data lines\n"
"\tplot 'eg6.dat' using 1:2, 'eg6.dat' using 1:3, 'eg6.dat' using 1:4\n"
"\texit\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:61
msgid ""
"You may not like using gnuplot and may prefer some other plotting program "
"such as gwave or gle. Gnucap output can be used by most plotting programs in "
"much the same manner as above by using the redirection arrow on the command "
"that runs the simulation (\"dc\" in this case). Note that it usually won't "
"work to redirect the normal output to a file using your shell and then cut "
"and paste that output into your plotting program because the normal output "
"does not use standard scientific notation, using the internal redirection "
"option provided also guarantees you get a nice, portable data file in "
"standard exponential notation."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:69
msgid ""
"If the above did work you should have been able to see the node voltages as "
"a function of supply voltage and see the diodes move into their conductive "
"band one by one. And see the traditional 0.7 volt drop across each diode.  "
"However, various diodes behave differently so gnucap needs to know what sort "
"of diode you are using. That is what the \".model\" command line is doing "
"for you -- it associated parameters in the diode model with a name that you "
"choose to assign to your diodes. (By the way, I have no idea what the true "
"measured parameters are for a real 1N414)."
msgstr ""

#. type: Title ======
#: manual/examples/phase_shift_oscillator.txt:1
#, no-wrap
msgid "Phase shift oscillator"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:3 manual/examples/simple_power_supply.txt:3
#, no-wrap
msgid "Getting started"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:6
msgid ""
"In this example, we will analyze a phase shift oscillator.  It was designed "
"in a hurry, so the specs are not expected to be very good.  We will see."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:8
msgid ""
"It uses a single BJT, plus an emitter follower, and runs on a single-ended "
"12 volt supply."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:10
msgid "Some measurements might include:"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Oscillation frequency\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Start-up time (how long it takes to stabilize)\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Distortion\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:16
msgid "Of course, we will look at the waveform."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:18
msgid ""
"I did this on the 2008-07-07 development snapshot, using some new features.  "
"I am not showing some of the mistake and trial steps, so your results may be "
"a little different."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:20
msgid "I am using an external waveform viewer \"gwave\" to display the waveforms."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:22
msgid "That's enough for now, let's go..."
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:23
#, no-wrap
msgid "The circuit"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:26
msgid "{{gnucap:pso.tar.gz|Here's a netlist for the circuit:}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:43
#, no-wrap
msgid ""
"  ' phase shift oscillator\n"
"  .model npn npn bf=100\n"
"  Vcc (vcc 0) pulse(iv=0 pv=12 rise=.01)\n"
"  Rb1 (vcc b) 100k\n"
"  Rb2 (b 0)   10k\n"
"  Rc  (vcc c) 10k\n"
"  Re  (e 0)   1k\n"
"  Ce  (e 0)   5000u\n"
"  Re2 (e2 0)  1k\n"
"  Q1  (c b e)    npn\n"
"  Q2  (vcc c e2) npn\n"
"  C1  (e2 f1) .01u\n"
"  C2  (f1 f2) .01u\n"
"  C3  (f2 b)  .01u\n"
"  Rf1 (f1 0)  10k\n"
"  Rf2 (f2 0)  10k\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:45
msgid "There are some tricks here .."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:47
msgid ""
"First, the power supply (Vcc).  It is a voltage source, but instead of just "
"saying \"DC=12\" to make it a constant 12 volt supply, I made it a pulse.  "
"It starts at zero, and waits until time=.01 to switch on.  I did this "
"because I want to see how it starts."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:49
msgid ""
"With just plain \"DC=12\" it would still oscillate, but I cannot be sure of "
"the actual start waveform.  For one, the emitter bypass would already be "
"charged."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:51
msgid "Next, I used a simple model of the BJT, specifying only the beta."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:53
msgid ""
"The emitter bypass gives a time constant of 5 seconds, which should make the "
"start-up nice and slow."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:55
msgid ""
"Finally, to show some contempt for good design, I just picked R and C for "
"the filter arbitrarily, with no real idea what the frequency would be."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:72
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2008.07.07 RCS 26.86\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get pso.ckt\n"
"  ' phase shift oscillator\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:74
msgid "Load the circuit .. it echos the title line."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:76
msgid "As a check, list it, see if it is what you expected."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:95
#, no-wrap
msgid ""
"  gnucap> list\n"
"  .model npn npn ( level=1 kf=NA( 0.) af=NA( 1.) bf= 100. br=NA( 1.) is=NA( "
"100.E-18) nf=NA( 1.) nr=NA( 1.) isc=NA(\n"
"   0.) re=NA( 0.) rc=NA( 0.) cjc=NA( 0.) cje=NA( 0.) cjs=NA( 0.) fc=NA( 0.5) "
"mjc=NA( 0.33) mje=NA( 0.33) mjs=NA( 0.)\n"
"   tf=NA( 0.) tr=NA( 0.) xtf=NA( 0.) xtb=NA( 0.) xti=NA( 3.) eg=NA( 1.11))\n"
"  Vcc ( vcc 0 ) pulse iv= 0. pv= 12. delay=NA( 0.) rise= 0.01 fall=NA( 0.) "
"width=NA( Inf) period=NA( Inf)\n"
"  Rb1 ( vcc b )  100.K\n"
"  Rb2 ( b 0 )  10.K\n"
"  Rc ( vcc c )  10.K\n"
"  Re ( e 0 )  1.K\n"
"  Ce ( e 0 )  0.005\n"
"  Re2 ( e2 0 )  1.K\n"
"  Q1 ( c b e )  npn NA( 1.)\n"
"  Q2 ( vcc c e2 )  npn NA( 1.)\n"
"  C1 ( e2 f1 )  10.n\n"
"  C2 ( f1 f2 )  10.n\n"
"  C3 ( f2 b )  10.n\n"
"  Rf1 ( f1 0 )  10.K\n"
"  Rf2 ( f2 0 )  10.K\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:97
msgid ""
"Looks good ..  note the \"NA\" fields ....  NA(5) means that the value is "
"unspecified, but assumed to be 5.  You can see what parameters were "
"specified, and which took the defaults."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:99
msgid "Before making a run, you need to set a few things up ..."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:102
#, no-wrap
msgid ""
"Pick the points you want to view (all node voltages):\n"
"  gnucap> print tran v(nodes)\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:105
#, no-wrap
msgid ""
"Pick the points you want to be able to do things like \"measure\" on (all "
"probes named \"v\" on anything, including nodes, devices, etc):\n"
"  gnucap> store tran v(*)\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:114
#, no-wrap
msgid ""
"Now, check the options.  We may want to change some:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= "
"0.001  abstol= 1.p  vntol= 1.u  trtol= 7\n"
"  0  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  "
"itl1=100  itl2=50  itl3=6  itl4=20  itl5=5000\n"
"  er  dampmax= 1.  dampmin= 0.5  dampstrategy=0  floor= 1.E-21  vfloor= 1.f  "
"roundofftol= 100.f  temperature= 27.  s\n"
"  ansits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  "
"traceload  itermin=1  vmax= 5.  vmin=-5.  dtm\n"
"  old= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= "
"0.25  trstepcoef2= 0.04166667  trstepcoe\n"
"   units=spice\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:117
#, no-wrap
msgid ""
"The only one I will change now is the printing precision .. Set it to 8 "
"digits.  Starting an oscillator takes a long time.\n"
"  gnucap> opt numdgt=8\n"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:118
#, no-wrap
msgid "Get started, run to steady state"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:121
msgid ""
"For starters, let's run it for 10 seconds, with a trial time step of .01.  "
"\"trace all\" says to output all of the internal time steps too.  Otherwise, "
"you will just get the ones you asked for."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:123
msgid ""
"I directed it to a file, boringly called \"z\".  Then look at it with "
"\"gwave\".  The bang (!) says to run a command through the shell.  The "
"ampersand (&) says to leave it running and return, just like a shell "
"command.  That way we can keep the waveforms on the screen and keep going."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:126
#, no-wrap
msgid ""
"  gnucap> tran 0 10 .01 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:132
msgid ""
"Here's the waveform.  It looks like it doesn't start oscillating until about "
"1 second.  Then takes until about 5 seconds to settle.  It looks like 10 "
"seconds was a good guess."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:134
msgid "{{gnucap:w1.png}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:136
msgid "Here's an expanded view just as it starts to oscillate:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:138
msgid "{{gnucap:w7.png}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:140
msgid "The last few cycles at the end of the run:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:142
msgid "{{gnucap:w8.png}}"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:143
#, no-wrap
msgid "The measurements we want"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:146
msgid ""
"Now, tighten the tolerance, so we can get good measurements.  The default "
"settings are fine most of the time, but for this we need better."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:156
#, no-wrap
msgid ""
"See what they are:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= "
"0.001  abstol= 1.p  vntol= 1.u  trtol= 7.  chgtol= 10.f  pivtol= 100.f\n"
"  pivrel= 0.001  numdgt=8  tnom= 27.  cptime=30000  limtim=2  limpts=201  "
"lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6\n"
"  itl4=20  itl5=5000  itl6=0  itl7=1  itl8=99  defl= 100.u  defw= 100.u  "
"defad= 0.  defas= 0.  clobber  dampmax= 1.  dampmin= 0.5  dampstrategy=0\n"
"  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  short= "
"10.u  out=9999  ydivisions= 4.  phase=degrees  order=auto  mode=mixed\n"
"  transits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  "
"traceload  itermin=1  vmax= 5.  vmin=-5.  dtmin= 1.p  dtratio= 1.G  rstray\n"
"  cstray  harmonics=9  trstepgrow= 1.E+99  trstephold= 1.E+99  trstepshrink= "
"2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2=\n"
"  0.04166667  trstepcoef3= 0.005208333  noquitconvfail  edit  recursion=20  "
"language=acs  insensitive  units=spice\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:159
#, no-wrap
msgid ""
"Now tighten \"reltol\" and \"trtol\".\n"
"  gnucap> opt reltol=.0001 trtol=1\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:163
#, no-wrap
msgid ""
"and run for another .01 seconds, continuing...\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:172
#, no-wrap
msgid ""
"and make some measurements...\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.00943\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.00778\n"
"  gnucap> param frequency={1/(t2-t1)}\n"
"  gnucap> eval frequency\n"
"  frequency= 606.060606060714\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:174
msgid ""
"For the Fourier analysis, pick a fundamental of half of the real "
"fundamental, as an indicator of accuracy.  We all know, there should be "
"nothing there.  If the component at the odd frequencies is too big, it means "
"the frequency we specified is slightly in error, and we need to tighten "
"tolerances and fine tune."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:183
#, no-wrap
msgid ""
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 303.030303030357\n"
"  gnucap> print fourier v(e2)\n"
"  gnucap> fourier 0 10k 303.030303030357\n"
"  #Time          v(e2)\n"
"   10.0133       8.9974012\n"
"   10.013326     8.7969959\n"
"   10.013352     8.5847199\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:197
#, no-wrap
msgid ""
"   10.016574     9.0517243\n"
"   10.0166       8.8549586\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0656      16.98   90.000  2.2861       7.18  -44.748\n"
"   303.03     0.034076   -29.35  118.607  0.011025   -39.15  -16.141\n"
"   606.06     3.0907       9.80  134.748  1.           0.00    0.000\n"
"   909.09     0.040746   -27.80  -43.182  0.013183   -37.60 -177.930\n"
"   1.2121K    0.3894      -8.19  -94.915  0.12599    -17.99  130.337\n"
"   1.5152K    0.017954   -34.92   17.761  0.0058088  -44.72 -116.987\n"
"   1.8182K    0.15704    -16.08    4.083  0.05081    -25.88 -130.665\n"
"   2.1212K    0.0042367  -47.46   67.220  0.0013708  -57.26  -67.528\n"
"   2.4242K    0.079307   -22.01   94.762  0.02566    -31.82  -39.986\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:199
msgid "303 Hz has a relative amplitude of -39 db.  Not very good."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:201
msgid "Tighten the tolerances and measure again:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:206
#, no-wrap
msgid ""
"  gnucap> opt reltol=.00001 trtol=1\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= Inf\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:208
msgid "Error ....  we already went past 10.01 seconds ..  Move ahead and try again."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:224
#, no-wrap
msgid ""
"  gnucap> tran 10.03 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.02911\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.02747\n"
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 304.878048780472\n"
"  gnucap> eval frequency\n"
"  frequency= 609.756097560944\n"
"  gnucap> fourier 0 10k 304.878048780472\n"
"  #Time          v(e2)\n"
"   10.029986     6.3978311\n"
"   10.030012     6.1507251\n"
"   10.030037     5.9090503\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:248
#, no-wrap
msgid ""
"   10.033189     7.1588976\n"
"   10.033215     6.9059126\n"
"   10.03324      6.6531773\n"
"   10.033266     6.4023893\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0581      16.97   90.000  2.2836       7.17 -104.675\n"
"   304.88     256.82u    -71.81   -1.240  83.092u    -81.61  164.086\n"
"   609.76     3.0908       9.80 -165.325  1.           0.00    0.000\n"
"   914.63     0.0011098  -59.09 -171.143  359.08u    -68.90   -5.817\n"
"   1.2195K    0.38362     -8.32   21.927  0.12412    -18.12 -172.748\n"
"   1.5244K    103.52u    -79.70  178.156  33.493u    -89.50  -16.518\n"
"   1.8293K    0.14832    -16.58 -177.459  0.047988   -26.38  -12.133\n"
"   2.1341K    357.2u     -68.94 -179.519  115.57u    -78.74  -14.193\n"
"   2.439K     0.079273   -22.02  -23.966  0.025648   -31.82  141.360\n"
"   2.7439K    132.94u    -77.53 -126.976  43.011u    -87.33   38.350\n"
"   3.0488K    0.049584   -26.09  126.722  0.016043   -35.89  -67.952\n"
"   3.3537K    168.29u    -75.48  163.828  54.45u     -85.28  -30.847\n"
"   3.6585K    0.033637   -29.46  -84.750  0.010883   -39.27   80.575\n"
"   3.9634K    163.24u    -75.74 -138.899  52.816u    -85.54   26.426\n"
"   4.2683K    0.024012   -32.39   63.711  0.0077689  -42.19 -130.964\n"
"   4.5732K    52.818u    -85.54  168.840  17.089u    -95.35  -25.834\n"
"   4.878K     0.018021   -34.88 -148.890  0.0058308  -44.69   16.435\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:250
msgid "That's better.  Noise is -68 db or better.  305 Hz is -81 db."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:252
msgid ""
"As I said, the oscillator isn't very good.  The second harmonic is only 18 "
"db below the fundamental."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:253
msgid "Enough for now..."
msgstr ""

#. type: Title ======
#: manual/examples/resistors_and_sources.txt:1
#, no-wrap
msgid "Resistors and sources"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:6
msgid ""
"The previous example covers enough concepts to model arbitrarily complex "
"networks of resistors and sources. These are essentially linear circuits "
"that have no relation to time. A more elaborate example is presented below:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:8
msgid "eg2.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:21
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND VOLTAGE SOURCES\n"
"V1 2 1 10\n"
"V2 4 3 5\n"
"V3 0 3 3\n"
"R1 1 2 220\n"
"R2 2 3 4.7k\n"
"R3 4 5 3.3k\n"
"R4 3 5 10k\n"
"R5 0 1 22k\n"
"R6 0 5 15k\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:23
msgid "Run this with:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:32
#, no-wrap
msgid ""
"<code>\n"
"gnucap> get eg2.ckt\n"
"gnucap> print dc v(1) v(2) v(3) v(4) v(5)\n"
"gnucap> dc\n"
"#           v(1)       v(2)       v(3)       v(4)       v(5)\n"
" 0.        -10.712    -0.71161   -3.         2.         0.65161\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:34
msgid ""
"Note that this is about the limit of what can be done with these two "
"components. Other components that offer further possibilities are the "
"current source (any component with a name that begins with \"I\" is a "
"current source) and the dependent sources:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:40
#, no-wrap
msgid ""
"|first letter of name |output type |input type |\n"
"|E                    |voltage     |voltage    |\n"
"|F                    |current     |current    |\n"
"|G                    |current     |voltage    |\n"
"|H                    |voltage     |current    |\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:49
msgid ""
"Each of these has a gain value expressing the relation between its output "
"and its input and they allow the modeling of linear amplifiers and other "
"such devices. As mentioned above, none of these components understand time "
"nor can they be used to represent a nonlinear device.  Thus, any network "
"constructed from the components that have been seen so far will be reducible "
"to a Thevenin or Norton equivalent circuit when considered from the point of "
"view of one particular node and the ground node 0."
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:51
msgid "eg3.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:77
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND DEPENDENT SOURCES\n"
"*\n"
"* Reduce this complicated collection of dependencies\n"
"* down to a single Thevenin equivalent between node 2 and\n"
"* the ground node 0\n"
"*\n"
"I1 1 4 2\n"
"V1 1 0 5\n"
"E1 5 2 1 3 0.4\n"
"F1 5 6 R1 3e-2\n"
"G1 2 3 4 6 1.3\n"
"H1 3 0 R3 1\n"
"R1 4 5 2.2\n"
"R2 1 2 470\n"
"R3 0 2 330\n"
"R4 3 6 1k\n"
"R5 5 6 1e4\n"
"*\n"
"* Look at the voltage at node 2 and the impedance looking into node 2\n"
"*\n"
".print dc v(2) z(2)\n"
".dc\n"
".end\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:86
msgid ""
"Notice that this example file contains some lines that begin with a dot.  "
"These are command lines and behave exactly like the commands you type in "
"interactive mode. These command lines are dotted because of the old SPICE "
"tradition of executing all of the component lines first and then the command "
"lines, gnucap doesn't bother with this, it executes every line in the order "
"that it sees them, but it still follows the old idea of dotting the command "
"lines as a little tribute to SPICE and to make it easier to see what is "
"going on when you read a .ckt file."
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:88
msgid "When you run this example, you might try:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:90
#, no-wrap
msgid "  gnucap -b eg3.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:97
msgid ""
"And (all going well) you will see that node 2 is equivalent to a source of "
"54.343 volts in series with an 0.83888 ohm resistor.  You should also notice "
"that gnucap never goes into interactive command mode.  This is because of "
"the \".end\" command that tells gnucap to finish at this point.  You may "
"want to use this example circuit in interactive mode, to achieve this you "
"could either delete the \".end\" command, or (from the system prompt) type:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:100
#, no-wrap
msgid ""
"  gnucap\n"
"  get eg3.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:104
msgid ""
"Then you can use other interactive commands. Note that you can modify the "
"circuit interactively too. Consider adding another resistor by typing the "
"following at the interactive prompt:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:108
#, no-wrap
msgid ""
"  build R3\n"
"  R6 3 4 12k\n"
"  <blank line>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:114
msgid ""
"Which allows you to adjust the topology of the circuit in memory. This "
"includes adding components and modifying existing components. You can "
"interactively remove components from the circuit using the \"delete\" "
"command or you can wipe out the entire circuit using the \"clear\" command.  "
"To put the adjusted topology into a file you use the save command:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:118
#, no-wrap
msgid ""
"  save eg3_mod.ckt\n"
"  quit\n"
"  cat eg3_mod.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:124
msgid ""
"Looking at what you have saved you will probably notice a few things: "
"firstly, gnucap has remembered your comment lines and command lines and "
"saved them too; secondly, your extra line was inserted into the file before "
"the line containing component \"R3\", this is caused by the argument on the "
"\"build\" command and allows you to insert your build lines where you want "
"them."
msgstr ""

#. type: Title ======
#: manual/examples/simple_power_supply.txt:1
#, no-wrap
msgid "A simple power supply"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:6
msgid "In this example, we will analyze a simple power supply."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:8
msgid ""
"The power supply consists of a \"lump\" power transformer with fairly loose "
"coupling for short circuit protection, a full wave bridge rectifier, and a "
"filter capacitor.  The desired output is about 50 volts at .5 amps (100 Ohm "
"load), with less than 1 volt of ripple.  The power supply should be able to "
"handle a short with no damage, with no fuse."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:10
msgid ""
"An inexperienced engineer has chosen a transformer with primary inductance "
"of 1 Henry, secondary inductance of .1 Henry, a turns ratio of 3.16:1.  The "
"stock transformer has a coefficient of coupling of .9.  He has also chosen "
"1N4004 diodes, and a 5000 uf filter capacitor."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:12
msgid ""
"The first goal of simulation is to validate the design.  Then, make "
"adjustments to the design to meet the specs."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:14
msgid ""
"To validate the design, the following measurements need to be made, not "
"necessarily in this order."
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "DC output voltage, loaded (100 Ohm) and unloaded.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Ripple voltage.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid ""
"Current in diodes: waveform, average, steady state peak, power-on surge, "
"AC.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Current in filter cap: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input current: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input power, VAR, and power factor: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid ""
"Above currents and power for load = nominal (100 Ohm), unloaded, and shorted "
"(.01 Ohm)\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Diode voltages, PIV, etc.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Transformer voltages\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Impact of high line (132 volts) and low line (108 volts)\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:27
msgid ""
"This example will show how to do some of these.  The rest are left as an "
"exercise.  You can make all of these measurements with gnucap."
msgstr ""

#. type: Title =====
#: manual/examples/simple_power_supply.txt:29
#, no-wrap
msgid "Building the circuit"
msgstr ""

#. type: Title =====
#: manual/examples/simple_power_supply.txt:31 about/plugins/models.txt:2
#, no-wrap
msgid "Models"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:34
msgid "First, let's make subcircuits for the transformer and diode bridge:"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:40
#, no-wrap
msgid ""
"  .subckt transformer (p1 p2 s1 s2)\n"
"  L1 (p1 p2) 1\n"
"  L2 (s1 s2) .1\n"
"  K1 (L1 L2) .9\n"
"  .ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:48
#, no-wrap
msgid ""
"  .subckt bridge (in1 in2 minus plus)\n"
"  .model 1n4004 d is=1n\n"
"  D1 (in1 plus) 1n4004\n"
"  D2 (in2 plus) 1n4004\n"
"  D3 (minus in1) 1n4004\n"
"  D4 (minus in2) 1n4004\n"
"  .ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:50
msgid "Save it in the file \"models\"."
msgstr ""

#. type: Title ====
#: manual/examples/simple_power_supply.txt:51
#, no-wrap
msgid "Main circuit"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:54
msgid "Now, let's run it interactively..  Type in the circuit..."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:68
#, no-wrap
msgid ""
"  $ gnucap\n"
"  ..... (signs on)\n"
"  gnucap> include models\n"
"  gnucap> list\n"
"     ..... (list of circuit so far)\n"
"  gnucap> spice\n"
"  gnucap-spice>Vin (in 0) sin (freq=60 ampl=170) ac 120\n"
"  gnucap-spice>X1 (in 0 s1 s2) transformer\n"
"  gnucap-spice>X2 (s1 s2 0 out) bridge\n"
"  gnucap-spice>Rload (out 0) rload\n"
"  gnucap-spice>Cfilter (out 0) cfilter\n"
"  gnucap-spice>.control\n"
"  gnucap>\n"
msgstr ""

#. type: Title =====
#: manual/examples/simple_power_supply.txt:69
#, no-wrap
msgid "Simulate"
msgstr ""

#. type: Title ====
#: manual/examples/simple_power_supply.txt:71
#, no-wrap
msgid "Set up and first run"
msgstr ""

#. type: Title ======
#: manual/examples/things_that_can_go_wrong.txt:1
#, no-wrap
msgid "Things that can go wrong"
msgstr ""

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:3
#, no-wrap
msgid "Voltage sources in parallel"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:6
msgid "eg4.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:9
#, no-wrap
msgid ""
"<code>\n"
"VOLTAGE SOURCES IN PARALLEL\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:16
msgid "V1 1 0 10.0 V2 1 0 10.2 .print dc v(1) i(V1) i(V2)  .dc .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:26
msgid ""
"Here we have V1 and V2 both driving the same node at about 10 volts.  "
"Actually, V2 is very slightly higher than 10 volts so there will be some "
"argument between V1 and V2 as to exactly what the final voltage at node 1 "
"really is. You should see that huge currents are flowing through the "
"supplies (10,000 amps) just due to this small voltage difference. Also note "
"that gnucap does not throw in the towel and give up, nor does it fail to "
"converge... the answer that it gets for v(1)  is a compromise, halfway "
"between the two sources."
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:31
msgid ""
"What is does is introduce a slight imperfection in the voltage sources so "
"that they do have a small internal series resistor. This allows it to make "
"the best guess that it can in a difficult situation. How much is this "
"resistance? You can find out like so:"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:34
#, no-wrap
msgid ""
"\tacs\n"
"\toptions\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:41
msgid ""
"Look at the value of the option called \"short\" (near the middle of the "
"block of options), this is the value (in ohms) of the internal resistance of "
"a voltage source. The \"u\" character means \"micro\" or 1e-6 so the default "
"value of a short circuit is 1e-5 ohms. You might decide that a different "
"short circuit value is more appropriate for running the above circuit so you "
"can type (from the prompt):"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:46
#, no-wrap
msgid ""
"\toptions short=0.5\n"
"\tget eg4.ckt\n"
"\tdc\n"
"\texit\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:53
msgid ""
"Which should show you the same voltage (10.1) but now the current has "
"reduced to only one fifth of an Amp (still not small but a lot more "
"reasonable if you were building this with real supplies).  Other option "
"values can be altered in much the same way and input files can contain "
"\".options\" command lines in order to set these options whenever the "
"circuit is loaded."
msgstr ""

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:54
#, no-wrap
msgid "Current sources in series"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:57
msgid "eg5.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:60
#, no-wrap
msgid ""
"<code>\n"
"CURRENT SOURCES IN SERIES\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:67
msgid "I1 0 1 2.0001 I2 1 0 2.0 .print dc v(1) i(I1) i(I2)  .dc .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:77
msgid ""
"The case of putting two current sources in series is much the same concept "
"as two voltage sources in parallel. However notice that gnucap copes with it "
"in a different manner. It cannot find a compromise current that is partway "
"between the two sources and it always gives a huge value for the voltage at "
"node 1. At least it doesn't crash and it does give results that give some "
"suggestion as to where the problem might be. There is an option \"gmin\" "
"that introduces resistance into a current source, or you can explicitly add "
"these resistors if you like by putting the resistor in parallel with the "
"current source."
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:82
msgid ""
"What if you had a big, complex circuit, you messed up by putting two current "
"sources in series but you never thought about checking the strange node? How "
"would you ever know that the circuit was broken? Try this exercise:"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:88
#, no-wrap
msgid ""
"\tacs\n"
"\tget eg5.ckt\n"
"\talarm dc v(*)(-1e3,1e3)\n"
"\tdc\n"
"\tquit\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:94
msgid ""
"Now you get a warning whenever any component gets more that 1000 volts "
"across it. This can be used to test component breakdown if you know that you "
"are using components that cannot tolerate high voltages. It can also be used "
"to ensure that your simulated circuit stays within what you might expect to "
"be the absolute maximum values."
msgstr ""

#. type: Title ======
#: manual/howto.txt:1
#, no-wrap
msgid "How to"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:probes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:expressions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:measure|measurements]]\n"
msgstr ""

#. type: Title ======
#: manual/howto/expressions.txt:1
#, no-wrap
msgid "Parameter expressions"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:4
msgid "Gnucap supports expressions for almost all parameters."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:6
msgid ""
"Ideally, the usual syntax is supported.  Actually, in some cases you must "
"enclose the expression in quotes or curly braces."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:8
msgid ""
"Expressions use late evaluation and dynamic scoping, like a functional "
"language."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:10
msgid ""
"The \"eval\" command evaluates and prints the present value of an "
"expression."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:12
msgid ""
"The \"measure\" command evaluates and assigns the present value of an "
"expression.  For now, it only takes simple function calls used in "
"measurements."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:21
#, no-wrap
msgid ""
"  gnucap> param a=5\n"
"  gnucap> param b=a+3\n"
"  gnucap> eval a\n"
"  a= 5.\n"
"  gnucap> eval b\n"
"  b= 8.\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:23
msgid "Now change the value of \"a\"."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:27
#, no-wrap
msgid ""
"  gnucap> param a=9\n"
"  gnucap> eval b\n"
"  b= 12.\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:29
msgid "Thanks to late evaluation, the value of \"b\" also changed."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:31
msgid "This is so you can do things like this:"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:34
#, no-wrap
msgid ""
"  r1 (in out) resistor r={rtotal*ratio}\n"
"  r2 (out 0)  resistor r={rtotal*(1-ratio)}\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:37
#, no-wrap
msgid ""
"  param rtotal=100k\n"
"  param ratio=.5\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:39
msgid "r1 and r2 are both 50k."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:41
#, no-wrap
msgid "  param rtotal=10k\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:43
msgid "r1 and r2 are both 5k."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:45
#, no-wrap
msgid "  param ratio = .3\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:47
msgid "r1 is 3k.  r2 is 7k."
msgstr ""

#. type: Title =====
#: manual/howto/expressions.txt:48
#, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:51
msgid ""
"The usual binary operators (+ - * /) are supported in the usual way with the "
"usual precedence."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:53
msgid ""
"The usual comparison operators ( < > <''''= >= == != ) are supported.  The "
"result is 1 if it evaluates to true, 0 if it evaluates to false."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:55
msgid "The binary operators (&& ||) are supported, and evaluate to 1 or 0."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:59
msgid ""
"These functions are included by default.  More functions can be added as "
"plugins."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:73
#, no-wrap
msgid ""
"|abs(x)    |Magnitude of x.  |\n"
"|cos(x)    |Cosine of x.  |\n"
"|cosh(x)   |Hyperbolic cosine of x.  |\n"
"|eval(x)   |Evaluate x.  |\n"
"|exp(x)    |e raised to the x power.  |\n"
"|int(x)    |Integer part of x.  |\n"
"|log(x)    |Natural log of x.  |\n"
"|na(x)     |\"Not available\".  Returns \"NA\" regardless of its argument.  "
"|\n"
"|pow(x,y)  |x raised to the y power.  |\n"
"|sin(x)    |Sine of x.  |\n"
"|sinh(x)   |Hyperbolic sine of x.  |\n"
"|sqrt(x)   |Square root of x.  |\n"
"|tan(x)    |Tangent of x.  |\n"
"|tanh(x)   |Hyperbolic tangent of x.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:4
msgid ""
"Gnucap offers a comprehensive set of probes.  This section lists system "
"probes, node probes, and common element probes."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:6
msgid ""
"Probes always have the syntax name_of_probe(device_or_node).  Example: "
"vdd(m1)."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:8
msgid ""
"You can access components in subcircuits by connecting the names with "
"dots. For example: Xone.X67.R56 is R56 in X67 in Xone. Some built-in "
"elements, including diodes, transistors, and mosfets, contain subcircuits "
"with internal elements. M12.Cgd is the gate to drain capacitor of mosfet "
"M12."
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:9
#, no-wrap
msgid "System probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:12
msgid "For system probes, use the device name \"0\"."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:21
#, no-wrap
msgid ""
"|iter       |The number of iterations needed for convergence for this "
"printed step including any hidden steps.  |\n"
"|bypass     |Prints a code indicating whether model evaluation can be "
"bypassed.\\\\  0=bypass turned off by user.\\\\  1=bypass enabled by user, "
"but not active now.\\\\  11=bypass is possible.  |\n"
"|control    |A number indicating why the simulator chose this time to "
"simulate at.\\\\  1=The user requested it. One of the steps in a sweep.\\\\  "
"2=A scheduled discrete event. An element required a solution at this "
"time.\\\\  3=The effect of the skip parameter.\\\\  4=The iteration count "
"exceeded ITL4 so the last step was rejected and is being redone at a smaller "
"time step.\\\\  5=The iteration count exceeded ITL3 so the increase in time "
"step is limited.\\\\  6=Determined by local truncation error or some other "
"device dependent approximation in hopes of controlling accuracy.\\\\  "
"7=Determined by a movable analog event. An element required a solution at "
"this time.\\\\  8=The step size was limited due to iteration count.\\\\  "
"9=This is an initial step. The size was arbitrarily set to 1/100 of the user "
"step size.\\\\  10+x=The previous step was rejected.\\\\  20+x=A zero time "
"step was replaced by mrt.\\\\  30+x=The required step size less than mrt, so "
"it was replaced by mrt.  |\n"
"|damp       |Newton damping factor.  |\n"
"|generator  |The output of the signal generator. In a transient analysis, "
"it shows the output of the signal generator, as set up by the generator "
"command. In a DC analysis, it shows the DC input voltage (not the power "
"supply). In an OP analysis, it shows the DC input, normally zero.  |\n"
"|hidden     |The number of hidden steps.  |\n"
"|temp       |The simulation temperature in degrees Celsius.  |\n"
"|time       |The current time in a transient analysis. In AC analysis it "
"shows the time at which the bias point was set, 0 if it was set in a DC or "
"OP analysis, or -1 if it is the bias was not set (power off).  |\n"
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:22
#, no-wrap
msgid "Node probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:25
msgid "All modes."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:30
#, no-wrap
msgid ""
"|v    |Voltage.  |\n"
"|z    |Impedance looking into the node.  |\n"
"|mdy  |Matrix diagonal \"y\".  |\n"
"|mdz  |Matrix diagonal \"z\".  (1/mdy)  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:32
msgid "Transient, DC, OP, only."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:38
#, no-wrap
msgid ""
"|logic  |A numeric interpretation of the logic value at the node. The value "
"is displayed encoded in a number of the form a.bc where\\\\ \\\\ a is the "
"logic state:\\\\ 0 = logic 0\\\\ 1 = rising\\\\ 2 = falling\\\\ 3 = logic "
"1\\\\ 4 = unknown\\\\ \\\\ b is an indication of the quality of the digital "
"signal.\\\\ 0 is a fully valid logic signal.\\\\ Nonzero indicates it does "
"not meet the criteria for logic simulation.\\\\ \\\\ c indicates how the "
"node was calculated:\\\\ 0 indicates logic simulation.\\\\ 1 indicates "
"analog simulation of a logic device.\\\\ 2 indicates analog simulation of "
"analog devices.  |\n"
"|lastchange  |The most recent time at which the logic state changed.  |\n"
"|finaltime   |The scheduled time a pending logic state change will occur.  "
"|\n"
"|diter       |Iteration number for last digital update.  |\n"
"|aiter       |Iteration number for last analog update.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:40
msgid "AC only."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:42
msgid ""
"In addition to those listed here, you can add a suffix (M, P, R, I and db) "
"for magnitude, phase, real part, imaginary part, and decibels, to any valid "
"probe."
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:43
#, no-wrap
msgid "Element probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:46
msgid ""
"Each element type has several parameters that can be probed. In general, the "
"form is Parameter(element). Wild cards are allowed in element names to allow "
"probing the same parameter of a group of elements."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:48
msgid ""
"For components in a subcircuit, the names are connected with dots. For "
"example X13.R12 is R12 in the subcircuit X13."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:54
msgid "All devices:"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:59
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second "
"port.  |\n"
"|errortime      |Suggestion of next time point based on truncation or "
"interpolation error.  |\n"
"|eventtime      |Suggestion of next time point based on movable events.  |\n"
"|timefuture     |Suggestion of next time point, the sooner of errortime and "
"eventtime.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:63
msgid ""
"Most elements,\\\\ devices that do not have an internal subcircuit,\\\\ "
"devices that can be defined simply by y=f(x)."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:86
#, no-wrap
msgid ""
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for "
"four terminal devices. The first node in the net list is assumed positive.  "
"|\n"
"|vin       |Input voltage.  The voltage across the input terminals. For "
"two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, "
"out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power "
"indicates that the part is supplying power. Its value is the same as (PD - "
"PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always "
"positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is "
"always positive and does not consider its own dissipation.  |\n"
"|input     |The input of the device. It is the current through a resistor "
"or inductor, the voltage across a capacitor or admittance, etc. It is the "
"value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is "
"the voltage across a resistor, the charge stored in a capacitor, the flux in "
"an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is "
"also the effective value of the part, in its units. If the part is ordinary, "
"it will just show its value, but if it is time variant or nonlinear, it "
"shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is "
"constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp "
"is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the "
"present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|z         |Circuit impedance seen by this device, with this device not "
"counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this "
"device.  Prints a meaningless number in transient analysis.  |\n"
msgstr ""

#. type: Title ======
#: manual/languages.txt:1
#, no-wrap
msgid "Languages"
msgstr ""

#. type: Plain text
#: manual/languages.txt:4
msgid ""
"By use of plugins, Gnucap gives you a choice of simulation languages.  The "
"following are the simulation languages supported in this release."
msgstr ""

#. type: Plain text
#: manual/languages.txt:8
msgid ""
"[[gnucap:manual:languages:Verilog]]\\\\ "
"[[gnucap:manual:languages:Spectre]]\\\\ "
"[[gnucap:manual:languages:Spice]]\\\\ [[gnucap:manual:languages:ACS]]"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:1 spectre.txt:1
#, no-wrap
msgid "Language : Spectre"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:4 spectre.txt:4
msgid ""
"The Spectre language plugin attempts to support the syntax of the Cadence "
"Spectre simulator."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:6 spectre.txt:6
msgid ""
"Not all features of Spectre are supported, but those that work will work "
"with Spectre syntax.  Wherever possible, Gnucap features will work in "
"Spectre mode, even if they don't work in Spectre."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:8 spectre.txt:8
msgid "The Spectre mode is case sensitive, and uses \"SI\" units."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:10 manual/languages/verilog.txt:10 spectre.txt:10
msgid ""
"The \"SI\" units are case sensitive.  1p is 1e-12.  1P is 1e15.  1m is "
"1e-3.  1M is 1e6."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:12 manual/languages/verilog.txt:12 spectre.txt:12
msgid "Comments are preceded by /****/ and extend to the end of the line."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:14 spectre.txt:14
msgid ""
"The format is line oriented.  A newline terminates a statement.  You can "
"extend a line by ending it with \\ ."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:16 spectre.txt:16
msgid "From startup, you can set Spectre mode with the command line:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:18 spectre.txt:18
#, no-wrap
msgid "  simulator lang=spectre\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:20
msgid "or"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:22
#, no-wrap
msgid "  spectre\n"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:23 manual/languages/verilog.txt:24 spectre.txt:36
#, no-wrap
msgid "Components"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:26 manual/languages/verilog.txt:27
msgid "All components have the same syntax:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:28
#, no-wrap
msgid "  label (port list) type arguments\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 manual/languages/verilog.txt:34 spectre.txt:46
#, no-wrap
msgid "**Label** : a string.  The first letter has no significance.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 spectre.txt:46
#, no-wrap
msgid ""
"**Port list** : A list of the ports (connections), whitespace delimited.  "
"Mapping is determined by order.  The port list should be surrounded by "
"parentheses.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 spectre.txt:46
#, no-wrap
msgid ""
"**Type** : The type of component.  If there is a \"model\" statement, this "
"is the name in the model statement.  Otherwise, it could be the name of a "
"\"subckt\", a Verilog \"module\" or \"paramset\", or a standard device.  "
"This is called \"master\" in the Spectre manual.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33
#, no-wrap
msgid ""
"**Arguments** : A list of arguments (parameters or values).  All arguments "
"are name = value pairs, of the form \"name = value\", whitespace delimited.  "
"The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:36
#, no-wrap
msgid ""
"  Rload (out 0) resistor r=10K\n"
"  X1 (out in vc) amp rload=100K\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:38
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Spectre mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:41
#, no-wrap
msgid ""
"  Vcc (vc  0) vsource  dc=15 // Spice-style source arguments are not "
"supported.\n"
"  Vin (in  0) vsource  ac=1  // Spice-style source arguments are not "
"supported.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:44 manual/languages/verilog.txt:46
msgid "But you can switch modes, to one that does support the syntax:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:53
#, no-wrap
msgid ""
"  // assume it is starting in Spectre mode\n"
"  - spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .spectre\n"
"  // Now it is back in Spectre mode.\n"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:54 manual/languages/verilog.txt:58 spectre.txt:19
#, no-wrap
msgid "Top-level blocks"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:57 spectre.txt:22
msgid "Two top level blocks are supported: model and subckt."
msgstr ""

#. type: Title =====
#: manual/languages/spectre.txt:58 spectre.txt:23
#, no-wrap
msgid "model"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:61 spectre.txt:26
msgid ""
"A \"model\" statement sets parameters based on an existing compiled model.  "
"This will be extended to cover all \"masters\".  It becomes a \"master\" "
"that can be instantiated later.  It is equivalent to a spice \".model\" or a "
"Verilog \"paramset\"."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:64
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"model\" newname itsmaster parameters\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 spectre.txt:33
#, no-wrap
msgid "**model** : Keyword identifies a model statement.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75 spectre.txt:33
#, no-wrap
msgid ""
"**newtype** : The new type being defined.  This can be used as a device type "
"later.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75 spectre.txt:33
#, no-wrap
msgid "**itsmaster** : The type it is derived from.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69
#, no-wrap
msgid ""
"**Arguments** : A list of arguments (parameters or values).  All arguments "
"are name - value pairs, of the form \"name = value\", whitespace delimited.  "
"The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:71
#, no-wrap
msgid "  model gp_npn npn bf=150\n"
msgstr ""

#. type: Title =====
#: manual/languages/spectre.txt:72
#, no-wrap
msgid "subckt"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:88
#, no-wrap
msgid ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1   (base vcc)      resistor  r=1M  // 1 megohm\n"
"  Rb2   (base 0  )      resistor  r=100k\n"
"  Rc    (col  vcc)      resistor  r=100k\n"
"  Re    (emit 0  )      resistor  r=10k\n"
"  Ce    (emit 0  )      capacitor c=1m  // 1 millifarad\n"
"  Cin   (base in )      capacitor c=1u\n"
"  Q1    (col base emit) gp-npn\n"
"  Q2    (vcc col e2)    gp-npn\n"
"  Re2   (e2   0  )      resistor  r=1k\n"
"  Cout  (e2   out)      capacitor c=10u\n"
"  Rload (out 0  )       resistor  r=rload\n"
"  ends amp\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:93
#, no-wrap
msgid ""
"  X1    (out in vc)     amp      rload=100k\n"
"  Vcc   (vc  0)         vsource  dc=15\n"
"  Vin   (in  0)         vsource  ac=1\n"
"  Rload (out 0)         resistor r=10k\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:97 spectre.txt:69
msgid ""
"Commands usually have the same syntax as components, but there is no port "
"list."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:99 spectre.txt:71
msgid ""
"The Spectre mode does not introduce any new commands.  The only change is "
"the syntax."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:101 spectre.txt:73
msgid ""
"In Spectre mode, there is a label before the command, like a component.  The "
"label names a file which will contain the results of the command.  The "
"filename extension is the command."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:103 spectre.txt:75
msgid ""
"As an non-standard extension, using a dash '-' as the label sends the "
"command output to the standard output."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:105 spectre.txt:77
msgid "Commands are executed in the order given."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:109 spectre.txt:81
#, no-wrap
msgid ""
"  setbias op\n"
"  response ac start=20 stop=20K dec=10\n"
"  - ac\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:111 spectre.txt:83
msgid "This is equivalent to the native mode:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:115 spectre.txt:87
#, no-wrap
msgid ""
"  op >setbias.op\n"
"  ac start=20 stop=20K dec=10 >response.ac\n"
"  ac\n"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:116 manual/languages/verilog.txt:126 spectre.txt:88
#, no-wrap
msgid "Extras"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:119 spectre.txt:91
#, no-wrap
msgid ""
"You can switch languages any time with the appropriate command.  The command "
"must be in spectre syntax, with a label or dash first.  The command to "
"switch back must be issued in the language you switched to.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:123 spectre.txt:95
msgid ""
"The current implementation in gnucap differs slightly from the Cadence "
"product."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid "The \"master\" must be defined before it is referenced.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 spectre.txt:99
#, no-wrap
msgid ""
"The devices and commands are whatever gnucap has installed, which are "
"probably different from what Spectre (the simulator) provides.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid ""
"The circuit must be defined before any commands using it, unless you want to "
"simulate a partial circuit.  Scripted and interactive modifications to the "
"circuit are done the way gnucap usually does.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 spectre.txt:99
#, no-wrap
msgid "There is an interactive mode, with spectre syntax.\n"
msgstr ""

#. type: Title ======
#: manual/languages/verilog.txt:1
#, no-wrap
msgid "Language : Verilog"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:4
msgid ""
"The Verilog language plugin attempts to support the syntax of the "
"Verilog-AMS language."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:6
msgid ""
"Not all features of Verilog-AMS are supported, but those that work will work "
"with Verilog-AMS syntax.  Wherever possible, Gnucap features will work in "
"Verilog-AMS mode, even if they don't work in Verilog-AMS."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:8
msgid "The Verilog mode is case sensitive, and uses \"SI\" units."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:14
msgid ""
"The format is not line oriented.  A semicolon terminates a statement.  You "
"can extend a line by ending it with \\ ."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:16
msgid ""
"In gnucap, for now, you must have one statement per line.  This is "
"non-standard."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:18
msgid "From startup, you can set Verilog mode with the command line:"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:20
#, no-wrap
msgid "  simulator lang=verilog\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:23
#, no-wrap
msgid ""
"or\n"
"  verilog\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:29
#, no-wrap
msgid "  type #(arguments) label (port list) ;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid ""
"**Type** : The type of component.  If there is a \"paramset\" statement, "
"this is the name in the paramset statement.  Otherwise, it could be the name "
"of a \"subckt\", \"model\", or a standard device.  This is called \"master\" "
"in the Spectre manual.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid ""
"**Arguments** : A list of arguments (parameters or values).  All arguments "
"are name - value pairs, of the form \".name(value)\", separated by a comma.  "
"The value may be an expression.  In some cases, a principal value can be "
"given just by value, without its name.  The argument list is surrounded by "
"parentheses, and prefixed by \"#\".\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid ""
"**Port list** : A list of the ports (connections), separated by a comma.  "
"Mapping can be determined by order or by name.  The port list should be "
"surrounded by parentheses.  By order, list them, comma separated.  By name, "
"they use the same syntax as arguments.  .name(value)\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:37
#, no-wrap
msgid ""
"  resistor #(10K)     Rload (out, 0);         // one unnamed argument, ports "
"by order\n"
"  resistor #(.r(10K)) Rload (.p(out), .n(0)); // the same component, "
"arguments by name, ports by name\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:39
#, no-wrap
msgid "  amp #(.rload(100K)) X1 (.out(out), .in(in), .vcc(vc));\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:41
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Verilog mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:44
#, no-wrap
msgid ""
"  // vsource  #(.dc(15)) Vcc (.p(vc), .n(0)); // Spice-style source "
"arguments are not supported.\n"
"  // vsource  #(.ac(1))  Vin (.p(in), .n(0)); // Spice-style source "
"arguments are not supported.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:55
#, no-wrap
msgid ""
"  // assume it is starting in Verilog mode\n"
"  spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .verilog\n"
"  // Now it is back in Verilog mode.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:61
msgid "Two top level blocks are supported: module and paramset."
msgstr ""

#. type: Title =====
#: manual/languages/verilog.txt:62
#, no-wrap
msgid "paramset"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:65
msgid ""
"A \"paramset\" statement sets parameters based on an existing compiled "
"model.  This will be extended to cover all \"masters\".  It becomes a "
"\"master\" that can be instantiated later.  It is equivalent to a spice "
"\".model\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:70
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"paramset\" newname itsmaster \";\"\n"
"    parameters\n"
"  \"endparamset\"\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid "**paramset** : Keyword identifies a paramset statement.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid ""
"**Parameters** : A list of arguments (parameters or values).  All arguments "
"are name - value pairs, of the form \".name = value;\".  (dot name equals "
"value semicolon) The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:79
#, no-wrap
msgid ""
"  paramset gp_npn npn;\\\n"
"    .bf=150;\\\n"
"  endparamset\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:81
msgid ""
"According to the standard, lines are not significant.  In gnucap, for now, "
"all must be on one line or lines extended by ending with \"\\\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:83
msgid ""
"Note that the parameter syntax in paramset is different from the parameter "
"syntax instantiating a device."
msgstr ""

#. type: Title =====
#: manual/languages/verilog.txt:83
#, no-wrap
msgid "module"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:86
msgid ""
"The basic building block is called a \"module\".  Modules are descriptions "
"of individual components.  Gnucap directly supports only the structural "
"subset of Verilog, so a \"module\" here is equivalent to a Spice \"subckt\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:88
msgid "Modules take the form:"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:98
#, no-wrap
msgid ""
"  * A header line\n"
"    * Keyword \"module\".\n"
"    * The name of the new module being defined.\n"
"    * The list of ports, separated by commas, in parentheses\n"
"    * semicolon \";\"\n"
"  * Parameter statements.\n"
"  * The \"netlist\".\n"
"  * A closing line\n"
"    * Keyword \"endmodule\".\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:114
#, no-wrap
msgid ""
"  module amp (out, in, vcc);\n"
"    parameter rload=10k;\n"
"    resistor  #(.r(1M))   Rb1  (base, vcc);        // 1 megohm\n"
"    resistor  #(.r(100K)) Rb2  (base, 0  );\n"
"    resistor  #(100K)     Rc   (col,  vcc);\n"
"    resistor  #(.r(10K))  Re   (.p(emit), .n(0));\n"
"    capacitor #(.c(1m))   Ce   (.p(emit), .n(0));  // 1 millifarad\n"
"    capacitor #(.c(1u))   Cin  (base, in );\n"
"    gp_npn                Q1   (.c(col), .b(base), .e(emit));\n"
"    gp_npn                Q2   (.c(vcc), .b(col), .e(e2));\n"
"    resistor  #(.r(1K))   Re2  (e2,  0  );\n"
"    capacitor #(.c(10u))  Cout (e2,  out);\n"
"    resistor  #(.r(rload))Rload(out, 0 );\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:119
#, no-wrap
msgid ""
"  amp      #(.rload(100K)) X1    (.out(out), .in(in), .vcc(vc));\n"
"  vsource  #(.dc(15))      Vcc   (.p(vc), .n(0));\n"
"  vsource  #(.ac(1))       Vin   (.p(in), .n(0));\n"
"  resistor #(10K)          Rload (out, 0);\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:123
msgid "The Verilog language has no concept of commands."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:125
msgid "In gnucap, commands are executed at top level the same as the native mode."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid ""
"You can switch languages any time with the appropriate command.  In most "
"cases, just name the language you want to switch to.  More generally, you "
"can do \".option lang=xxx\".  The command to switch back must be issued in "
"the language you switched to.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid ""
"You can define a top-level circuit in Verilog syntax.  The Verilog standard "
"provides no way to define a top level circuit.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can include commands, which work the same as the Gnucap native mode.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:135
msgid "The current implementation in gnucap is a very preliminary subset."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid ""
"The devices and commands are whatever gnucap has installed, not necessarily "
"what is defined in any standard.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid ""
"The main circuit can also be in Verilog syntax.  The Verilog standard has no "
"concept of components at top level.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid ""
"To simulate, there must be a component at top level.  Uninstantiated modules "
"do nothing.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Port direction statements like \"inout\" are not supported.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Discipline statements like \"electrical\" are not supported.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid ""
"Some components, and some types of arguments, are not supported in Verilog "
"mode, but you can switch modes at any time.\n"
msgstr ""

#. type: Title ======
#: manual/measure/at.txt:1
#, no-wrap
msgid "\"at\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:6
msgid "Measure a signal at a time or frequency."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:10
#, no-wrap
msgid "  at(probe=\"p(d)\"  at=time  derivative)\n"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:15
#, no-wrap
msgid ""
"|probe       |The name of a probe to measure.  |\n"
"|at\\\\ x      |Measure the value here.  |\n"
"|derivative  |Flag: measure the derivative instead of the value.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:19
msgid ""
"If you specify x to be out of range, it returns the value at the end, with a "
"derivative of zero."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:21 manual/measure/cross.txt:33
msgid ""
"If you didn't store the waveform (see store command), it throws a \"no "
"match\" exception, which prints \"no match\"."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:27
#, no-wrap
msgid ""
"  measure sample = at(probe=\"v(out)\", at=4u)\n"
"Measure the value of \"v(out)\" at 4 microseconds.\n"
"  measure sample = at(probe=\"v(out)\", at=4u, derivative)\n"
"Measure the derivative of \"v(out)\" at 4 microseconds.\n"
msgstr ""

#. type: Title ======
#: manual/measure/cross.txt:1
#, no-wrap
msgid "\"cross\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:6
msgid "Find the time or frequency where a probed value crosses a reference."
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:10
#, no-wrap
msgid ""
"  cross(probe=\"p(d)\" cross=value begin=time end=time rise fall last "
"first)\n"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:21
#, no-wrap
msgid ""
"^arg name       ^default  ^description  ^\n"
"|probe          |required   |The name of a probe to measure.  |\n"
"|cross          |0          |The value it crosses.  |\n"
"|begin\\\\ after  |-infinity  |The window begins at this time or frequency.  "
"|\n"
"|end\\\\ before   |+infinity  |The window ends at this time or frequency.  "
"|\n"
"|first          |true       |Find the first crossing in the window.  "
"(Cancels last.)  |\n"
"|last           |false      |Find the last crossing in the window.  (Cancels "
"first.)  |\n"
"|rise           |true       |Consider only rising crossings.  (Cancels "
"fall.)  |\n"
"|fall           |false      |Consider only falling crossings.  (Cancels "
"rise.)  |\n"
msgstr ""

#. type: Title =====
#: manual/measure/cross.txt:21
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:27
#, no-wrap
msgid ""
"For this function to detect a crossing, it must actually cross.\n"
"  * A steady state at the cross value is not a crossing.\n"
"  * Being at the cross value and leaving is not a crossing.\n"
"  * Merely touching (becoming equal to) the cross value and leaving from the "
"same side is not a crossing.\n"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:31
msgid ""
"If there is no crossing within the specified range, it returns \"Inf\" "
"(infinity)."
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:42
#, no-wrap
msgid ""
"  measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated "
"whenever t1 or t2 changes.\n"
msgstr ""

#. type: Title ======
#: manual/measure/mean.txt:1
#, no-wrap
msgid "\"mean\", \"integrate\", \"rms\" measures"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:8
#, no-wrap
msgid ""
"| mean      |Find the mean or average value of a waveform.  |\n"
"|integrate  |Find the integral of a waveform, the area under the curve.  |\n"
"|rms        |Find the RMS (root mean square) value of a waveform.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:14
#, no-wrap
msgid ""
"  mean(probe=\"p(d)\"  begin=time  end=time)\n"
"  integrate(probe=\"p(d)\"  begin=time  end=time)\n"
"  rms(probe=\"p(d)\"  begin=time  end=time)\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:21
#, no-wrap
msgid ""
"^arg name  ^default  ^description  ^\n"
"|probe     |required    |The name of a probe to measure.  |\n"
"|begin     |- infinity  |Start averaging at this time or frequency.  |\n"
"|end       |+ infinity  |Stop averaging at this time or frequency.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:25
msgid ""
"The \"mean\" measure gives you the true average or mean value.  The mean "
"value of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:27
msgid ""
"The \"integrate\" measure gives you the integral, or area under the curve, "
"signed.  The integral of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:29
msgid "The \"rms\" measure gives you the RMS (root mean square) value."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:38
#, no-wrap
msgid ""
"  measure sample = mean(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the mean value of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
"  measure sample = mean(probe=\"v(out)\" begin=4u)\n"
"Find the mean value of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:44
#, no-wrap
msgid ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the area under the curve of v(out) between 4 microseconds and 6 "
"microseconds.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Find the area under of v(out) for an entire run.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Find the area under of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Title ======
#: manual/measure/minmax.txt:1
#, no-wrap
msgid "\"min\", \"max\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:6
msgid "Find the time or frequency where a probed value hits a maximum or minimum."
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:10
#, no-wrap
msgid "  min(probe=\"p(d)\" begin=time end=time last first arg)\n"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:20
#, no-wrap
msgid ""
"^arg name  ^default    ^description  ^\n"
"|probe     |required   |The name of a probe to measure.  |\n"
"|arg       |false      |Find the time or frequency at which the min or max "
"occurs. (instead of the value)  |\n"
"|begin     |-infinity  |The window begins at this time or frequency.  |\n"
"|end       |+infinity  |The window ends at this time or frequency.  |\n"
"|first     |true       |Find the first min or max in the window.  (Cancels "
"last.)  |\n"
"|last      |false      |Find the last min or max in the window.  (Cancels "
"first.)  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:35
#, no-wrap
msgid ""
"  measure maxvalue = max(probe=\"v(out)\" cross=0 last)\n"
"Find the maximum value of v(out).\n"
"  measure t2 = max(probe=\"v(out)\" last arg)\n"
"Find the last time when a maximum occurred.\n"
"  measure t1 = max(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a maximum occurred before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated "
"whenever t1 or t2 changes.\n"
"  measure t0 = min(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a minimum occurred before t2.\n"
"  param risetime = {t2-t0}\n"
msgstr ""

#. type: Title ======
#: manual/measure/slope.txt:1
#, no-wrap
msgid "\"slope\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:6
msgid "Find the slope or slew rate of a waveform."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:10
#, no-wrap
msgid ""
"  slope(probe=\"p(d)\" initial=value final=value begin=time end=time "
"expression)\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:22
#, no-wrap
msgid ""
"^arg name    ^default  ^description  ^\n"
"|probe       |required   |The name of a probe to measure.  |\n"
"|initial     |0          |The initial value.  |\n"
"|final       |0          |The final value.  |\n"
"|begin       |-infinity  |The window begins at this time or frequency.  |\n"
"|end         |+infinity  |The window ends at this time or frequency.  |\n"
"|first       |true       |Find the first crossing in the window.  (Cancels "
"last.)  |\n"
"|last        |false      |Find the last crossing in the window.  (Cancels "
"first.)  |\n"
"|expression  |false      |The result is an unreduced expression.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:26
msgid ""
"Ordinarily, the result is a number.  If the probe is a voltage probe the "
"units would be volts per second."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:28
msgid ""
"If the \"expression\" keyword is given the result is an unreduced "
"expression."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:34
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as a "
"number.\n"
"  sr= 30.15738K\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:37
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last expression)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as an "
"unreduced expression.\n"
"  sr={( 2.--2.)/( 0.001066319- 933.6812u)}\n"
msgstr ""

#. type: Title ======
#: manual/tech.txt:1
#, no-wrap
msgid "Tech notes"
msgstr ""

#. type: Plain text
#: manual/tech.txt:4
msgid "This section describes technical aspects of Gnucap."
msgstr ""

#. type: Plain text
#: manual/tech.txt:6
msgid ""
"Here, you will find information that will help you understand how it works "
"and to extend it."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[gnucap:manual:tech:plugins]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[gnucap:manual:tech:testing]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid ""
"[[http://gnucap.org/gnucap-man-html/gnucap-man105.html|adding models "
"(old)]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man107.html|old tech notes]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins.txt:1 manual/tech/plugins/coding.txt:1 manual/tech/plugins/files.txt:1 about/plugins/commands.txt:1 about/plugins/languages.txt:1 about/plugins/measurements.txt:1 about/plugins/methods.txt:1 about/plugins/models.txt:1 about/plugins.txt:1
#, no-wrap
msgid "Plugins"
msgstr ""

#. type: Plain text
#: manual/tech/plugins.txt:4
msgid "This section describes the Gnucap plugin system, for programmers."
msgstr ""

#. type: Title =====
#: manual/tech/plugins.txt:5 manual/tech/plugins/coding.txt:3 manual/tech/plugins/files.txt:3 user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Concepts"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Files]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Coding]]\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "Plugin types"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:commands]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:languages|simulation languages]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:behavioral functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:parameter functions and measurements]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/devices.txt:1 manual/tech/plugins/devices/ac_analysis.txt:1 manual/tech/plugins/devices/allocation_and_setup.txt:1 manual/tech/plugins/devices/dc_and_transient_analysis.txt:1 manual/tech/plugins/devices/parameters.txt:1 manual/tech/plugins/devices/ports.txt:1 manual/tech/plugins/devices/probes.txt:1 manual/tech/plugins/devices/query.txt:1
#, no-wrap
msgid "Device plugins"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/devices.txt:3 manual/tech/plugins/commands.txt:3 manual/tech/plugins/parameter_functions_and_measurements.txt:3 manual/tech/plugins/languages.txt:3
#, no-wrap
msgid "Framework"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:6
msgid ""
"Devices, model definitions, commands, and subcircuit definitions are all "
"stored in a linked list, and are defined by classes derived from \"CARD\".  "
"The container is a CARD_LIST."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:8
msgid "Device instances are derived from COMPONENT, which is derived from CARD."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:10
msgid ""
"Model and paramset statements are derived from MODEL_CARD, which is derived "
"from CARD."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:12
msgid "There are special classes of devices that are derived from COMPONENT."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:17
#, no-wrap
msgid ""
"|COMPONENT   |e_compon.h |all devices, including those defined by subcircuit "
"expansion. |\n"
"|BASE_SUBCKT |e_subckt.h |devices that are defined in terms of other "
"devices, as subcircuits, with an internal hierarchy. |\n"
"|ELEMENT     |e_elemnt.h |devices that are not defined in terms of other "
"devices. |\n"
"|STORAGE     |e_storag.h |elements that store some historical information, "
"such as previous states. |\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:19
msgid ""
"Devices do not contain any parsing or printing code, but do contain methods "
"for setting and reading parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:21
msgid ""
"Some devices do contain parsing or printing code in methods with a name that "
"includes \"obsolete_callback\".  That is not documented here, and will "
"eventually be removed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:23
msgid ""
"One static object of every type is created at program startup or when a "
"plugin is loaded.  A pointer to that static object is installed in a "
"dispatcher, and later accessed by name or through that pointer.  This is the "
"only interface."
msgstr ""

#. type: Title =====
#: manual/tech/plugins/devices.txt:23 manual/tech/plugins/commands.txt:16 manual/tech/plugins/devices/ac_analysis.txt:2 manual/tech/plugins/devices/allocation_and_setup.txt:2 manual/tech/plugins/devices/dc_and_transient_analysis.txt:2 manual/tech/plugins/devices/parameters.txt:2 manual/tech/plugins/devices/ports.txt:2 manual/tech/plugins/devices/probes.txt:2 manual/tech/plugins/devices/query.txt:2 manual/tech/plugins/parameter_functions_and_measurements.txt:24 manual/tech/plugins/languages/instance/label.txt:3 manual/tech/plugins/languages/instance/ports.txt:3 manual/tech/plugins/languages/instance/type.txt:3 manual/tech/plugins/languages.txt:34 manual/tech/plugins/languages/type.txt:3
#, no-wrap
msgid "Implementation"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:26
msgid ""
"Device plugins need to include at least one file, defining its base class.  "
"Often, that is the only include file needed."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:query|Simple query functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Ports]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Parameters]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Allocation and setup]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:DC and transient analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:AC analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:probes]]\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:5
#, no-wrap
msgid "Coding"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:8
msgid ""
"This section describes the internals of a plugin, including how it "
"interfaces to the core simulator."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:12
msgid ""
"The interface to plugins is through C++ derived classes, virtual functions, "
"and a dispatcher."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:14
msgid ""
"There are several types of plugins.  The type is determined by the base "
"class that is used.  When a plugin is loaded, a single static object is "
"created, and registered with a dispatcher.  The dispatcher allows a lookup "
"by name."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:23
#, no-wrap
msgid ""
"Plugin types may include:\n"
"  * devices and models\n"
"  * commands\n"
"  * measurements\n"
"  * languages\n"
"  * functions for use in expressions\n"
"  * I/O interface\n"
"  * compatibility\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:25
msgid ""
"It is intended that the entire interface, all models, and almost all "
"functionality will determined by plugins."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:28
msgid ""
"Most plugins will create new subtypes of something.  To explain how it "
"works, I will use parameter functions as an example."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:30
msgid "We have a base class:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:37
#, no-wrap
msgid ""
"<code cpp>\n"
"class FUNCTION {\n"
"public:\n"
"  virtual double eval(double arg)const = 0;\n"
"};\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:39
msgid "This is in a header file \"u_function.h\""
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:41
msgid ""
"This base class is simple.  It has one member function, which a number as "
"input, performs some operation on it, and returns the result."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:44
msgid ""
"Let's make a function to take the absolute value of a numeric argument, as a "
"plugin.  You need to include the header:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:48
msgid "<code cpp> #include \"u_function.h\" </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:50
msgid "Then make a derived class, and create one instance of it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:60
#, no-wrap
msgid ""
"<code cpp>\n"
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return std::abs(arg);\n"
"  }\n"
"} p;\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:62
msgid "Now, register it with the dispatcher so we can find it:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:66
msgid ""
"<code cpp> DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"abs\", "
"&p); </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:68
msgid "If you want to also access it by another name, you can do that too:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:72
msgid ""
"<code cpp> DISPATCHER<FUNCTION>::INSTALL d2(&function_dispatcher, "
"\"absolute_value\", &p); </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:74
msgid ""
"That's all.  The names of the class and instances don't matter because they "
"are local to the plugin.  You find it through the dispatcher, with the name "
"you use to INSTALL it.  In this case, either \"abs\" or \"absolute_value\" "
"will find this plugin."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:76
msgid ""
"If you want to also be able to static-link this plugin, enclose the class "
"and dispatcher installs in an anonymous namespace."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:77
#, no-wrap
msgid "Another Example"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:80
msgid ""
"Here's an example of another one with the same base, all together so you can "
"see it as a unit:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:83
msgid "<code cpp> #include \"u_function.h\""
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:93
#, no-wrap
msgid ""
"class square : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return arg * arg;\n"
"  }\n"
"} p;\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"square\", &p);\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:95
msgid "That's all!"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:96
#, no-wrap
msgid "Compiling it"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:99
msgid ""
"The procedure for compiling it is system dependent, and is usually set up "
"when you install the main simulator."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:101
msgid "In general, you need to make a \"shared object\" or \"dynamic link\" module."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:103
msgid "On Linux, usually this works:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:107
#, no-wrap
msgid ""
"<code>\n"
"g++ -shared -fPIC -o outfile.so infile.cc\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:109
msgid ""
"This take a source file \"infile.cc\", and generates a plugin file "
"\"outfile.so\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:111
msgid "Then you can load it:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:115
#, no-wrap
msgid ""
"<code>\n"
"gnucap> load ./outfile.so\n"
"</code>\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/commands.txt:1
#, no-wrap
msgid "Command plugins"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:6
msgid "Command plugins are called by a command interpreter, in a loop."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:8
msgid ""
"Usually, the main loop reads from the standard input or a file, line by "
"line.  Extension lines are combined when the file is read, so the command "
"code doesn't see them.  The string is converted to a \"command string\", an "
"object of type \"CS\", which is defined in \"ap.h\".  This command string "
"contains the data, an index showing how far it has been read, and some "
"status."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:10
msgid ""
"The command string begins with the name of the command.  This is looked up "
"in the \"command_dispatcher\" using the subscript operator.  The dispatcher "
"returns a pointer to a static object that will interpret the command, or a "
"NULL pointer if there is no match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:12
msgid ""
"Then, the method \"do_it\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current \"scope\" so parameter expressions can be evaluated correctly.  If "
"\"do_it\" returns, it is assumed to have correctly done what was requested.  "
"If something is wrong, it may throw an exception."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:14
msgid ""
"Each command defines a new class, derived from \"CMD\" which is defined in "
"\"c_comand.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:16
msgid ""
"The header file \"globals.h\" is needed because it contains the declaration "
"of the dispatcher."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:19
msgid "Plugins need to #include two files: \"c_comand.h\" and \"globals.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:21
msgid ""
"Only one method is needed for each command: \"''do_it(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:23 manual/tech/plugins/parameter_functions_and_measurements.txt:31
msgid ""
"Declare one static object of this new type, and INSTALL it in the "
"DISPATCHER."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:27
msgid "<code cpp> #include \"gnucap/c_comand.h\" #include \"gnucap/globals.h\""
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:36
#, no-wrap
msgid ""
"class CMD_HELLO : public CMD {\n"
"  void do_it(CS& Cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // code goes here\n"
"  }\n"
"} so;\n"
"DISPATCHER<CMD>::INSTALL d(&command_dispatcher, \"hello\", &so);\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/ac_analysis.txt:3
#, no-wrap
msgid "AC analysis"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:6
msgid ""
"The AC functions in Gnucap correspond to a combination of the AC and PZ "
"functions in Spice.  Actually, they are more like the PZ functions, in the "
"sense that frequency (SIM::jomega) is complex."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:7
#, no-wrap
msgid "void ac_iwant_matrix()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:9 manual/tech/plugins/devices/dc_and_transient_analysis.txt:7
msgid "Notify the sparse matrix of what nodes this device uses."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:11
msgid ""
"AC analysis uses a single matrix \"acx\", which serves as both the nodal "
"admittance matrix and the LU factors.  This is likely to change in the "
"future to two matrices like in transient analysis."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:16
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node "
"pairs that need allocating.\n"
"This line:\n"
"  acx.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and "
"_n[1].  This is usually four places in the matrix.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:21
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * ac_iwant_matrix_passive(), for two-terminal elements like resistors, "
"with a symmetric stamp\n"
"  * ac_iwant_matrix_active(), for controlled sources, with an asymmetric "
"stamp\n"
"  * ac_iwant_matrix_extended(), the general case, allocates all "
"combinations\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:22
#, no-wrap
msgid "void ac_begin()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:24
msgid ""
"This is called at the beginning of every AC analysis.  It should call "
"BASE::ac_begin() before doing anything else.  It sets the value of any AC "
"variables that remain constant through a run."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:25
#, no-wrap
msgid "void do_ac()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:27
msgid ""
"In most cases, the do_ac functions do the real work, or call the ac_eval "
"function to do it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:29
msgid ""
"If necessary, it evaluates the model. Calling this function more than once "
"on an iteration is harmless, except for the waste of time.  Usually, it uses "
"state variables from a previous DC or transient analysis to compute AC "
"values."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:31
msgid "Unlike Spice, Gnucap does not actually load the matrix here."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:32
#, no-wrap
msgid "void ac_load()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:34
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_ac."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:36 manual/tech/plugins/devices/dc_and_transient_analysis.txt:69
msgid ""
"The actual loading is done by one or more of a small group of general "
"functions, depending on whether the element is active, passive, poly, or a "
"source. Only certain patterns can be stamped. Complex devices use a "
"combination of these patterns."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:37 manual/tech/plugins/devices/dc_and_transient_analysis.txt:71
msgid "WARNING to model developers: DO NOT stamp the matrix directly!"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/allocation_and_setup.txt:3
#, no-wrap
msgid "Allocation and setup"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:5
#, no-wrap
msgid "default constructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:7
msgid ""
"A default constructor is required.  It is used to construct the static "
"object that is registered with the dispatcher.  It should do what a default "
"constructor usually does."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:8
#, no-wrap
msgid "copy constructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:10
msgid ""
"A copy constructor is required.  Most objects are created by the copy "
"constructor, as copies of the object registered with the dispatcher.  "
"Usually, it should do a SHALLOW copy.  In particular, a COMMON should be "
"linked and not copied.  A copy constructor must explicitly invoke the copy "
"constructor of the base class."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:11
#, no-wrap
msgid "destructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:13
msgid ""
"Usually a destructor is not required, but it is a good idea to provide one "
"anyway even if it is empty.  It must deallocate any dynamic memory that is "
"used."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:14
#, no-wrap
msgid "CARD* clone()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:16
msgid ""
"Create a new object as a copy of this one, using the copy constructor with "
"the argument \"*this\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:17
#, no-wrap
msgid "void expand()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:19
msgid ""
"The expand function expands subcircuits and models, as needed.  Unlike "
"Spice, it does not really flatten the circuit, but it allocate space for the "
"additional storage, attaches models, and related tasks.  It is called once "
"after reading the circuit, and possibly later when the topology of the "
"circuit is changed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:21
msgid ""
"It is possible that it may be called more than once.  If it is called twice "
"in succession, the result must be the same as if it were called once.  "
"Either it frees then re-expands, or (preferably) it keeps what it can and "
"checks to make sure it is correct."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:23
msgid ""
"Most simple elements do not have expand functions. Most advanced components "
"do."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:25
msgid ""
"It is not expected to compute any values, but it is allowed to call "
"\"precalc\" if needed in case the values affect topology.  It is preferred "
"that the action of expand is the same regardless of parameter values."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:27
msgid ""
"Expanding a subcircuit makes a copy of it, and remaps the nodes. Most "
"components use a shallow copy. That is, if something is attached through a "
"pointer, the value of the pointer is copied, not the attachment. Commons are "
"never copied when the owner components are copied, but commons may be "
"duplicated later if something changes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:28
#, no-wrap
msgid "void expand_first()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:30
msgid ""
"The expand_first function is an expand function that is done first, before "
"any plain expand functions.  Usually it is not needed, but sometimes there "
"are order dependencies, so this provides a way to control the calling "
"order.  As an example, for current controlled sources with a sense element, "
"the controlled source can send a message to the controlling element that can "
"result in a different expansion."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:31
#, no-wrap
msgid "void expand_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:33
msgid ""
"The expand_last function is an expand function that is done last, after any "
"plain expand functions.  Usually it is not needed, but sometimes there are "
"order dependencies, so this provides a way to control the calling order.  As "
"an example, for current controlled sources with a sense element, the "
"controlled source must be expanded after the sense element."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:34
#, no-wrap
msgid "void precalc_first(), void precalc_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:36
msgid ""
"The precalc functions attempt to pre-calculate anything that will remain "
"constant during a simulation run. This includes size dependent transistor "
"parameters and the stamp values for linear elements.  It also evaluates "
"parameter expressions."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:38
msgid ""
"It is possible that it may be called more than once.  It must not change its "
"input data in any way.  If it is called twice in succession, the result must "
"be the same as if it were called once."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:40
msgid ""
"Some values must be calculated before determining structure.  These go in "
"precalc_first."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:42
msgid ""
"Some values must be calculated after structure is determined.  These go in "
"precalc_last."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:46
msgid ""
"Some values don't matter whether they are calculated before or after "
"structure is determined.  It strictly doesn't matter whether they are in "
"precalc_first or precalc_last.  By convention, evaluation of parameter "
"expressions goes in precalc_first, calculation of other values that are done "
"only once goes in precalc_last."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:47
#, no-wrap
msgid "void map_nodes()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:48
msgid ""
"Map the user node names to internal node numbers.  Almost always, the "
"inherited function does what is needed, which is to loop over all nodes "
"(both ports and internal) and call their \"map\" function, and recursively "
"map subcircuits."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:3
#, no-wrap
msgid "DC and transient analysis"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:5
#, no-wrap
msgid "void tr_iwant_matrix()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:9
msgid ""
"Two matrices are used, \"aa\" and \"lu\".  The matrix \"aa\" is the nodal "
"admittance matrix.  The matrix \"lu\" is the LU factors of the admittance "
"matrix.  Both need to be notified, and have identical patterns."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:15
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node "
"pairs that need allocating.\n"
"This line:\n"
"  aa.iwant(_n[0].m_(),_n[1].m_());\n"
"  lu.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and "
"_n[1].  This is usually four places in the matrix.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:20
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * tr_iwant_matrix_passive(), for two-terminal elements like resistors, "
"with a symmetric stamp\n"
"  * tr_iwant_matrix_active(), for controlled sources, with an asymmetric "
"stamp\n"
"  * tr_iwant_matrix_extended(), the general case, allocates all "
"combinations\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:21
#, no-wrap
msgid "void tr_begin()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:23
msgid ""
"This is called at the beginning of every DC or OP analysis, and transient "
"analysis unless it is continuing a previous run.  It initializes all state "
"variables, sets up the initial guess for nonlinear analysis, and fills in "
"reasonable values for historical states.  It should call BASE::tr_begin() "
"before doing anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:24
#, no-wrap
msgid "void tr_restore()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:26
msgid ""
"This is called when continuing a transient analysis.  It must restore state "
"variables and history to a consistent state if the previous analysis was "
"stopped uncleanly.  It should call BASE::tr_restore() before doing anything "
"else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:27
#, no-wrap
msgid "void dc_advance()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:29
msgid ""
"This is called first when moving to a new DC sweep point.  It saves old "
"values of state variables as needed, and advances local time.  It also sets "
"up the initial values for iteration if needed.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::dc_advance() before doing "
"anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:30
#, no-wrap
msgid "void tr_advance()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:32
msgid ""
"This is called first when moving to a new time step.  It saves old values of "
"state variables as needed, and advances local time.  It also sets up the "
"initial values for iteration at the new time.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::tr_advance() before doing "
"anything else."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:34
msgid ""
"For delay elements like logic devices and transmission lines, this function "
"does the real work. It takes previous results and applies them, generating "
"data that will be later loaded into the matrix."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:35
#, no-wrap
msgid "void tr_regress()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:37
msgid ""
"This is called instead of tr_advance() when moving backwards in time.  The "
"usual code throws away the most recent state variables, restores the values "
"from the previous step, and backs up all of the stored state data.  It "
"should call BASE::tr_regress() before doing anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:38
#, no-wrap
msgid "bool tr_needs_eval()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:40
msgid ""
"Return a judgment of whether or not this device is in need of evaluation at "
"this time and this iteration.  In the simplest case, you can defer writing "
"this function by just returning \"true\", but that leads to needless full "
"evaluations.  The main purpose of this function is to wake up a latent "
"device.  For a general example of this function, look in spice_wrapper.cc."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:41
#, no-wrap
msgid "void tr_queue_eval()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:43
msgid ""
"Conditionally queue this component for evaluation.  In most cases, you can "
"omit this function and use the inherited version which does "
"''{if(tr_needs_eval()){q_eval();}}''.  The function \"''q_eval()''\" "
"unconditionally queues this component for evaluation."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:44
#, no-wrap
msgid "bool do_tr()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:46
msgid ""
"In most cases, the do_tr functions do the real work, or call the tr_eval "
"function to do it. It evaluates the model, checks convergence, and queues it "
"for loading. Calling this function more than once on an iteration is "
"harmless, except for the waste of time."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:48
msgid ""
"Usually, it calculates the function and derivative. It may also do "
"integration, interpolation, iteration, or whatever is required. The result "
"is a set of values ready to stamp into the admittance matrix and current "
"vector."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:50
msgid "There are several distinct steps within this function."
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid ""
"The first step is to gather the information necessary to make the "
"computations. Usually, this is the node voltages, but it could be currents, "
"temperature, charge, or something else.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid ""
"The next step is to evaluate any attached function. This could be done in "
"line, or by a call to tr_eval. The result of this evaluation is stored in "
"_y0 (of type FPOLY1. The tr_eval function reads the value of x from _y0, and "
"fills in the f0 with the result of function evaluation, and f1 with its "
"derivative. The tr_eval function must also check for convergence by "
"comparing the new _y0 with the old value, _y1. This attached function is "
"generic in the sense that it is the same for all device types. This is the y "
"= f(x) that is referred to in the behavioral modeling documentation.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "These values are stored for convergence checking and probing.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid ""
"After that, it must be converted to a current and admittance so it can be "
"used in the system of nodal equations. This step is dependent on what type "
"of device it is. For a conductance element, tr_eval directly returns the "
"correct information, so nothing needs to be done here. For a capacitor, this "
"step does numerical integration. Capacitors store this in _i0. Most other "
"elements do not store this result directly.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid ""
"Then, it must be converted into CPOLY form to meet the requirements of the "
"system of equations.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid ""
"The device is queued for loading. Unlike Spice, Gnucap does not actually "
"load the matrix here.\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:58
#, no-wrap
msgid "bool do_tr_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:60
msgid ""
"This is the same as do_tr, except that it is called last.  It is used when "
"there is a dependency on a do_tr of another device when it the other device "
"must be evaluated first, such as current controlled sources.  It is only "
"called if it is queued.  Most devices don't have a do_tr_last.  For devices "
"that do, the body of do_tr should be \"''{SIM::late_evalq.push_back(this); "
"return true;}''\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:61
#, no-wrap
msgid "void tr_load()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:63
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_tr."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:65
msgid ""
"Actually, it does much more. In most cases, it actually loads a correction "
"factor, assuming the old values are already loaded. To do this, it keeps "
"track of what values are actually loaded. Whether it loads a correction or "
"the actual value is determined first by the option incmode, then by status "
"information about the solution. If it is suspected that correcting would "
"cause too much roundoff error, it loads the actual value. The decision of "
"whether to do a full load or an update is global."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:67
msgid ""
"In addition, it may apply damping in hopes of improving convergence. This "
"means to load a value somewhere between the new and old values, in effect "
"taking a partial step. The decision to damp is semi-global. Groups of "
"elements are adjusted together."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:72
#, no-wrap
msgid "void tr_unload()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:74
msgid ""
"This function removes the component from the matrix, possibly by subtracting "
"off what was loaded. Usually, it sets the current values to 0 and calls "
"tr_load."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:75
#, no-wrap
msgid "TIME_PAIR tr_review()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:77
msgid ""
"The tr_review function checks errors and signal conditions after a time step "
"has converged. It returns two values of an approximate time that the element "
"wants for the next step, and stores that information in the instance "
"variable _time_by."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:79
msgid ""
"\"''_time_by._error_estimate''\" is an estimate of the desired next time "
"based on analog error estimate.  It is used to control truncation error, "
"curve fitting error, and overall smoothness of the result.  The actual next "
"time will probably be sooner than this number suggests, and is considered to "
"be more accurate.  Usually you would set it indirectly by "
"''_time_by.min_error_estimate(suggested_next_time);''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:81
msgid ""
"\"''_time_by._event''\" is an estimate of the desired next time based on "
"ambiguous events.  It is used to control accuracy of cross events and "
"situations where clusters of time steps are needed for accuracy.  The actual "
"time will try to match this as close as practical.  Shorter time steps do "
"not improve accuracy.  Usually you would set it indirectly by "
"''_time_by.min_event(suggested_next_time);''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:83
msgid ""
"It is usually appropriate to call BASE::tr_review before doing anything "
"else.  If not, you should call ''_time_by.reset()'' first."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:85
msgid ""
"If there is a tr_accept function, and you want it to be called, you must "
"queue it here by calling q_accept()."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:86
#, no-wrap
msgid "void tr_accept()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:89
msgid ""
"This function is called after the solution at a time step has been "
"accepted. For most devices, it does nothing. For devices having storage and "
"delayed propagation, it evaluates what signal will be propagated. For a "
"transmission line, it calculates and sends on the reflections."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:91
msgid ""
"It is called only when queued, so either tr_review or do_tr must call "
"q_accept() to queue it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:93
msgid ""
"Only tr_accept is allowed to add events to the event queue "
"(SIM::new_event())."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:6
msgid ""
"These methods provide all access to parameters.  Parameters are seen as "
"strings in this context, because it is more flexible.  Usually parameters "
"are accessed by index, as if in an array.  It is up to the implementer to "
"decide what type of storage to actually use."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:8
msgid ""
"Indexing starts at 0 in CARD, and counts up from there.  The indexing of "
"parameters should be consecutive.  For example, if the base class has "
"parameters numbered up to 16, you should start at 17.  The appropriate "
"starting number can be obtained by calling BASE::param_count().  The "
"preferred internal index method is to start at 0, and index from the value "
"BASE::param_count-1-i where i is the external index.  If the result of "
"BASE::param_count-1-i is out of range, call the matching BASE method, "
"passing i through.  In this section BASE:: refers to the most immediate base "
"class.  All of these methods are required, and will march through the class "
"hierarchy until the request is satisfied."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:10
msgid ""
"Some devices use another set of methods, \"obsolete_callback\".  This is not "
"documented here and not recommended for any new work.  Support for "
"\"obsolete_callback\" will be dropped at some time in the future."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:11
#, no-wrap
msgid "int param_count()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:13
msgid "Return (local_param_count + BASE::param_count())."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:14
#, no-wrap
msgid "bool param_is_printable(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:16
msgid ""
"Return true if it is appropriate to print the value of this parameter in a "
"netlist.  Some parameters should be printed regardless of their status, in "
"which case this function can just return true for that index.  You can "
"return false to always suppress the printing of a parameter and its value.  "
"Sometimes you might want to do some kind of test to determine whether or not "
"to print the parameter.  Usually, the function must determine a result for "
"its own, and return BASE::param_is_printable for others.  If you want to "
"suppress the printing of all base class parameters, return false for index "
"out of range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:17
#, no-wrap
msgid "std::string param_name(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:19
msgid ""
"Return the preferred name of a parameter given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:20
#, no-wrap
msgid "std::string param_name(int i,int j)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:22
msgid ""
"Return an alternative name of a parameter given an index i, and an alternate "
"index j.  When j == 0, it returns the preferred name.  When j > 0, it "
"returns either an alternative name or an empty string."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:23
#, no-wrap
msgid "std::string param_value(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:25
msgid ""
"Return the value of a parameter as a string given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:26
#, no-wrap
msgid "void set_param_by_name(std::string name, std::string value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:28
msgid ""
"Set the value of a parameter, by name.  Providing this method is optional.  "
"If you don't provide it, the base class provides a version that looks up the "
"index corresponding to the name and calls set_param_by_index.  It should "
"throw \"Exception_No_Match\" if there is no parameter corresponding to the "
"name."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:29
#, no-wrap
msgid "void set_param_by_index(int i, std::string&, int offset)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:31
msgid ""
"Set the value of a parameter, by index.  Providing this method is required "
"if set_param_by_name is not provided, or if you want to be able to accept a "
"list of unnamed parameters in an alternative syntax.  The usual procedure "
"for scanning down the base classes applies.  If you don't want to scan the "
"base classes, throw \"Exception_Too_Many\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:32
#, no-wrap
msgid "std::string value_name()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:33
msgid ""
"Return the name of the parameter to set when just a numeric value is given, "
"as in most Spice primitives.  If you don't want to accept any unnamed "
"parameters, return an empty string."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/ports.txt:3
#, no-wrap
msgid "Ports"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:5
#, no-wrap
msgid "void set_port_by_name(std::string& name, std::string& value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:7
msgid ""
"Make a connection between a port and the rest of the circuit, by name as in "
"Verilog.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:8
#, no-wrap
msgid "void set_port_by_index(int index, std::string& value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:10
msgid ""
"Make a connection between a port and the rest of the circuit, by position as "
"in Spice.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:11
#, no-wrap
msgid "std::string port_name(int i)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:13
msgid ""
"Return the name of a port given its index.  This is required, because all "
"devices have unique port names."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/ports.txt:14
#, no-wrap
msgid "Current ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:17
msgid ""
"Most devices do not have current ports, so these methods are usually not "
"needed."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:18
#, no-wrap
msgid "void set_current_port_by_index(int, const std::string&)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:20
msgid ""
"Make a connection between a current port and the rest of the circuit, by "
"position as in Spice.  This is required if the device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:21
#, no-wrap
msgid "const std::string current_port_value(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:23
msgid ""
"Return the name of the element that a current port is connected to.  This is "
"required if the device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:24
#, no-wrap
msgid "std::string current_port_name(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:25
msgid ""
"Return the name of a current port given its index.  This is required if the "
"device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:5
#, no-wrap
msgid "double tr_probe_num(const std::string&)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:8
msgid ""
"This function returns a probe value for DC, OP, and transient analysis, "
"selected by a string argument.  Any state variable or parameter may be "
"selected."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:10
msgid ""
"Usually the code consists of a string of if - elseif statements.  If none "
"match, in most cases it should call BASE::tr_probe_num and return its "
"result."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:23
#, no-wrap
msgid ""
"<code cpp>\n"
"double DEV_CAPACITANCE::tr_probe_num(const std::string& x)const\n"
"{\n"
"  if (Umatch(x, \"q{cap} |ch{arge} \")) {\n"
"    return _y[0].f0;\n"
"  }else if (Umatch(x, \"c{apacitance} \")) {\n"
"    return _y[0].f1;\n"
"  }else{\n"
"    return STORAGE::tr_probe_num(x);\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:24
#, no-wrap
msgid "XPROBE ac_probe_ext(const std::string&)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:28
msgid ""
"This function returns a probe value for AC analysis, selected by a string "
"argument.  Any state variable or parameter may be selected."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:30
msgid "It returns an XPROBE object:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:41
#, no-wrap
msgid ""
"<code cpp>\n"
"enum mod_t {mtNONE, mtMAG, mtPHASE, mtREAL, mtIMAG};\n"
"class XPROBE{\n"
"private:\n"
"  COMPLEX _value;\n"
"  mod_t   _modifier; // default\n"
"  double  _dbscale;  // 20 for voltage, 10 for power, etc.\n"
"// .....\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:43
msgid ""
"Usually, the returned value is made by a constructor with one argument, "
"using defaults for _modifier and _dbscale.  The value is a COMPLEX number."
msgstr ""

#. type: Title =====
#: manual/tech/plugins/devices/query.txt:3 manual/tech/plugins/languages/simple_query_functions.txt:3
#, no-wrap
msgid "Simple query functions"
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:5
#, no-wrap
msgid "Used by parser"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:7
#, no-wrap
msgid "int max_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:9
msgid ""
"Return the maximum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it returns a "
"constant."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:10
#, no-wrap
msgid "int min_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:12
msgid ""
"Return the minimum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it is the same as "
"max_nodes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:13
#, no-wrap
msgid "int_num_current_ports()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:15
msgid ""
"Return the required number of current ports.  There are ports in a netlist "
"that are really branch elements used as current probes.  If omitted, the "
"inherited method returns zero.  If this function returns a non-zero value, "
"the device may not work with all netlist formats."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:16
#, no-wrap
msgid "int tail_size()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:18
msgid ""
"Return the minimum number of non-ports following the ports.  It is a hack to "
"help the Spice format parser distinguish between a port name and the device "
"type.  If omitted, the inherited method returns 0 or 1, but usually 1 is the "
"correct value."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:19
#, no-wrap
msgid "Used by allocation functions and checking"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:21
#, no-wrap
msgid "int net_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:23
msgid ""
"Return the actual number of ports.  If max_nodes == min_nodes, the only "
"valid value is the same, so it is permissible to return that number.  "
"Otherwise, it is determined when the netlist is read.  If the syntax is "
"correct it will always be between min_nodes and max_nodes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:24
#, no-wrap
msgid "int ext_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:26
msgid ""
"Return the number of external nodes.  If omitted, the inherited method "
"returns max_nodes()."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:27
#, no-wrap
msgid "int int_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:29
msgid ""
"Return the number of internal nodes.  If omitted, the inherited method "
"return 0."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:30
#, no-wrap
msgid "int_matrix_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:32
msgid ""
"Return the number of nodes that stamp into the matrix.  The value is usually "
"int_nodes() + ext_nodes()."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:33
#, no-wrap
msgid "Special simple element property flags (usually not needed)"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:35
#, no-wrap
msgid "bool has_inode()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:37
msgid ""
"Return true if the device has a hidden node that can be used as a current "
"probe.  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:38
#, no-wrap
msgid "bool has_iv_probe()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:40
msgid ""
"Return true if the device can be used as a current probe for current "
"controlled spice devices.  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:41
#, no-wrap
msgid "bool is_device()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:43
msgid ""
"Return true if the device is a device.  In this context, the inherited "
"method returns true, so it can always be omitted.  It is listed here because "
"a netlist can also include non-device objects, and this function identifies "
"the difference."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:44
#, no-wrap
msgid "bool is_source()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:46
msgid ""
"Return true if the device is a fixed source.  If omitted, the inherited "
"method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:47
#, no-wrap
msgid "bool f_is_value()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:49
msgid ""
"Return true if the result of evaluating a behavioral function is the "
"\"value\".  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:50
#, no-wrap
msgid "bool_makes_own_scope()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:51
msgid ""
"Return true if the device makes its own scope for searching.  This is used "
"for the header lines of subcircuits.  For normal devices, it can be omitted, "
"which will return false."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:5
#, no-wrap
msgid "Files"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:8
msgid ""
"Gnucap plugins are standard \"shared object\" or \"dynamic link\" files, "
"native to the environment."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:10
msgid "Plugins must be compiled for the particular system, like shared libraries."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:11
#, no-wrap
msgid "System Requirements"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:14
msgid ""
"The host system must be capable of dynamic linking, and support the "
"POSIX.1-2001 system calls for loading and unloading dynamic libraries on "
"demand.  In particular, the calls \"dlopen\", \"dlclose\", and \"dlerror\" "
"are used.  The \"dlsym\" call is not used."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:16
msgid ""
"If the system does not support these calls directly, but does have the "
"functionality in a different form, a set of wrapper functions is needed."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:17
#, no-wrap
msgid "Interface"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:20
msgid ""
"Plugins are loaded by the \"load\" (or \"attach\") command, and unloaded by "
"the \"unload\" (or \"detach\") command.  These commands are defined in the "
"source file \"c_attach.cc\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:22
msgid ""
"As of when this is being written, the files must be compiled before "
"loading.  In the future, there will be changes to enable the ability to "
"compile plugins on demand."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:24
msgid ""
"As per the specification of \"dlopen\", when a plugin is loaded, "
"constructors for all of its static objects are run.  Normally, the linkage "
"is through derived classes and a dispatcher, but other interfaces are "
"possible by callbacks in the constructor.  Also, all callbacks are resolved "
"at this time.  A plugin will fail to load if callbacks cannot be resolved."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:26
msgid ""
"If it is desired to load a plugin in spite of unresolved callbacks, you can "
"load with the \"lazy\" option.  If you do this, the plugin is likely to work "
"partially but fail when it attempts to call the missing function.  This is "
"not recommended for released code and likely to not work with non-POSIX "
"systems.  It is provided as a debugging aid."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:28
msgid ""
"Likewise, when a plugin is unloaded, destructors for the static objects are "
"run."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:30
msgid ""
"The \"dlsym\" function is not needed, because the interface is through "
"derived classes."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:31
#, no-wrap
msgid "Microsoft-Windows Interface"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:34
msgid ""
"Microsoft-Windows does not support the needed POSIX system calls directly, "
"so a set of wrapper functions is used.  The MS functions are "
"\"LoadLibrary\", \"FreeLibrary\", and \"GetLastError\".  These wrapper "
"functions are defined in \"md.h\"."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:35
#, no-wrap
msgid "Namespaces"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:38
msgid ""
"Normally, each plugin has its own namespace, so its symbols are not visible "
"to the main program or to other plugins."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:40
msgid ""
"If it is desired to make the symbols visible outside, you can load with the "
"\"public\" option.  This is not recommended for released code and likely to "
"not work with non-POSIX systems.  It is provided as a debugging aid."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:41
#, no-wrap
msgid "Static linking"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:44
msgid ""
"In some cases it is desirable to static link code modules that are designed "
"as plugins.  Usually, all that is needed is to add the file to the list."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:45
msgid ""
"There may be a problem with name clashes, because static linked modules "
"share the main program's namespace.  If a plugin has only one source file, "
"you can enclose all of the code in an anonymous namespace to avoid name "
"clashes."
msgstr ""

#. type: Title ======
#: manual/tech/plugins/parameter_functions_and_measurements.txt:1
#, no-wrap
msgid "Parameter function and measurement plugins"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:6
msgid ""
"The \"measure\" command and \"parameter\" commands work differently because "
"of parsing problems.  This is will be fixed someday."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:8
msgid ""
"One important difference is that the \"measure\" command fully evaluates the "
"function call, and any expressions associated with it, at the time of the "
"command, but the \"parameter\" command defers evaluation to when the "
"parameter is actually used."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:12
msgid ""
"The \"measure\" command calls a single function for evaluation, and assigns "
"its result to a parameter.  It also prints the result.  The parameter may be "
"used in parameter expressions and as an argument to another measure command."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:14
msgid ""
"The command takes the form of an assignment statement.  The target name is "
"stashed.  The name of the function is looked up in the "
"\"function_dispatcher\", using the subscript operator. The dispatcher "
"returns a pointer to a static object, or a NULL pointer if there is no "
"match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:16
msgid ""
"Then, the method \"eval\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current scope so parameter expressions can be evaluated correctly. If "
"\"eval\" returns, it is assumed to have correctly done what was "
"requested. If something is wrong, it may throw an exception.  \"eval\" "
"returns a //string// containing the result, which is a string representation "
"of the numeric value."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:20
msgid "The \"parameter\" command simply reads and stores the arguments as a string."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:22
msgid ""
"Later, when the parameter is used, the string is evaluated, resulting in a "
"reduced version of the expression, also as a string.  Portions that cannot "
"be evaluated are preserved as expressions."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:24
msgid ""
"As with the \"measure\", the entire argument list is passed as a \"CS\".  "
"The scope will be the scope in which the parameter is used (dynamic "
"scoping)."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:27
msgid ""
"Usually, plugins need to include two files: \"u_parameter.h\" and "
"\"u_function.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:29
msgid ""
"Only one method is needed for each command: \"''eval(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:33
msgid ""
"Parameter functions use the \"function_dispatcher\".  Measure functions use "
"the \"measure_dispatcher\"."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:34
#, no-wrap
msgid "Parameter functions"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:37
msgid ""
"The argument list is usually a list of expressions separated by commas, "
"similar to many programming languages."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:39
msgid "A simple function with one argument:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:42
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"\n"
"#include \"u_function.h\"\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:55
#, no-wrap
msgid ""
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x;\n"
"    Cmd >> x;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::abs(x));\n"
"  }\n"
"} p_abs;\n"
"DISPATCHER<FUNCTION>::INSTALL d_abs(&function_dispatcher, \"abs\", "
"&p_abs);\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:57
msgid "A function with two arguments:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid ""
"<code>\n"
"class pow : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x, y;\n"
"    Cmd >> x >> y;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    y.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::pow(x,y));\n"
"  }\n"
"} p_pow;\n"
"DISPATCHER<FUNCTION>::INSTALL d_pow(&function_dispatcher, \"pow\", "
"&p_pow);\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid "Measurement functions"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:74
msgid ""
"Measurement functions appear to be the same as parameter functions, but are "
"not interchangeable."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:76
msgid "Usually, the following additional includes are needed:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:83
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"  // parameter expressions\n"
"#include \"s__.h\"          // find the wave object\n"
"#include \"m_wave.h\"       // the \"wave\" object, containing the data to "
"measure\n"
"#include \"u_function.h\"   // the base class\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:85
msgid ""
"Parameters are usually given as optional name=value pairs, with expressions, "
"in any order."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:96
#, no-wrap
msgid ""
"<code>\n"
"class MEASURE : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    std::string probe_name;\n"
"    PARAMETER<double> before(BIGBIG);\n"
"    PARAMETER<double> after(-BIGBIG);\n"
"    bool last = false;\n"
"    bool arg = false;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:105
#, no-wrap
msgid ""
"    unsigned here = Cmd.cursor();\n"
"    Cmd >> probe_name;\n"
"    WAVE* w = SIM::find_wave(probe_name);  // this is the wave to scan for "
"the measurement\n"
"                                           // specified first, without "
"saying \"probe=\"\n"
"    if (!w) { // didn't find it\n"
"      Cmd.reset(here);\n"
"    }else{\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:119
#, no-wrap
msgid ""
"    here = Cmd.cursor();                   // scan for parameters\n"
"    do {\n"
"      ONE_OF\n"
"\t|| Get(Cmd, \"probe\",  &probe_name)\n"
"\t|| Get(Cmd, \"before\", &before)\n"
"\t|| Get(Cmd, \"after\",  &after)\n"
"\t|| Get(Cmd, \"end\",    &before)\n"
"\t|| Get(Cmd, \"begin\",  &after)\n"
"\t|| Set(Cmd, \"arg\",    &arg, true)\n"
"\t|| Set(Cmd, \"last\",   &last, true)\n"
"\t|| Set(Cmd, \"first\",  &last, false)\n"
"\t;\n"
"    }while (Cmd.more() && !Cmd.stuck(&here));\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:124
#, no-wrap
msgid ""
"    if (!w) {                               // \"probe=\" .. the wave to "
"scan\n"
"      w = SIM::find_wave(probe_name);\n"
"    }else{\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:128
#, no-wrap
msgid ""
"    if (w) {\n"
"      before.e_val(BIGBIG, Scope);          // evaluate parameters\n"
"      after.e_val(-BIGBIG, Scope);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:149
#, no-wrap
msgid ""
"      // find the min.\n"
"      double time = (last) ? -BIGBIG : BIGBIG;  // what to return if there's "
"no min.\n"
"      double m = BIGBIG;\n"
"      WAVE::const_iterator begin = lower_bound(w->begin(), w->end(), "
"DPAIR(after, -BIGBIG));\n"
"      WAVE::const_iterator end   = upper_bound(w->begin(), w->end(), "
"DPAIR(before, BIGBIG));\n"
"      for (WAVE::const_iterator i = begin; i < end; ++i) {\n"
"\tdouble val = i->second;\n"
"\tif (val < m || (last && (val == m))) {\n"
"\t  time = i->first;\n"
"\t  m = val;\n"
"\t}else{\n"
"\t}\n"
"      }\n"
"      return to_string((arg) ? (time) : (m));\n"
"    }else{\n"
"      throw Exception_No_Match(probe_name);\n"
"    }\n"
"  }\n"
"} p2;\n"
"DISPATCHER<FUNCTION>::INSTALL d2(&measure_dispatcher, \"min\", &p2);\n"
"</code>\n"
msgstr ""

#. type: Title ======
#: about.txt:1
#, no-wrap
msgid "About Gnucap"
msgstr ""

#. type: Plain text
#: about.txt:4
msgid "Gnucap is a modern \"post-spice\" analog and mixed signal circuit simulator."
msgstr ""

#. type: Plain text
#: about.txt:6
msgid ""
"Gnucap is designed so it can eventually replace Spice.  Today, it can "
"replace Spice in some applications.  There are some significant technical "
"advantages.  It is a work in progress.  New features are added regularly as "
"time and demand permits."
msgstr ""

#. type: Plain text
#: about.txt:23
#, no-wrap
msgid ""
"  * [[gnucap:about:plugins|Plugins, for extreme flexibility.]]\n"
"    * [[gnucap:about:plugins:models|Models.]]\n"
"    * [[gnucap:about:plugins:commands|Commands.]]\n"
"    * [[gnucap:about:plugins:methods|Simulation methods.]]\n"
"    * [[gnucap:about:plugins:functions|Behavioral modeling functions.]]\n"
"    * [[gnucap:about:plugins:measurements|Measurements]]\n"
"    * [[gnucap:about:plugins:interface|Interface to other software.]]\n"
"    * [[gnucap:about:plugins:languages|Simulation languages and "
"compatibility]]\n"
"    * [[gnucap:about:plugins:other:|Almost anything.]]\n"
"  * [[gnucap:about:algorithms|Modern algorithms]]\n"
"    * true mixed-mode engine, analog events, the essence of modern "
"\"fast-spice\" simulators.\n"
"    * Improved speed with full Spice accuracy.\n"
"    * Improved accuracy through rigorous error control.\n"
"    * User control of speed vs. accuracy tradeoffs.\n"
"  * Fully interactive operation with scripting.\n"
"  * Parameters, measures.\n"
"  * Multiple simulation languages, including Spice, Verilog, and Spectre.  "
"More are coming!\n"
msgstr ""

#. type: Title ======
#: about/algorithms.txt:1
#, no-wrap
msgid "Algorithms"
msgstr ""

#. type: Plain text
#: about/algorithms.txt:4
msgid "Gnucap is the original \"Analog Fast-Spice\"."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:6
msgid ""
"Gnucap's DC, AC, and Transient analysis are based on the traditional nodal "
"analysis, similar to Spice.  As a starting point, this provides the same "
"accuracy and generality we associate with Spice-type simulation.  From this "
"well-known starting point, Gnucap has enhanced the algorithms, for improved "
"speed, accuracy, and robustness, with user defined options to select what "
"tradeoffs to apply when."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:8
msgid ""
"Gnucap uses a vector sparse matrix solver that supports low rank updates and "
"partial solutions.  For large circuits this can be significantly faster than "
"a traditional sparse matrix solver.  The vector approach provides fast "
"access, as fast as a regular dense matrix would be, while preserving cache "
"localism that you would not ordinarily get with a general sparse solver.  "
"For a full, dense matrix, it is as efficient as a full matrix solver.  For a "
"tridiagonal matrix, it is as efficient as a dedicated tridiagonal solver."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:10
msgid ""
"For a large circuit, only the parts of the circuit where there is activity "
"are solved.  It is now possible to avoid redundant processing linear and "
"latent parts of a circuit.  This improves speed significantly with no loss "
"of accuracy.  This is part of the basis of most of today's \"fast-spice\" "
"simulators, and was made available first here."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:12
msgid ""
"Transient time step control checks more than just truncation error and "
"iteration count.  There are additional checks for smoothness of most "
"voltages and state variables, even where there are no storage elements.  "
"There is also support for movable events, such as \"cross\" events, so "
"switching times, zero crossings, and waveform peaks are properly controlled."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:14
msgid ""
"This is managed by a set of queues, so time is not wasted processing devices "
"when there is nothing happening."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:16
msgid ""
"All of this is user controllable.  By setting some options, on one extreme "
"you can turn off the optimizations, reverting to a more robust (and slower) "
"derivative of the Spice algorithms, or you can choose to go for speed."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:18
msgid ""
"The core provides a library of functions that can be used to build new types "
"of analysis.  The matrix solver is a template class, so it can solve for all "
"data types, including a symbolic type for a future symbolic analysis."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:20
msgid "Finally, it is all plugin based, inviting extensions and experiments."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:5 about/plugins/languages.txt:5 about/plugins/measurements.txt:5 about/plugins/methods.txt:5 about/plugins/models.txt:4
#, no-wrap
msgid "The past"
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:8
msgid ""
"Traditional simulators have most of the commands built-in, so you are stuck "
"with the commands you have. Most of them do have some kind of alias "
"mechanism, but that is all.  If you want to add real functionality, you "
"can't."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:9 about/plugins/languages.txt:13 about/plugins/measurements.txt:9 about/plugins/methods.txt:11 about/plugins/models.txt:10
#, no-wrap
msgid "The present"
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:12
msgid ""
"Unlike Spice, commands are not compiled into the simulator. Commands, all "
"commands, are plugins that can be changed by a user at run time."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:14
msgid ""
"It is possible to static-link commands if desired, but it is not "
"recommended."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:16
msgid ""
"The distribution tarball includes most of the basic Spice commands, and "
"some non-basic ones."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:17 about/plugins/languages.txt:17 about/plugins/measurements.txt:13 about/plugins/methods.txt:15 about/plugins/models.txt:28
#, no-wrap
msgid "The future"
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:20
msgid ""
"There could be wrapper plugins, so you can use other languages like Python "
"or TCL to write commands."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:22
msgid "More commands will be added to the standard set."
msgstr ""

#. type: Title =====
#: about/plugins/languages.txt:3
#, no-wrap
msgid "Simulation languages and compatibility"
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:8
msgid ""
"The most popular simulator, and most popular circuit simulation language is "
"\"SPICE\"."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:10
msgid ""
"The SPICE format was a breakthrough when it was invented, in the 1970's, but "
"we have outgrown it."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:12
msgid ""
"The SPICE format has been extended, in many ways, by both commercial and "
"free simulators.  Each one is a little different. Until recently, Gnucap "
"used only an extended version of the SPICE format.  There is an ongoing "
"problem with tradeoffs between compatibility and growth.  It seems that they "
"are all different, and every extension breaks something."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:16
msgid ""
"Gnucap now uses \"language plugins\" to determine the source language.  Of "
"course, the traditional SPICE format is supported.  There are also plugins "
"to support netlists in Spectre and Verilog format."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:20
msgid ""
"Since the language is a plugin, there can be several to mimic the variants.  "
"It is no longer necessary to trade between compatibility and growth.  There "
"could easily be a dozen \"SPICE\" plugins, each compatible with a different "
"version."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:22
msgid ""
"New languages can be added too, including direct support for the internal "
"format of schematic capture and layout programs."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:24
msgid ""
"The plugins can also add commands, so it should be possible to make exact "
"compatibility with any other simulator."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:26
msgid ""
"There are plans for the future to make the output pluggable too.  This will "
"enable a choice of output formats, and tight integration with other tools "
"for post-processing.  It could also make it possible for the output to mimic "
"another simulator."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:8
msgid ""
"The ability to make generalized post-measurements has been available in "
"expensive commercial simulators for a long time.  Any simulator can tell you "
"voltages and currents.  The ability to easily measure things like slew rate "
"and rise time has not been so easy in the free simulators."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:12
msgid ""
"A measure command (a plugin) can make post-measurements, interactively or "
"scripted.  Measurements like crossing time, rise time, slew rate, and "
"overshoot are available.  These are all plugins, so you can add your own "
"when you need to.  They set parameters, so you can use the results in "
"expressions to make more complex measurements, or to automatically change "
"component values or command parameters."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:16
msgid ""
"Proposed improvements in scripting will enable you to write your own more "
"complicated measurements, an optimizer, or even what seems like new analysis "
"methods."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:18
msgid ""
"It is also possible to write wrappers for the measurements that are provided "
"to add others, or for compatibility with the other simulators."
msgstr ""

#. type: Title =====
#: about/plugins/methods.txt:3
#, no-wrap
msgid "Simulation methods"
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:8
msgid ""
"The most popular simulation methods are based on nodal analysis, which is "
"taught in every undergraduate EE program.  The basic AC, DC, and transient "
"analysis are well known."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:10
msgid ""
"Other methods are usually available only in specialized simulators.  There "
"are some special purpose academic simulators.  There are lots more expensive "
"commercial simulators."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:14
msgid ""
"Gnucap supports the traditional Spice methods, plus or minus a little.  On "
"the plus side, the transient analysis is event driven and uses some "
"technique that can give you significant speedup.  On the minus side, Gnucap "
"is missing some methods that are important, such as noise."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:18
msgid ""
"With plugins, there is a place for the missing modes to be added.  Anyone "
"can contribute.  Works in progress can be shared, because it is your choice "
"whether to use the extension or not."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:7
msgid ""
"Traditional simulators have most of the models built-in, so you are stuck "
"with the models you have.  Most of them do have macros, and all of them have "
"subcircuits.  Some commercial simulators have more, but with the free "
"simulators, you need to dig in and recompile."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:9
msgid "Gnucap draws on the knowledge of Spice, and moves on."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:14
msgid ""
"Unlike Spice, models are not compiled into the simulator.  Models, all "
"models, are plugins that can be changed by a user at run time."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:16
msgid "It is possible to static-link models if desired, but it is not recommended."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:18
msgid ""
"The distribution tarball includes most of the basic \"Spice\" models, "
"including the simple devices (resistors, sources, transistors)."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:20
msgid ""
"There is a wrapper \"spice-wrapper.cc\" that allows the use of unmodified "
"Spice C models.  You need a simple configuration file with each Spice "
"model.  There are just a few lines to configure.  It can usually be done in "
"just a few minutes."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:22
msgid ""
"Models written for several versions of Spice are supported directly.  As of "
"when this is written, there is direct support for Berkeley 3e, Berkeley 3f, "
"and NGspice 17, and Jspice 3-2.5.  Other versions may also work, but have "
"not been tested."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:24
msgid ""
"With the real Spice, you need to modify the models for the particular "
"version of Spice you have.  Also, with the real Spice, you need to change "
"some names to avoid name clashes.  In Gnucap, you don't need to do either.  "
"All of the mentioned formats are supported directly and can co-exist.  The "
"plugin system puts each model in its own namespace, so duplicate names are "
"not a problem."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:26
msgid ""
"There is a model compiler \"gnucap-modelgen\" which accepts a high-level "
"description of a model.  This is backward compatible with old versions of "
"gnucap."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:28
msgid ""
"You can also use the \"ADMS\" model compiler, to generate a Spice model, "
"then use spice-wrapper to use it with gnucap."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:31
msgid "There is work in progress to use Icarus Verilog as the model compiler."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:33
msgid ""
"There are plans to make a modified version of ADMS that generates efficient "
"Gnucap code that can be used directly."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:35
msgid ""
"There are plans to improve the plugin attachment procedure so you will be "
"able to develop and debug compiled models interactively."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:36
msgid ""
"There could be wrapper plugins, so you can use other tools like octave and "
"\"R\" to write models."
msgstr ""

#. type: Plain text
#: about/plugins.txt:4
msgid ""
"Gnucap is designed to use a light-weight, portable core that provides an "
"environment to which new features can be added as \"plugins\" which are "
"supported separately from the main simulator.  These plugins can be loaded "
"and unloaded at run time if desired.  Most plugins can also be \"static "
"linked\" if desired, giving the appearance of a traditional single "
"executable program that will run on relatively primitive systems."
msgstr ""

#. type: Plain text
#: about/plugins.txt:6
msgid ""
"Since plugins can be loaded at run time, it is possible to have the main "
"program, and a standard set of libraries and plugins, installed and managed "
"on a network, or by the system administrator, and provide a way for each "
"user to add custom features including models."
msgstr ""

#. type: Plain text
#: about/plugins.txt:8
msgid ""
"In the usual configuration, a set of plugins is loaded automatically, giving "
"the capability expected of a Spice-like simulator, with some enhancements."
msgstr ""

#. type: Plain text
#: about/plugins.txt:10
msgid ""
"Plugins are standard compiled shared object modules, usually \".so\" or "
"\".dll\" files.  The source of plugins is portable across platforms, but the "
"compiled code must be compiled for the specific system."
msgstr ""

#. type: Plain text
#: about/plugins.txt:12
msgid ""
"At the lowest level, plugins are written in C++ and compiled.  There will be "
"tools to support other languages, using preprocessors, wrappers, or both.  "
"They can be added at any time, without recompiling the simulator core."
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:models|Models.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:commands|Commands.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:methods|Simulation methods.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:functions|Behavioral modeling functions.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:measurements|Measurements]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:interface|Interface to other software.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:languages|Simulation languages and compatibility]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:other:|Almost anything.]]\n"
msgstr ""

#. type: Plain text
#: manual/devices/inductor.txt:1
msgid "L"
msgstr ""

#. type: Title =====
#: manual/examples/noise_syntax.txt:1
#, no-wrap
msgid "Noise Syntax"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:4
msgid ""
"//This section contains descriptions which are not implemented yet in "
"simualtor. Work is in progress.//"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:6
msgid "Spice .noise command syntax is implemented:"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:8
msgid "''.noise V(<N1>[,<N2>]) <VIN> <ac_description>''"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<N1>, <N2> - output node numbers, if N2 is omited ground is implied;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<VIN> - input AC source at which noise power will be calculated;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<ac_description>  - gnucap AC simulation statement.\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:14
msgid "Here are some examples:"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:16
#, no-wrap
msgid "''.noise V(6) Vin dec 10 20 20k''\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:19
msgid ""
"- noise at node 6 w.r.t. ground, calculated to **Vin**, noise power densinty "
"will be calculated using **10** points per **dec**ade (logarithmic scale) in "
"frequency range from **20Hz** to **20KHz**"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:22
#, no-wrap
msgid "''.noise V(6,3) VSRC oct 2 10 10k''\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:24
msgid ""
"- noise between nodes 6 and 3, calculated to **VSRC**, noise power densinty "
"will be calculated using **2** points per **oct**ave (logarithmic scale) in "
"frequency range from **10Hz** to **10kHz**"
msgstr ""

#. type: Title =====
#: manual/howto/measurements.txt:1
#, no-wrap
msgid "Measures"
msgstr ""

#. type: Plain text
#: manual/howto/measurements.txt:13
#, no-wrap
msgid ""
"|[[gnucap:manual:measure:at]]     |The value of a wave at a point, or its "
"derivative.  |\n"
"|[[gnucap:manual:measure:mean|average]]\\\\ [[gnucap:manual:measure:mean]]              "
"|Average or mean value.  |\n"
"|[[gnucap:manual:measure:cross]]  |Find crossings.  |\n"
"|[[gnucap:manual:measure:integrate]]\\\\ "
"[[gnucap:manual:measure:integrate|area]]  |The area under the curve.  |\n"
"|[[gnucap:manual:measure:max]]    |Maximum value, or its point.  |\n"
"|[[gnucap:manual:measure:min]]    |Minimum value, or its point.  |\n"
"|[[gnucap:manual:measure:rms]]    |The RMS value.  |\n"
"|[[gnucap:manual:measure:slope|slewrate]]\\\\ "
"[[gnucap:manual:measure:slope]]\\\\ [[gnucap:manual:measure:slope|ddt]]  "
"|Slew rate or slope.  |\n"
msgstr ""

#. type: Title ======
#: manual/measure/integrate.txt:1
#, no-wrap
msgid "\"integrate\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:6
msgid "Find the integral of a waveform, the area under the curve."
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:10
#, no-wrap
msgid "  integrate(probe=\"p(d)\"  begin=time  end=time)\n"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:17
#, no-wrap
msgid ""
"^arg name  ^default     ^description  ^\n"
"|probe     |required    |The name of a probe to measure.  |\n"
"|begin     |- infinity  |Start averaging at this time or frequency.  |\n"
"|end       |+ infinity  |Stop averaging at this time or frequency.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:21
msgid ""
"This measure gives you the integral, or area under the curve, signed.  The "
"integral of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:29
#, no-wrap
msgid ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the mean value of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Find the mean value of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Plain text
#: manual/rr.txt:1
msgid "RR"
msgstr ""

#. type: Title ====
#: manual/tech/code_coverage_testing.txt:1
#, no-wrap
msgid "Code coverage testing"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:4
msgid ""
"To assist in testing the following procedure is used.  This is a "
"semi-automated procedure, intended to assist in developing a test suite that "
"fully tests the code, and to guide the developer in a code review."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:6
msgid ""
"This procedure uses the ''untested()'' macro as a marker to indicate what "
"has been tested and not.  It is performed on each source file."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:24
#, no-wrap
msgid ""
"  - With an editor:\n"
"    - Replace all ''{'' with ''{untested();''.\n"
"    - Replace all '':'' in switch statements with '':untested();''\n"
"    - If there are any code blocks without curlys, manually insert the "
"untested() calls.\n"
"    - Be sure to cover all cases in switch statements, and all branches of "
"an ''if'' statement, including empty branches.\n"
"    - If it is possible to have zero passes through a loop, that case must "
"also be tested.\n"
"    - If there are ?: or similar operators, both options must be tested.\n"
"    - Multiple paths due to #if and other preprocessor directives must also "
"be tested on the same level.\n"
"  - Recompile, with debug enabled so the untested statements will print when "
"run.\n"
"  - Run gnucap on the test input files.\n"
"  - Wherever you see the output from ''untested()'' (file, line, function)\n"
"    - Look at the results to verify that they are correct.\n"
"    - Look at the code to verify that it is clean and correct.\n"
"    - Remove that particular ''untested()'' call.\n"
"    - Go back to step 2.\n"
"  - Stop when you don't see any more file-line-function in the output.\n"
"  - Look at the code to see what ''untested()'' calls remain.  This "
"indicates code that is not tested by the test files.  If this is new code, "
"you need to create more tests to cover that code.\n"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:26
msgid ""
"When done, put a comment in the code just below the header block to indicate "
"the status:"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:29
msgid ""
"==//testing=script 2012.12.12== This procedure was done on that date.  Some "
"''untested'' remains."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:32
msgid ""
"==//testing=script,complete 2012.12.12== This procedure was done on that "
"date.  No ''untested'' remains.  Test suite provides 100% coverage."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:35
msgid ""
"==//testing=script,sparse 2012.12.12== This procedure was done on that "
"date.  Many ''untested'' remains.  Test suite is clearly inadequate here."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:38
msgid ""
"==//testing=obsolete 2012.12.12== This procedure was done on that date.  "
"Changes have been made to the code since that date, but the procedure was "
"not repeated.  Additional testing is needed."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:41
msgid ""
"==//testing=trivial 2012.12.12== This procedure was done on that date, but "
"there is nothing to see because the file contains no executable code.  The "
"file is probably a header file."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:43
msgid ""
"The absence of the //testing comment is taken to mean that no testing or "
"only informal testing was done, so that file is considered to be still in "
"development, not ready for release."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:45
msgid ""
"If changes are made after the indicated test date, the procedure was done "
"partially on only the new code meeting the indicated test level, do not "
"change the date.  Only change the date when the full procedure is done "
"again."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:47
msgid ""
"For new code, the \"script,complete\" level is expected in most cases, but "
"admittedly there are some cases where exception handling cannot be tested "
"completely."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:49
msgid ""
"For old code with changes, possibly done before this procedure was "
"initiated, the \"script\" level is acceptable provided the few remaining "
"blocks are marked as untested() or itested() and well understood.  itested() "
"means that it is known that it was tested, the untested message was seen, "
"but it is not in the regression suite."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:51
msgid ""
"The details here assume C++ code.  For other source languages, an equivalent "
"level of testing is expected."
msgstr ""

#. type: Title =====
#: manual/tech/compiling.txt:1
#, no-wrap
msgid "Compiling for test"
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:4
msgid "Gnucap has two different modes for compiling."
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/compiling.txt:7
#, no-wrap
msgid ""
"For regular users, only default compile options are used, for minimum "
"clutter during compiling, so real problems will stand out.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/compiling.txt:7
#, no-wrap
msgid ""
"For developers, additional warnings are enabled, to catch minor issues that "
"may lead to errors.  For code to be accepted into the main distribution (not "
"plugins that are distributed separately) it must compile without warnings, "
"with most compiler warnings enabled.\n"
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:9
msgid ""
"For g++, the following compile options are used to enable additional "
"warnings."
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:18
#, no-wrap
msgid ""
"<code>\n"
"  -DUNIX  -g -O0 -I. -I../../include -DTRACE_UNTESTED \\\n"
"  -Wall -Wextra \\\n"
"  -Wswitch-enum -Wundef -Wpointer-arith -Woverloaded-virtual \\\n"
"  -Wcast-qual -Wcast-align -Wpacked -Wshadow -Wconversion \\\n"
"  -Winit-self -Wmissing-include-dirs -Winvalid-pch \\\n"
"  -Wvolatile-register-var -Wstack-protector \\\n"
"  -Wlogical-op -Wvla -Woverlength-strings -Wsign-conversion\n"
"</code>\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/languages/args.txt:1 manual/tech/plugins/languages/command.txt:1 manual/tech/plugins/languages/comment.txt:1 manual/tech/plugins/languages/find_type_in_string.txt:1 manual/tech/plugins/languages/instance.txt:1 manual/tech/plugins/languages/label.txt:1 manual/tech/plugins/languages/lang_base.h.txt:1 manual/tech/plugins/languages/module.txt:1 manual/tech/plugins/languages/parse_top_item.txt:1 manual/tech/plugins/languages/ports.txt:1 manual/tech/plugins/languages/simple_query_functions.txt:1 manual/tech/plugins/languages/top_level.txt:1
#, no-wrap
msgid "Language plugins : Implementation"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/args.txt:3
#, no-wrap
msgid "parse, print args"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/args.txt:5 manual/tech/plugins/languages/command.txt:5 manual/tech/plugins/languages/comment.txt:5 manual/tech/plugins/languages/instance/label.txt:7 manual/tech/plugins/languages/instance/ports.txt:7 manual/tech/plugins/languages/instance.txt:5 manual/tech/plugins/languages/instance/type.txt:9 manual/tech/plugins/languages/label.txt:5 manual/tech/plugins/languages/module.txt:5 manual/tech/plugins/languages/ports.txt:5 manual/tech/plugins/languages/type.txt:9
#, no-wrap
msgid "Background"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:8
msgid "\"Args\" are the parameters of the device."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:10
msgid "Some languages read in args by order, some by name, some either way."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:12
msgid ""
"When reading by order, the meaning is determined by the order in the list.  "
"A single value, such as resistance of a resistor, specified as just a "
"number, is a simple case of reading by order.  There is also a special case "
"that allows you to identify one as the \"value\" and read the rest by name."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:14 manual/tech/plugins/languages/instance/ports.txt:20 manual/tech/plugins/languages/ports.txt:18
msgid ""
"The syntax varies.  Some separate by whitespace, some separate by a comma.  "
"Some may use \"name=value\".  Another may use \".name(value)\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:16 manual/tech/plugins/languages/instance/ports.txt:22 manual/tech/plugins/languages/ports.txt:20
msgid ""
"All of this must be considered in coding these functions.  Because of this, "
"we cannot say to \"usually\" use a particular function."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:18
msgid ""
"Some languages and devices use a different method \"obsolete_callback\" to "
"handle the args.  This is legacy code remaining from before there were "
"plugins.  Those will be recoded, and eventually obsolete_callback will be "
"removed.  It is not otherwise documented here."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/args.txt:19
#, no-wrap
msgid "parse_args"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:22
msgid "This functions reads the args from the input and stores the info."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:24 manual/tech/plugins/languages/instance/ports.txt:28 manual/tech/plugins/languages/ports.txt:26
msgid ""
"Here is an example from Verilog, which accepts either order dependent or "
"name=value pairs.  The whole list is enclosed in parentheses.  The port "
"names are separated by commas.  The format for a name=value pair is "
"''.name(value)''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:26 manual/tech/plugins/languages/instance/ports.txt:30 manual/tech/plugins/languages/ports.txt:28
msgid ""
"Remember, in the CS stream class \"stream >> variable\" reads into the "
"variable, like the usual C++ iostream.  As an extension \"stream >> "
"constant\" reads and consumes only a matching constant from the stream."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:28
msgid ""
"While reading by order, the value is set by the function "
"''set_param_by_index(index, value)''.  An exception ''Exception_Too_Many'' "
"will be thrown if there are too many.  Your code must catch the exception, "
"and should print a message, and move on."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:30 manual/tech/plugins/languages/args.txt:81
#, no-wrap
msgid ""
"Due to the way hierarchy is implemented, the count is backwards.  The "
"highest numbered parameter is first.  One way to do this is to use an index "
"that starts at 0 and is incremented with every read, and subtract that from "
"''x->param_count()''.   Alternatively, you could start at "
"''x->param_count()-1'' and count down.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:32
msgid ""
"While reading by name, the value is set by the function "
"''set_param_by_name(name, value)''.  An exception ''Exception_No_Match'' "
"will be thrown if the device type does not have a parameter that matches.  "
"Your code must catch the exception.  Probably it should print a message, and "
"move on.  In some cases, you may want to silently ignore invalid parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_args_instance(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:73
#, no-wrap
msgid ""
"  if (cmd >> \"#(\") {\n"
"    if (cmd.match1('.')) {\n"
"      // by name\n"
"      while (cmd >> '.') {\n"
"\tunsigned here = cmd.cursor();\n"
"\tstd::string name  = cmd.ctos(\"(\", \"\", \"\");\n"
"\tstd::string value = cmd.ctos(\",)\", \"(\", \")\");\n"
"\tcmd >> ',';\n"
"\ttry{\n"
"\t  x->set_param_by_name(name, value);\n"
"\t}catch (Exception_No_Match&) {untested();\n"
"\t  cmd.warn(bDANGER, here, x->long_label() + \": bad parameter \" + name + "
"\" ignored\");\n"
"\t}\n"
"      }\n"
"    }else{\n"
"      // by order\n"
"      int index = 1;\n"
"      while (cmd.is_alnum() || cmd.match1(\"+-.\")) {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string value = cmd.ctos(\",)\", \"\", \"\");\n"
"\t  x->set_param_by_index(x->param_count() - index++, value, 0/*offset*/);\n"
"\t}catch (Exception_Too_Many& e) {untested();\n"
"\t  cmd.warn(bDANGER, here, e.message());\n"
"\t}\n"
"      }\n"
"    }\n"
"    cmd >> ')';\n"
"  }else{\n"
"    // no args\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/args.txt:74
#, no-wrap
msgid "print_args"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:77
msgid "Printing the arg list is just a loop."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:79
msgid ""
"The print loop prints them in order, the same order as the order dependent "
"readin."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:83
msgid ""
"For a device that uses the \"obsolete_callback\", no loop is needed, just "
"call ''print_args_obsolete_callback'' and let the device code do the work."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:103
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_args(OMSTREAM& o, const MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  if (x->use_obsolete_callback_print()) {\n"
"    x->print_args_obsolete_callback(o, this);  //BUG//callback//\n"
"  }else{\n"
"    for (int ii = x->param_count() - 1;  ii >= 0;  --ii) {\n"
"      if (x->param_is_printable(ii)) {\n"
"\tstd::string arg = \" .\" + x->param_name(ii) + \"=\" + x->param_value(ii) "
"+ \";\";\n"
"\to << arg;\n"
"      }else{\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/command.txt:3
#, no-wrap
msgid "parse, print command"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:8
msgid ""
"A command object executes a command, does not store anything.  The reference "
"to \"dot\" and \"dotcard\" is historical, because in Spice, commands were "
"prefixed by a dot."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:10
msgid "This section may change as scripting is enhanced."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:12
msgid "For reference, here is the class definition from d_dot.h ."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:32
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class DEV_DOT : public CARD {\n"
"private:\n"
"  std::string\t_s;\n"
"  explicit DEV_DOT(const DEV_DOT& p) :CARD(p) {set_constant(true);}\n"
"public:\n"
"  explicit\tDEV_DOT()\t\t:CARD() {set_constant(true);}\n"
"private: // override virtual\n"
"  std::string   value_name()const\t{return \"\";}\n"
"  char\t\tid_letter()const\t{untested();return '\\0';}\n"
"  std::string\tdev_type()const\t\t{untested();return \"dotcard\";}\n"
"  CARD*\t\tclone()const\t\t{return new DEV_DOT(*this);}\n"
"public:\n"
"  void set(const std::string& S) {_s = S;}\n"
"  const std::string& s()const {return _s;}\n"
"};\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/command.txt:33 manual/tech/plugins/languages/comment.txt:32
#, no-wrap
msgid "parse_comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:36
msgid ""
"The parse function reads the string and executes it by calling "
"''CMD::commandproc''.  Then the new object is deleted, and the function "
"returns a NULL pointer."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:44
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"DEV_DOT* LANG_VERILOG::parse_command(CS& cmd, DEV_DOT* x)\n"
"{\n"
"  assert(x);\n"
"  x->set(cmd.fullstring());\n"
"  CARD_LIST* scope = (x->owner()) ? x->owner()->subckt() : "
"&CARD_LIST::card_list;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:52
#, no-wrap
msgid ""
"  cmd.reset(0);\n"
"  CMD::cmdproc(cmd, scope);\n"
"  delete x;\n"
"  return NULL;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/command.txt:53 manual/tech/plugins/languages/comment.txt:46
#, no-wrap
msgid "print_comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:56
msgid "For now, all that is needed is to print it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:65
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_command(OMSTREAM& o, const DEV_DOT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->s() << '\\n';\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/comment.txt:3
#, no-wrap
msgid "parse, print comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:8
msgid "A comment object stores a string, otherwise does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:10
msgid "For reference, here is the class definition from d_coment.h ."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:31
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class DEV_COMMENT : public CARD {\n"
"private:\n"
"  std::string\t_s;\n"
"  explicit\tDEV_COMMENT(const DEV_COMMENT& p)\n"
"\t\t\t\t:CARD(p) {set_constant(true);}\n"
"public:\n"
"  explicit\tDEV_COMMENT()\t:CARD()  {set_constant(true);}\n"
"private: // override virtual\n"
"  char\t\tid_letter()const\t{return '\\0';}\n"
"  std::string\tdev_type()const\t\t{return \"comment\";}\n"
"  CARD*\t\tclone()const\t\t{return new DEV_COMMENT(*this);}\n"
"  std::string   value_name()const\t{return \"\";}\n"
"public:\n"
"  void set(const std::string& s) {_s = s;}\n"
"  std::string comment()const {return _s;}\n"
"};\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:35
msgid ""
"The parse function reads the string and stores it.  Usually, to \"set\" the "
"comment to the \"fullstring\" is all that is needed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:46
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"DEV_COMMENT* LANG_VERILOG::parse_comment(CS& cmd, DEV_COMMENT* x)\n"
"{\n"
"  assert(x);\n"
"  x->set(cmd.fullstring());\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:49
msgid ""
"It would seem that all that is needed is to print it, but it is also "
"necessary to make sure that the printout is in a form that the current "
"language interprets as a comment.  You could just prefix it with the comment "
"marker, but this could cause a buildup in cases where there are repeated "
"saves and reads of the file.  Therefore, it is best to check the stored "
"prefix and only output an extra prefix if it doesn't match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:55
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_comment(OMSTREAM& o, const DEV_COMMENT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:63
#, no-wrap
msgid ""
"  if ((x->comment().compare(0, 2, \"//\")) != 0) {\n"
"    o << \"//\";\n"
"  }else{\n"
"  }\n"
"  o << x->comment() << '\\n';\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/find_type_in_string.txt:3
#, no-wrap
msgid "find_type_in_string"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:6
msgid ""
"This function scans an input string and extracts the \"type\" from it.  In "
"some cases the type is explicitly stated and easy to find.  In others "
"finding the type can be tricky.  In any case, scanning is reset to the "
"beginning after the type is found."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:8
msgid ""
"Here is a simple case, where the type is the first word on the line, unless "
"it is a comment which begins with ''/''''/''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:26
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"std::string LANG_VERILOG::find_type_in_string(CS& cmd)\n"
"{\n"
"  unsigned here = cmd.cursor();\n"
"  std::string type;\n"
"  if ((cmd >> \"//\")) {\n"
"    assert(here == 0);\n"
"    type = \"dev_comment\";\n"
"  }else{\n"
"    cmd >> type;\n"
"  }\n"
"  cmd.reset(here);\n"
"  return type;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:27
msgid ""
"This function can be considerably more complex if the type is not first in "
"line.  In some cases it is necessary to read to the end then back up."
msgstr ""

#. type: Title ======
#: manual/tech/plugins/languages/instance/label.txt:1 manual/tech/plugins/languages/instance/ports.txt:1 manual/tech/plugins/languages/instance/type.txt:1 manual/tech/plugins/languages.txt:1 manual/tech/plugins/languages/type.txt:1
#, no-wrap
msgid "Language plugins"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/instance/label.txt:5 manual/tech/plugins/languages/label.txt:3
#, no-wrap
msgid "parse, print label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:10 manual/tech/plugins/languages/label.txt:8
msgid "The label is a string by which this instance is known."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:12 manual/tech/plugins/languages/label.txt:10
msgid ""
"In a paramset (Spice .model) the label is the name of the new type being "
"defined."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:14 manual/tech/plugins/languages/label.txt:12
msgid ""
"A \"short_label\" is the simple form of the label, without scope "
"information."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:16 manual/tech/plugins/languages/label.txt:14
msgid "A \"long_label\" is a full label including hierarchical scope information."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/label.txt:17 manual/tech/plugins/languages/label.txt:15
#, no-wrap
msgid "parse_label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:20 manual/tech/plugins/languages/instance/type.txt:24 manual/tech/plugins/languages/label.txt:18 manual/tech/plugins/languages/type.txt:24
msgid ""
"This function usually reads the type from the input string, then calls "
"''set_dev_type'' to set it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:22 manual/tech/plugins/languages/instance/type.txt:26 manual/tech/plugins/languages/label.txt:20 manual/tech/plugins/languages/type.txt:26
msgid "Usually, you can use this function:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:34 manual/tech/plugins/languages/label.txt:32
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_label(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
"  std::string my_name;\n"
"  cmd >> my_name;\n"
"  x->set_label(my_name);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/label.txt:35 manual/tech/plugins/languages/label.txt:33
#, no-wrap
msgid "print_label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:38 manual/tech/plugins/languages/label.txt:36
msgid "Printing the type usually simple.  Usually, you can use this function:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:48 manual/tech/plugins/languages/label.txt:46
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_label(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->short_label();\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/instance/ports.txt:5 manual/tech/plugins/languages/ports.txt:3
#, no-wrap
msgid "parse, print ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:10 manual/tech/plugins/languages/ports.txt:8
msgid ""
"Ports are the connections, how this particular instance is connected to the "
"rest of the circuit."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:12 manual/tech/plugins/languages/ports.txt:10
msgid "Paramsets do not have ports."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:14
msgid ""
"In most languages, ports are nodes.  \"Through\" ports such as currents are "
"rarely supported.  In a language that does support current ports, the syntax "
"is the same."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:16 manual/tech/plugins/languages/ports.txt:14
msgid ""
"Most languages read in ports by order.  The meaning of a port is determined "
"by the order in a port list.  For example, in a diode, the first is the "
"anode, the second is the cathode."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:18 manual/tech/plugins/languages/ports.txt:16
msgid "Some also support name=value pairs.  Some use either."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/ports.txt:23 manual/tech/plugins/languages/ports.txt:21
#, no-wrap
msgid "parse_ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:26 manual/tech/plugins/languages/ports.txt:24
msgid "This functions reads the ports from the input and stores the info."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:32 manual/tech/plugins/languages/ports.txt:30
msgid ""
"While reading by order, the value is set by the function "
"''set_port_by_index(index, value)''.  The index starts at 0 and must be "
"incremented with every read.  An exception ''Exception_Too_Many'' will be "
"thrown if there are too many.  Your code must catch the exception, and "
"should print a message, and move on."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:34 manual/tech/plugins/languages/ports.txt:32
msgid ""
"While reading by name, the value is set by the function "
"''set_port_by_name(name, value)''.  An exception ''Exception_No_Match'' will "
"be thrown if the device type does not have a parameter that matches.  Your "
"code must catch the exception.  Probably it should print a message, and move "
"on.  In some cases, you may want to silently ignore invalid parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:40 manual/tech/plugins/languages/ports.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_ports(CS& cmd, COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:75 manual/tech/plugins/languages/ports.txt:73
#, no-wrap
msgid ""
"  if (cmd >> '(') {\n"
"    if (cmd.is_alnum()) {\n"
"      // by order\n"
"      int index = 0;\n"
"      while (cmd.is_alnum()) {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string value;\n"
"\t  cmd >> value;\n"
"\t  x->set_port_by_index(index++, value);\n"
"\t}catch (Exception_Too_Many& e) {untested();\n"
"\t  cmd.warn(bDANGER, here, e.message());\n"
"\t}\n"
"      }\n"
"    }else{\n"
"      // by name\n"
"      while (cmd >> '.') {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string name, value;\n"
"\t  cmd >> name >> '(' >> value >> ')' >> ',';\n"
"\t  x->set_port_by_name(name, value);\n"
"\t}catch (Exception_No_Match&) {untested();\n"
"\t  cmd.warn(bDANGER, here, \"mismatch, ignored\");\n"
"\t}\n"
"      }\n"
"    }\n"
"    cmd >> ')';\n"
"  }else{untested();\n"
"    cmd.warn(bDANGER, \"'(' required (parse ports)\");\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/ports.txt:76 manual/tech/plugins/languages/ports.txt:74
#, no-wrap
msgid "print_ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:85 manual/tech/plugins/languages/ports.txt:86
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_ports_long(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  // print in long form ...    .name(value)\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:103 manual/tech/plugins/languages/ports.txt:104
#, no-wrap
msgid ""
"  o << \" (\";\n"
"  std::string sep = \".\";\n"
"  for (int ii = 0;  x->port_exists(ii);  ++ii) {\n"
"    o << sep << x->port_name(ii) << '(' << x->port_value(ii) << ')';\n"
"    sep = \",.\";\n"
"  }\n"
"  for (int ii = 0;  x->current_port_exists(ii);  ++ii) {\n"
"    o << sep << x->current_port_name(ii) << '(' << x->current_port_value(ii) "
"<< ')';\n"
"    sep = \",.\";\n"
"  }\n"
"  o << \")\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_ports_short(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  // print in short form ...   value only\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:117 manual/tech/plugins/languages/ports.txt:118
#, no-wrap
msgid ""
"  o << \" (\";\n"
"  std::string sep = \"\";\n"
"  for (int ii = 0;  x->port_exists(ii);  ++ii) {\n"
"    o << sep << x->port_value(ii);\n"
"    sep = \",\";\n"
"  }\n"
"  for (int ii = 0;  x->current_port_exists(ii);  ++ii) {\n"
"    o << sep << x->current_port_value(ii);\n"
"    sep = \",\";\n"
"  }\n"
"  o << \")\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:3 manual/tech/plugins/languages/instance/type.txt:5 manual/tech/plugins/languages/type.txt:5
#, no-wrap
msgid "parse, print instance, paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:8
msgid "A netlist is primarily a list of instances."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:10
msgid "Synonyms for instance include component, device, element."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:12
msgid "Examples of instances include resistors, transistors."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:14
msgid ""
"A paramset is a prototype for an instance.  Internally, it is the same "
"except that a paramset has no ports, but most languages have a different "
"syntax for it.  The word \"paramset\" is from Verilog syntax.  In Spice, "
"this would be a \"model\" statement."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:16
msgid "In most cases, the data can clearly be divided into four parts:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:21
#, no-wrap
msgid ""
"**type**  -- The type of this instance.  (resistor)\\\\\n"
"**label** -- The name of this instance.  (R22)\\\\\n"
"**ports** -- Connections, nodes, ports, pins.\\\\\n"
"**args**  -- Arguments, parameters, values.  (R=10k, tolerance=5%)\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:23
msgid ""
"To simplify coding, it is usually best to set up four separate functions to "
"parse, and four to print.  These should be \"static\" or \"private member\" "
"functions, so they are visible only in this file.  The top level "
"''parse_instance'' and ''print_instance'' can be just a set of calls to "
"these functions, in the appropriate order."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:type]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:label]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:ports]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:args]]\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:29
#, no-wrap
msgid "parse_instance, parse_paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:32
msgid ""
"The parse function reads the input string, interprets it, and stores the "
"data as interpreted.  The string itself is not stored."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:60
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"COMPONENT* LANG_SPECTRE::parse_instance(CS& cmd, COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  cmd.reset(0);\n"
"  parse_label(cmd, x);\n"
"  parse_ports(cmd, x);\n"
"  parse_type(cmd, x);\n"
"  parse_args(cmd, x);\n"
"  cmd.check(bWARNING, \"what's this?\");\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"MODEL_CARD* LANG_SPECTRE::parse_paramset(CS& cmd, MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  cmd.reset(0).skipbl();\n"
"  cmd >> \"model \";\n"
"  parse_label(cmd, x);\n"
"  parse_type(cmd, x);\n"
"  parse_args(cmd, x);\n"
"  cmd.check(bWARNING, \"what's this?\");\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:62
msgid ""
"''cmd.reset(0)'' at the beginning resets the parser/scanner to the beginning "
"of the line."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:64
msgid ""
"''cmd.check(bWARNING, \"what's this?\")'' checks that the line is used up, "
"the cursor should be at the end of the line.  If not, there is something "
"wrong, so it prints a warning."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:65
#, no-wrap
msgid "print_instance, print_paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:68
msgid ""
"The print function re-creates a string from the stored data.  It should be "
"in a form suitable to be passed to ''parse'', to recreate the same "
"instance.  The round-trip should be lossless, in the sense of having "
"identical data.  It serves as a check that both parse and print are working "
"correctly."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:70
msgid ""
"It is not necessary or desirable to EXACTLY reproduce the input.  Rather, "
"show how the input was interpreted.  In cases where something could be "
"ambiguous, this is important.  The printed output should be a cleaned-up "
"version of the input."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:72
msgid "To parse in one language then print in another does a translation."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:93
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPECTRE::print_instance(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  print_label(o, x);\n"
"  print_ports(o, x);\n"
"  print_type(o, x);\n"
"  print_args(o, x);\n"
"  o << \"\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPECTRE::print_paramset(OMSTREAM& o, const MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  o << \"model \" << x->short_label() << ' ' << x->dev_type() << ' ';\n"
"  print_args(o, x);\n"
"  o << \"\\n\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:94 manual/tech/plugins/languages/module.txt:70
#, no-wrap
msgid "A command to get it started"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:97
msgid ""
"For instances, usually parse and print are all you need.  Finding a matching "
"type gets it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:99
msgid ""
"For paramsets (''.model'' in Spice) in addition to the above, it is "
"necessary to make a command to recognize a keyword to get it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:101
msgid "It needs to allocate a new ''MODEL_CARD'', parse it, then store it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:112
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_PARAMSET : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // already got \"paramset\"\n"
"    std::string my_name, base_name;\n"
"    cmd >> my_name;\n"
"    unsigned here = cmd.cursor();\n"
"    cmd >> base_name;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:132
#, no-wrap
msgid ""
"    //const MODEL_CARD* p = model_dispatcher[base_name];\n"
"    const CARD* p = lang_verilog.find_proto(base_name, NULL);\n"
"    if (p) {\n"
"      MODEL_CARD* new_card = dynamic_cast<MODEL_CARD*>(p->clone());\n"
"      if (new_card) {\n"
"\tassert(!new_card->owner());\n"
"\tlang_verilog.parse_paramset(cmd, new_card);\n"
"\tScope->push_back(new_card);\n"
"      }else{\n"
"\tcmd.warn(bDANGER, here, \"paramset: base has incorrect type\");\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, here, \"paramset: no match\");\n"
"    }\n"
"  }\n"
"} p1;\n"
"DISPATCHER<CMD>::INSTALL d1(&command_dispatcher, \"paramset\", &p1);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:134
msgid ""
"In some cases (Spice) you need to deal with the \"level\" concept here.  The "
"same type field (for example ''NMOS'') can map to severa l different "
"prototypes (level 1,2,3,...).  Those prototypes ultimately need different "
"internal names, and a scheme to map them here."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:145
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_MODEL : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // already got \"model\"\n"
"    std::string my_name, base_name;\n"
"    cmd >> my_name;\n"
"    unsigned here1 = cmd.cursor();\n"
"    cmd >> base_name;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:161
#, no-wrap
msgid ""
"    // \"level\" kluge ....\n"
"    // if there is a \"level\" keyword, with integer argument,\n"
"    // tack that onto the given modelname and look for that\n"
"    cmd.skip1b('(');\n"
"    int level = 0;\n"
"    {\n"
"      unsigned here = cmd.cursor();\n"
"      scan_get(cmd, \"level \", &level);\n"
"      if (!cmd.stuck(&here)) {\n"
"\tchar buf[20];\n"
"\tsprintf(buf, \"%u\", level);\n"
"\tbase_name += buf;\n"
"      }else{\n"
"      }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:163
#, no-wrap
msgid "    const MODEL_CARD* p = model_dispatcher[base_name];\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:180
#, no-wrap
msgid ""
"    if (p) {\n"
"      MODEL_CARD* new_card = dynamic_cast<MODEL_CARD*>(p->clone());\n"
"      if (new_card) {\n"
"\tassert(!new_card->owner());\n"
"\tlang_spice.parse_paramset(cmd, new_card);\n"
"\tScope->push_back(new_card);\n"
"      }else{untested();\n"
"\tcmd.warn(bDANGER, here1, \"model: base has incorrect type\");\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, here1, \"model: \\\"\" + base_name + \"\\\" no "
"match\");\n"
"    }\n"
"  }\n"
"} p1;\n"
"DISPATCHER<CMD>::INSTALL d1(&command_dispatcher, \".model\", &p1);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ===
#: manual/tech/plugins/languages/instance/type.txt:7 manual/tech/plugins/languages/type.txt:7
#, no-wrap
msgid "parse, print type"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:12 manual/tech/plugins/languages/type.txt:12
msgid ""
"It may seem redundant to parse the type again, because the type is already "
"known.  It was determined by ''find_type_in_string'', then the type was "
"looked up, and a new instance of that type was created."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:14 manual/tech/plugins/languages/type.txt:14
msgid ""
"Often, it is, but sometimes parameters are encoded in the type, with several "
"type names really representing the same real type.  One example of this is "
"the \"NPN\" and \"PNP\" transistors, which are the same type with a polarity "
"parameter, or the name associated with a paramset (Spice .model card)."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:16 manual/tech/plugins/languages/type.txt:16
msgid ""
"On the other hand, sometimes an identical type name could represent "
"different real types.  An example of this is the different \"levels\" of "
"Spice MOSFET models.  This is handled by trickery in parsing, and is not "
"discussed here because it is a bad idea."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:18 manual/tech/plugins/languages/type.txt:18
msgid ""
"In Spice format, sometimes the type is implied by the first letter of the "
"label, and never explicitly appears.  In this case, the explicit parse and "
"print can be skipped."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:20 manual/tech/plugins/languages/type.txt:20
msgid ""
"In a paramset (including a Spice .model), the type is the master type being "
"copied, not the new type being defined."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/instance/type.txt:21 manual/tech/plugins/languages/type.txt:21
#, no-wrap
msgid "parse_type ==="
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:38 manual/tech/plugins/languages/type.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_type(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
"  std::string new_type;\n"
"  cmd >> new_type;\n"
"  x->set_dev_type(new_type);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/instance/type.txt:39 manual/tech/plugins/languages/type.txt:39
#, no-wrap
msgid "print_type"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:42 manual/tech/plugins/languages/type.txt:42
msgid ""
"Printing the type usually simple.  In some cases (Spice) the type may not be "
"printed.  The extra code is not shown here."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:52 manual/tech/plugins/languages/type.txt:52
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_type(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->dev_type();\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/lang_base.h.txt:3
#, no-wrap
msgid "lang_base.h"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/lang_base.h.txt:6
msgid ""
"If your version of gnucap does not supply lang_base.h, use this one, copy it "
"to the place where the gnucap headers are."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/lang_base.h.txt:15
msgid ""
"<code cpp> #include \"globals.h\" #include \"c_comand.h\" #include "
"\"d_dot.h\" #include \"d_coment.h\" #include \"d_subckt.h\" #include "
"\"e_model.h\" #include \"u_lang.h\" </code>"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/module.txt:3
#, no-wrap
msgid "parse, print module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:8
msgid ""
"A module is container of instances.  To a compiler, a module can also "
"contain code to be executed, but gnucap does not directly support that."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:10
msgid "A Spice \"subckt\" is a module."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "type -- A module defines a new type.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "[[.:label]] -- The label is the name of the new type.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "[[.:ports]] -- This is the list of connections.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid ""
"[[.:args]] -- The arg list is optional.  If left out, the arg list is open.  "
"It accepts whatever it is fed.\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/module.txt:16
#, no-wrap
msgid "parse_module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:19
msgid ""
"A module is a collection.  Parsing it means to parse the header, then the "
"body, then the trailer.  Parsing the body is a loop, getting text and "
"calling ''new_''''_instance'' on each pass, until some indication that it is "
"done.  It is important to have some kind of guarantee that the loop will "
"exit."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:25
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"MODEL_SUBCKT* LANG_SPECTRE::parse_module(CS& cmd, MODEL_SUBCKT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:31
#, no-wrap
msgid ""
"  // header\n"
"  cmd.reset(0).skipbl();\n"
"  cmd >> \"subckt \";\n"
"  parse_label(cmd, x);\n"
"  parse_ports(cmd, x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:35
#, no-wrap
msgid ""
"  // body\n"
"  for (;;) {\n"
"    cmd.get_line(\"spectre-subckt>\");\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:46
#, no-wrap
msgid ""
"    if (cmd >> \"ends \") {\n"
"      break;\n"
"    }else{\n"
"      new__instance(cmd, x, x->subckt());\n"
"    }\n"
"  }\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/module.txt:47
#, no-wrap
msgid "print_module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:55
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPICE_BASE::print_module(OMSTREAM& o, const MODEL_SUBCKT* x)\n"
"{\n"
"  assert(x);\n"
"  assert(x->subckt());\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:59
#, no-wrap
msgid ""
"  o << \".subckt \" <<  x->short_label();\n"
"  print_ports(o, x);\n"
"  o << '\\n';\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:64
#, no-wrap
msgid ""
"  for (CARD_LIST::const_iterator\n"
"\t ci = x->subckt()->begin(); ci != x->subckt()->end(); ++ci) {\n"
"    print_item(o, *ci);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:69
#, no-wrap
msgid ""
"  o << \".ends \" << x->short_label() << \"\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:73
msgid ""
"In addition to the above, it is necessary to make a command to recognize a "
"keyword to get it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:75
msgid "It needs to allocate a new ''MODEL_SUBCKT'', parse it, then store it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:93
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_SUBCKT : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    MODEL_SUBCKT* new_module = new MODEL_SUBCKT;\n"
"    assert(new_module);\n"
"    assert(!new_module->owner());\n"
"    assert(new_module->subckt());\n"
"    assert(new_module->subckt()->is_empty());\n"
"    lang_spectre.parse_module(cmd, new_module);\n"
"    Scope->push_back(new_module);\n"
"  }\n"
"} p2;\n"
"DISPATCHER<CMD>::INSTALL d2(&command_dispatcher, \"subckt\", &p2);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/parse_top_item.txt:3
#, no-wrap
msgid "parse_top_item"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:6
msgid ""
"The function ''parse_top_item'' must be provided.  Usually you can just copy "
"this."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:16
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::parse_top_item(CS& cmd, CARD_LIST* Scope)\n"
"{\n"
"  cmd.get_line(\"gnucap-verilog>\");\n"
"  new__instance(cmd, NULL, Scope);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:18
msgid ""
"It parses one line of input, where the definition of \"line\" may differ "
"depending on the language."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:20
msgid ""
"The string, in this case ''\"gnucap-verilog>\"'' is used as a prompt in "
"interactive mode, and is suppressed when reading from a file."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:22
msgid ""
"For educational purposes, the code for ''new_''''_instance'' follows.  You "
"do not need to duplicate it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:24
msgid ""
"You do need to provide ''find_type_in_string'', which returns the type as a "
"string, by scanning the input."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:26
msgid ""
"''parse_item'' is shown here.  It dispatches to one of ''parse_module'', "
"''parse_instance'', ''parse_paramset'', ''parse_comment'', or "
"''parse_command'', which you must provide."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:56
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANGUAGE::new__instance(CS& cmd, MODEL_SUBCKT* owner, CARD_LIST* "
"Scope)\n"
"{\n"
"  if (cmd.is_end()) {\n"
"    // nothing\n"
"  }else{\n"
"    std::string type = find_type_in_string(cmd);\n"
"    if (const CARD* proto = find_proto(type, owner)) {\n"
"      CARD* new_instance = proto->clone_instance();\n"
"      assert(new_instance);\n"
"      new_instance->set_owner(owner);\n"
"      CARD* x = parse_item(cmd, new_instance);\n"
"      if (x) {\n"
"\tassert(Scope);\n"
"\tScope->push_back(x);\n"
"      }else{\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, type + \": no match\");\n"
"    }\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"CARD* LANGUAGE::parse_item(CS& cmd, CARD* c)\n"
"{\n"
"  // See Stroustrup 15.4.5\n"
"  // If you can think of a better way, tell me.\n"
"  // It must be in the LANGUAGE class, not CARD.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:74
#, no-wrap
msgid ""
"  if (dynamic_cast<MODEL_SUBCKT*>(c)) {\n"
"    return parse_module(cmd, prechecked_cast<MODEL_SUBCKT*>(c));\n"
"  }else if (dynamic_cast<COMPONENT*>(c)) {\n"
"    return parse_instance(cmd, prechecked_cast<COMPONENT*>(c));\n"
"  }else if (dynamic_cast<MODEL_CARD*>(c)) {\n"
"    return parse_paramset(cmd, prechecked_cast<MODEL_CARD*>(c));\n"
"  }else if (dynamic_cast< DEV_COMMENT*>(c)) {\n"
"    return parse_comment(cmd, prechecked_cast<DEV_COMMENT*>(c));\n"
"  }else if (dynamic_cast<DEV_DOT*>(c)) {\n"
"    return parse_command(cmd, prechecked_cast<DEV_DOT*>(c));\n"
"  }else{untested();\n"
"    incomplete();\n"
"    unreachable();\n"
"    return NULL;\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:12
msgid ""
"In most languages, ports are nodes.  \"Through\" ports such as currents are "
"rarely supported.  Nodes and through ports are stored in separate lists.  As "
"of when this is being written, only the Spice format supports through ports "
"in any way, and even this is limited to just a few devices."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:77
msgid ""
"Printing the port list is just a loop.  Two loops are needed, one for "
"traditional node ports, the other for through or current ports.  This part "
"is inherently inconsistent.  It is necessary to print them because they may "
"be there, even if there is no way to input them other than to use a "
"different language.  This could change in a future release."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:79
msgid ""
"The print loop prints them in order, the same order as the order dependent "
"readin.  Here are two variants of the print loop, one with names, the other "
"without."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:5
#, no-wrap
msgid "~LANGUAGE()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:10
#, no-wrap
msgid ""
"C++ rules require a virtual destructor when there are virtual functions.  "
"You need to define one as a tracing aid.  It can be an empty function.\n"
"<code cpp>\n"
"  ~LANG_VERILOG() {itested();}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:11
#, no-wrap
msgid "std::string name()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:16
#, no-wrap
msgid ""
"Return the name to use as a key to enable this language.\n"
"<code cpp>\n"
"  std::string name()const {return \"verilog\";}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:17
#, no-wrap
msgid "bool case_insensitive()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:22
#, no-wrap
msgid ""
"Return false if the language is case sensitive, true if case insensitive.\n"
"<code cpp>\n"
"  bool case_insensitive()const {return false;}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:23
#, no-wrap
msgid "UNITS units()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:28
#, no-wrap
msgid ""
"This function determines how numeric strings with multiplier suffixes such "
"as \"10m\" are parsed.  It should return ''uSI'' for standard SI units.  (M "
"= meg = 10^6, m = milli = 10^-3)  or ''uSPICE'' for SPICE syntax (M = milli "
"= 10^-3, Meg = meg = 10^6).\n"
"<code cpp>\n"
"  UNITS units()const {return uSI;}\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/simple_query_functions.txt:29
#, no-wrap
msgid "Used by obsolete_callback"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:32
msgid "These functions describe the syntax for parameter assignment statements."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:34
msgid ""
"For example, the most common syntax is ''x=value'', but Verilog uses "
"''.x(value)''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:36
msgid "You need to specify the front, mid, and back strings."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:44
#, no-wrap
msgid ""
"For ''x=value''\n"
"the code is:\n"
"<code cpp>\n"
"  std::string arg_front()const {return \" \";}\n"
"  std::string arg_mid()const {return \"=\";}\n"
"  std::string arg_back()const {return \"\";}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:51
#, no-wrap
msgid ""
"For ''.x(value)''\n"
"the code is:\n"
"<code cpp>\n"
"  std::string arg_front()const {return \".\";}\n"
"  std::string arg_mid()const {return \"(\";}\n"
"  std::string arg_back()const {return \")\";}\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/top_level.txt:3
#, no-wrap
msgid "Top Level"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:6
msgid "At top level, you need to include the header file."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:10
msgid "<code cpp> #include \"gnucap/lang_base.h\" </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:12
msgid ""
"If you want to be able to static link the plugin, or combine it with others, "
"wrap it in an anonymous namespace."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:23
msgid ""
"<code cpp> namespace { "
"/*--------------------------------------------------------------------------*/ "
"// all of your other code goes here "
"/*--------------------------------------------------------------------------*/ "
"} // close the anonymous namespace "
"/*--------------------------------------------------------------------------*/ "
"/*--------------------------------------------------------------------------*/ "
"// end of file </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:25
msgid "Inside of there, you need to define a new class."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:33
#, no-wrap
msgid ""
"<code cpp>\n"
"class LANG_SPECTRE : public LANGUAGE {\n"
"public:\n"
"  ~LANG_SPECTRE() {}\n"
"  std::string name()const {return \"spectre\";}\n"
"  bool case_insensitive()const {return false;}\n"
"  UNITS units()const {return uSI;}\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:38
#, no-wrap
msgid ""
"public: // override virtual, used by callback\n"
"  std::string arg_front()const {return \" \";}\n"
"  std::string arg_mid()const {return \"=\";}\n"
"  std::string arg_back()const {return \"\";}\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:47
#, no-wrap
msgid ""
"public: // override virtual, called by commands\n"
"  void\t\tparse_top_item(CS&, CARD_LIST*);\n"
"  DEV_COMMENT*\tparse_comment(CS&, DEV_COMMENT*);\n"
"  DEV_DOT*\tparse_command(CS&, DEV_DOT*);\n"
"  MODEL_CARD*\tparse_paramset(CS&, MODEL_CARD*);\n"
"  MODEL_SUBCKT* parse_module(CS&, MODEL_SUBCKT*);\n"
"  COMPONENT*\tparse_instance(CS&, COMPONENT*);\n"
"  std::string\tfind_type_in_string(CS&);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:58
#, no-wrap
msgid ""
"private: // override virtual, called by print_item\n"
"  void print_paramset(OMSTREAM&, const MODEL_CARD*);\n"
"  void print_module(OMSTREAM&, const MODEL_SUBCKT*);\n"
"  void print_instance(OMSTREAM&, const COMPONENT*);\n"
"  void print_comment(OMSTREAM&, const DEV_COMMENT*);\n"
"  void print_command(OMSTREAM& o, const DEV_DOT* c);\n"
"private: // local\n"
"  void print_args(OMSTREAM&, const CARD*);\n"
"} lang_spectre;\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:60
msgid ""
"Then delcare one static instance of it and \"INSTALL\" it with the "
"\"DISPATCHER\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:66
#, no-wrap
msgid ""
"<code cpp>\n"
"DISPATCHER<LANGUAGE>::INSTALL\n"
"\td(&language_dispatcher, lang_spectre.name(), &lang_spectre);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:68
msgid ""
"In general, the names do not need to be unique.  It is ok if another plugin "
"has the same names."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:69
msgid "However, the ''name()'' string above should be unique so you can find it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:6
msgid ""
"Language plugins read and write a particular simulation language, and set up "
"related commands.  They determine the syntax used by gnucap."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:8
msgid ""
"This refers to SIMULATION languages, like \"spice\", \"spectre\" or "
"\"verilog\", not NATURAL languages."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:10
msgid ""
"Language plugins need to #include the file: ''gnucap/lang_base.h''.  Others "
"may be needed in some cases."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:12
msgid ""
"The base class ''LANGUAGE'' is defined in ''gnucap/u_lang.h'' which is "
"included by ''gnucap/lang_base.h''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:14
msgid ""
"The \"parse\" and \"print\" functions go together.  For every \"parse\" "
"there must be a \"print\" that regenerates a string suitable for input to "
"\"parse\" that is equivalent to the original."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:16
msgid ""
"As a generalization, to read a file the function ''parse_top_item'' is "
"called in a loop:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:22
#, no-wrap
msgid ""
"<code>\n"
"  for (;;) {\n"
"    OPT::language->parse_top_item(file, Scope);\n"
"  }\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:24
msgid ""
"The loop exits when an exception is thrown, most likely "
"''Exception_End_Of_Input''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:26
msgid ""
"This function must be provided by the language plugin.  A set of other "
"functions must also be provided, as in this example:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:28
msgid ""
"As with all plugins, declare one static object of this new type, and INSTALL "
"it in the DISPATCHER."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:30
msgid ""
"In addition to this, you will probably need to supply a few commands to "
"recognize keywords at top level."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:32
msgid "Details are described in the following \"Implementation\" section."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:Top level]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:lang_base.h]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:Simple query functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:parse_top_item]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:find_type_in_string]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:comment]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:command]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:instance|instance, paramset]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:module]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:commands]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/testing.txt:1
#, no-wrap
msgid "Testing"
msgstr ""

#. type: Plain text
#: manual/tech/testing.txt:4
msgid "This section describes Gnucap test procedures, policy, and test macros."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[test macros]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[compiling]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[code coverage testing]]\n"
msgstr ""

#. type: Title =====
#: manual/tech/test_macros.txt:1
#, no-wrap
msgid "Test Macros"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:4
msgid "Gnucap supplies a set of test macros in the file gnucap/io_trace.h ."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:6
msgid ""
"This file may be included more than once, at any place in the code, to "
"change the options."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:8
msgid ""
"All of these macros do nothing when compiled with default settings.  They "
"exist so they can be left in the code and enabled or disabled as needed by "
"developers without burdening end users with their clutter."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:9
#, no-wrap
msgid "unreachable()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:13
#, no-wrap
msgid ""
"  #define unreachable() (printf(\"@@#\\n@@@unreachable:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:15
msgid ""
"It prints the word \"unreachable\", the source file name, line number, and "
"function name."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:17
msgid ""
"Use this macro to identify blocks of code that are unreachable in normal "
"use.  Any output when the program is run indicates bugs in the code."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:19
msgid ""
"It is appropriate to question why such a block of code should exist at all.  "
"Normally, it shouldn't and should be removed.  However, there are cases "
"where a function or other code must exist to satisfy a link requirement or "
"to defeat something."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:21
msgid ""
"One example of the link requirement is member functions in a base class that "
"are overridden.  The usual recommended style is to use a \"pure virtual\", "
"but then you can't instantiate any instances unless an overriding function "
"exists.  In some cases, it is known that it is never used, but required for "
"instantiation, hence \"unreachable\"."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:23
msgid ""
"Another example is overriding default and copy constructors with the purpose "
"of preventing their use.  If you don't define one, C++ will create public "
"default and copy constructors without asking.  To prevent automatic "
"construction or copying, you could make them private, but to make it private "
"you need to define your own.  In this case, those inhibiting constructors "
"are unreachable."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:25
msgid "Usually an \"unreachable\" block can be empty except for the macro call."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:26
#, no-wrap
msgid "incomplete()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:30
#, no-wrap
msgid ""
"  #define incomplete() (printf(\"@@#\\n@@@incomplete:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:32
msgid ""
"It prints the word \"incomplete\", the source file name, line number, and "
"function name."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:34
msgid ""
"Use this macro to identify blocks of code that are known to not function "
"correctly."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:36
msgid ""
"This is intended to be used as a reminder that attention is needed here, "
"otherwise the problems could be forgotten until they show in a more "
"unpleasant way."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:37
#, no-wrap
msgid "untested()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:45
#, no-wrap
msgid ""
"  #ifdef TRACE_UNTESTED\n"
"  #define untested() (printf(\"@@#\\n@@@:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
"  #else\n"
"  #define untested()\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:47
msgid ""
"If ''TRACE_UNTESTED'' is defined, it prints the source file name, line "
"number, and function name.  Otherwise (normally) it does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:49
msgid ""
"It is used in code coverage testing, and to identify blocks of code for "
"which testing is inadequate, specifically blocks of code that are not "
"covered by the suite of test files."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:51
msgid "Such blocks of code are suspect when bugs are reported."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:52
#, no-wrap
msgid "itested()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:60
#, no-wrap
msgid ""
"  #ifdef TRACE_ITESTED\n"
"  #define itested() (printf(\"@@#\\n@@@:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
"  #else\n"
"  #define itested()\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:62
msgid ""
"If ''TRACE_ITESTED'' is defined, it prints the source file name, line "
"number, and function name.  Otherwise (normally) it does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:64
msgid ""
"It is used in code coverage testing, and to identify blocks of code for "
"which only interactive informal testing was done.  It was tested, but the "
"test suite does not cover it."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:65
#, no-wrap
msgid "trace0(), trace1(), trace2(), ...."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:74
#, no-wrap
msgid ""
"  #ifdef DO_TRACE\n"
"  #define trace0(s) (printf(\"@#@%s\\n\", s))\n"
"  #define trace1(s,x) (printf(\"@#@%s  %s=%g\\n\", s, #x, (double)(x)))\n"
"  #else\n"
"  #define trace0(s)\n"
"  #define trace1(s,x)\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:76
msgid ""
"If ''DO_TRACE'' is defined, it prints something, otherwise (normally) it "
"does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:78
msgid "''trace0'' prints a string message."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:83
#, no-wrap
msgid ""
"''trace1'' prints a string message and one argument.\n"
"  trace1(\"hello\", data);\n"
"prints:\n"
"  hello data=329232\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:85
msgid "and so on."
msgstr ""

#. type: Title ======
#: projects.txt:1
#, no-wrap
msgid "Projects"
msgstr ""

#. type: Plain text
#: projects.txt:4
msgid ""
"Gnucap is inviting anyone to take on projects.  Most of them involve "
"creating plugins.  All of them create something that is identifiably yours, "
"that will be noticed.  Most of them will stretch your skills a bit.  If you "
"want to learn about simulation, beyond what you can get at school, this is "
"the place."
msgstr ""

#. type: Plain text
#: projects.txt:6
msgid "Here are some suggestions:"
msgstr ""

#. type: Title =====
#: projects.txt:6
#, no-wrap
msgid "Interface to other free EDA software"
msgstr ""

#. type: Plain text
#: projects.txt:9
msgid ""
"The \"language plugins\" allow gnucap to read and write different netlist "
"languages.  They can also provide the capability to directly read and write "
"the formats of schematic and layout programs such as gEDA and Kicad.  Any "
"one of these is a good \"summer-of-code\" project."
msgstr ""

#. type: Plain text
#: projects.txt:11
msgid "The formats in need of support, grouped by priority:"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Free schematic formats:  <del>gEDA/gschem</del>, Kicad/eeschema, Qucs\n"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Free PCB layout formats:  gEDA/PCB, Kicad/pcbnew\n"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Proprietary formats:  Eagle, Multisim, Orcad, LTspice\n"
msgstr ""

#. type: Plain text
#: projects.txt:17
msgid "Formats that are <del>crossed out</del> are already works in progress."
msgstr ""

#. type: Plain text
#: projects.txt:19
msgid ""
"These plugins, when used with gnucap, will provide an interface for smooth "
"interoperation.  When used with gnucap's translation utility (a subset of "
"gnucap), they will provide the ability to translate from any supported "
"format to any other, and also to a Verilog based intermediate language that "
"can be used as a neutral, nonproprietary exchange format."
msgstr ""

#. type: Title =====
#: projects.txt:24
#, no-wrap
msgid "Command compatibility plugins"
msgstr ""

#. type: Plain text
#: projects.txt:27
msgid ""
"Some other simulators have a scripting language with lots of commands.  One "
"example is the \"nutmeg\" part of Spice.  Gnucap has the mechanism, but only "
"a few commands are implemented."
msgstr ""

#. type: Plain text
#: projects.txt:29
msgid ""
"A possible summer of code project would be to implement a set of these "
"commands.  One or two commands would be a very easy project, too easy for a "
"whole summer.  A bunch of these commands, would be a great project."
msgstr ""

#. type: Plain text
#: projects.txt:31
msgid ""
"These plugins, combined with \"output compatibility\" plugins will allow "
"gnucap to be used as a drop-in replacement for commercial simulators in some "
"applications."
msgstr ""

#. type: Title =====
#: projects.txt:32
#, no-wrap
msgid "Output compatibility plugins"
msgstr ""

#. type: Plain text
#: projects.txt:35
msgid ""
"The only output format supported by gnucap has been a generic ASCII format "
"that is compatible with most spreadsheets and general purpose programs like "
"octave and gnuplot.  We need more specific formats, to support some more "
"special purpose post-processor tools.  The most obvious here is a Spice "
"\"rawfile\" format.  There are both binary and ASCII formats, many of them.  "
"Some are similar enough that if you have one, a trivial change gives you "
"another.  The most requested seems to be the \"HSpice\" format, and the "
"Tiburon format, which are often used as references.  These are similar, and "
"the Spice3f5 format is close enough to be a trivial edit away."
msgstr ""

#. type: Plain text
#: projects.txt:37
msgid ""
"These plugins, combined with \"command compatibility\" plugins will allow "
"gnucap to be used as a drop-in replacement for commercial simulators in some "
"applications."
msgstr ""

#. type: Plain text
#: spectre.txt:28
msgid "The syntax is: \"model\" newname itsmaster parameters"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:33 spectre.txt:46
#, no-wrap
msgid ""
"**Arguments** : A list of arguments (parameters or values).  All arguments "
"are name - value pairs, of the form \"name = value\", whitespace delimited.  "
"In Spectre, the value may be an expression.  In gnucap, for now, the value "
"must be an actual value or parameter name.\n"
msgstr ""

#. type: Plain text
#: spectre.txt:35
#, no-wrap
msgid "  model gp-npn npn bf=150\n"
msgstr ""

#. type: Plain text
#: spectre.txt:41
msgid "All components have the same syntax:\\\\ label (port list) type arguments"
msgstr ""

#. type: Plain text
#: spectre.txt:61
#, no-wrap
msgid ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1  (base vcc) resistor r=1M   // 1 megohm\n"
"  Rb2  (base 0  ) resistor r=100k\n"
"  Rc   (col  vcc) resistor r=100k\n"
"  Re   (emit 0  ) resistor r=10k\n"
"  Ce   (emit 0  ) capacitor c=1m  // 1 millifarad\n"
"  Cin  (base in ) capacitor c=1u\n"
"  Q1 (col base emit) gp-npn\n"
"  Q2 (vcc col e2) gp-npn\n"
"  Re2  (e2   0  ) resistor r=1k\n"
"  Cout (e2   out) capacitor c=10u\n"
"  Rload (out 0  ) resistor r=rload\n"
"  ends amp\n"
msgstr ""

#. type: Plain text
#: spectre.txt:65
#, no-wrap
msgid ""
"  Vcc (vcc 0) vsource dc=15\n"
"  Vin (in  0) vsource ac=1\n"
"  Rload (out 0) resistor r=10k\n"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:99
#, no-wrap
msgid "The \"master\" must be before it is referenced.\n"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:99
#, no-wrap
msgid ""
"The circuit must be before any commands using it, unless you want to "
"simulate a partial circuit.  Scripted and interactive modifications to the "
"circuit are done the way gnucap usually does.\n"
msgstr ""

#. type: Title ======
#: start.txt:1
#, no-wrap
msgid "Gnucap Wiki"
msgstr ""

#. type: Plain text
#: start.txt:4
msgid "Gnucap is the GNU Circuit Analysis Package"
msgstr ""

#. type: Plain text
#: start.txt:6
msgid ""
"Gnucap is a modern post-spice circuit simulator with several advantages over "
"Spice derivatives."
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[about|About Gnucap, the sales pitch]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[http://gnucap.org/gnucap.html|Old web site]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[http://savannah.gnu.org/mail/?group_id=562|Mailing lists]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid ""
"Download: [[http://www.gnucap.org/devel|Development snapshots]] "
"[[http://www.gnucap.org/archive|Old stable versions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid ""
"Development: [[http://savannah.gnu.org/projects/gnucap|Savannah]] "
"[[http://git.savannah.gnu.org/cgit/gnucap.git|GIT repository]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "Help wanted: [[projects]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid ""
"[[http://gnucap.org/gnucap-man-html/index.html|Stable version (0.35) "
"manual]] [[http://gnucap.org/gnucap-man.pdf|pdf]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[manual|Snapshot manual]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[gnucap:user:user|User contributions]]\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:2
#, no-wrap
msgid "**1.ALIAS**\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:4
msgid "Purpose:Creates an alias for command"
msgstr ""

#. type: Plain text
#: user/alias.txt:6 user/alter.txt:6 user/aspice.txt:6 user/cls.txt:6 user/colon_command.txt:6 user/colon_commmand.txt:6 user/command.txt:6 user/def.txt:6 user/echo.txt:6 user/history.txt:6 user/mdump.txt:6 user/set.txt:6 user/setv.txt:6 user/shell.txt:6 user/strcmp.txt:6 user/sysinfo.txt:6 user/unalias.txt:6 user/undef.txt:6 user/version.txt:6
msgid "Status:Implemented"
msgstr ""

#. type: Plain text
#: user/alias.txt:8 user/alter.txt:9 user/colon_command.txt:8 user/colon_commmand.txt:8 user/command.txt:8 user/def.txt:8 user/echo.txt:8 user/history.txt:8 user/mdump.txt:8 user/quit.txt:8 user/shell.txt:8 user/strcmp.txt:8 user/sysinfo.txt:8 user/unalias.txt:8 user/undef.txt:8 user/version.txt:8
msgid "Syntax:"
msgstr ""

#. type: Plain text
#: user/alias.txt:10
#, no-wrap
msgid "    alias [word] [command]\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:12 user/aspice.txt:13 user/cls.txt:12 user/colon_command.txt:12 user/colon_commmand.txt:12 user/command.txt:12 user/def.txt:12 user/echo.txt:12 user/history.txt:14 user/mdump.txt:13 user/set.txt:12 user/setv.txt:12 user/shell.txt:12 user/strcmp.txt:13 user/sysinfo.txt:12 user/unalias.txt:13 user/undef.txt:13 user/version.txt:12
msgid "Comments:"
msgstr ""

#. type: Plain text
#: user/alias.txt:14
msgid "Command creates an alias for command with the name word."
msgstr ""

#. type: Plain text
#: user/alias.txt:16 user/alter.txt:18 user/aspice.txt:19 user/colon_command.txt:16 user/colon_commmand.txt:16 user/command.txt:16 user/def.txt:16 user/echo.txt:16 user/history.txt:18 user/mdump.txt:17 user/netlist_import_and_export.txt:123 user/noise_implementation.txt:30 user/noise_syntax.txt:19 user/quit.txt:15 user/set.txt:16 user/setv.txt:16 user/shell.txt:18 user/strcmp.txt:17 user/sysinfo.txt:16 user/unalias.txt:19 user/undef.txt:17 user/version.txt:16
msgid "Example:"
msgstr ""

#. type: Plain text
#: user/alias.txt:24
#, no-wrap
msgid ""
"     gnucap>alias info sysinfo\n"
"     gnucap>info\n"
"     Model name\t        : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"     OS Description     :\"Ubuntu 12.04 LTS\"\n"
"     CPU MHz\t        : 2494.409\n"
"     RAM Available      :1012348kB\n"
"     RAM Free           :132372kB\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:2
#, no-wrap
msgid "**13.ALTER**\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:4
msgid "Purpose:Command is used to change the value of a parameter."
msgstr ""

#. type: Plain text
#: user/alter.txt:12
#, no-wrap
msgid ""
"      alter\n"
"      alter parameter-name value\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:15
msgid "Comments:Sets the value of specified parameter"
msgstr ""

#. type: Plain text
#: user/alter.txt:20
msgid "To modify the value of vcc in a ciruit"
msgstr ""

#. type: Plain text
#: user/alter.txt:23
#, no-wrap
msgid ""
"      gnucap>alter vcc = 15\n"
"      gnucap>\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:25
msgid "and to modify the resitances say R1 and R2"
msgstr ""

#. type: Plain text
#: user/alter.txt:28
#, no-wrap
msgid ""
"       gnucap>alter R1=5k R2=100\n"
"       gnucap>\n"
msgstr ""

#. type: Plain text
#: user/another_page.txt:1
msgid "not another page"
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:2
msgid "====Why Asco?===="
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:4
msgid ""
"[[http://asco.sourceforge.net|Asco]] is a small C program that implements "
"several numerical optimizers and interfaces to some circuit simulators. asco "
"(version 0.4.8) does not particularly support gnucap as a backend, but "
"rather provides a generic interface to any program that processes text "
"somehow."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:6
msgid ""
"while the functionality of asco could well be integrated into gnucap, it "
"seems easier to do it this way. also it always makes sense to provide "
"alternatives, considering that asco is quite worthless without a "
"simulator. otoh, asco then can be use to benchmark gnucap, motivate "
"measurement extensions for gnucap etc."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:8
msgid "====Implementation===="
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:10
msgid ""
"the proposed implementation "
"[[git://tool.em.cs.uni-frankfurt.de/git/asco|here]] works with gnucap. some "
"provided examples (inv, amp3) are adapted accordingly. here, in contrast to "
"asco-0.4.8, the simulator is running interactively. this not only runs much "
"faster (skipping extra initialization), but also is simpler to use, as much "
"less input needs to be generated, and less output needs to be processed."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:13
msgid ""
"gnucap needs to be patched to not throw (debug) garbage to stdout.  that "
"might improve with output plugins. of course some problems arise from using "
"spice (as a 'language')."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:14
msgid ""
"this approach (and asco in general) needs a lot of work. this is a place to "
"start..."
msgstr ""

#. type: Plain text
#: user/aspice.txt:2
#, no-wrap
msgid "**23.ASPICE**\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:4
msgid ""
"Purpose:Start an asynchronous run and loads the data to specified output "
"file."
msgstr ""

#. type: Plain text
#: user/aspice.txt:9
#, no-wrap
msgid ""
"Syntax:\n"
"      aspice input_file output_file\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:15
msgid ""
"input_file is a file which is to be run in batch mode and output_file "
"corresponds to the file on which data will be loaded.If output_file already "
"exists then the contents of the file are overwritten by the current output."
msgstr ""

#. type: Plain text
#: user/aspice.txt:21
msgid ""
"Suppose my script file contains an instruction to execute the version "
"command.Then,command to get the output of the script into another file say, "
"version.txt is"
msgstr ""

#. type: Plain text
#: user/aspice.txt:26
#, no-wrap
msgid ""
"      gnucap>aspice script version.txt\n"
"      Gnucap\n"
"      Main version: 2009.12.07 RCS 26.136\n"
"      gnucap>\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:28
msgid "Now,version.txt contains the output of version command."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:2
msgid ""
"compling/installing/loading plugins must be as easy as possible. there are "
"three kinds of modules that need to taken into account."
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Plugins shipped and installed within gnucap\n"
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Device models, compiled locally, simulation based\n"
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Plugins from other sources, compiled out-of-tree, installable.\n"
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:8
msgid ""
"Assume (upstream) gnucap ships a plugin (s_fancy.so). what would a user want "
"to do? load it. that means, she expects the command \"load s_fancy.so\" to "
"load the module, just like she would type \"modprobe fancy\" when loading a "
"kernel module. thus, two things must match: the path where plugins are "
"installed to, and the path where gnucap is looking for modules. the install "
"path is nothing seriously exotic, and already implemented in autotools, it's "
"called \"pkglibdir\". gnucap uses 'dlopen' (see dlopen(3)) to load "
"modules. that means it looks for dynamic libraries, where the system keeps "
"dynamic libraries, which is in /lib, /usr/lib etc. the common way to make it "
"look for modules in pkglibdir is linking with the rpath flag, which sets "
"RPATH, see chrpath(1). basically this means, the path where plugins lie "
"around is hardcoded in the gnucap binary. which totally makes sense, esp. if "
"you want to have more than one gnucap, lets say for developing purposes."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:10
msgid ""
"in order to compile a device model, we need to know where the headers "
"are. usually the preprocessor looks for them in /usr/include, but that's "
"_not_ where we want them to be. so gnucap better ships an executable that "
"simply tells us the search path, or alternatively the CPPFLAGS we need to "
"pass to the preprocessor. this executable could be a shell script that takes "
"a switch and prints a line accordingly. needless to say that gnucap must "
"install headers for this to work."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:12
msgid ""
"how would you want to install plugins from other sources? as simple as "
"possible: wget plugin.tbz2; tar -xf !$; cd plugin; less README; "
"./configure_orwhateverelse; make install. the problem: we need to know where "
"to install to. probably 'chrpath $(which gnucap) | sed -e s/.*RPATH=//' is "
"not portable. so we add a switch to the script above that makes it print "
"pkglibdir."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:14
msgid ""
"(for everyone who has ever compiled (linux) kernel modules: yes, it would be "
"nice to have makefiles for staged plugins, but this totally looks like "
"overkill to me)"
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:18
msgid ""
"and finally, this has been implemented already: there are some repos on "
"git://tool.em.cs.uni-frankfurt.de/git/ \"gnucap\" contains a branch "
"\"gnucap+dev\" with minimal changes above 0.36 to make this work.  in "
"\"gnucap-geda\" (master) i've packed lang_gschem that way. \"gnucap-adms\" "
"(\"master\") contains a model compiler (in \"master\") that ships 2 example "
"plugins and an out-of-tree compile helper script."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:19
msgid ""
"some plugins need upstream changes or forked gnucap versions. the best way "
"would be to have the plugin build system just check for a particular hack "
"and give up with a notice (not implemented yet)."
msgstr ""

#. type: Plain text
#: user/circbyline.txt:2
#, no-wrap
msgid "**21.CIRCBYLINE**\n"
msgstr ""

#. type: Plain text
#: user/circbyline.txt:4
msgid "Purpose:Enter a circuit line by line."
msgstr ""

#. type: Plain text
#: user/circbyline.txt:5 user/rmcirc.txt:5 user/run.txt:5 user/showmod.txt:5 user/source.txt:5
msgid "Status:Done"
msgstr ""

#. type: Plain text
#: user/cls.txt:2
#, no-wrap
msgid "**CLS**\n"
msgstr ""

#. type: Plain text
#: user/cls.txt:4
msgid "Purpose:Clears the gnucap interpreter"
msgstr ""

#. type: Plain text
#: user/cls.txt:10
#, no-wrap
msgid ""
"Syntax:\n"
"      cls\n"
"      cls [command]\n"
msgstr ""

#. type: Plain text
#: user/cls.txt:15
msgid ""
"A command can be issued with cls,it first clears the interpreter and then "
"run th command.  A bare cls simply clears the interpreter."
msgstr ""

#. type: Plain text
#: user/cls.txt:18
msgid ""
"Example: Following command first clears the screen and then runs the command "
"'sysinfo'."
msgstr ""

#. type: Plain text
#: user/cls.txt:25
#, no-wrap
msgid ""
"       gnucap>cls sysinfo\n"
"       Model name\t  : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"       OS Description     :\"Ubuntu 12.04 LTS\"\n"
"       CPU MHz\t          : 2494.409\n"
"       RAM Available      : 1012348kB\n"
"       RAM Free           : 132372kB\n"
"       gnucap>\n"
msgstr ""

#. type: Title ===
#: user/code-related_stuff.txt:1 user/noise_implementation.txt:53
#, no-wrap
msgid "Code related stuff"
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:4 user/noise_implementation.txt:56
msgid ""
"Currently noise simulation is implemented as plugin which is available at "
"github at the following [[ https://github.com/gserdyuk/gnucap-plugins | link "
"]]"
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:6 user/noise_implementation.txt:58
msgid "It re-uses s_ac.cc file (ac simulation) to implement noise analysis."
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:8 user/noise_implementation.txt:60
msgid ""
"At the present moment (April 2011) noise works with only "
"[[https://github.com/gserdyuk/gnucap-a | gnucap-a]] branch of gnucap, but "
"hopefully soon it will work with main trunk too."
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:9 user/noise_implementation.txt:62
msgid "[TBD - make description of the noise code]"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:2 user/colon_commmand.txt:2 user/command.txt:2
#, no-wrap
msgid "**20. '':'' Command**\n"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:4 user/colon_commmand.txt:4 user/command.txt:4
msgid ""
"Purpose: command : issued with multiple commands separated by semi-colon "
"runs each command one by one."
msgstr ""

#. type: Plain text
#: user/colon_command.txt:10 user/colon_commmand.txt:10 user/command.txt:10
#, no-wrap
msgid "     : command_1;command_2;.....;command_n\n"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:14 user/colon_commmand.txt:14 user/command.txt:14
msgid ""
"Any number of commands may be passes to the : command. Shell commands passed "
"with ! command are not executed.Like, :!ls will fail to run."
msgstr ""

#. type: Plain text
#: user/colon_command.txt:26 user/colon_commmand.txt:26 user/command.txt:26
#, no-wrap
msgid ""
"      gnucap>: ver\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      gnucap>: ver;echo \"Hello World!\"\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      Hello World!\n"
"      gnucap>: strcmp \"Hello\" Hello;def f;shell\n"
"      flag=0\n"
"      >x^2+y^2\n"
"      itsrishre@rishabh-laptop:~$exit\n"
"      gnucap>\n"
msgstr ""

#. type: Title ======
#: user/command_plugins.txt:1
#, no-wrap
msgid "Commands Checklist"
msgstr ""

#. type: Plain text
#: user/command_plugins.txt:6
msgid ""
"Gnucap commands are defined by plugins.  This section defines all commands "
"supplied in the gnucap-WIP branch."
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:13
#, no-wrap
msgid "[[MDUMP]] - Prints the dc tran matrix values.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:15
#, no-wrap
msgid ""
"[[RMCIRC]] - Removes the current circuit from the list of circuits sourced "
"into gnucap.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:17
#, no-wrap
msgid "[[CIRCBYLINE]] - Enter a circuit line by line.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:19
#, no-wrap
msgid "[[PRE]] - Executes command prior to parsing the circuit.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:21
#, no-wrap
msgid "[[TRACE]] - Command is used to trace nodes.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:27
#, no-wrap
msgid "[[SHOWMOD]] - Lists model parameter values.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:29
#, no-wrap
msgid "[[ALTER]] - Change parameters\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:35
#, no-wrap
msgid "[[SOURCE]] - Loads a gnucap input file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:37
#, no-wrap
msgid "[[HISTORY]] - Review the previous commands.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:39
#, no-wrap
msgid "[[RUN]] - Run the silumation as specified in the input file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:41
#, no-wrap
msgid ""
"[[ASPICE]] - Start an asynchronous run and loads the data to specified "
"output file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:49
#, no-wrap
msgid "[[ALIAS]] - Creates an alias for command.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:51
#, no-wrap
msgid "[[CLS]] - Clears the gnucap interpreter.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:53
#, no-wrap
msgid "[[DEF]] - Command is used to define a function.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:55
#, no-wrap
msgid "[[ECHO]] - Prints the text.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:57
#, no-wrap
msgid "[[QUIT]] - Terminates the gnucap interpreter.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:59
#, no-wrap
msgid "[[SETV]] - Sets the value of a variable.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:61
#, no-wrap
msgid "[[SHELL]] - Calls the command interpreter of operating system.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:63
#, no-wrap
msgid "[[STRCMP]] - Compares two string.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:65
#, no-wrap
msgid "[[SYSINFO]] - Command prints the system information.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:67
#, no-wrap
msgid "[[UNALIAS]] - Removes the definition for each alias name specified.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:69
#, no-wrap
msgid "[[UNDEF]] - Command removes the the user-defined functions.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:71
#, no-wrap
msgid "[[VERSION]] - Prints the version of gnucap being used.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:73
#, no-wrap
msgid ""
"[[Colon Command]] - Command '':'',a colon, issued with multiple commands "
"separated by semi-colon runs each command one by one.\n"
msgstr ""

#. type: Plain text
#: user/command_plugins.txt:74
#, no-wrap
msgid ""
"*//Commands's Syntax,Details and Examples will be added after the command is "
"implemented.//\n"
msgstr ""

#. type: Plain text
#: user/def.txt:2
#, no-wrap
msgid "**2.DEF**\n"
msgstr ""

#. type: Plain text
#: user/def.txt:4
msgid "Purpose:Command is used to define a function."
msgstr ""

#. type: Plain text
#: user/def.txt:10
#, no-wrap
msgid "    def [function_name]\n"
msgstr ""

#. type: Plain text
#: user/def.txt:14
msgid ""
"Maximum three arguments can be provided which can be of type int or "
"float.Variables are named x,y,z by default and only these variables should "
"be used in the expression."
msgstr ""

#. type: Plain text
#: user/def.txt:27
#, no-wrap
msgid ""
"      gnucap>def f\n"
"      >x*2+y*2+z*2\n"
"      gnucap>f(1,2,3)\n"
"      12.\n"
"      gnucap>f(1.0,2.2,3.4)\n"
"      13.2\n"
"      gnucap>def max\n"
"      >(x>y)*x+(x<=y)*y\n"
"      gnucap>max(3.0,4.0)\n"
"      4.0\n"
"      gnucap>\n"
msgstr ""

#. type: Title ======
#: user/details_of_geda_plugin.txt:1
#, no-wrap
msgid "Details of the implementation of the gEDA/gschem plugin======"
msgstr ""

#. type: Plain text
#: user/details_of_geda_plugin.txt:19
#, no-wrap
msgid ""
"=====Introduction=====\n"
"The plugin for parsing and printing schematic files in the gEDA/gschem "
"format is at <sup>[1]</sup> "
"[[https://github.com/sksavant/gnucap/tree/lang_gschem/|Github "
"branch]]. \\\\\n"
"Get it by cloning the git repo : //git clone git@github.sksavant/gnucap.git "
"--branch lang_gschem//\n"
"or get this zip file : "
"[[https://github.com/sksavant/gnucap/zipball/lang_gschem|zipfile]]\n"
"\\\\ \\\\\n"
"If you already have latest snapshot of gnucap installed you just need to get "
"the following files: '//src/lang_gschem.cc//', '//src/d_net.cc//', "
"'//src/d_place.cc//'. Also some "
"[[https://github.com/sksavant/gnucap/compare/al...lang_gschem#diff-53|change]] "
"is need in lang_verilog.cc to print verilog code correctly.\n"
"Some examples are present in '//geda/examples/ //'\n"
"\\\\ \\\\\n"
"After getting the files compile the plugin with the following command: "
"\\\\\n"
"    g++ -DHAVE_GEDA -shared -fPIC -o lang_geda.so lang_geda.cc d_net.cc "
"d_place.cc  $(pkg-config --cflags gtk+-2.0 --libs libgeda)\n"
"And load it after running gnucap as follows: \\\\\n"
"    gnucap>load ./lang_geda.so\n"
"This line can be added to '~/.gnucaprc' to load the plugin every time gnucap "
"starts. \\\\\n"
"Switch the language to gEDA/gschem with the following command:\n"
"    gnucap>option lang=gschem OR\n"
"    gnucap>gschem\n"
msgstr ""

#. type: Plain text
#: user/details_of_geda_plugin.txt:44
#, no-wrap
msgid ""
"=====How parsing works in lang_geda=====\n"
"When the command 'gschem' is given, "
"[[http://sksavant.github.com/gnucap/d0/d46/classanonymous__namespace_02lang__geda_8cc_03_1_1_c_m_d___g_s_c_h_e_m.html#a3a2cad7bedd3a820604937467e020369|CMD_GSCHEM::do_it]] "
"is called.\n"
"After setting the language to gschem,  "
"[[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a164f7c8baeadf6b7acfca754153a45b5|parse_top_item]] "
"is called, which will call "
"[[http://sksavant.github.com/gnucap/d8/d92/class_l_a_n_g_u_a_g_e.html#a1ecab49c51a0f6d914170c04edb420a8|new__instance]] "
"after getting a line from the command stream. \\\\\n"
"Now depending on the type of the line parsed, which is found from "
"[[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#af6b409e3eb2cf7d30080fbb989e0989d|find_type_in_string]], "
"corresponding parse_.. function is called.\n"
"If a //command// or //dev_comment// is got, "
"[[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a6c16c20ae8bb07669183e0a3a6c87da8|parse_command]] "
"or "
"[[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a23093bf34decc6675ef6b917829c491c|parse_comment]] "
"is called respectively. \\\\ \\\\\n"
"If component is found, then "
"[[http://sksavant.github.com/gnucap/d2/d22/classanonymous__namespace_02lang__geda_8cc_03_1_1_c_m_d___c.html#a7c6d49a0e81fde05d6f402ac895596f5|CMD_C::do_it]] "
"is called, which\n"
"  * creates a new empty placeholder model (MODEL_SUBCKT)\n"
"  * calls "
"[[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#abb190d7c72473be3e72c16323673e73e|parse_componmod]] "
"which will\n"
"    * get the symbol file name\n"
"    * parse the symbol file and set the ports by name\n"
"    * resets the cmd\n"
"    * returns NULL if the model is not needed i.e, it is graphical\n"
"  * If the model is not graphical ,push back into the CARD_LIST\n"
"  * set componentname as the label of the model and componentmod as false "
"and call new<nowiki>__</nowiki>instance.\n"
"If net or place or any other is got, parse_instance is called which will "
"call respective parse_ functions.\\\\\n"
"When parse_net is called it will :\n"
"  * Get the x y coordinates of the two ports\n"
"  * parse the symbol file\n"
"  * Call create_place which will create a CS with the place parameters and  "
"parse it through new<nowiki>__</nowiki>instance.\n"
"  * Check if there are any attributes after this line, parse them into "
"set_param_by_name '{..}\n"
"If a component is got, call parse_component which will :\n"
"  * Get the position, angle, mirror flag and the symbol file name of the "
"component\n"
"  * Parse the symbol file associated with the component to get the ports and "
"get the ports' coordinates relative to the component.\n"
"  * Depending on the angle and mirror flag, get the absolute position of the "
"ports of the component, create a new place with the position of nodes and "
"call set_port_by_index to set the ports\n"
"  * Check if there are any attributes after this line, parse them into "
"set_param_by_name '{..}\n"
msgstr ""

#. type: Plain text
#: user/discussions.txt:15
#, no-wrap
msgid ""
"is there a need for s_noise.cc? noise seems to be just about probes.\n"
"in e_aux.h a function like\n"
"<code cpp>\n"
"inline COMPLEX port_noise(const node_t& n1, const node_t& n2){\n"
"  std::fill_n(CKT_BASE::_sim->_sens, 1*CKT_BASE::_sim->_total_nodes+1, 0);\n"
"  CKT_BASE::_sim->_sens[n1.m_()] = 1;\n"
"  CKT_BASE::_sim->_sens[n2.m_()] = -1;\n"
"  CKT_BASE::_sim->_acx.fbsubt(CKT_BASE::_sim->_sens); // use Gennadys "
"transposed fbsub\n"
"  double a = CARD_LIST::card_list.do_noise();\n"
"  return a;\n"
"}\n"
"</code>\n"
"could be used to probe the noise (called in e_element.cc and e_node.cc just "
"like port_impedance is called).\n"
"of course an array with sensitivity data needs to be added to SIM, also "
"do_noise() must sum up all noise contributions like in Gennadys "
"implementation.\n"
msgstr ""

#. type: Plain text
#: user/discussions.txt:17
msgid ""
"imo noise simulation is a bad candidate for a plugin, as there seems to be "
"no way to make it work without changing internals. once noise works, a "
"plugin that implements spice command compatibility might make more sense."
msgstr ""

#. type: Plain text
#: user/discussions.txt:18
msgid "--felixs"
msgstr ""

#. type: Plain text
#: user/echo.txt:2
#, no-wrap
msgid "**3.ECHO**\n"
msgstr ""

#. type: Plain text
#: user/echo.txt:4
msgid "Purpose:Prints the text"
msgstr ""

#. type: Plain text
#: user/echo.txt:10
#, no-wrap
msgid "     echo [text]\n"
msgstr ""

#. type: Plain text
#: user/echo.txt:14
msgid "Command echoes the text in the interpreter."
msgstr ""

#. type: Plain text
#: user/echo.txt:23
#, no-wrap
msgid ""
"     gnucap> echo\n"
"     Usage: echo [text]\n"
"     gnucap>echo \"Hello\"\n"
"     \"Hello\"\n"
"     gnucap>echo Hello World!\n"
"     Hello World!\n"
"     gnucap>\n"
msgstr ""

#. type: Title ===
#: user/gnucap_linear_solver.txt:1
#, no-wrap
msgid "GNucap Linear Solver"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:3
msgid ""
"Gnucal linear solver is implemented in file m_matrix.h - that is C++ "
"template."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:6
msgid ""
"Most things are depicted in very extensive comments to this file.  Some "
"things which are discovered and are listed here."
msgstr ""

#. type: Title ==
#: user/gnucap_linear_solver.txt:7
#, no-wrap
msgid "No zero diagonal element allowed"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:10
msgid "Solver has an issue if diagonal element is zero. lets consider system:"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:16
#, no-wrap
msgid ""
"<code>\n"
"  | eps   -1|        | -1 |\n"
"  |         | *X  =  |    |\n"
"  | 10   -10|        |  0 |\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:18
msgid ""
"if eps =0 or close to 0 (like 1.e-20 or so) current solver gives wrong "
"answer of {1,0}."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:20
msgid "having eps=1.e-6 answer id ok = {1,1}"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:22
msgid ""
"This may be explained that during LU decomposition with no permutations with "
"very small eps some values may grow higher 1/machine_eps and mask "
"significant digits."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:26
msgid ""
"Practical advice: Do not use .options gmin smaller than 1.e-6 .. 1.e-8 "
"unless you know what you do.  With current solver in my distort results ."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:28
msgid "Note - spice circuit which creates this system:"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:38
#, no-wrap
msgid ""
"<code>\n"
"* circuit - close to Rozenbrok\n"
".options nobypass\n"
".options gmin = 1.e-6\n"
"* i1 = 10 *( v2 - v1^2)\n"
"* i2 = 1 - v1\n"
"*\n"
"I1  1 0      dc 0\n"
"G11 1 0 1 0  -10\n"
"G11 1 0 2 0   10\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:41
#, no-wrap
msgid ""
"G21 2 0 1 0   -1\n"
"I2  2 0      dc 1\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:43
msgid ".print op v(1) v(2) i(I1) i(I2)"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:46
msgid ".op .end"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:47 user/language_plugin_for_gschem.txt:160
msgid "</code>"
msgstr ""

#. type: Title ===
#: user/gnucap_nonlinear_solver.txt:1
#, no-wrap
msgid "Gnucap Nonlinear Solver"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:4
msgid ""
"This sections will describe my (gserdyuk) analysis of gnucap nonlinear "
"solver, comparison of it to classic Newton notation and notes which will "
"appear on the course of the study."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:5
#, no-wrap
msgid "Classic Newton Notation"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:8
msgid "Let us consider vector system of equations"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:10
msgid "'' F = Y*X + N(X) + I =0 (1) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:16
#, no-wrap
msgid ""
"where\n"
"  * Y - linear matrix (here - impedance)\n"
"  * X - unknows (here - node voltages)\n"
"  * N(X) - currents of nonlinear branches\n"
"  * I - free vector\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:18
msgid "To solve that simultaneous equations with newton algorithms:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:20
#, no-wrap
msgid "''F_c = F(X_c)                  (2)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:22
#, no-wrap
msgid "''S_c = inv(dF/dX)*F_c;         (3)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:24
#, no-wrap
msgid "''X_n = X_c-S_c;                (4)''\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "X_c - current vector of independent values\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "F_c - current value of nonlinear function  (1)\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "S_c - step at current iteration\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "dF/dX = J - jacobian matrix, calculated at value X_c\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "X_n - vector of independent values at next step\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:32
msgid ""
"Note - this formula does not contain damp factor - it will e considered "
"later"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:34
msgid "Such series of X_c have to converge to solution point X_* where F(X_*)=0."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:35
#, no-wrap
msgid "Newton in Gnucap - simplest case"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:38
msgid ""
"//Simplest case of Newton method in gnucap - no damping, no incremental "
"calculation.//"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:40
msgid ""
"Gnucap uses a bit modified formulation of formulas (2) - (4) to solve same "
"equations (1)."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:42
#, no-wrap
msgid "'' FG(X) = dN/dX*X_c-N(X)-I;     (5) ''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:44
#, no-wrap
msgid "'' FG_c  = FG(X_c) ;         (6) ''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:46
msgid "'' X_n = inv(J)*FG = inv(J)*(dN/dX*X_c-N-I) ; (7) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:48
msgid "'' J = dF/dX ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:50
msgid "'' where FG, dF/dx, dN/dX and N are calculated in point X_c ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:56
#, no-wrap
msgid ""
"namely:\n"
"  - a) Modified error function does not contain linear term Y*X;\n"
"  - b) Jacobian in gnucap formulation is the same as in original formulation "
"( dF/dx, not dFG/dx ) ;\n"
"  - c) solution of equaton (7) gives new X point instead of the newtonian "
"step.\n"
"  - d) values dN/dX(X_c) - N(X_c) are calculated from each device whoich "
"operation point is changed - so it saves computation resources.\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:58
msgid "Indeed. Lets make substitutions:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:60
msgid "'' X_n = X_c-inv(J)*F = X_c-inv(J)*(I+N+Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:62
msgid "'' = inv(J)*J*X_c-inv(J)*(I+N+Y*X_c) = inv(J)*(J*X_c-I-N-Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:64
msgid "'' = inv(J)*(dN/dX*X_c+Y*X_c-I-N-Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:66
msgid "finally"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:68
msgid "'' = inv(J)*(dN/dX*X_c-I-N); ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:71
msgid "Where all values J, dN/dX, N are caluclaed in point X_c Note that"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:73
msgid "'' J= dF/dX = dN/dX+Y (8) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:75
msgid "This has some consequences (see below)."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:76
#, no-wrap
msgid "Damping"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:78
msgid "Damped Newton instead of update formula (4) uses smaller step:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:80
#, no-wrap
msgid "''X_n = X_c-k_c*S_c;                (9)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:82
msgid "where k is damping factor."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:84
msgid ""
"There is formal proof that process (9) converges globally under certain "
"conditions and keeps quadratic convergence rate if k=1."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:86
msgid ""
"I.e. at the some iteration \"current\", when next point X_n is calculated, "
"reduced step is used. After that, F and J are caclulated exactly at value "
"X_n."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:87
#, no-wrap
msgid "Damping in Gnucap"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:90
msgid "Gnucap implements somehow modified approach here too."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:92
msgid ""
"When X_n is calculated, Gnucap computes element parameters at value X_n, but "
"then calculates FG and J as:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:94
msgid "''FG_n = (1-k)*FG(X_c) + k*FG(X_n)  (10)''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:96
#, no-wrap
msgid "''J_n  = (1-k)*J(X_c)  + k*J(X_n)   (11)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:98
msgid "Thus FG_c and J_c are linear interpolation between FG(X_c)=FG_c and FG_n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:100
msgid "But should be"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:102
#, no-wrap
msgid "''FG_c=FG( (1-k)*X_c+k*X_n )       (12)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:104
msgid "Same for Jacobian."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:106
msgid ""
"This excludes from consideration higher order derivatives of F(X) and "
"(partially)  reduces sense of dumping."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:108
msgid ""
"//NB. This is my understanding of Gnucap gumping. If somebody have different "
"opinion - please post it here.//"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:111
msgid ""
"Currently is planned to implement solver which will use 12 instead of "
"10,11. I will report results of numeric experiments."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:113
#, no-wrap
msgid "Calculation of Error function and error norm"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:117
msgid ""
"To implement linear search along Newtonian direction it is desired to have "
"strict measure - is next point is better than current or not.  Such measure "
"can be F or ||F|| - indeed - at solution point we have F=0 and ||F||=0."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:119
msgid ""
"Unfortunately Gnucap formulation does not give F, but rather calculate FG, "
"which does not tend to zero as X_c -> X*. So - new measure has to eb "
"introduced."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:121
msgid "To calculate F we can use the following formula:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:123
#, no-wrap
msgid "''F_c = J_c * X_c - FG   (13)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:125
msgid ""
"This will require keeping original Jacobian matrix. In case of incremental "
"processing it may mean an issue - we will investigate incremental processing "
"later"
msgstr ""

#. type: Title ===
#: user/gnucap_nonlinear_solver.txt:127
#, no-wrap
msgid "Other Sections"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:130
msgid ""
"[[NewtonNumericExample1 | Newton Numeric Example ]] - compares standard and "
"modified newton steps; damped step"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:132
msgid ""
"[[ProgramingDetails | Programing Details ]] - describe programming details "
"of solver"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:134
msgid ""
"[[QueuesAndOPtBypass | Queues and OPT::bypass ]] - covers **bypass** mode "
"and queues"
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:3
msgid ""
"The verilog-ams specification adds on to the verilog, (IEEE-1364-2001 or "
"IEEE-1364-2005), versions.  I will be testing cross workability with Icarus "
"Verilog of the same spec year."
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:7
msgid ""
"I'm not sure yet which verilog-ams version we will use to match up with "
"netlist verilog, and not sure about needing to read the IEEE verilog specs "
"-- they're not freely available.  Acellera.org free publishes Verilog-AMS "
"Language Reference Manual, Release 2.3.1 last changed June 1, 2009."
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:9
msgid ""
"It may be that running a quick sanity test of netlists with icarus verilog "
"will catch blunders as well as reading IEEE-1364-2005."
msgstr ""

#. type: Plain text
#: user/history.txt:2
#, no-wrap
msgid "**4.HISTORY**\n"
msgstr ""

#. type: Plain text
#: user/history.txt:4
msgid "Purpose:Review the previous commands"
msgstr ""

#. type: Plain text
#: user/history.txt:12
#, no-wrap
msgid ""
"    history\n"
"    history -t\n"
"    history -s\n"
msgstr ""

#. type: Plain text
#: user/history.txt:16
msgid ""
"Command prints the history of commands that has been executed after enabling "
"the history track mode. Commands tracking can be stopped by disabling the "
"history mode."
msgstr ""

#. type: Plain text
#: user/history.txt:21
#, no-wrap
msgid ""
"      gnucap>history -t  starts tracking history\n"
"      gnucap>history     prints the history\n"
"      gnucap>history -s  stops tracking history\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:3
msgid ""
"the gnucap ''bm_'' framework can be used to plug in impulse response filters "
"to elements.  with these, filtering is as simple as this:"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:10
#, no-wrap
msgid ""
"  spice\n"
"  .model sfir fir coefs=(1,0,-1,1,1,1,1,0,0,-1) step=1m\n"
"  .model sir int_filter step=0.1m\n"
"  v1 nin 0 1\n"
"  e1 nout 0 nin 0 sfir\n"
"  e2 nint 0 nin 0 sir\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:14
#, no-wrap
msgid ""
"  .print tran v(nin) v(nint) v(nout) Vout(e1)\n"
"  .tran 0 2m 0.02m basic\n"
"  .end\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:16
msgid ""
"here ''sfir'' is a finite impulse reponse filter with 10 "
"coefficients. ''sir'' is an integrating filter, which is implemented "
"similarly to the other ''iirs'' (but more efficient). in ac analysis, the "
"filter transfer function can be computed using libfftw."
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:18
msgid ""
"these filters can also be used to generate alpha-noise from white "
"noise. gnucap could get this in a netlist:"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:25
#, no-wrap
msgid ""
"  V0   n0   0 noise r=1 amp=0.1 step=0.1m alpha=0\n"
"  V0.5 n0.5 1 noise r=1 amp=0.1 step=0.1m alpha=0.5\n"
"  V1   n1   2 noise r=1 amp=0.1 step=0.1m alpha=1\n"
"  V1.5 n1.5 3 noise r=1 amp=0.1 step=0.1m alpha=1.5\n"
"  V2   n2   4 noise r=1 amp=0.1 step=0.1m alpha=2\n"
"  V2.5 n2.5 5 noise r=1 amp=0.1 step=0.1m alpha=2.5\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:27
msgid ""
"unfortunately if alpha!=0 and alpha!=2, this is inefficient, but at least "
"its not as ugly as precalculating noise."
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:28
msgid ""
"the implementation on [[git://tool/git/gnucap|tool]] (git repo) works, and "
"is slightly incomplete (but was fun to write)."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:2
msgid "=====Language Plugin for schematic files of GSchem ====="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:8
msgid ""
"====Introduction==== The plan <sup>[1]</sup> is to write a plugin for Gnucap "
"to support schematic files from gEDA/gschem <sup>[2]</sup>.  Schematics are "
"graphical representation of circuits using abstract symbols showing "
"components and their connections. \\\\ The idea for netlist import and "
"export is at the wiki page : [[Netlist import and export]] \\\\ The "
"technical details on on how this gEDA/gschem plugin is implemented is at the "
"page: [[Details of gEDA plugin]]"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:12
msgid ""
"====How to parse schematics==== The schematic files are converted into "
"verilog netlist.  The steps involved in parsing the schematic are described "
"below, as observed by working out a few examples manually :"
msgstr ""

#. type: Title ===
#: user/language_plugin_for_gschem.txt:12
#, no-wrap
msgid "Identifying components"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Search for the identifier \"C\" at the start of the line.\n"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid ""
"Search for the device name of the component. If device=none or graphical=1 "
"(in the symbol file of the component), then ignore it as it doesn't have any "
"electrical significance [3]. Else, index them in the order of their "
"occurrence in the schematic.\n"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid ""
"Get the name and value of the attributes associated with the components "
"recognized by index of the component.\n"
msgstr ""

#. type: Title ===
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Positioning the nodes and pins==="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:40
#, no-wrap
msgid ""
"  - Get the components' placement information from the schematic and using "
"the placement of the components and the relative position of pins from the "
"symbol file of the component, get the positions of active edges of the pins "
"of all the components.\n"
"  -For each component, get the pins' active edge's relative coordinates are "
"in the symbol file say (px,py).Then execute the logic as shown below to get "
"the position of the pins. (Say component position is (cx,cy))\n"
"  - Create a `ifdef directive to write the placement of nodes in it. Nodes "
"are placed at the corresponding pins from which they originate. 'place' in "
"verilog has attributes x,y corresponding to x-coordinate and y-coordinate of "
"the nodes' placement.\n"
"<code python>\n"
"     if mirror_flag==0:\n"
"       if angle==0:\n"
"         (pxn,pyn)=(cx,cy) + (+px,+py)\n"
"       elif angle==90:\n"
"         (pxn,pyn)=(cx,cy) + (-py,+px)\n"
"       elif angle==180:\n"
"         (pxn,pyn)=(cx,cy) + (-px,-py)\n"
"       elif angle==270:\n"
"         (pxn,pyn)=(cx,cy) + (+py,-px)\n"
"     elif mirror_flag=1:\n"
"       if angle==0:\n"
"         (pxn,pyn)=(cx,cy) + (-px,+py)\n"
"       elif angle==90:\n"
"         (pxn,pyn)=(cx,cy) + (-py,-px)\n"
"       elif angle==180:\n"
"         (pxn,pyn)=(cx,cy) + (+px,-py)\n"
"       elif angle==270:\n"
"         (pxn,pyn)=(cx,cy) + (+py,+px)\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:47
#, no-wrap
msgid ""
"===Writing nets between pins===\n"
"  - Search for nets in schematics identified by \"N\" at start of line.\n"
"  - For each net get the two co-ordinates it is connecting. If there are "
"already nodes at those co-ordinates, create a net with those nodes as "
"endpoints. Else create some name for the new node and save the node.\n"
"  - Check the placement of the nodes to see if any nodes are implicitly "
"connected, i.e, if they have same co-ordinates. If True, create a net "
"between them\n"
"  - Go through all nets and check all the nodes(except those the net ends "
"in), if they are on that net. If True, create a net from the node to one of "
"the end-nodes of the net.\n"
"  - Complex nets can be simplified but don't need to be. If done, resulting "
"schematic from this netlist on re-conversion differs.\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:51
msgid ""
"The [[https://docs.google.com/open?id=0B7mgwfV1A9p5aURQNENjM3ZLdWs|Flow "
"Chart]] for parsing the schematic is as follows : {{ "
"gnucap:user:gschemparsing_color_flow_chart.png?1000X1300 }}"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:158
#, no-wrap
msgid ""
"====Example of parsing:1====\n"
"Consider the voltage divider circuit as shown below :\n"
"{{ :gnucap:user:circuit1_schematic_parsing_eg.png?400x300 }}\n"
"It's schematic voltage_divider.sch is :\n"
"<code text>\n"
"v 20100214 2\n"
"C 40000 40000 0 0 0 title-B.sym\n"
"C 44000 49000 1 90 1 voltage-3.sym\n"
"{\n"
"T 43300 48800 5 8 0 0 270 2 1\n"
"device=VOLTAGE_SOURCE\n"
"T 43500 48700 5 10 1 1 270 2 1\n"
"refdes=Vin\n"
"T 43500 48800 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
"C 44100 48900 1 0 0 resistor-1.sym\n"
"{\n"
"T 44400 49300 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 44300 49200 5 10 1 1 0 0 1\n"
"refdes=R1\n"
"T 44100 48900 5 10 1 1 0 0 1\n"
"value=2k\n"
"}\n"
"C 45300 48100 1 90 0 resistor-1.sym\n"
"{\n"
"T 44900 48400 5 10 0 0 90 0 1\n"
"device=RESISTOR\n"
"T 45000 48300 5 10 1 1 90 0 1\n"
"refdes=R2\n"
"T 45300 48100 5 10 1 1 0 0 1\n"
"value=1k\n"
"}\n"
"N 43800 48100 45200 48100 4\n"
"C 44200 47800 1 0 0 gnd-1.sym\n"
"N 43800 49000 44100 49000 5\n"
"N 45000 49000 45200 49000 6\n"
"</code>\n"
"  *When parsing this, we convert it into an augmented netlist with placement "
"information contained in an `ifdef directive.\n"
"  *There are 5 components: 1 title, 2 resistors, 1 ground pin and a voltage "
"source in this circuit which can be identified from the lines starting with "
"the identifier \"C\" for components. Out of them ,the 'title' has no "
"electrical meaning (identified from 'graphical=1' attribute in the symbol "
"file \"title-B.sym\"). The 'device' attribute will identify the component.\n"
"  *Now, we have 4 components having electrical meaning. 2 \"RESISTOR\"s and "
"a VOLTAGE_SOURCE having 2 pins each (pin information got from the symbol "
"files, \"resistor-1.sym\" and \"voltage-3.sym\") and a ground with one "
"pin. They have some attributes like refdes,value which are passed on to the "
"netlist. Index the components in the order in which they appear in the "
"schematic.\n"
"The verilog code with just the components (no connections in it yet) is :\n"
"<code verilog >\n"
"//Construction_of_netlist_part1\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"//to add net and placement...\n"
"endmodule\n"
"</code>\n"
"  *The nodes have a placement in the schematic (use same position as the "
"pins connecting connecting to the nodes). Get that directly from the "
"schematic and save it in `ifdef directive. Use the index to identify the "
"placement.\n"
"  *From the information of placement of components and using the symbol "
"files, we now get the placement of the active edges of pins of components : "
"p11,p12,p21,p22,p31,p32,p41; . For eg, in the symbol file of resistor the "
"active edges of pins are at (0,100) and (900,100). Add these to the "
"co-ordinates of the placement of the components to get the position of "
"pins.\n"
"<code text>\n"
"p11: (44100,49000) ; p12: (45000,49000) ;\n"
"p21: (45200,48100) ; p22: (45200,49000) ; //when rotate by 90, x and y axis "
"interchange.\n"
"p31: (43800,49000) ; p32: (43800,48100) ; //when mirror image is taken "
"subtract the co-ordinaates\n"
"//(Eg :43800=44000-200 and 48100=49000-900)\n"
"p41: (44300,48100)\n"
"</code>\n"
"  *We place the nodes at the same place as the corresponding pins.\n"
"The code with the placement of nodes is :\n"
"<code verilog>\n"
"//Construction_of_netlist_part2\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"`ifdef SCHEMATIC\n"
"//the attributes of 'place' are x,y. x and y are integers, generally "
"multiples of 100.\n"
"place #(.x(44100),.y(49000)) node11;\n"
"place #(.x(45000),.y(49000)) node12;\n"
"place #(.x(45200),.y(48100)) node21;\n"
"place #(.x(45200),.y(49000)) node22;\n"
"place #(.x(43800),.y(49000)) node31;\n"
"place #(.x(43800),.y(48100)) node32;\n"
"place #(.x(44300),.y(48100)) node41;\n"
"`endif\n"
"endmodule\n"
"</code>\n"
"  *Now from the pin positions, we parse the nets. The nets are marked by the "
"identifier 'N' in the schematic. There are 3 nets in the schematic for this "
"example.\n"
"The final verilog netlist is as follows\n"
"<code verilog>\n"
"//Construction_of_netlist_part3_final\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"net net1 (node32,node21); //this net connects (43800,48100) to "
"(45200,48100). where nodes node32 and node21 are located resp.\n"
"net net2 (node31,node11); //similarly for other nets\n"
"net net3 (node12,node22);\n"
"`ifdef SCHEMATIC\n"
"//the attributes of 'place' are x,y. x and y are integers, generally "
"multiples of 100.\n"
"place #(.x(44100),.y(49000)) node11;\n"
"place #(.x(45000),.y(49000)) node12;\n"
"place #(.x(45200),.y(48100)) node21;\n"
"place #(.x(45200),.y(49000)) node22;\n"
"place #(.x(43800),.y(49000)) node31;\n"
"place #(.x(43800),.y(48100)) node32;\n"
"place #(.x(44300),.y(48100)) node41;\n"
"`endif\n"
"endmodule\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:328
#, no-wrap
msgid ""
"====Example of parsing:2====\n"
"Now, consider a more complex example: A differential amplifier circuit.\n"
"{{ :gnucap:user:circuit_diffamp_sch.png?342X390 }}\n"
"The schematic of the differential amplifier circuit is :\n"
"<code text>\n"
"v 20110115 2\n"
"C 40000 40000 0 0 0 title-B.sym\n"
"C 46400 44400 1 0 0 resistor-1.sym\n"
"{\n"
"T 46700 44800 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 46600 44700 5 10 1 1 0 0 1\n"
"refdes=Re1\n"
"T 46600 44200 5 10 1 1 0 0 1\n"
"value=150\n"
"}\n"
"C 47700 44400 1 0 0 resistor-1.sym\n"
"{\n"
"T 48000 44800 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 47900 44700 5 10 1 1 0 0 1\n"
"refdes=Re2\n"
"T 47900 44200 5 10 1 1 0 0 1\n"
"value=150\n"
"}\n"
"C 48800 46900 1 90 0 resistor-1.sym\n"
"{\n"
"T 48400 47200 5 10 0 0 90 0 1\n"
"device=RESISTOR\n"
"T 48500 47000 5 10 1 1 90 0 1\n"
"refdes=Rc\n"
"T 48900 47200 5 10 1 1 0 0 1\n"
"value=20k\n"
"}\n"
"C 47300 44200 1 270 0 current-1.sym\n"
"{\n"
"T 48300 43600 5 10 0 0 270 0 1\n"
"device=CURRENT_SOURCE\n"
"T 47800 43900 5 10 1 1 270 0 1\n"
"refdes=Ic\n"
"T 46700 43700 5 10 1 1 0 0 1\n"
"value=0.5mA\n"
"}\n"
"C 45700 45400 1 0 0 BC547-1.sym\n"
"{\n"
"T 46600 46100 5 10 0 0 0 0 1\n"
"device=BC547\n"
"T 46600 45900 5 10 1 1 0 0 1\n"
"refdes=Q1\n"
"T 46500 45500 5 10 0 0 0 0 1\n"
"footprint=TO92\n"
"}\n"
"C 49300 45400 1 0 1 BC547-1.sym\n"
"{\n"
"T 48400 46100 5 10 0 0 0 6 1\n"
"device=BC547\n"
"T 48400 45900 5 10 1 1 0 6 1\n"
"refdes=Q2\n"
"T 48500 45500 5 10 0 0 0 6 1\n"
"footprint=TO92\n"
"}\n"
"C 47300 47800 1 0 0 vcc-1.sym\n"
"{\n"
"T 47100 48000 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
"C 47200 42700 1 0 0 vcc-minus-1.sym\n"
"{\n"
"T 47600 42800 5 10 1 1 0 0 1\n"
"value=-10\n"
"}\n"
"N 46300 47800 46300 46400 4\n"
"N 46300 45400 46300 44500 4\n"
"N 46300 44500 46400 44500 4\n"
"N 47300 44500 47700 44500 4\n"
"N 48600 44500 48700 44500 4\n"
"N 48700 44500 48700 45400 4\n"
"N 47500 44200 47500 44500 4\n"
"N 48700 46900 48700 46400 4\n"
"C 49200 45600 1 0 0 gnd-1.sym\n"
"C 44900 45800 1 0 0 input-1.sym\n"
"{\n"
"T 44900 46100 5 10 0 0 0 0 1\n"
"device=INPUT\n"
"T 45100 46100 5 10 1 1 0 0 1\n"
"pinlabel=Vi\n"
"}\n"
"C 48700 46500 1 0 0 output-1.sym\n"
"{\n"
"T 48800 46800 5 10 0 0 0 0 1\n"
"device=OUTPUT\n"
"T 49300 46800 5 10 1 1 0 0 1\n"
"pinlabel=Vo\n"
"}\n"
"N 46300 47800 48700 47800 4\n"
"</code>\n"
"Following the process for parsing schematic, the first step is\n"
"  *Identifying the components: After identifying the components and the "
"attributes of components. The draft netlist without any placement yet is as "
"below:\n"
"<code verilog>\n"
"//Netlist_part1\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
"//To_Add_Placement_and_Nets\n"
"endmodule\n"
"</code>\n"
"  *Geting the absolute positions of the active edges of pins of the "
"components, and place nodes which correspond to that pin of the component at "
"that position in an `ifdef SCHEMATIC. The netlist after getting placement of "
"nodes is :\n"
"<code verilog>\n"
"//Netlist_part2\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
"`ifdef SCHEMATIC\n"
"place #(.x(47300),.y(44500)) node1_1;\n"
"place #(.x(46400),.y(44500)) node1_2;\n"
"place #(.x(48600),.y(44500)) node2_1;\n"
"place #(.x(47700),.y(44500)) node2_2;\n"
"place #(.x(48700),.y(47800)) node3_1;\n"
"place #(.x(48700),.y(46900)) node3_2;\n"
"place #(.x(47500),.y(44200)) node4_1;\n"
"place #(.x(47500),.y(43300)) node4_2;\n"
"place #(.x(46300),.y(46400)) node5_1;\n"
"place #(.x(46300),.y(45400)) node5_2;\n"
"place #(.x(45700),.y(45900)) node5_3;\n"
"place #(.x(48700),.y(46400)) node6_1;\n"
"place #(.x(48700),.y(45400)) node6_2;\n"
"place #(.x(49300),.y(45900)) node6_3;\n"
"place #(.x(47500),.y(47800)) node7_1;\n"
"place #(.x(47500),.y(43300)) node8_1;\n"
"place #(.x(49300),.y(45900)) node9_1;\n"
"place #(.x(45700),.y(45900)) node10_1;\n"
"place #(.x(48700),.y(46600)) node11_1;\n"
"`endif\n"
"</code>\n"
"  *Now in this step we search for 'net's in the schematic and write "
"them. After writing nets, the final netlist is as follows.\n"
"<code verilog>\n"
"//Netlist_part3_final\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:344
msgid ""
"net net1 (node0 ,node5_1); net net2 (node5_2,node1 ); net net3 (node1 "
",node1_2); net net4 (node1_1,node2_2); net net5 (node2_1,node2 ); net net6 "
"(node2 ,node6_2); net net7 (node4_1,node3 ); net net8 (node3_2,node6_1); net "
"net9 (node0 ,node3_1); net net10(node4_2,node8_1); net "
"net11(node5_3,node10_1); net net12(node6_3,node9_1); net net13(node3 "
",node1_1); net net14(node11_1,node3_2); net net15(node7_1 ,node0 );"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:371
msgid ""
"`ifdef SCHEMATIC place #(.x(47300),.y(44500)) node1_1; place "
"#(.x(46400),.y(44500)) node1_2; place #(.x(48600),.y(44500)) node2_1; place "
"#(.x(47700),.y(44500)) node2_2; place #(.x(48700),.y(47800)) node3_1; place "
"#(.x(48700),.y(46900)) node3_2; place #(.x(47500),.y(44200)) node4_1; place "
"#(.x(47500),.y(43300)) node4_2; place #(.x(46300),.y(46400)) node5_1; place "
"#(.x(46300),.y(45400)) node5_2; place #(.x(45700),.y(45900)) node5_3; place "
"#(.x(48700),.y(46400)) node6_1; place #(.x(48700),.y(45400)) node6_2; place "
"#(.x(49300),.y(45900)) node6_3; place #(.x(47500),.y(47800)) node7_1; place "
"#(.x(47500),.y(43300)) node8_1; place #(.x(49300),.y(45900)) node9_1; place "
"#(.x(45700),.y(45900)) node10_1; place #(.x(48700),.y(46600)) node11_1; "
"place #(.x(46300),.y(47800)) node0; place #(.x(46300),.y(44500)) node1; "
"place #(.x(48700),.y(44500)) node2; place #(.x(47500),.y(44500)) node3; "
"`endif </code>"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:375
msgid ""
"====How to build schematics==== The following procedure outlines how a "
"schematic is built from a verilog netlist. This constitutes the second part "
"of the proposal <sup>[1]</sup>.  It is mostly the inverse of parsing "
"schematics."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:384
#, no-wrap
msgid ""
"===Create an augmented netlist with placement info===\n"
"  - Get the symbols to be used for each component(module in the netlist) "
"with help of user input\n"
"    * User gives the symbol to use directly\n"
"    * User gives the symbol name from the standard library which can be "
"obtained\n"
"    * User gives the 'device' attribute that corresponds to that module "
"which can be searched from the standard symbols\n"
"  - Replace the modules of original netlist with new modules named with the "
"'device' name. They are same as the original modules but with a parameter "
"string 'sym' which corresponds to the symbol to be used for that device.\n"
"  - Rename the nodes connected to pins of the components such that each has "
"unique name and separate the collapsed nets and place a net between such "
"nodes with default (ideal) parameters i.e, 'zero' resistance, 'zero' "
"inductance etc.\n"
"  - Place the nodes in an `ifdef directive using 'place' module which takes "
"2 attributes x,y ,the co-ordinates of the node. (*TODO : heuristic for "
"placement)\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:389
#, no-wrap
msgid ""
"===Position the components in the schematic===\n"
"  - Place components in between the nodes their pins are connected. In case "
"of a 2-pin device place the pins in between the nodes. Get the device "
"position using relative positions of pins in a symbol.\n"
"  - Write the first line in gschem file with appropriate version (not needed "
"but better done) and place the components at the positions calculated "
"above\n"
"  - Add text attributes to the components in schematic like device, refdes, "
"value etc. Use the format T //xc yc// 5 10 0 0 0 0 1 for invisible "
"attributes like device. Use T //xc yc// 5 10 1 1 0 0 1 for value-only "
"visible attributes. Refer to <sup>[4]</sup> for specs\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:394
#, no-wrap
msgid ""
"===Creating nets between nodes and pins===\n"
"  - Write nets from the nodes to the pins they connect.\n"
"  - Look for 'net's in the netlist and write a net from the co-ordinates of "
"one node to another connected node.\n"
"  - (*TODO): In case a net is slant, to use complex connection between pins "
"made of horizontal/vertical nets.\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:432
#, no-wrap
msgid ""
"====Example of Building====\n"
"Consider the voltage divider circuit netlist as written below.\n"
"<code verilog>\n"
"module voltage_div ();\n"
"//A simple voltage divider circuit as an example\n"
"resistor #(.r(2k)) R1  (.p(p1),.n(p2));\n"
"resistor #(.r(1k)) R2  (.p(p2),.n(p3));\n"
"vsource #(.dc(10)) Vin (.p(p1),.n(p3));\n"
"endmodule\n"
"</code>\n"
"  *With the help of user input, we now get the symbols that we use for each "
"module. For resistor we use resistor-1.sym. It will be determined in either "
"of following ways\n"
"    *User gives the symbol to use directly (wrote by them)\n"
"    *User gives the symbol name from the standard library which can be "
"obtained\n"
"    *User gives the 'device' attribute for the component and we can search "
"the standard library or a built-index (?) of it for symbols with such a "
"device name\n"
"  *Now we create an augmented netlist from this with the placement info and "
"different modules defined by the name same as the value of 'device' "
"attribute (eg. RESISTOR etc).\n"
"  *If the nets are collapsed between pins/nodes, then separate them and "
"place a net in between the nodes with parameter values of the net 'zero' "
"(resistance,inductance etc) i.e, the ideal connection\n"
"  *Place the nodes of components at some place. For now they'll be placed "
"randomly. Random placement gives unaesthetic schematics. (*TODO) Develop a "
"heuristic so that placement is not random and has aesthetic appeal.\n"
"The augmented netlist is\n"
"<code verilog>\n"
"//augmented_netlist_with_placement\n"
"module voltage_div ();\n"
"RESISTOR #(.r(2k),.sym(resistor-1.sym) R1  (.p(node11),.n(node12));\n"
"RESISTOR #(.r(1k),.sym(resistor-1.sym)) R2  (.p(node21),.n(node22));\n"
"VOLTAGE_SOURCE #(.dc(10),.sym(voltage-3.sym)) Vin (.p(node31),.p(node32));\n"
"net net1 (node12,node21); //this net is corresponds to net at pin p2\n"
"net net2 (node22,node32); //corresponds to net at pin p3\n"
"net net3 (node11,node31); //corresponds to net at pin p1\n"
"`ifdef SCHEMATIC //placing the nodes randomly as multiples of 100\n"
"//,not differing by too much and taking care that nodes of same device "
"differ only in one of the x & y co-ordinated\n"
"  place #(.x(45200),.y(48100)) node11;\n"
"  place #(.x(43900),.y(48100)) node12;\n"
"  place #(.x(43800),.y(47000)) node21;\n"
"  place #(.x(42800),.y(47000)) node22;\n"
"  place #(.x(43800),.y(46400)) node31;\n"
"  place #(.x(43800),.y(47400)) node32;\n"
"`endif\n"
"endmodule\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:439
msgid ""
"module RESISTOR(pin1,pin2) begin; parameter string sym; parameter real res; "
"electrical pin1,pin2; resistor #(.r(res)) R (.p(pin1),.n(pin2)); endmodule"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:446
msgid ""
"module VOLTAGE_SOURCE(pinp,pinn) begin; parameter string sym; parameter real "
"dc; electrical pinp,pinn; vsource #(.dc(dc)) Vs (.p(pinp),.n(pinn)); "
"endmodule"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:512
#, no-wrap
msgid ""
"</code>\n"
"  *Now, we start building the schematic from the augmented netlist. First, "
"we write the nets connecting nodes. 'net's in verilog connect 2 nodes. As "
"all nodes have been placed in the 'ifdef directive, we can write nets in "
"schematic as follows.\n"
"  *Write the version line in the start and write nets starting with the "
"identifier 'N' followed by the x & y co-ordinates of the nodes the net "
"connects.\n"
"<code text>\n"
"v 20100214 2\n"
"//components yet to be placed.\n"
"N 43900 48100 43800 47000 5 //net1\n"
"N 42800 47000 43800 47400 5 //net2\n"
"N 45200 48100 43800 46400 5 //net3\n"
"</code>\n"
"  *Now, we place the components in between the nodes their pins are  "
"connected to. Resistor R1 is connected between node11 and node 12. We get "
"device position as follows :\n"
"<code python>\n"
"node11=[45200,48100]\n"
"node12=[43900,48100]\n"
"for i in range(len(node11)):\n"
"  node_m[i]=(node11[i]+node12[i])/2\n"
"#that gives node_m=[44550,49000]\n"
"#the resistor has pins at\n"
"p1_abs=[0,100]\n"
"p2_abs=[900,100]\n"
"#So the pins' absolute positions are\n"
"for i in range(2):\n"
"  p12[i]=(p2_abs[i]-p1_abs[i])/2\n"
"  p1[i]=node_m[i]-p12[i] #p1=[44550-450,49000]=[41000,49000] and\n"
"  p2[i]=node_m[i]+p12[i] #p2=[44550+450,49000]=[45000,49000]\n"
"  dev[i]=p1[i]-p1_abs[i] #The device is the placed at 'p1'-'p1_abs'\n"
"#this logic needs to be improved..\n"
"</code>\n"
"  *Now we get all pin positions and device positions from the above logic.\n"
"<code text>\n"
"p11: (45200,48100) ; p12: (44100,48100) ; //device R1\n"
"p21: (43700,47000) ; p22: (42800,47000) ; //device R2\n"
"p31: (43800,46400) ; p32: (43800,47300) ; //device Vin\n"
"R1 : (44100,48000) ; R2 : (42800,46900) ; Vin: (44000,46400) and rotated by "
"90.\n"
"</code>\n"
"  *Using the placement of pins and components from above logic. We position "
"the components and connect the pins to the nodes through nets.\n"
"<code text>\n"
"v 20100214 2\n"
"C 44100 48000 1 0 0 resistor-1.sym\n"
"{\n"
"T 44100 48000 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 44100 48400 5 10 1 1 0 0 1\n"
"refdes=R1\n"
"T 44100 47700 5 10 1 1 0 0 1\n"
"value=2k\n"
"}\n"
"C 42800 46900 1 0 0 resistor-1.sym\n"
"{\n"
"T 42800 46900 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 42800 47300 5 10 1 1 0 0 1\n"
"refdes=R2\n"
"T 42800 46600 5 10 1 1 0 0 1\n"
"value=1k\n"
"}\n"
"C 44000 46400 1 90 0 voltage-3.sym\n"
"{\n"
"T 44000 46400 5 10 0 0 0 0 1\n"
"device=VOLTAGE_SOURCE\n"
"T 44000 46800 5 10 1 1 0 0 1\n"
"refdes=Vin\n"
"T 44000 46100 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:519
msgid ""
"N 45200 48100 45000 48100 4 //p11 N 43900 48100 44100 48100 4 //p12 N 43800 "
"47000 43700 47000 4 //p21 N 42800 47000 42800 47000 4 //p22 N 43800 46400 "
"43800 46400 4 //p31 N 43800 47400 43800 47300 4 //p32"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:524
msgid ""
"N 43900 48100 43800 47000 4 //net1 N 42800 47000 43800 47400 4 //net2 N "
"45200 48100 43800 46400 4 //net3 </code>"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:528
msgid ""
"The schematic built from the netlist is as shown below : \\\\ {{ "
":gnucap:user:circuit1_building_new_nodes.png?400x380 }}"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:530
msgid "====References===="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:536
msgid ""
"[1] "
"[[http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/savy2020/1| "
"GSoC Proposal]] \\\\ [2] "
"[[http://wiki.geda-project.org/geda:gschem_ug|gEDA/gschem]] \\\\ [3] "
"[[http://wiki.geda-project.org/geda:master_attributes_list#graphical|Schematic "
"Attribute List : graphical ]] \\\\ [4] "
"[[http://wiki.geda-project.org/geda:file_format_spec|File format specs : "
"Schematic ]] \\\\ [5] [[http://gnucap-gsoc.blogspot.in|Blog]] contains "
"weekly updates and documentation of the timeline for this project under "
"GSoC. \\\\ [6] [[http://www.github.com/sksavant/gnucap/tree/lang_gschem| "
"Github branch ]] containing the code."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:2
msgid "Language plugin for Qucs"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:4
msgid ""
"The basis idea is to parse the output schematic or the netlist of the qucs "
"and create an intermediate netlist that is execetable in gnucap"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:6
msgid "Example of a netlist file is shown below"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:8
msgid "# Qucs 0.0.16 bridge.sch"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:20
msgid ""
"IProbe:Pr1 _net0 _net1 R:R2 _net2 _net3 R=\"500 Ohm\" Temp=\"26.85\" "
"Tc1=\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" Vdc:V1 _net3 gnd U=\"1 V\" R:R5 gnd "
"_net2 R=\"Rmeasure\" Temp=\"26.85\" Tc1=\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" "
"R:R1 _net0 _net3 R=\"Rbranch\" Temp=\"26.85\" Tc1=\"0.0\" Tc2=\"0.0\" "
"Tnom=\"26.85\" R:R4 gnd _net0 R=\"Rbranch\" Temp=\"26.85\" Tc1=\"0.0\" "
"Tc2=\"0.0\" Tnom=\"26.85\" .DC:DC1 Temp=\"26.85\" reltol=\"0.001\" "
"abstol=\"1 pA\" vntol=\"1 uV\" saveOPs=\"no\" MaxIter=\"150\" saveAll=\"no\" "
"convHelper=\"none\" Solver=\"CroutLU\" R:R3 _net1 _net2 R=\"500 Ohm\" "
"Temp=\"26.85\" Tc1=\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" .SW:SW1 Sim=\"DC1\" "
"Type=\"lin\" Param=\"Rmeasure\" Start=\"10 Ohm\" Stop=\"1 kOhm\" "
"Points=\"100\" .SW:SW2 Sim=\"SW1\" Type=\"lin\" Param=\"Rbranch\" "
"Start=\"200 Ohm\" Stop=\"1 kOhm\" Points=\"4\" Eqn:Eqn1 Umeasure=\"500 * "
"abs(Pr1.I)\" Export=\"yes\""
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:23
msgid "Description of the Netlist file"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:25
msgid "First line shows the version of the qucs and the file path"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:28
msgid ""
"The list of the components in Qucs can be seen in the link below "
"http://qucs.sourceforge.net/docs/textmode.pdf"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:30
msgid "Description of a schematic file will be done in future"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:32
msgid "Identifying the Components"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:34
msgid "The first letter in the netlist gives the component type"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:36
msgid ""
"_net gives information about in between which nodes the component is "
"connected"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:49
msgid ""
"#include \"c_comand.h\" #include \"d_dot.h\" #include \"d_coment.h\" "
"#include \"d_subckt.h\" #include \"e_model.h\" #include \"u_lang.h\" "
"#include <fts.h> #include \"io_trace.h\""
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:51
msgid "#include <gmpxx.h> // to workaround bug in gmp header about __cplusplus"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:56
msgid ""
"/*--------------------------------------------------------------------------*/ "
"namespace { "
"/*--------------------------------------------------------------------------*/ "
"class LANG_QUCS : public LANGUAGE {"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:68
#, no-wrap
msgid ""
"public:\n"
"    //\n"
"    enum MODE {mATTRIBUTE, mCOMMENT} _mode;\n"
"    mutable int _no_of_lines;\n"
"    mutable bool _componentmod;\n"
"    mutable std::string _componentname;\n"
"    mutable bool _gotaline;\n"
"    //\n"
"    std::string name()const {return \"qucs\";}\n"
"    bool case_insensitive()const {return false;}\n"
"    UNITS units()const {return uSI;}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:79
#, no-wrap
msgid ""
"public: //functions to be declared\n"
"    std::string arg_front()const {\n"
"        return \" \"; //arbitrary\n"
"    }\n"
"    std::string arg_mid()const {\n"
"        return \"=\"; //arbitrary\n"
"    }\n"
"    std::string arg_back()const {\n"
"        return \"\";  //arbitrary\n"
"    }\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:89
#, no-wrap
msgid ""
"public:\n"
"    void\t\t  parse_top_item(CS&, CARD_LIST*);\n"
"    DEV_COMMENT*  parse_comment(CS&, DEV_COMMENT*);\n"
"    DEV_DOT*\t  parse_command(CS&, DEV_DOT*);\n"
"    MODEL_CARD*\t  parse_paramset(CS&, MODEL_CARD*);\n"
"    MODEL_SUBCKT* parse_module(CS&, MODEL_SUBCKT*);\n"
"    COMPONENT*\t  parse_instance(CS&, COMPONENT*);\n"
"    std::string\t  find_type_in_string(CS&);\n"
"    MODEL_SUBCKT* parse_componmod(CS&, MODEL_SUBCKT*);\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:96
#, no-wrap
msgid ""
"private:\n"
"    void print_paramset(OMSTREAM&, const MODEL_CARD*);\n"
"    void print_module(OMSTREAM&, const MODEL_SUBCKT*);\n"
"    void print_instance(OMSTREAM&, const COMPONENT*);\n"
"    void print_comment(OMSTREAM&, const DEV_COMMENT*);\n"
"    void print_command(OMSTREAM& o, const DEV_DOT* c);\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:98
msgid "}lang_qucs;"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:111
#, no-wrap
msgid ""
"static void parse_place(CS& cmd, COMPONENT* x)\n"
"{\n"
"    trace0(\"Got into parse_place\");\n"
"    assert(x);\n"
"    assert(OPT::language->find_type_in_string(cmd)==\"place\");\n"
"    cmd>>\"place\";\n"
"    std::string _portname,_x,_y;\n"
"    cmd>>\" \">>_portname>>\" \">>_x>>\" \">>_y;\n"
"    x->set_param_by_name(\"x\",_x);\n"
"    x->set_param_by_name(\"y\",_y);\n"
"    x->set_port_by_index(0,_portname);\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:175
#, no-wrap
msgid ""
"static void parse_place(CS& cmd, COMPONENT* x)\n"
"{\n"
"    trace0(\"Got into parse_place\");\n"
"    assert(x);\n"
"    assert(OPT::language->find_type_in_string(cmd)==\"place\");\n"
"    cmd>>\"place\";\n"
"    std::string _portname,_x,_y;\n"
"    cmd>>\" \">>_portname>>\" \">>_x>>\" \">>_y;\n"
"    x->set_param_by_name(\"x\",_x);\n"
"    x->set_param_by_name(\"y\",_y);\n"
"    x->set_port_by_index(0,_portname);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static void create_place(std::string cmdstr,COMPONENT* x)\n"
"{\n"
"    CS place_cmd(CS::_STRING,cmdstr);\n"
"    OPT::language->new__instance(place_cmd,NULL,x->scope());\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static std::string findplacewithsameposition(COMPONENT* x,std::string "
"xco,std::string yco)\n"
"{\n"
"    for (CARD_LIST::const_iterator ci = x->scope()->begin(); ci != "
"x->scope()->end(); ++ci) {\n"
"        if((*ci)->dev_type()==\"place\"){\n"
"            if(xco==(*ci)->param_value(1) && yco==(*ci)->param_value(0)){\n"
"                return static_cast<COMPONENT*>(*ci)->port_value(0);\n"
"            }\n"
"        }\n"
"    }\n"
"    return \"\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static std::string* findnodeonthisnet(CARD *x, std::string x0, std::string "
"y0, std::string x1, std::string y1)\n"
"{\n"
"    for(CARD_LIST::const_iterator ci = x->scope()->begin(); ci != "
"x->scope()->end(); ++ci) {\n"
"        if((*ci)->dev_type()==\"place\"){\n"
"            std::string _x=(*ci)->param_value(1),_y=(*ci)->param_value(0);\n"
"            if (y0==y1){\n"
"                if(  ( ( (atoi(x1.c_str()) < atoi(_x.c_str())) and "
"(atoi(_x.c_str())<atoi(x0.c_str())) ) || ( (atoi(x0.c_str()) < "
"atoi(_x.c_str())) and (atoi(_x.c_str())<atoi(x1.c_str())) ) ) and _y==y0 and "
"_x!=x0 and _x!=x1){\n"
"                    trace0(\"true0\");\n"
"                    std::string* coord=new std::string[2];\n"
"                    coord[0]=_x;\n"
"                    coord[1]=_y;\n"
"                    return coord;\n"
"                }\n"
"                else{\n"
"                    return NULL;\n"
"                }\n"
"            }else if (x0==x1){\n"
"                if(  ( ( (atoi(y1.c_str()) < atoi(_y.c_str())) and "
"(atoi(_y.c_str())<atoi(y0.c_str())) ) || ( (atoi(y0.c_str()) < "
"atoi(_y.c_str())) and (atoi(_y.c_str())<atoi(y1.c_str())) ) ) and _x==x0 and "
"_y!=y0 and _y!=y1){\n"
"                    trace0(\"true1\");\n"
"                    std::string* coord=new std::string[2];\n"
"                    coord[0]=_x;\n"
"                    coord[1]=_y;\n"
"                    return coord;\n"
"                }else{\n"
"                    return NULL;\n"
"                }\n"
"            }\n"
"            else{\n"
"                return NULL;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:2
#, no-wrap
msgid "**5.MDUMP**\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:4
msgid "Purpose:Prints the dc tran matrix values."
msgstr ""

#. type: Plain text
#: user/mdump.txt:11
#, no-wrap
msgid ""
"     mdump\n"
"     mdump filename\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:15
msgid ""
"Command dumps the dc-tran matrix into the console,if the filename is "
"specified then output is redirected to the file.Two matrices one before the "
"lu decomposition and one after the lu decomposition is dumped."
msgstr ""

#. type: Plain text
#: user/mdump.txt:30
#, no-wrap
msgid ""
"     gnucap>mdump\n"
"     DC-Tran matrix before LU decomposition:\n"
"     0.    0.    0.    0.\n"
"     0.    0.02776   -0.005802   -0.02186\n"
"     0.   -0.02738    0.01161    0.01578\n"
"     0.   -273.8u   -0.005802    0.006157\n"
"     DC-Tran matrix after LU decomposition:\n"
"     0.    0.    0.    0.\n"
"     0.    0.02776   -0.209   -0.7874\n"
"     0.   -0.02738    0.00589   -0.9816\n"
"     0.   -273.8u   -0.005859    190.1u\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:43
#, no-wrap
msgid ""
"     gnucap>mdump matrix.txt\n"
"     gnucap>!cat matrix.txt\n"
"     DC-Tran matrix before LU decomposition:\n"
"     0.0000 \t    0.0000 \t  0.0000 \t0.0000\n"
"     0.0000 \t    0.0278 \t -0.0058       -0.0219\n"
"     0.0000 \t   -0.0274 \t  0.0116 \t0.0158\n"
"     0.0000 \t   -0.0003 \t -0.0058 \t0.0062\n"
"     DC-Tran matrix after LU decomposition:\n"
"     0.0000 \t    0.0000 \t  0.0000 \t0.0000\n"
"     0.0000 \t    0.0278 \t -0.2090       -0.7874\n"
"     0.0000 \t   -0.0274 \t  0.0059       -0.9816\n"
"     0.0000 \t   -0.0003 \t -0.0059 \t0.0002\n"
"     gnucap>\n"
msgstr ""

#. type: Title ======
#: user/netlist_import_and_export.txt:1
#, no-wrap
msgid "File format translation"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:4
msgid ""
"We need a universal translator system that can translate in all directions "
"between Free EDA tools, possible future free EDA tools, and outside tools "
"that are likely to be used with free EDA tools."
msgstr ""

#. type: Title =====
#: user/netlist_import_and_export.txt:4
#, no-wrap
msgid "Scope"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:7
msgid ""
"Of course, everything to everything is not reasonable.  So, set a limit of "
"circuit oriented free EDA tools, possible future tools, and outside tools "
"that are likely to be used them.  Of course, tool formats where translation "
"doesn't make sense don't need to be supported."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:9
msgid ""
"Most tools use a format much like a netlist, often with some special "
"information.  So, use a netlist based intermediate format.  First translate "
"to the intermediate format, then translate out.  The intermediate format "
"should be sufficiently expressive that there can be a lossless round trip "
"from the tool format to the intermediate format and back."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:11
msgid ""
"Lossless means that the resultant file is equivalent in how it works.  It is "
"not necessary to preserve formatting and other things that don't matter."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:13
msgid ""
"All of the formats needing translation presently consist of lists of "
"objects, with some kind of encapsulation.  Each object has connections and "
"attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:15
msgid ""
"This suggests the possible of a standard netlist format as the intermediate "
"format."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:17
msgid "Further discussion related only to formats that fit this model."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:19
msgid ""
"If possible, the format chosen should have a history of use for at least "
"part of this, and have a published specification that is externally "
"controlled and freely available."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:21
msgid ""
"There needs to be a way to merge changes from any target/source without "
"messing up other parts."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:22
#, no-wrap
msgid "Tool types needing support"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "schematic\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "layout\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "simulation\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:27
#, no-wrap
msgid "Free tools"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:40
#, no-wrap
msgid ""
"Lossless round trip is required, so archival storage can use the "
"intermediate format.\n"
"  * gschem\n"
"  * pcb\n"
"  * gnucap\n"
"  * Icarus Verilog\n"
"  * NGspice\n"
"  * Qucs\n"
"  * Kicad\n"
"  * Magic\n"
"  * Electric\n"
"  * Xcircuit\n"
"  * Fritzing\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:41
#, no-wrap
msgid "Non-free import and export"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:47
#, no-wrap
msgid ""
"Support for these will allow gEDA tools to play nice with the commercial "
"world.  Basic functionality is needed, but it doesn't need to be lossless.  "
"Lossless should be possible, but it is not a high priority to actually "
"implement it.\n"
"  * Eagle\n"
"  * Orcad\n"
"  * LTspice\n"
"  * Pads\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:48
#, no-wrap
msgid "gEDA missing functionality"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:55
#, no-wrap
msgid ""
"Hopefully having a translator system will provide a seed so these can be "
"done.\n"
"  * Back annotation from layout or simulation to schematic\n"
"  * Static timing analysis\n"
"  * Post-layout signal integrity simulation.\n"
"  * Layout - schematic comparison\n"
"  * Use of the same schematic for the whole project.\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:55
#, no-wrap
msgid "Explicitly not supported"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Plotting\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Commands\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Behavioral modeling\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Translating the symbols or footprints themselves.\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:63
msgid "All of these consist of lists of objects, with connections and attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:65
msgid ""
"It is tradition that a netlist is used for interchange, but the traditional "
"approach only goes one way, because information is lost in the translation."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:67
msgid ""
"The format must convey the meaning, not necessarily in the same way as the "
"tool's native format or internal storage."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:69
msgid ""
"It is not necessary to translate parts that are usually in libraries, and "
"are tool specific, such as models, symbols, or footprints."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:71
msgid ""
"All contenders for possible formats must support a lossless round-trip to "
"any other."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:72
#, no-wrap
msgid "Some possible formats"
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:74
#, no-wrap
msgid "Spice"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:77
msgid ""
"A popular netlist format.  It has a history of use for interchange, but not "
"yet for physical placement.  Problems: irregular syntax, not sufficiently "
"expressive.  These problems have been a major hassle for years for "
"developers.  It is well accepted, but not by people who know it well."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:78
#, no-wrap
msgid "Verilog"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:81 user/netlist_import_and_export.txt:85
msgid ""
"The structural subset is a good netlist format.  It is regular, sufficiently "
"expressive, and has a published standard.  It has a history of use for "
"interchange, but not yet for physical placement."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:82
#, no-wrap
msgid "VHDL"
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:86
#, no-wrap
msgid "Spectre"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:89
msgid ""
"The structural subset is a good netlist format.  It is regular, sufficiently "
"expressive, but belongs to one company (Cadence), so rule it out.  It has a "
"history of use for simulation only."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:90
#, no-wrap
msgid "XML"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:93
msgid ""
"XML is not really a format but a syntax.  A good format can easily be made "
"based on XML, but has no history of use in a similar context.  The syntax is "
"well documented but there is no outside documentation of application in any "
"related use."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:94
#, no-wrap
msgid "Representation of physical placement"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:97
msgid ""
"This part is the only part where there is not a strong history of use for "
"VHDL and Verilog."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:99
msgid "Ideas:"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"Nets are also objects with connections and attributes.  Nets have meaning in "
"all contexts.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"A place on a schematic can be considered to be an object, with connections "
"and attributes.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"Pads, connectors, thermals, vias .. are also objects, with connections and "
"attributes.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"Use `define (assuming Verilog format) to set aside sections that have "
"meaning in one context but not another.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"This is a high level description.  Take a high level view across all.  It's "
"not lines, boxes, and circles.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"If you must, lines, boxes, and circles can be objects too, but not "
"translatable because they have no meaning in other contexts.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid ""
"Attributes that have no meaning are silently ignored.  Attributes that have "
"meaning in one context but not in another context are ignored where they "
"have no meaning.\n"
msgstr ""

#. type: Title =====
#: user/netlist_import_and_export.txt:108
#, no-wrap
msgid "Applications"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:111
msgid "Choosing the Verilog format as one possibility."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:113
msgid "The unit of encapsulation is the \"module\":"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:117
#, no-wrap
msgid ""
"  module my-module(connections);\n"
"  // contents\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:119
msgid "Each object in the list has a consistent syntax:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:121
#, no-wrap
msgid "  type #(attributes) name (connections);\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:126
#, no-wrap
msgid ""
"  resistor #(.r(1k)) r123 (a, b);\n"
"  resistor #(.r(1k)) r234 (.p(b), .n(c));\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:128
msgid "\"r\" is the name of an attribute.  \"1k\" is the value (a string)."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:130
msgid ""
"In the first example, connections are determined by order.  In the second, "
"they are mapped by name.  Node \"b\" connects to pin \"p\" and node \"c\" "
"connects to pin \"n\"."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:132
msgid "A \"net\" is also an object."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:134
msgid ""
"In the above example, both connect to node b directly.  In a schematic "
"representation the connection would not be direct, but through a \"net\""
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:138
#, no-wrap
msgid ""
"  resistor #(.r(1k)) r123 (.p(a1), .n(b1));\n"
"  resistor #(.r(1k)) r125 (.p(b2), .n(c2));\n"
"  net b (.1(b1), .2(b2));\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:140
msgid "The name of the net is \"b\".  It has no attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:142
msgid "For schematic, you can now place the nodes:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:147
#, no-wrap
msgid ""
"  place #(.x(1222), .y(3438)) place11333 (b1);\n"
"  place #(.x(4334), .y(8433)) place34894 (b2);\n"
"  place #(.x(9393), .y(4232)) place49334 (a1);\n"
"  place #(.x(2932), .y(2384)) place34983 (c2);\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:149
msgid ""
"Portions that apply in only certain contexts can be selectively included "
"with 'ifdef:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:159
#, no-wrap
msgid ""
"  module my_circuit;\n"
"    `ifdef SCHEMATIC\n"
"      place ...\n"
"      place ...\n"
"    `endif\n"
"     res ...\n"
"     res ...\n"
"     net ...\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:161
msgid "Complex nets can be encapsulated:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:171
#, no-wrap
msgid ""
"  module net23842 (1,2,3);\n"
"    net n23482 (1,2);\n"
"    net n84333 (2,3);\n"
"    `ifdef SCHEMATIC\n"
"      place ...\n"
"      place ...\n"
"      place ...\n"
"    `endif\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:174
#, no-wrap
msgid ""
"  module net9393 (1,2);\n"
"    net #(.color(blue), .thickness(thin)) n38423 (1,2);\n"
"  endmodule\n"
msgstr ""

#. type: Title ===
#: user/newtonnumericexample1.txt:1
#, no-wrap
msgid "Newton Numeric Example 1"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:4
msgid "Let us consider simple 1-node circuit"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:12
#, no-wrap
msgid ""
"<code>\n"
"       --------+-------------\n"
"      |        |             |\n"
"    I=0.001   R=1000     i=V^3/1000\n"
"      |        |             |\n"
"     ---      ---           ---\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:14
msgid "Which is equivalent to equation:"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:16
msgid "F(V) = I + V/R + N(V) = V/1000 + 1/1000*V^3 - 0.001"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:18
msgid "J(V) = 1/1000 + 3/1000 * V^2"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:20
msgid "F'(V)= 3/1000*V^2*V + 0.001 - 1/1000*V^3"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:22
msgid ""
"model code and circuit file for this example are [[ "
"NewtonNumericExample1_Code | here ]]"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:24
msgid "Iteration sequence for this equation will be:"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:47
#, no-wrap
msgid ""
"^ Iteration ^ Newton classic (2,3) ^ Gnucap's Newton Modification (5,6,7) ^ "
"Damped |\n"
"^ 0         | V0=0                 | V0=0                                 |  "
"|\n"
"|           | J=0.001              | J=0.001                              |  "
"|\n"
"|           | F=-0.001             | F' = 0.001                           |  "
"|\n"
"|           | S=F/J=-1             | R  =F'/J=0.001/0.001=1;             |   "
"|\n"
"|           | V1= V0-S = 1         | V1 = R = 1                          |  "
"|\n"
"^ 1         | V1=1                 | V1 =1                               |  "
"|\n"
"|           | J=0.004              | J = 0.004                           |  "
"|\n"
"|           | F=0.001              | F' =0.003                           |  "
"|\n"
"|           | S=F/J=0.25           | R=F'/J=0.75                         |  "
"|\n"
"|           | V2=V1-S=0.75         | V2=R=0.75                           |  "
"|\n"
"^ 2         | V2=0.75              | V2=0.75                             |  "
"|\n"
"|           | J=0.0026875          | J=0.0026875                         |  "
"|\n"
"|           | F=0.000171875        | F'=0.00184375                       |  "
"|\n"
"|           | S=F/J=0.063953       | R=F'/J=0.686047                     |  "
"|\n"
"|           | V3=V2-S=0.0686047    | V3=R=0.686047                       |  "
"|\n"
"^ 3         | V3=0.0686047         | V3=0.0686047                        | "
"...|\n"
"|           | J=0.0024119815       | J=0.0024119815                      |  "
"|\n"
"|           | F=0.00000894221      | F'=0.00164579043                    |  "
"|\n"
"|           | S=F/J=0.003707       | R=F'/J=0.68234                      |  "
"|\n"
"|           | V4=V3-S=068234       | V4=R=0.68234                        |  "
"|\n"
"|...        | ...                  | ...                                 |  "
"|\n"
msgstr ""

#. type: Title ===
#: user/noise_calculation_basics.txt:1 user/noise_implementation.txt:7
#, no-wrap
msgid "Noise calculations basics"
msgstr ""

#. type: Plain text
#: user/noise_calculation_basics.txt:4 user/noise_implementation.txt:11
msgid ""
"Noise is claculated using adjacent system method [TBD GS - complete, explain "
"]"
msgstr ""

#. type: Title =====
#: user/noise_implementation.txt:1
#, no-wrap
msgid "Noise Implementation"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:4
msgid "This section contains all stuff related to AC Noise calculation in Gnucap."
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:6
msgid ""
"Currently (April 2011) noise is implemented in experimental branch and work "
"as plugin. Please see [[Code-related Stuff]] for more details."
msgstr ""

#. type: Title ===
#: user/noise_implementation.txt:12 user/noise_syntax.txt:1
#, no-wrap
msgid "Noise Simulation Syntax"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:15 user/noise_syntax.txt:4
msgid ""
"To run noise simulation - ad the following line to circuit file (spice "
"format):"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:17 user/noise_syntax.txt:6
msgid "''.noise V(a,b) Dev stepmode points fromF toF''"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:26 user/noise_syntax.txt:15
#, no-wrap
msgid ""
"  * V(a,b)  - output to measure noise at - nodes a to b; possible form:\n"
"V(a) is the same as V(a,0)\n"
"  * Dev    - device which is considered as input\n"
"  * stepmode - [o{ctave}, d{ecade}, lin, ti{mes}, step, by, +, *]\n"
"  * points - number of points (depends on stepmode)\n"
"  * fromF   - lowest frequency\n"
"  * toF     - highest frequency\n"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:28 user/noise_syntax.txt:17
msgid ""
"It will calculate noise power density between output nodes \"a\" and \"b\" "
"and equivalent power at input device \"Dev\" using \"stepmode\" making "
"\"points\" in frequency range \"fromF\"-\"toF\""
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:32 user/noise_syntax.txt:21
msgid "'' .noise v(3) V1 oct 5 10 10K ''"
msgstr ""

#. type: Bullet: ' - '
#: user/noise_implementation.txt:34 user/noise_syntax.txt:23
#, no-wrap
msgid ""
"calcualate spectral noise density at node \"3\" and reduce it to input "
"device V1 making 5 points per octave in frequency range from 10HZ to 10KHZ\n"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:36 user/noise_syntax.txt:25
msgid "'' .noise V(10,12) I1 dec 2 10K 10MEG''"
msgstr ""

#. type: Bullet: ' - '
#: user/noise_implementation.txt:38 user/noise_syntax.txt:27
#, no-wrap
msgid ""
"calcualate spectral noise density between nodes 10 and 12 and reduce it to "
"input device I1 making 2 points per decade in frequency range from 10KHZ to "
"10MHZ\n"
msgstr ""

#. type: Title ==
#: user/noise_implementation.txt:40 user/noise_syntax.txt:29
#, no-wrap
msgid "Output"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:45 user/noise_syntax.txt:34
msgid ""
"Usually simulators also support ''.print noise'' statement. Now it is not "
"implemented yet.  Currently output contains:"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:47 user/noise_syntax.txt:36
msgid "'' Freq inoise_density onoise_density ''"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:49 user/noise_syntax.txt:38
msgid ""
"Also - at the end of the frequency range total power over the range s "
"integrated:"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:51 user/noise_syntax.txt:40
msgid "'' inoise_total onoise_total ''"
msgstr ""

#. type: Bullet: '  * '
#: user/noise_implementation.txt:64
#, no-wrap
msgid "[[Discussions]] regarding noise implementation\n"
msgstr ""

#. type: Plain text
#: user/one_more.txt:1 user/test.txt:1
msgid "test"
msgstr ""

#. type: Plain text
#: user/pre.txt:2
#, no-wrap
msgid "**6.PRE**\n"
msgstr ""

#. type: Plain text
#: user/pre.txt:4
msgid "Purpose:Executes command prior to parsing the circuit"
msgstr ""

#. type: Plain text
#: user/pre.txt:5 user/reset.txt:5 user/trace.txt:5
msgid "Status:Not implemented"
msgstr ""

#. type: Title ===
#: user/programingdetails.txt:1
#, no-wrap
msgid "Programming Details"
msgstr ""

#. type: Plain text
#: user/programingdetails.txt:11
#, no-wrap
msgid ""
"Topmost level solver computations are concentrated in s__solve.cc file in\n"
"<code c++> SIM::solve(...) </code>\n"
"inside it main important steps:\n"
"<code c++> do { </code>\n"
"assume we have some value of unknowns: X_c\n"
"calculate model parameters\n"
"<code c++>   evaluate models; </code>\n"
"load matrices (Jacobian J and vector FG)\n"
msgstr ""

#. type: Plain text
#: user/programingdetails.txt:17
#, no-wrap
msgid ""
"note, that dumping is implemented duing matrix & vector loading process.\n"
"<code c++>   load_marix(); </code>\n"
"solve equations and obtan new poin X_n\n"
"<code c++>   solve_equations(); </code>\n"
"until equations will converge or iteration limit will not be acieved\n"
"<code c++>  } while ( ! converged && ! _sim-> "
"exceeds_iteration_limit(it1));</code>\n"
msgstr ""

#. type: Title ===
#: user/queuesandoptbypass.txt:1
#, no-wrap
msgid "Queues and OPT::bypass"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:4
msgid ""
"To improve speed GNucap solver uses device queues, most queues are activated "
"when OPT::bypass is set to true."
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:6
msgid "This section will create analysis of how this is implemented."
msgstr ""

#. type: Title ==
#: user/queuesandoptbypass.txt:7
#, no-wrap
msgid "No bypass (OPT::bypass==false)"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:11
msgid ""
"Looking at code of SIM::evaluate_models() - if (OPT::bypass==false) then "
"only _late_evalq queue is used."
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:14
#, no-wrap
msgid "first for all devices do_tr() is performed (no queues);\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:14
#, no-wrap
msgid "then - for devices in _late_evalq queue is executed method do_tr_last();\n"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:17
msgid "Same approach is used in TRANSIENT::sweep():"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:20
#, no-wrap
msgid "for all devices is executed do_tr()\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:20
#, no-wrap
msgid "for _late_evalq is executed do_tr_last()\n"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:22
msgid "_late_evalq itself is declared in u_sim_data.h"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:24
msgid "elements can be added to _late_evalq are:"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_cccs\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_ccvs\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_coil\n"
msgstr ""

#. type: Title ==
#: user/queuesandoptbypass.txt:29
#, no-wrap
msgid "bypass (OPT::bypass==true)"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:30
msgid "TBD"
msgstr ""

#. type: Plain text
#: user/quit.txt:2
#, no-wrap
msgid "**7.QUIT**\n"
msgstr ""

#. type: Plain text
#: user/quit.txt:4
msgid "Purpose:Terminates the gnucap interpreter"
msgstr ""

#. type: Plain text
#: user/quit.txt:6
msgid "Status:Implemeted"
msgstr ""

#. type: Plain text
#: user/quit.txt:11
#, no-wrap
msgid ""
"    quit\n"
"    quit [status]\n"
msgstr ""

#. type: Plain text
#: user/quit.txt:13
msgid ""
"Comments: This quit command is the modified form of the current quit "
"command.status(integer)can be passed as a parameter which signals the "
"success or failure of the termination process to the Operating "
"System.Non-zero status indicates unsuccessful termination to the Operating "
"System."
msgstr ""

#. type: Plain text
#: user/quit.txt:19
#, no-wrap
msgid ""
"     gnucap>quit 0       returns a success value to the Operating system\n"
"     Make sure you have saved everything you wanted to.\n"
"     Are you sure you want to quit?y/n:\n"
msgstr ""

#. type: Plain text
#: user/reset.txt:2
#, no-wrap
msgid "**9.RESET**\n"
msgstr ""

#. type: Plain text
#: user/reset.txt:4
msgid ""
"Purpose:Reset command re-parses the input file.The circuit can then be "
"re-run from its initial state"
msgstr ""

#. type: Plain text
#: user/rmcirc.txt:2
#, no-wrap
msgid "**8.RMCIRC**\n"
msgstr ""

#. type: Plain text
#: user/rmcirc.txt:4
msgid ""
"Purpose:Removes the current circuit from the list of circuits sourced into "
"gnucap"
msgstr ""

#. type: Plain text
#: user/run.txt:2
#, no-wrap
msgid "**RUN**\n"
msgstr ""

#. type: Plain text
#: user/run.txt:4
msgid "Purpose:Run the silumation as specified in the input file."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:4
msgid ""
"====Overview==== Sensitivity can be calculated from a solution of the "
"adjoint system, see \"Computer Methods for Circuit Analysis and Design "
"(Vlach and Singhal)\"."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:6
msgid "In gnucap it may look like this:"
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:12
#, no-wrap
msgid ""
"  include netlist.ckt\n"
"  .print dc v(nodes)\n"
"  .dc\n"
"  .print sens R(R1) W(MN1)\n"
"  .sens v(node0) v(node1)\n"
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:14
msgid ""
"calculates the sensitivities of node voltages with respect to device "
"parameters."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:17
msgid ""
"====Implementation==== the ''.sens'' command is similar to the ac "
"command. it expects a dc operation point to be computed already. It loads "
"the acx matrix and does an lu decomposition. then for all outputs it solves "
"the adjoint system using Gennadys ''fbsubt()'' and iterates the "
"probelist. the solution is stored in ''double _sim->_sens[numberofnodes]''."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:19
msgid ""
"devices need to provide a ''XPROBE sens_probe_ext(string) const'' for this "
"to work. this function uses the adjacent values from ''sim->_sens''."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:20
msgid ""
"the [[git://tool.em.cs.uni-frankfurt.de/git/gnucap|repository on tool]] "
"contains this implementation attempt (the wiki doesnt display the link, see "
"source)."
msgstr ""

#. type: Plain text
#: user/set.txt:2 user/setv.txt:2
#, no-wrap
msgid "**10.SETV**\n"
msgstr ""

#. type: Plain text
#: user/set.txt:4 user/setv.txt:4
msgid "Purpose:Sets the value of a variable"
msgstr ""

#. type: Plain text
#: user/set.txt:10 user/setv.txt:10
#, no-wrap
msgid ""
"Syntax:\n"
"      setv assign_to = value\n"
"      setv assign_to value\n"
msgstr ""

#. type: Plain text
#: user/set.txt:14 user/setv.txt:14
msgid ""
"Commands sets the value of \"assign_to\" variable to \"value\".These values "
"can be accessed via a show command."
msgstr ""

#. type: Plain text
#: user/set.txt:22 user/setv.txt:22
#, no-wrap
msgid ""
"       gnucap>setv\n"
"       Usage:setv assign_to = value\n"
"       gnucap>setv a = 3\n"
"       gnucap>showmod\n"
"       a=3\n"
"       gnucap>\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:2
#, no-wrap
msgid "**11.SHELL**\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:4
msgid "Purpose:Calls the command interpreter of operating system."
msgstr ""

#. type: Plain text
#: user/shell.txt:10
#, no-wrap
msgid "     shell [system_command]\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:14
msgid ""
"system_command is the command which is to be run in interpreter.It is to be "
"passed as an argument."
msgstr ""

#. type: Plain text
#: user/shell.txt:16
msgid "Run 'exit' command to return to gnucap command interpreter."
msgstr ""

#. type: Plain text
#: user/shell.txt:21
#, no-wrap
msgid ""
"     gnucap> shell\n"
"     itsrishre@rishabh-laptop:~$\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:23
msgid ""
"When you are done with the shell,you can type exit to return to gnucap "
"interpreter."
msgstr ""

#. type: Plain text
#: user/shell.txt:25
#, no-wrap
msgid ""
"     itsrishre@rishabh-laptop:~$ exit\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/showmod.txt:2
#, no-wrap
msgid "**12.SHOWMOD**\n"
msgstr ""

#. type: Plain text
#: user/showmod.txt:4
msgid "Purpose:Lists model parameter values"
msgstr ""

#. type: Plain text
#: user/source.txt:2
#, no-wrap
msgid "**13.SOURCE**\n"
msgstr ""

#. type: Plain text
#: user/source.txt:4
msgid "Purpose:Reads a gnucap input file"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:2
#, no-wrap
msgid "**14.STRCMP**\n"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:4
msgid "Purpose:Compares two string"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:11
#, no-wrap
msgid ""
"    strcmp string1 string2\n"
"    strcmp --help\n"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:15
msgid ""
"Compare two strings and outputs 0 if the two strings are equal otherwise "
"output is the difference of the first non-matching character in string1 and "
"string2. Strings may be passed with or without  ."
msgstr ""

#. type: Plain text
#: user/strcmp.txt:26
#, no-wrap
msgid ""
"    gnucap> strcmp \"hello\" hello   evaluates to true(flag=0)\n"
"    flag=0\n"
"    gnucap> strcmp hello hello     also evaluates to true.\n"
"    flag=0\n"
"    gnucap> strcmp --help          prints the usage of the command.\n"
"    Usage: strcmp string1 string2\n"
"    Output Value:output variable flag is 0 if the two strings are equal "
"otherwise output is the difference of the first non-matching character\n"
"    in string1 and string2.\n"
"    gnucap>\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:2
#, no-wrap
msgid "**15.SYSINFO**\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:4
msgid "Purpose:Command prints the system information"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:10
#, no-wrap
msgid "     sysinfo\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:14
msgid ""
"Command prints the useful system information which users may use to send bug "
"reports to the gnucap developers community. This command doesn't works on "
"Windows."
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:23
#, no-wrap
msgid ""
"      gnucap> sysinfo\n"
"      Model name\t      : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"      OS Description    :\"Ubuntu 12.04 LTS\"\n"
"      CPU MHz\t      : 2494.420\n"
"      RAM Available     : 1012348kB\n"
"      RAM Free          : 145640kB\n"
"      gnucap>\n"
msgstr ""

#. type: Title ====
#: user/test_test.txt:1
#, no-wrap
msgid "test test"
msgstr ""

#. type: Plain text
#: user/test_test.txt:3
msgid "this is a test"
msgstr ""

#. type: Plain text
#: user/test_test.txt:5
msgid "[[another page]]"
msgstr ""

#. type: Plain text
#: user/test_test.txt:6
msgid "[[one more]]"
msgstr ""

#. type: Plain text
#: user/trace.txt:2
#, no-wrap
msgid "**16.TRACE**\n"
msgstr ""

#. type: Plain text
#: user/trace.txt:4
msgid "Purpose:Trace command traces nodes"
msgstr ""

#. type: Plain text
#: user.txt:2
#, no-wrap
msgid ""
" --- //[[savant.2020@gmail.com|Savant Krishna]] 2012/03/31 09:59// --- "
"//[[savant.2020@gmail.com|Savant Krishna]] 2012/03/31 09:59//====== User "
"contributions ======\n"
msgstr ""

#. type: Plain text
#: user.txt:4 user/user.txt:4
msgid "This page provides an area for users to make contributions."
msgstr ""

#. type: Plain text
#: user.txt:9 user/user.txt:9
#, no-wrap
msgid ""
"To add yours ....\n"
"  - Create an account for yourself\n"
"  - Edit this page to add a link to the new page you will make\n"
"  - Make the new page for your contribution.\n"
msgstr ""

#. type: Plain text
#: user.txt:10 user/user.txt:10
#, no-wrap
msgid "----\n"
msgstr ""

#. type: Plain text
#: user.txt:13 user/user.txt:13
msgid ""
"\\\\ [[Noise implementation]] - here is all stuff related to .noise command "
"implementation: syntax, noise calculation basics, discussions regarding "
"noise implementation and code-related stuff. Noise command implementation is "
"not complete yet, so all material have \"working\" status."
msgstr ""

#. type: Plain text
#: user.txt:15 user/user.txt:15
msgid ""
"[[Gnucap Nonlinear Solver]] - explanation of Gnucap nonlinear "
"solver. Comparison with classic Newton formulation and some additional "
"considerations"
msgstr ""

#. type: Plain text
#: user.txt:17 user/user.txt:17
msgid ""
"[[Gnucap Linear Solver]] - Gnucap implements parse linear solver and it has "
"own \"quirks\". THis section describes known informaton about solver and "
"known issues"
msgstr ""

#. type: Plain text
#: user.txt:19 user/user.txt:19
msgid "[[Gnucap_Library]] - Experimental shared library version of Gnucap"
msgstr ""

#. type: Plain text
#: user.txt:22 user/user.txt:22
msgid ""
"[[Gnucap_Python]] - A plugin that allows Python code to be executed within a "
"Gnucap session and a Gnucap Python extension that allows direct access to "
"the Gnucap core from Python"
msgstr ""

#. type: Plain text
#: user.txt:24 user/user.txt:24
msgid ""
"[[Netlist import and export]] - Here is an idea for import and export of "
"netlists from schematics, layouts, and foreign systems, inspired by Gnucap "
"language plugins."
msgstr ""

#. type: Plain text
#: user.txt:26
msgid ""
"[[Language plugin for gschem]] - Plugin which can convert .sch file output "
"of gschem into .ckt which can be analyzed by gnucap."
msgstr ""

#. type: Plain text
#: user.txt:27 user/user.txt:30
msgid ""
"[[Sensitivity Anlysis]] - A Perl script to assist with sensitivity anylsis "
"of a circuit in gnucap"
msgstr ""

#. type: Plain text
#: user/unalias.txt:2
#, no-wrap
msgid "**17.UNALIAS**\n"
msgstr ""

#. type: Plain text
#: user/unalias.txt:4
msgid "Purpose:Removes the definition for each alias name specified."
msgstr ""

#. type: Plain text
#: user/unalias.txt:11
#, no-wrap
msgid ""
"     unalias [word]\n"
"     unalias all\n"
msgstr ""

#. type: Plain text
#: user/unalias.txt:15
msgid "word is the aliased name of the command."
msgstr ""

#. type: Plain text
#: user/unalias.txt:17
msgid "all option removes all the specified aliases."
msgstr ""

#. type: Plain text
#: user/unalias.txt:21
msgid "If info is the aliased name of sysinfo then it can be unaliased like"
msgstr ""

#. type: Plain text
#: user/unalias.txt:26
#, no-wrap
msgid ""
"     gnucap>unalias info  Removes the alias for sysinfo\n"
"     gnucap>unalias all   Removes all aliases\n"
"     are you sure you want to remove all aliases?y/n:y\n"
"     all aliases removed.\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:2
#, no-wrap
msgid "**18.UNDEF**\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:4
msgid "Purpose:Command removes the the user-defined functions."
msgstr ""

#. type: Plain text
#: user/undef.txt:11
#, no-wrap
msgid ""
"    undef [function_name]\n"
"    undef all\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:15
msgid "all flag removes all the user defined functions."
msgstr ""

#. type: Plain text
#: user/undef.txt:22
#, no-wrap
msgid ""
"     gnucap>undef max    Removes the ''max'' function\n"
"     gnucap>unalias all   Removes all function definitions\n"
"     are you sure you want to remove all function definitions?y/n:y\n"
"     all functions removed.\n"
"     gnucap>\n"
msgstr ""

#. type: Title ======
#: user/user.txt:1
#, no-wrap
msgid "User contributions"
msgstr ""

#. type: Plain text
#: user/user.txt:26
msgid "[[Language plugin for gschem]] -"
msgstr ""

#. type: Plain text
#: user/user.txt:28
msgid ""
"[[Gnucap_verilog_reconciled]] - Fix inconsistencies with verilog-ams in the "
"verilog language plugin and fix gEDA gnetlist verilog-ams back end to match."
msgstr ""

#. type: Plain text
#: user/user.txt:32
msgid ""
"[[Build System for Plugins]] - a proposal on how to painlessly "
"compile/install/load plugins"
msgstr ""

#. type: Plain text
#: user/user.txt:34
msgid "[[Sensitivity Command]] - a sensitivity analysis implementation"
msgstr ""

#. type: Plain text
#: user/user.txt:36
msgid ""
"[[IR filters and (tr-)noise]] - behavioural models implementing {F,I}IR "
"filters. possible noise applications"
msgstr ""

#. type: Plain text
#: user/user.txt:38
msgid "[[asco for gnucap]] - circuit optimization revisited"
msgstr ""

#. type: Plain text
#: user/user.txt:40
msgid "[[aging analysis]] - running tran in a loop, implementing aging effects"
msgstr ""

#. type: Plain text
#: user/user.txt:42
msgid "[[gnucap-adms]] - an admsXml-based verilog-a model compiler"
msgstr ""

#. type: Plain text
#: user/user.txt:44
msgid "[[Command Plugins]]- set of command plugins for scripting purposes."
msgstr ""

#. type: Plain text
#: user/user.txt:45
msgid ""
"[[Language Plugin for Qucs]] - Plugin which to convert output file of Qucs "
"into verilog netlist (.va or .vams) which can be analyzed by gnucap."
msgstr ""

#. type: Plain text
#: user/version.txt:2
#, no-wrap
msgid "**19.VERSION**\n"
msgstr ""

#. type: Plain text
#: user/version.txt:4
msgid "Purpose:Prints the version of gnucap being used"
msgstr ""

#. type: Plain text
#: user/version.txt:10
#, no-wrap
msgid "  version\n"
msgstr ""

#. type: Plain text
#: user/version.txt:14
msgid "'ver' also works."
msgstr ""

#. type: Plain text
#: user/version.txt:19
#, no-wrap
msgid ""
"      gnucap> version\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      gnucap>\n"
msgstr ""
