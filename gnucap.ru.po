# Russian translations for gnucap package
# Copyright (C) 2013 Vladimir Zhbanov
# This file is distributed under the same license as the gnucap package.
#
msgid ""
msgstr ""
"Project-Id-Version: gnucap\n"
"POT-Creation-Date: 2013-07-26 12:43+0400\n"
"PO-Revision-Date: 2013-05-16 17:16+0400\n"
"Last-Translator: Vladimir Zhbanov <vzhbanov@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: Title ======
#: manual.txt:1
#, no-wrap
msgid "Gnucap manual"
msgstr "Руководство по gnucap"

#. type: Plain text
#: manual.txt:4
msgid "This is a draft of the manual for the development version of gnucap."
msgstr "Это черновой набросок руководства для разрабатываемой версии gnucap."

#. type: Plain text
#: manual.txt:6
msgid "It attempts to describe the latest development release."
msgstr "Здесь мы пытаемся описать самую последнюю разрабатываемую версию."

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Introduction]]\n"
msgstr "[[gnucap:manual:Introduction.ru |Введение            ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Commands]]\n"
msgstr "[[gnucap:manual:Commands.ru     |Команды             ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Devices]]\n"
msgstr "[[gnucap:manual:Devices.ru      |Устройства          ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Languages]]\n"
msgstr "[[gnucap:manual:Languages.ru    |Языки               ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Howto|How to]]\n"
msgstr "[[gnucap:manual:Howto.ru        |Как сделать         ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Compatibility]]\n"
msgstr "[[gnucap:manual:Compatibility.ru|Совместимость       ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Tech|Tech notes]]\n"
msgstr "[[gnucap:manual:Tech.ru         |Технические заметки ]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Building and Installation]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Сборка и установка]]\n"

#. type: Bullet: '  * '
#: manual.txt:15
#, no-wrap
msgid "[[gnucap:manual:Examples]]\n"
msgstr "[[gnucap:manual:Examples.ru     |Примеры             ]]\n"

#. type: Title ======
#: manual/commands.txt:1 manual/languages/spectre.txt:94
#: manual/languages/verilog.txt:120
#, no-wrap
msgid "Commands"
msgstr "Команды"

#. type: Plain text
#: manual/commands.txt:4
msgid ""
"Gnucap commands are defined by plugins.  This section defines all commands "
"supplied in the main tarball."
msgstr ""
"Команды gnucap определяются посредством плагинов. В настоящем разделе "
"определяются все команды, поставляемые в основном tar-архиве."

#. type: Plain text
#: manual/commands.txt:6
msgid ""
"Your installation may not have all of these commands, and may have others in "
"addition to these.  It depends on which plugins you have installed."
msgstr ""
"В вашей установке может не быть всех представленных ниже команд, или могут "
"быть другие в дополнение к указанным. Это зависит от того, какие у вас "
"установлены плагины."

#. type: Title =====
#: manual/commands.txt:7
#, no-wrap
msgid "\"Simulation\" or \"analysis\" commands"
msgstr "Команды для моделирования или анализа"

#. type: Plain text
#: manual/commands.txt:10
msgid "These commands are the core simulation commands."
msgstr "Здесь представлены основные команды моделирования."

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:ac]] Performs a small signal AC (frequency domain) analysis. Sweeps frequency.\n"
msgstr "[[gnucap:manual:commands:ac.ru|ac]] Малосигнальный частотный анализ (в частотной области) при изменении частоты.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:dc]] Performs a nonlinear DC analysis, for determining transfer characteristics. Sweeps DC input or component values.\n"
msgstr "[[gnucap:manual:commands:dc.ru|dc]] Нелинейный анализ (расчёт статического режима) по постоянному току для определения передаточной характеристики при изменении входа по постоянному току или значений компонентов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:fourier]] Transient analysis, with results in frequency domain.\n"
msgstr "[[gnucap:manual:commands:fourier.ru|fourier]] Временной анализ с результатами в частотной области.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:op]] Performs a nonlinear DC analysis, for determining quiescent operating conditions. Sweeps temperature.\n"
msgstr "[[gnucap:manual:commands:op.ru|op]] Нелинейный анализ (расчёт статического режима) по постоянному току для определения статических условий работы при изменении температуры.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:transient]] Performs a nonlinear transient (time domain) analysis. Sweeps time.\n"
msgstr "[[gnucap:manual:commands:transient.ru|transient]] Нелинейный временной анализ (во временной области) при изменении времени.\n"

#. type: Title =====
#: manual/commands.txt:17
#, no-wrap
msgid "\"Data\" commands"
msgstr "Команды для работы с данными"

#. type: Plain text
#: manual/commands.txt:20
msgid "These commands manipulate the circuit."
msgstr "Данные команды служат для работы со схемами."

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:build]] Build a new circuit or change an existing one.\n"
msgstr "[[gnucap:manual:commands:build.ru |build        ]] Построение новой схемы или изменение уже существующей.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:delete|clear]] Delete the entire circuit, titles, etc.\n"
msgstr "[[gnucap:manual:commands:delete.ru|clear        ]] Удаление схемы полностью, заголовков и т. д.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:delete]] Delete a part, or group of parts.\n"
msgstr "[[gnucap:manual:commands:delete.ru|delete       ]] Удаление компонента, группы компонентов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:edit]] Edit the circuit description using your editor.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:fault|fault,unfault]] Temporarily change a component.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:list]] List the circuit on the display.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:alter|alter, modify]] Change a value, node, etc. For very simple changes.\n"
msgstr "[[gnucap:manual:commands:alter.ru |alter, modify]] Изменение значения компонента, узла и т. д. Для очень простых изменений.\n"

#. type: Title =====
#: manual/commands.txt:29
#, no-wrap
msgid "\"Parameter\" and \"Measure\" commands"
msgstr "Команды для работы с параметрами и измерениями"

#. type: Plain text
#: manual/commands.txt:32
msgid "These commands work with parameters."
msgstr "Данные команды предназначены для работы с параметрами."

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:parameter]] Set or view parameters.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:measure]] Make (post) measurements on your circuit.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:eval]] Evaluate parameters.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:37
#, no-wrap
msgid "\"Probe\" commands"
msgstr "Команды для датчиков"

#. type: Plain text
#: manual/commands.txt:40
msgid "These commands set up probes for later use."
msgstr ""
"Данные команды предназначены для настройки «датчиков» для дальнейшего "
"использования."

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:alarm]] Select points in the circuit to check against limits.\n"
msgstr "[[gnucap:manual:commands:alarm.ru|alarm]] Выбор точек схемы для проверки на превышение пределов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:plot|plot, iplot]] Select points in the circuit (and their range) to plot.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:print|print, iprint, probe]] Select points in the circuit to print as table.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:store]] Select points in the circuit to store for post-processing.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:46
#, no-wrap
msgid "\"File\" commands"
msgstr "Команды для работы с файлами"

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:include]] Include a file from disk. Add it the what is already in memory.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:lib]] Include parts of a library file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:load|load, unload]] Load a plugin.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:get]] Get a circuit from a disk file. Deletes old one first for a fresh start. (deprecated)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:save]] Save the circuit in a file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:log]] Create a log file.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:outfile|>]] Send a copy of the screen output to a file.\n"
msgstr ""

#. type: Title =====
#: manual/commands.txt:57
#, no-wrap
msgid "\"Other\" commands"
msgstr "Прочие команды"

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid "[[gnucap:manual:commands:end]] Perform analyses in queue. New circuit follows. (Implemented incorrectly.)\n"
msgstr "[[gnucap:manual:commands:end.ru|end]] Выполнение анализов по очереди. Далее следует описание новой схемы. (Реализовано неправильно.)\n"

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid "[[gnucap:manual:commands:exit|exit, quit]] Exits the program.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:options]] View and set system options. (Same as set.)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:temp]] Set or view temperature.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:width]] Set output width.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:sweep]] Sweep a component. (Loop function.) (deprecated)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:generator]] View and set the transient analysis function generator.\n"
msgstr "[[gnucap:manual:commands:generator.ru|generator]] Просмотр и настройка параметров функционального генератора для временного анализа.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:freeze|freeze, unfreeze]] Mark this time point, so transient analysis will restart here.\n"
msgstr "[[gnucap:manual:commands:freeze.ru|freeze, unfreeze]] Отметка указанной точки времени для перезапуска в ней временного анализа.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:chdir]] Change current directory.\n"
msgstr "[[gnucap:manual:commands:chdir.ru|chdir]] Смена текущего каталога.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:pause]] Wait for key hit in batch mode.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:status]] Display resource usage, etc.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, fuzzy, no-wrap
#| msgid "View and create the heading line for printouts and files."
msgid "[[gnucap:manual:commands:title]] View and create the heading line for printouts and files.\n"
msgstr "Просмотр и создание строки заголовка для вывода на печать и в файлы."

#. type: Title ======
#: manual/commands/ac.txt:1
#, no-wrap
msgid "\"ac\" command"
msgstr "Команда «ac»"

#. type: Title =====
#: manual/commands/ac.txt:3 manual/commands/alarm.txt:3
#: manual/commands/alter.txt:3 manual/commands/build.txt:3
#: manual/commands/chdir.txt:3 manual/commands/dc.txt:3
#: manual/commands/delete.txt:3 manual/commands/edit.txt:3
#: manual/commands/eval.txt:3 manual/commands/exit.txt:4
#: manual/commands/fault.txt:3 manual/commands/fourier.txt:3
#: manual/commands/freeze.txt:3 manual/commands/generator.txt:3
#: manual/commands/get.txt:3 manual/commands/include.txt:3
#: manual/commands/lib.txt:3 manual/commands/list.txt:3
#: manual/commands/load.txt:3 manual/commands/log.txt:3
#: manual/commands/measure.txt:3 manual/commands/op.txt:3
#: manual/commands/options.txt:3 manual/commands/options.txt:11
#: manual/commands/outfile.txt:3 manual/commands/parameter.txt:3
#: manual/commands/pause.txt:3 manual/commands/plot.txt:3
#: manual/commands/print.txt:3 manual/commands/save.txt:3
#: manual/commands/status.txt:3 manual/commands/store.txt:3
#: manual/commands/sweep.txt:3 manual/commands/temp.txt:3
#: manual/commands/title.txt:3 manual/commands/transient.txt:3
#: manual/commands/width.txt:3 manual/devices/basic/complex.txt:7
#: manual/devices/basic/exp.txt:8 manual/devices/basic/fit.txt:6
#: manual/devices/basic/generator.txt:7 manual/devices/basic/poly.txt:8
#: manual/devices/basic/posy.txt:8 manual/devices/basic/pulse.txt:8
#: manual/devices/basic/sffm.txt:8 manual/devices/basic/sin.txt:8
#: manual/devices/basic/tanh.txt:8 manual/devices/capacitor.txt:32
#: manual/devices/lossless_transmission_line.txt:7
#: manual/devices/mutual_inductance.txt:7 manual/devices/switches.txt:25
#: manual/measure/at.txt:3 manual/measure/cross.txt:3
#: manual/measure/mean.txt:3 manual/measure/minmax.txt:3
#: manual/measure/slope.txt:3
#, no-wrap
msgid "Purpose"
msgstr "Назначение"

#. type: Plain text
#: manual/commands/ac.txt:6
msgid "Performs a small signal, steady state, AC analysis. Sweeps frequency."
msgstr ""
"Выполнение малосигнального частотного анализа в установившемся режиме при "
"изменении частоты."

#. type: Title =====
#: manual/commands/ac.txt:7 manual/commands/alarm.txt:7
#: manual/commands/alter.txt:7 manual/commands/build.txt:7
#: manual/commands/chdir.txt:7 manual/commands/dc.txt:7
#: manual/commands/delete.txt:7 manual/commands/edit.txt:7
#: manual/commands/eval.txt:7 manual/commands/exit.txt:8
#: manual/commands/fault.txt:7 manual/commands/fourier.txt:7
#: manual/commands/freeze.txt:7 manual/commands/generator.txt:7
#: manual/commands/get.txt:8 manual/commands/include.txt:7
#: manual/commands/lib.txt:7 manual/commands/list.txt:7
#: manual/commands/load.txt:7 manual/commands/log.txt:7
#: manual/commands/measure.txt:7 manual/commands/op.txt:7
#: manual/commands/options.txt:7 manual/commands/outfile.txt:7
#: manual/commands/parameter.txt:7 manual/commands/pause.txt:7
#: manual/commands/plot.txt:7 manual/commands/print.txt:7
#: manual/commands/save.txt:7 manual/commands/status.txt:7
#: manual/commands/store.txt:7 manual/commands/sweep.txt:7
#: manual/commands/temp.txt:7 manual/commands/title.txt:7
#: manual/commands/transient.txt:7 manual/commands/width.txt:7
#: manual/devices/basic/complex.txt:3 manual/devices/basic/exp.txt:3
#: manual/devices/basic/fit.txt:2 manual/devices/basic/generator.txt:3
#: manual/devices/basic/poly.txt:3 manual/devices/basic/posy.txt:3
#: manual/devices/basic/pulse.txt:3 manual/devices/basic/sffm.txt:3
#: manual/devices/basic/sin.txt:3 manual/devices/basic/tanh.txt:3
#: manual/devices/lossless_transmission_line.txt:3
#: manual/devices/mutual_inductance.txt:3 manual/devices/switches.txt:3
#: manual/measure/at.txt:7 manual/measure/cross.txt:7
#: manual/measure/mean.txt:9 manual/measure/minmax.txt:7
#: manual/measure/slope.txt:7
#, no-wrap
msgid "Syntax"
msgstr "Синтаксис"

#. type: Plain text
#: manual/commands/ac.txt:10
#, no-wrap
msgid "  ac {//options// ...} //start stop stepsize// {//options// ...} \n"
msgstr "| ''**ac** {//параметры// ...} //начало конец размер_шага// {//параметры// ...}'' |\n"

#. type: Title =====
#: manual/commands/ac.txt:11 manual/commands/alarm.txt:14
#: manual/commands/alter.txt:12 manual/commands/build.txt:11
#: manual/commands/chdir.txt:12 manual/commands/dc.txt:12
#: manual/commands/delete.txt:14 manual/commands/edit.txt:12
#: manual/commands/eval.txt:11 manual/commands/exit.txt:13
#: manual/commands/fault.txt:12 manual/commands/fourier.txt:13
#: manual/commands/freeze.txt:12 manual/commands/generator.txt:11
#: manual/commands/get.txt:12 manual/commands/include.txt:11
#: manual/commands/lib.txt:12 manual/commands/list.txt:12
#: manual/commands/load.txt:13 manual/commands/log.txt:13
#: manual/commands/measure.txt:10 manual/commands/op.txt:11
#: manual/commands/options.txt:15 manual/commands/outfile.txt:13
#: manual/commands/parameter.txt:14 manual/commands/pause.txt:15
#: manual/commands/plot.txt:18 manual/commands/print.txt:15
#: manual/commands/save.txt:11 manual/commands/status.txt:12
#: manual/commands/store.txt:15 manual/commands/sweep.txt:11
#: manual/commands/temp.txt:12 manual/commands/title.txt:12
#: manual/commands/transient.txt:11 manual/commands/width.txt:11
#: manual/devices/basic/complex.txt:11 manual/devices/basic/exp.txt:11
#: manual/devices/basic/fit.txt:11 manual/devices/basic/generator.txt:12
#: manual/devices/basic/poly.txt:12 manual/devices/basic/posy.txt:13
#: manual/devices/basic/pulse.txt:12 manual/devices/basic/sffm.txt:12
#: manual/devices/basic/sin.txt:12 manual/devices/basic/tanh.txt:12
#: manual/devices/capacitor.txt:35
#: manual/devices/lossless_transmission_line.txt:11
#: manual/devices/mutual_inductance.txt:11 manual/measure/mean.txt:22
#: manual/measure/slope.txt:23
#, no-wrap
msgid "Comments"
msgstr "Описание"

#. type: Plain text
#: manual/commands/ac.txt:14
msgid ""
"The \"ac\" command does a linear analysis about an operating point. It is "
"absolutely necessary to do an \"op\" analysis first on any nonlinear "
"circuit. Not doing this is the equivalent of testing it with the power off."
msgstr ""
"Команда **ac** служит для выполнения линейного анализа в области рабочей "
"точки. Для любой нелинейной схемы абсолютно необходимо сначала выполнить "
"анализ [[op.ru|op]]. Его невыполнение эквивалентно тестированию схемы с "
"отключенным питанием."

#. type: Plain text
#: manual/commands/ac.txt:16
msgid ""
"Three parameters are normally needed for an AC analysis: start frequency, "
"stop frequency and step size, in this order. If all of these are omitted, "
"the values from the most recent AC analysis are used."
msgstr ""
"Обычно для частотного анализа нужно три параметра: начальная частота, "
"конечная частота и размер шага, в указанном порядке. Если ничего из этого не "
"задано, будут использоваться значения самого последнего анализа."

#. type: Plain text
#: manual/commands/ac.txt:18
msgid ""
"If only one frequency is specified, a single point analysis will be done."
msgstr "Если указана только одна частота, будет сделан анализ в одной точке."

#. type: Plain text
#: manual/commands/ac.txt:20
msgid ""
"If only a new step size is specified, the old start and stop are kept and "
"only the step size is changed. This is indicated by a keyword: by, times, "
"decade or octave, or a symbol: + or *."
msgstr ""
"Если указан только новый размер шага, старые значения начальной и конечной "
"частоты будут сохранены и изменится только размер шага. Шаг задаётся с "
"помощью ключевых слов ''by'', ''times'', ''decade'' или ''octave'' или одним "
"из символов ''+'' или ''*''."

#. type: Plain text
#: manual/commands/ac.txt:22
msgid ""
"If the start frequency is zero, the program will still do an AC analysis. "
"The actual frequency can be considered to be the limit as the frequency "
"approaches zero. It is, therefore, still possible to have a non-zero phase "
"angle, but delays are not shown because they may be infinite."
msgstr ""
"Если начальная частота равна нулю, программа всё же выполнит частотный "
"анализ. За фактическую начальную частоту может приниматься предельное, очень "
"близкое к нулю значение. Поэтому угол фазы всё же может быть ненулевым, но "
"задержки не отображаются, поскольку они могут быть бесконечными."

#. type: Plain text
#: manual/commands/ac.txt:24
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command. This is different from Spice."
msgstr ""
"Контролируемые узлы должны быть заранее выбраны командами [[print.ru|print]] "
"или [[plot.ru|plot]]. Это отличие от SPICE."

#. type: Title =====
#: manual/commands/ac.txt:25 manual/commands/dc.txt:28
#: manual/commands/fourier.txt:36 manual/commands/op.txt:23
#: manual/commands/transient.txt:23
#, no-wrap
msgid "Options"
msgstr "Параметры"

#. type: Title ====
#: manual/commands/ac.txt:27 manual/commands/dc.txt:30
#: manual/commands/fourier.txt:38 manual/commands/op.txt:25
#: manual/commands/transient.txt:25
#, no-wrap
msgid "Sweep control"
msgstr "Настройка развёртки"

#. type: Plain text
#: manual/commands/ac.txt:36
#, no-wrap
msgid ""
"|start //frequency//   |Sweep start //frequency//.  |\n"
"|stop //frequency//    |Sweep stop //frequency//.  |\n"
"|+ //stepsize//        |Linear sweep. Add //stepsize// to get the next step. Same as by.  |\n"
"|* //multiplier//      |Log sweep. Multiply by //multiplier// to get the next step.  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next step. Same as +.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|octave //steps//      |Log sweep. Use //steps// steps per octave.  |\n"
"|times //multiplier//  |Log sweep. Multiply by //multiplier// to get the next step.  |\n"
msgstr ""
"|''start //частота//            ''|Начальная ''//частота//'' диапазона.  |\n"
"|''stop //частота//             ''|Конечная  ''//частота//'' диапазона.  |\n"
"|''+ //шаг//                    ''|Линейная развёртка. Для получения следующей частоты добавляется ''//шаг//''. То же самое, что ''by''.  |\n"
"|''* //множитель//              ''|Логарифмическая развёртка. Следующий шаг получается умножением предыдущего значения на ''//множитель//''.  |\n"
"|''by //шаг//                   ''|Линейная развёртка. Для получения следующей частоты добавляется ''//шаг//''. То же самое, что ''+''.  |\n"
"|''decade //количество_шагов//  ''|Логарифмическая развёртка. Используется заданное ''//количество_шагов//'' на декаду.  |\n"
"|''octave //количество_шагов//  ''|Логарифмическая развёртка. Используется заданное ''//количество_шагов//'' на октаву.  |\n"
"|''times //множитель//          ''|Логарифмическая развёртка. Следующий шаг получается умножением предыдущего значения на ''//множитель//''.  |\n"

#. type: Title ====
#: manual/commands/ac.txt:37 manual/commands/dc.txt:39
#: manual/commands/fourier.txt:44 manual/commands/op.txt:34
#: manual/commands/transient.txt:31
#, no-wrap
msgid "Input / Output"
msgstr "Вход / Выход"

#. type: Plain text
#: manual/commands/ac.txt:43 manual/commands/dc.txt:45
#: manual/commands/fourier.txt:50 manual/commands/op.txt:40
#: manual/commands/transient.txt:37
#, no-wrap
msgid ""
"|> //file//   |Send results of analysis to file.  |\n"
"|>> //file//  |Append results to file.  |\n"
"|noplot       |Suppress plotting.  |\n"
"|plot         |Graphic output, when plotting is normally off.  |\n"
"|quiet        |Suppress console output.  |\n"
msgstr ""
"|''> //файл//       ''| Вывод результатов анализа в ''//файл//''      |\n"
"|''%%>>%% //файл//  ''| Добавление результатов в ''//файл//''         |\n"
"|''noplot           ''| Запрет построения графиков                    |\n"
"|''plot             ''| Разрешение вывода графиков, если он запрещён  |\n"
"|''quiet            ''| Запрет вывода на консоль                      |\n"

#. type: Title ====
#: manual/commands/ac.txt:44 manual/commands/dc.txt:51
#: manual/commands/fourier.txt:58 manual/commands/op.txt:41
#: manual/commands/transient.txt:44
#, no-wrap
msgid "Other"
msgstr "Прочие"

#. type: Plain text
#: manual/commands/ac.txt:47
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command. This does not apply to nonlinear components, which will inherit the temperature from the operating point analysis.|\n"
"|temperature //degrees//  |Temperature, degrees C. This does not apply to nonlinear components, which will inherit the temperature from the operating point analysis.|\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]]. Это не касается нелинейных компонентов, которые наследуют свою температуру из анализа [[op.ru|op]].|\n"
"|''temperature //градусы//  ''| Температура, °C. Это не касается нелинейных компонентов, которые наследуют свою температуру из анализа [[op.ru|op]].|\n"

#. type: Title =====
#: manual/commands/ac.txt:48 manual/commands/alarm.txt:33
#: manual/commands/chdir.txt:18 manual/commands/dc.txt:55
#: manual/commands/delete.txt:24 manual/commands/edit.txt:22
#: manual/commands/eval.txt:15 manual/commands/fourier.txt:64
#: manual/commands/freeze.txt:18 manual/commands/generator.txt:42
#: manual/commands/get.txt:22 manual/commands/include.txt:19
#: manual/commands/list.txt:22 manual/commands/load.txt:29
#: manual/commands/log.txt:25 manual/commands/measure.txt:40
#: manual/commands/op.txt:50 manual/commands/outfile.txt:21
#: manual/commands/parameter.txt:30 manual/commands/pause.txt:21
#: manual/commands/plot.txt:45 manual/commands/print.txt:33
#: manual/commands/save.txt:19 manual/commands/store.txt:27
#: manual/commands/title.txt:18 manual/commands/transient.txt:50
#: manual/devices/basic/inline_behavioral_modeling.txt:79
#: manual/measure/at.txt:22 manual/measure/cross.txt:34
#: manual/measure/mean.txt:30 manual/measure/minmax.txt:21
#: manual/measure/slope.txt:29
#, no-wrap
msgid "Examples"
msgstr "Примеры"

#. type: Plain text
#: manual/commands/ac.txt:69
#, no-wrap
msgid ""
"  ac 10m\n"
"A single point AC analysis at 10 mHz.\n"
"  ac 1000 3000 100\n"
"Sweep from 1000 Hz to 3000 Hz in 100 Hz steps.\n"
"  ac start=1000 stop=3000 step=100\n"
"Same as the last one.\n"
"  ac 1000 3000 Octave\n"
"Sweep from 1000 Hz to 3000 Hz in octave steps. Since the sweep cannot end at 3000 Hz, in this case, the last step will really be 4000 Hz.\n"
"  ac by 250\n"
"Keep the same limits as before, but use 250 Hz steps. In this case, it means to sweep from 1000 to 3000 Hz, because that it what it was the last time.\n"
"  ac 5000 1000 -250\n"
"You can sweep downward, if you want. Remember that the increment would be negative.\n"
"  ac 20 20k *2\n"
"Double the frequency to get the next step.\n"
"  ac 20k 20 *.5\n"
"You can do a log sweep downward, too. A multiplier of less than one moves it down.\n"
"  ac\n"
"Do the same AC sweep again.\n"
"  ac >afile\n"
"Save the results in the file ''afile''. The file will look just like the screen. It will have all probe points. It will be a plot, if plotting is enabled.\n"
msgstr ""
"  ac 10m\n"
"Частотный анализ в одной точке при 10 МГц.\n"
"  ac 1000 3000 100\n"
"Изменение от 1000 Гц до 3000 Гц с шагом 100 Гц.\n"
"  ac start=1000 stop=3000 step=100\n"
"То же самое.\n"
"  ac 1000 3000 Octave\n"
"Изменение от 1000 Гц до 3000 Гц с шагом в октаву. Так как в данном случае\n"
"невозможно попасть в конечную точку диапазона 3000 Гц, последней точкой на\n"
"самом деле будет 4000 Гц.\n"
"  ac by 250\n"
"Изменять частоту в тех же самых пределах, что и прежде, но с шагом 250 Гц. В\n"
"данном случае это значит, что диапазон будет от 1000 до 3000 Гц, потому что\n"
"это тот самый диапазон, что был задан в последний раз.\n"
"  ac 5000 1000 -250\n"
"Если нужно, частоту можно менять в обратном направлении. Запомните, что шаг\n"
"может быть отрицательным.\n"
"  ac 20 20k *2\n"
"Для получения последующих шагов удваивать частоту.\n"
"  ac 20k 20 *.5\n"
"Можно изменять частоту по логарифмическому закону и в обратном направлении.\n"
"Для этого используется множитель меньше единицы.\n"
"  ac\n"
"Повторить тот же самый анализ.\n"
"  ac >afile\n"
"Сохранить результаты в файл ''afile''. Результаты в файле будут выглядеть\n"
"точно так же, как и на экране. Там будут результаты для всех датчиков.\n"
"Если разрешено построение графика, там будет график.\n"

#. type: Title ======
#: manual/commands/alarm.txt:1
#, no-wrap
msgid "\"alarm\" command"
msgstr "Команда «alarm»"

#. type: Plain text
#: manual/commands/alarm.txt:6
msgid "Select points in the circuit to check against user defined limits."
msgstr ""
"Выбор точек схемы для проверки на превышение установленных пользователем "
"пределов."

#. type: Plain text
#: manual/commands/alarm.txt:13
#, no-wrap
msgid ""
"  alarm\n"
"  alarm mode points ... ...\n"
"  alarm mode + points ... ...\n"
"  alarm mode - points ... ...\n"
"  alarm mode clear\n"
msgstr ""
"| ''**alarm**                              ''|\n"
"| ''**alarm** //режим       точки ... ...//''|\n"
"| ''**alarm** //режим// + //точки ... ...//''|\n"
"| ''**alarm** //режим// - //точки ... ...//''|\n"
"| ''**alarm** //режим//     clear          ''|\n"

#. type: Plain text
#: manual/commands/alarm.txt:17
msgid ""
"The `alarm' command selects points in the circuit to check against limits. "
"There is no output unless the limits are exceeded. If the limits are "
"exceeded a the value is printed."
msgstr ""
"Командой **alarm** выбираются точки схемы для проверки на превышение "
"пределов. Она ничего не выводит, пока пределы не превышены. При превышении "
"пределов выводится значение."

#. type: Plain text
#: manual/commands/alarm.txt:19 manual/commands/plot.txt:23
#: manual/commands/print.txt:20
msgid "There are separate lists of probe points for each type of analysis."
msgstr ""
"Для каждого вида анализа имеются отдельные списки [[..:howto:probes.ru|"
"датчиков]]."

#. type: Plain text
#: manual/commands/alarm.txt:21
msgid "To list the points, use the bare command `alarm'."
msgstr ""
"Для вывода перечня точек измерения используйте команду **''alarm''** без "
"параметров."

#. type: Plain text
#: manual/commands/alarm.txt:26 manual/commands/plot.txt:30
#, no-wrap
msgid ""
"Syntax for each point is:\n"
"  parameter(node)(limits)\n"
"  parameter(componentlabel)(limits)\n"
"  parameter(index)(limits)\n"
msgstr ""
"Синтаксис для каждой точки таков:\n"
"  параметр(узел)(пределы)\n"
"  параметр(обозначение_компонента)(пределы)\n"
"  параметр(индекс)(пределы)\n"

#. type: Plain text
#: manual/commands/alarm.txt:28 manual/commands/plot.txt:32
msgid "Some require a dummy index."
msgstr "Для некоторых параметров требуется фиктивный индекс."

#. type: Plain text
#: manual/commands/alarm.txt:30 manual/commands/plot.txt:34
msgid "For more information on the data available see the print command."
msgstr ""
"Более подробную информацию о доступных данных см. в [[print.ru|описании "
"команды print]]."

#. type: Plain text
#: manual/commands/alarm.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"alarm ac + v(3) adds v(3) to the existing set of AC probes. alarm ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами «''+''» или «''-''», их можно добавлять в "
"существующий список или удалять из него. **''alarm ac + v(3)''** добавит ''v"
"(3)'' в существующий набор датчиков для анализа [[ac.ru|ac]]. **''alarm ac - "
"q(c5)''** удалит ''q(c5)'' из списка. При удалении можно использовать "
"метасимволы «''*''» и «''?''»."

#. type: Plain text
#: manual/commands/alarm.txt:46
#, no-wrap
msgid ""
"  alarm ac vm(12)(0,5) vm(13)(-5,5)\n"
"Check magnitude of the voltage at node 12 against a range of 0 to 5, and node 13 against a range of -5 to 5 for AC analysis. Print a warning when the limits are exceeded.\n"
"  alarm op id(m*)(-100n,100n)\n"
"Check current in all mosfets. In op analysis, print a warning for any that are outside the range of -100 to +100 nanoamps. The range goes both positive and negative so it is valid for both N and P channel fets.\n"
"  alarm tran v(r83)(0,5) p(r83)(0,1u)\n"
"Check the voltage and power of R83 in the next transient analysis. The voltage range is 0 to 5. The power range is 0 to 1 microwatt. Print a warning when the range is exceeded.\n"
"  alarm\n"
"List all the probes for all modes.\n"
"  alarm dc\n"
"Display the DC alarm list.\n"
"  alarm ac clear\n"
"Clear the AC list.\n"
msgstr ""
"  alarm ac vm(12)(0,5) vm(13)(-5,5)\n"
"Проверять соответствие амплитуды напряжения узла 12 диапазону 0 ... 5, а узла 13 − диапазону -5 ... 5 для анализа [[ac.ru|ac]]. При превышении пределов выводить предупреждения.\n"
"  alarm op id(m*)(-100n,100n)\n"
"Проверять ток всех полевых транзисторов. При выполнении анализа [[op.ru|op]] выводить предупреждения для любого из них, ток которого вне диапазона -100 ... +100 наноампер.  Диапазон распространяется и в положительную, и в отрицательную сторону, поэтому это подходит как для транзисторов с n-, так и с p-каналом.\n"
"  alarm tran v(r83)(0,5) p(r83)(0,1u)\n"
"Проверять напряжение и мощность R83 в следующем [[transient.ru|временном анализе]]. Диапазон напряжения 0 ... 5. Диапазон мощности 0 ... 1 микроватт. При превышении диапазона вывести предупреждение.\n"
"  alarm\n"
"Вывести все датчики для всех режимов.\n"
"  alarm dc\n"
"Показать список точек сигнализации для [[dc.ru|dc]].\n"
"  alarm ac clear\n"
"Очистить список точек для [[ac.ru|ac]].\n"

#. type: Title ======
#: manual/commands/alter.txt:1
#, no-wrap
msgid "\"alter\", \"modify\" commands"
msgstr "Команды «alter», «modify»"

#. type: Plain text
#: manual/commands/alter.txt:6
msgid "Quickly change a component value."
msgstr "Быстрое изменение значения компонента."

#. type: Plain text
#: manual/commands/alter.txt:11
#, no-wrap
msgid ""
"  alter  partlabel=value ...\n"
"  modify partlabel=value ...\n"
msgstr ""
"|''**alter**  //обозначение_компонента=значение// ...''|\n"
"|''**modify** //обозначение_компонента=значение// ...''|\n"

#. type: Plain text
#: manual/commands/alter.txt:15
msgid ""
"This command quickly changes the value of a component. It is restricted to "
"simply changing the value."
msgstr ""
"Эта команда позволяет быстро изменить значение компонента. Её действие "
"ограничено только этим."

#. type: Plain text
#: manual/commands/alter.txt:17
msgid ""
"If several components have the same label or if wildcard characters are "
"used, all are changed."
msgstr ""
"Если обозначения нескольких компонентов одинаковы, а также при использовании "
"метасимволов, изменяются значения всех компонентов, соответствующих "
"заданному выражению."

#. type: Title ====
#: manual/commands/alter.txt:18 manual/commands/fault.txt:24
#: manual/commands/sweep.txt:31 manual/devices/basic/complex.txt:22
#: manual/devices/basic/fit.txt:73 manual/devices/basic/posy.txt:48
#: manual/devices/basic/tanh.txt:36 manual/howto/expressions.txt:13
#: manual/tech/plugins/coding.txt:25
#, no-wrap
msgid "Example"
msgstr "Пример"

#. type: Plain text
#: manual/commands/alter.txt:25
#, no-wrap
msgid ""
"  modify R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  modify C12=220p L1=1u\n"
"C12 is 220 pf and L1 is 1 uH.\n"
"  modify R*=22k\n"
"All resistors are now 22k.\n"
msgstr ""
"  modify R66=1k\n"
"R66 имеет теперь значение 1 кОм, независимо от того, каким оно было до того.\n"
"  modify C12=220p L1=1u\n"
"C12 теперь равно 220 пФ, а L1 --- 1 мкГн.\n"
"  modify R*=22k\n"
"Все резисторы теперь по 22 кОм.\n"

#. type: Title ======
#: manual/commands/build.txt:1
#, no-wrap
msgid "\"build\" command"
msgstr "Команда «build»"

#. type: Plain text
#: manual/commands/build.txt:6
msgid "Builds a new circuit, with Spice syntax."
msgstr "Построение новой схемы с использованием синтаксиса SPICE."

#. type: Plain text
#: manual/commands/build.txt:10
#, no-wrap
msgid "  build\n"
msgstr "|''**build**''|\n"

#. type: Plain text
#: manual/commands/build.txt:14
msgid ""
"\"Build\" lets you enter the circuit from the keyboard. The prompt changes "
"to > to show that the program is in the build mode."
msgstr ""
"Команда **build** позволяет ввести описание схемы с клавиатуры. Признаком "
"перехода в режим построения схемы является изменение приглашения программы "
"на ''>''."

#. type: Plain text
#: manual/commands/build.txt:16
msgid "At this point, type in the circuit components in Spice netlist format."
msgstr ""
"В этот момент можно вводить компоненты схем в формате списка соединений [[..:"
"languages:SPICE.ru|SPICE]]."

#. type: Plain text
#: manual/commands/build.txt:18
msgid ""
"Component labels must be unique. If not, the old one is modified according "
"to the new data, keeping old values where no new ones were specified."
msgstr ""
"Обозначения компонентов должны быть уникальными. В противном случае в "
"качестве новых компонентов будут использоваться одноимённые старые, "
"модифицированные в соответствии с новыми данными, и сохраняющие старые "
"значения для тех параметров, для которых не было указано новых."

#. type: Plain text
#: manual/commands/build.txt:20
msgid "Components are added to the end of the list."
msgstr "Компоненты добавляются к концу списка."

#. type: Plain text
#: manual/commands/build.txt:22
msgid ""
"Components being changed or replaced do not change their location in the "
"list."
msgstr ""
"Изменяемые или перемещаемые компоненты не меняют своего местоположения в "
"списке."

#. type: Plain text
#: manual/commands/build.txt:24
msgid ""
"If it is necessary to start over, \"delete all\" or \"clear\" will erase the "
"entire circuit in memory."
msgstr ""
"Если необходимо всё начать заново, полностью удалить схему из памяти можно "
"командами [[delete.ru|delete all]] или [[delete.ru|clear]]."

#. type: Plain text
#: manual/commands/build.txt:26
msgid "To exit this mode, enter a blank line."
msgstr "Для выхода из этого режима введите пустую строку."

#. type: Plain text
#: manual/commands/build.txt:27
msgid ""
"This command is deprecated, and may be removed in a future release.  You can "
"use the command \"spice\" instead."
msgstr ""
"Данную команду использовать не рекомендуется, в одной из будущих версий "
"программы она может быть удалена. Вместо неё можно использовать команду "
"[[spice.ru|spice]]."

#. type: Title ======
#: manual/commands/chdir.txt:1
#, no-wrap
msgid "\"chdir\" command"
msgstr "Команда «chdir»"

#. type: Plain text
#: manual/commands/chdir.txt:6
msgid "Changes or displays the current directory name."
msgstr "Смена текущего каталога и отображение его имени."

#. type: Plain text
#: manual/commands/chdir.txt:11
#, no-wrap
msgid ""
"  chdir {path}\n"
"  cd {path}\n"
msgstr ""
"|''**chdir** {//путь//}''|\n"
"|''**cd   ** {//путь//}''|\n"

#. type: Plain text
#: manual/commands/chdir.txt:15
msgid ""
"Change the current directory to that specified by path. See your system "
"manual for complete syntax."
msgstr ""
"Смена текущего каталога на заданный путь. Полный синтаксис см. в руководстве "
"по своей системе."

#. type: Plain text
#: manual/commands/chdir.txt:17
msgid "If no argument is given the current directory is displayed."
msgstr "Если аргумент не указан, выводится имя текущего каталога."

#. type: Plain text
#: manual/commands/chdir.txt:23
#, no-wrap
msgid ""
"  cd ../ckt\n"
"Change the current working directory to ../ckt.\n"
"  cd\n"
"Show the current working directory name.\n"
msgstr ""
"  cd ../ckt\n"
"Смена текущего рабочего каталога на ''../ckt''.\n"
"  cd\n"
"Показать имя текущего рабочего каталога.\n"

#. type: Title ======
#: manual/commands/dc.txt:1
#, no-wrap
msgid "\"dc\" command"
msgstr "Команда «dc»"

#. type: Plain text
#: manual/commands/dc.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, and sweeps the signal input, "
"or a component value."
msgstr ""
"Выполнение нелинейного расчёта статического режима по постоянному току при "
"изменении входного сигнала по постоянному току или значения физической "
"величины компонента."

#. type: Plain text
#: manual/commands/dc.txt:11
#, no-wrap
msgid ""
"  dc start stop stepsize {options ...}\n"
"  dc label start stop stepsize {options ...} \n"
msgstr ""
"|''**dc** //                       начало конец размер_шага// {//параметры ...//}''|\n"
"|''**dc** //обозначение_компонента начало конец размер_шага// {//параметры ...//}''|\n"

#. type: Plain text
#: manual/commands/dc.txt:15 manual/commands/fourier.txt:20
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command."
msgstr ""
"Контролируемые узлы должны быть заранее выбраны командами [[print.ru|print]] "
"или [[plot.ru|plot]]."

#. type: Plain text
#: manual/commands/dc.txt:17
msgid ""
"If there are numeric arguments, without a part label, they represent a ramp "
"from the generator function. They are the start value, stop value and step "
"size, in order. They are saved between commands, so no arguments will repeat "
"the previous sweep."
msgstr ""
"Если указаны числовые аргументы без обозначения компонента, ими задаётся "
"линейная функция генератора сигнала. Это начальное значение, конечное "
"значение и размер шага, в указанном порядке. Они сохраняются между "
"командами, поэтому ни при каких аргументах предыдущая развёртка повторяться "
"не будет."

#. type: Plain text
#: manual/commands/dc.txt:19
msgid ""
"A single parameter represents a single input voltage. Two parameters "
"instruct the computer to analyze for those two points only."
msgstr ""
"Одним параметром задаётся одно входное напряжение. Двумя параметрами "
"компьютеру даётся приказ произвести расчёт только для двух указанных точек."

#. type: Plain text
#: manual/commands/dc.txt:21
msgid ""
"In some cases, you will get one more step outside the specified range of "
"inputs due to internal rounding errors. The last input may be beyond the end "
"point."
msgstr ""
"В некоторых случаях вследствие внутренних ошибок округления один шаг может "
"оказаться за пределами указанного диапазона значений входных данных. "
"Последнее значение может оказаться после конечной точки."

#. type: Plain text
#: manual/commands/dc.txt:23
msgid ""
"This command also sets up a movable operating point for subsequent AC "
"analysis, which can be helpful in distortion analysis."
msgstr ""
"Этой командой также настраивается подвижная рабочая точка для последующего "
"анализа [[ac.ru|ac]], которая может быть полезной при анализе искажений."

#. type: Plain text
#: manual/commands/dc.txt:25
msgid ""
"The program will sweep any simple component, including resistors, "
"capacitors, and controlled sources. SPICE sweeps only fixed sources (types V "
"and I)."
msgstr ""
"Программа будет производить развёртку с изменением значения любого простого "
"компонента, включая резисторы, конденсаторы и управляемые источники "
"напряжения и тока. SPICE может менять лишь значения независимых источников "
"напряжения и тока (типов V и I)."

#. type: Plain text
#: manual/commands/dc.txt:27
msgid "This command will sweep up to 4 components, nested."
msgstr ""
"Этой командой производится развёртка с изменением значений до 4 компонентов "
"одновременно."

#. type: Plain text
#: manual/commands/dc.txt:38 manual/commands/op.txt:33
#, no-wrap
msgid ""
"|* //multiplier//      |Log sweep. Multiply the input by //multiplier// to get the next step. Do not pass zero volts!!  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next step.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|times //multiplier//  |Log sweep. Multiply the input by multiplier to get the next step. Do not pass zero volts!!  |\n"
"|continue              |Use the last step of a OP, DC or Transient analysis as the first guess.  |\n"
"|loop                  |Repeat the sweep, backwards.  |\n"
"|reverse               |Sweep in the opposite direction.  |\n"
msgstr ""
"|''* //множитель//         ''| Логарифмическая развёртка. Умножать входное значение на ''//множитель//'' для получения следующего шага. Не задавайте 0 вольт!  |\n"
"|''by //размер_шага//      ''| Линейная развёртка. Добавлять ''//размер_шага//'' для получения следующего шага.  |\n"
"|''decade //число_шагов//  ''| Логарифмическая развёртка. Использовать ''//число_шагов//'' на декаду.  |\n"
"|''times //множитель//     ''| Логарифмическая развёртка. Умножать входное значение на ''//множитель//'' для получения следующего шага. Не задавайте 0 вольт!  |\n"
"|''continue                ''| Использовать как первое приближение последний шаг анализа [[op.ru|op]], [[dc.ru|dc]] или [[transient.ru|transient]].  |\n"
"|''loop                    ''| Повторить развёртку в обратном направлении.  |\n"
"|''reverse                 ''| Развёртка в обратном направлении.  |\n"

#. type: Plain text
#: manual/commands/dc.txt:50 manual/commands/op.txt:49
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""
"|''trace off         ''| Без вывода расширенной трассировочной информации  |\n"
"|''trace warnings    ''| Отображение расширенных предупреждений            |\n"
"|''trace iterations  ''| Отображение каждой итерации                       |\n"
"|''trace verbose     ''| Расширенные диагностические сообщения             |\n"

#. type: Plain text
#: manual/commands/dc.txt:54 manual/commands/op.txt:44
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"

#. type: Plain text
#: manual/commands/dc.txt:70
#, no-wrap
msgid ""
"  dc 1\n"
"Do a single point DC signal simulation, with `1 volt' input.\n"
"  dc -10 15 1\n"
"Sweep the circuit input from -10 to +15 in steps of 1. (usually volts.) Do a DC transfer simulation at each step.\n"
"  dc\n"
"With no parameters, it uses the same ones as the last time. In this case, from -10 to 15 in 1 volt steps.\n"
"  dc V13 -10 15 1\n"
"Sweep the \"value\" of the component \"V13\" from -10 to +15 in steps of 1. Do a DC transfer simulation at each step.\n"
"  dc 20 0 -2\n"
"You can sweep downward, by asking for a negative increment. Sometimes, this will result in better convergence, or even different results! (For example, in the case of a bi-stable circuit.)\n"
"  dc -2 2 .1 loop\n"
"After the sweep, do it again in the opposite direction. In this case, the sweep is -2 to +2 in steps of .1. After it gets to +2, it will go back, and sweep from +2 to -2 in steps of -.1. The plot will be superimposed on the up sweep. This way, you can see hysteresis in the circuit.\n"
"  dc temperature=75\n"
"Simulate at 75 degrees, this time. Since we didn't specify new sweep parameters, do the same as last time. (Without the loop.)\n"
msgstr ""
"  dc 1\n"
"Выполнить моделирование статического режима по постоянному току в\n"
"одной точке с входным напряжением 1 вольт.\n"
"  dc -10 15 1\n"
"Изменять вход схемы от -10 до +15 с шагом 1 (обычно вольт).\n"
"Для каждого шага выполнять моделирование статических передаточных\n"
"характеристик по постоянному току.\n"
"  dc\n"
"Если параметры не указаны, используются те же параметры, что и в\n"
"последний раз. В данном случае моделирование от -10 до 15 с шагом\n"
"1 В.\n"
"  dc V13 -10 15 1\n"
"Изменять «значение» компонента ''V13'' от -10 до +15 с шагом 1.\n"
"Для каждого шага выполнять моделирование статических передаточных\n"
"характеристик по постоянному току.\n"
"  dc 20 0 -2\n"
"Запросив отрицательное приращение, можно менять значения в обратную\n"
"сторону. Иногда это приводит к лучшей сходимости, или даже к\n"
"отличающимся результатам! (Например, в случае бистабильной схемы.)\n"
"  dc -2 2 .1 loop\n"
"По завершению развёртки сделать её ещё раз в обратном направлении.\n"
"В данном случае значение изменяется от -2 до +2 с шагом 0,1. После\n"
"достижения значения +2 отсчёт пойдёт назад и развёртка пойдёт от\n"
"+2 до -2 с шагом -0,1. График будет наложен на развёртку вверх.\n"
"Таким образом в схеме можно наблюдать гистерезис.\n"
"  dc temperature=75\n"
"В этот раз моделировать при 75 градусах. Так как мы не указали\n"
"новые параметры развёртки, делать то же самое, что и в прошлый\n"
"раз (без ''loop'').\n"

#. type: Title ======
#: manual/commands/delete.txt:1
#, no-wrap
msgid "\"delete\" command"
msgstr "Команда «delete»"

#. type: Plain text
#: manual/commands/delete.txt:6
msgid "Remove a line, or a group of lines, from the circuit description."
msgstr "Удаление строки или группы строк из описания схемы."

#. type: Plain text
#: manual/commands/delete.txt:11
#, no-wrap
msgid ""
"  delete label ...\n"
"  delete all\n"
msgstr ""
"|''**delete** //обозначение_компонента// ...''|\n"
"|''**delete** all                           ''|\n"

#. type: Plain text
#: manual/commands/delete.txt:13
#, no-wrap
msgid "  clear\n"
msgstr "|''**clear**''|\n"

#. type: Plain text
#: manual/commands/delete.txt:17
msgid ""
"To delete a part, by label, enter the label. (Example `DEL R15'.) Wildcards "
"`*' and `?' are allowed, in which case, all that match are deleted."
msgstr ""
"Для удаления компонента по обозначению введите обозначение. (Пример: **''DEL "
"R15''**.) Разрешается использование метасимволов ''*'' и ''?'', в этом "
"случае удаляются любые совпадения."

#. type: Plain text
#: manual/commands/delete.txt:19
msgid ""
"To delete the entire circuit, the entire word ALL must be entered. (Example "
"`DEL ALL'.)"
msgstr ""
"Для удаления схемы целиком нужно ввести полностью слово ''ALL''. (Пример: "
"**''DEL ALL''**.)"

#. type: Plain text
#: manual/commands/delete.txt:21
msgid ""
"After deleting anything, there is usually no way to get it back, but if a "
"fault had been applied (see fault command) restore may have surprising "
"results."
msgstr ""
"Обычно после удаления всей схемы нет способа вернуть её обратно, но если до "
"того использовалась команда **''fault''** (см. [[fault.ru|описание команды "
"fault]]), попытка восстановления может привести с неожиданным результатам."

#. type: Plain text
#: manual/commands/delete.txt:23
msgid "\"clear\" is similar to, but a little more drastic than delete all."
msgstr ""
"Команда **''clear''** подобна команде **''delete all''**, но действует "
"несколько более радикально."

#. type: Plain text
#: manual/commands/delete.txt:35
#, no-wrap
msgid ""
"  delete all\n"
"Delete the entire circuit, but save the title.\n"
"  delete R12\n"
"Delete R12.\n"
"  delete R12 C3\n"
"Delete R12 and C3.\n"
"  delete R*\n"
"Delete all resistors. (Also, any models and subcircuits starting with R.)\n"
"  clear\n"
"Clear out everything to start over.\n"
msgstr ""
"  delete all\n"
"Удалить всю схему, но сохранить заголовок.\n"
"  delete R12\n"
"Удалить R12.\n"
"  delete R12 C3\n"
"Удалить R12 и C3.\n"
"  delete R*\n"
"Удалить все резисторы. (А также все модели и подсхемы, имена\n"
"которых начинаются на R.)\n"
"  clear\n"
"Очистить всё, чтобы начать всё с начала.\n"

#. type: Title ======
#: manual/commands/edit.txt:1
#, no-wrap
msgid "\"edit\" command"
msgstr "Команда «edit»"

#. type: Plain text
#: manual/commands/edit.txt:6
msgid "Use your editor to change the circuit."
msgstr "Использование редактора для изменения схемы."

#. type: Plain text
#: manual/commands/edit.txt:11
#, no-wrap
msgid ""
"  edit\n"
"  edit file\n"
msgstr ""
"  edit\n"
"  edit файл\n"

#. type: Plain text
#: manual/commands/edit.txt:15
msgid ""
"The edit command runs your editor on a copy of the circuit in memory, then "
"reloads it."
msgstr ""
"Команда edit открывает в редакторе копию схемы из памяти, затем загружает её "
"обратно."

#. type: Plain text
#: manual/commands/edit.txt:17
msgid "Edit file runs your editor on the specified file."
msgstr "Если указан файл, он открывается в редакторе."

#. type: Plain text
#: manual/commands/edit.txt:19
msgid ""
"If you are only changing a component value, the modify command may be easier "
"to use."
msgstr ""
"Для изменения только значения компонента может быть легче использовать "
"команду modify."

#. type: Plain text
#: manual/commands/edit.txt:21
msgid ""
"The program uses the EDITOR environment variable to find the editor to use. "
"The command fails if there is no EDITOR defined."
msgstr ""
"Для определения открываемого редактора программа использует переменную "
"окружения EDITOR.  Если эта переменная окружения не определена, команда "
"работать не будет."

#. type: Plain text
#: manual/commands/edit.txt:27
#, no-wrap
msgid ""
"  edit\n"
"Brings up your editor on the circuit.\n"
"  edit foo\n"
"Edits the file foo in your current directory.\n"
msgstr ""
"  edit\n"
"Открывает схему в вашем редакторе.\n"
"  edit foo\n"
"Открывает для редактирования файл foo в текущем каталоге.\n"

#. type: Plain text
#: manual/commands/end.txt:2
msgid "\"end\" command"
msgstr "====== Команда «end» ======"

#. type: Plain text
#: manual/commands/end.txt:4
msgid ""
"When run in batch mode from the shell, the END command cleans up and exits "
"the program."
msgstr ""
"При запуске в пакетном режиме из shell команда **end** приводит к завершению "
"работы и выходу из программы."

#. type: Plain text
#: manual/commands/end.txt:6
msgid ""
"In script mode (< command) it ends the script and returns to the program "
"prompt."
msgstr ""
"В режиме скрипта (при выполнении файла, открытого командой [[in.ru|<]]) она "
"завершает скрипт и возвращается к приглашению программы."

#. type: Plain text
#: manual/commands/end.txt:7
msgid "In interactive mode it exits the program."
msgstr "В интерактивном режиме команда служит для выхода из программы."

#. type: Title ======
#: manual/commands/eval.txt:1
#, no-wrap
msgid "\"eval\" command"
msgstr "Команда «eval»"

#. type: Plain text
#: manual/commands/eval.txt:6
msgid "Check and evaluate an expression."
msgstr "Проверка и оценка выражения."

#. type: Plain text
#: manual/commands/eval.txt:10
#, no-wrap
msgid "  eval expression\n"
msgstr "  eval выражение\n"

#. type: Plain text
#: manual/commands/eval.txt:14
msgid ""
"The eval command evaluates an expression and prints the result as a number."
msgstr "Команда eval оценивает выражение и выводит результат в виде числа."

#. type: Plain text
#: manual/commands/eval.txt:28
#, no-wrap
msgid ""
"  gnucap> param a={b+c+7}\n"
"  gnucap> eval a\n"
"  parameter b+c+7 has no value\n"
"  parameter b+c+7 has no value\n"
"  a= NA\n"
"  gnucap> param b=c+3\n"
"  gnucap> param c=4\n"
"  gnucap> eval a\n"
"  a= 18.\n"
"  gnucap> eval b+c\n"
"  (b + c)= 11.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> param a={b+c+7}\n"
"  gnucap> eval a\n"
"  parameter b+c+7 has no value\n"
"  parameter b+c+7 has no value\n"
"  a= NA\n"
"  gnucap> param b=c+3\n"
"  gnucap> param c=4\n"
"  gnucap> eval a\n"
"  a= 18.\n"
"  gnucap> eval b+c\n"
"  (b + c)= 11.\n"
"  gnucap>\n"

#. type: Title ======
#: manual/commands/exit.txt:1
#, no-wrap
msgid "\"exit\", \"quit\" commands"
msgstr "Команды «exit» и «quit»"

#. type: Plain text
#: manual/commands/exit.txt:7
#, no-wrap
msgid " Terminates the program.\n"
msgstr " Завершение программы.\n"

#. type: Plain text
#: manual/commands/exit.txt:12
#, no-wrap
msgid ""
"  exit\n"
"  quit\n"
msgstr ""
"  exit\n"
"  quit\n"

#. type: Plain text
#: manual/commands/exit.txt:15
msgid "Be sure you have saved everything you want to!"
msgstr "Убедитесь, что вы сохранили всё, что надо!"

#. type: Title ======
#: manual/commands/fault.txt:1
#, no-wrap
msgid "\"fault\" command"
msgstr "Команда «fault»"

#. type: Plain text
#: manual/commands/fault.txt:6
msgid "Temporarily change a component value."
msgstr "Временное изменение значения компонента."

#. type: Plain text
#: manual/commands/fault.txt:11
#, no-wrap
msgid ""
"  fault partlabel=value ...\n"
"  unfault\n"
msgstr ""
"  fault обозначение_компонента=значение ...\n"
"  unfault\n"

#. type: Plain text
#: manual/commands/fault.txt:15
msgid ""
"This command quickly changes the value of a component, usually with the "
"intention that you will not want to save it."
msgstr ""
"Эта команда служит для быстрого изменения значения, обычно если вы не "
"намереваетесь его сохранять."

#. type: Plain text
#: manual/commands/fault.txt:17
msgid ""
"If you apply this command to a nonlinear or otherwise strange part, it "
"becomes ordinary and linear until the fault is removed."
msgstr ""
"Если вы применяете эту команду к нелинейному или иным образом странному "
"компоненту, он становится обычным и линейным, пока этот сбой (fault) не "
"будет удалён."

#. type: Plain text
#: manual/commands/fault.txt:19
msgid "It is an error to fault a model call."
msgstr ""
"Ошибочно использовать создавать сбой с помощью fault для вызова модели."

#. type: Plain text
#: manual/commands/fault.txt:21
msgid ""
"If several components have the same label, the fault value applies to all of "
"them. (They will all have the same value.)"
msgstr ""
"Если несколько компонентов имеют одинаковое обозначение, значение fault "
"применяется к ним всем. (Они все будут иметь одинаковое значение.)"

#. type: Plain text
#: manual/commands/fault.txt:23
msgid "The unfault command restores the old values."
msgstr "Команда unfault восстанавливает старое значение."

#. type: Plain text
#: manual/commands/fault.txt:30
#, no-wrap
msgid ""
"  fault R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  unfault\n"
"Clears all faults. In this case, R66 has its old value again.\n"
msgstr ""
"  fault R66=1k\n"
"R66 теперь имеет значение 1 кОм, независимо от того, каким оно было раньше.\n"
"  unfault\n"
"Очищает все fault. В данном случае R66 снова получает своё старое значение.\n"

#. type: Plain text
#: manual/commands/fault.txt:35
#, no-wrap
msgid ""
"unfault can bring on surprises. Consider this sequence ...\n"
"  V1   1   0    ac  1\n"
"  C3   1   2    1u\n"
"  R4   2   0    10k\n"
msgstr ""
"unfault может выдавать сюрпризы. Рассмотрим следующую последовательность ...\n"
"  V1   1   0    ac  1\n"
"  C3   1   2    1u\n"
"  R4   2   0    10k\n"

#. type: Plain text
#: manual/commands/fault.txt:43
#, no-wrap
msgid ""
"  fault C3=100p\n"
"C3 is 100 picofarads, for now.\n"
"  modify C3=220p\n"
"C3 is 220 pf, for now. It will be restored.\n"
"  modify R4=1k\n"
"R4 is 1k. It will not be restored.\n"
"  unfault\n"
"C3 back to 1 uf, but R4 still 1k.\n"
msgstr ""
"  fault C3=100p\n"
"C3 теперь равно 100 пикофарадам.\n"
"  modify C3=220p\n"
"Значение C3 теперь равно 220 пФ. Оно будет восстановлено.\n"
"  modify R4=1k\n"
"Значение R4 равно 1 кОм. Оно не будет восстановлено.\n"
"  unfault\n"
"C3 возвращается в 1 мкФ, но значение R4 всё ещё равно 1 кОм.\n"

#. type: Title ======
#: manual/commands/fourier.txt:1
#, no-wrap
msgid "\"fourier\" command"
msgstr "Команда «fourier»"

#. type: Plain text
#: manual/commands/fourier.txt:6
msgid ""
"Performs a nonlinear time domain (transient) analysis, but displays the "
"results in the frequency domain."
msgstr ""
"Выполнение нелинейного анализа во временной области (временного анализа), но "
"отображение результатов в частотной области."

#. type: Plain text
#: manual/commands/fourier.txt:10
#, no-wrap
msgid "  fourier start stop stepsize {options ...} \n"
msgstr "|''**fourier** //начало конец размер_шага// {//параметры ...//}''|\n"

#. type: Plain text
#: manual/commands/fourier.txt:12
msgid "Start, stop, and stepsize are frequencies."
msgstr "''//Начало//'', ''//конец//'' и ''//размер_шага//'' --- это частоты."

#. type: Plain text
#: manual/commands/fourier.txt:16
msgid ""
"This command is slightly different and more flexible than the SPICE "
"counterpart. SPICE always gives you the fundamental and 9 harmonics. Gnucap "
"will do the same if you only specify one frequency. SPICE has the probes on "
"the same line. Gnucap requires you to specify the probes with the print "
"command."
msgstr ""
"Данная команда гибче аналогичной команды SPICE, и несколько от неё "
"отличается. SPICE всегда выдаёт основную частоту и 9 гармоник. gnucap делает "
"то же самое только при задании одной частоты. В SPICE датчики задаются в той "
"же строке. gnucap требует явного указания датчиков командой [[print.ru|"
"print]]."

#. type: Plain text
#: manual/commands/fourier.txt:18
msgid ""
"SPICE uses the last piece of a transient that was already done. Gnucap does "
"its own transient analysis, continuing from where the most recent one left "
"off, and choosing the step size to match the Fourier Transform to be done. "
"Because of this the Gnucap Fourier analysis is much more accurate than SPICE."
msgstr ""
"В SPICE используется последняя часть ранее сделанного временного анализа. В "
"gnucap проводится свой собственный временной анализ. Он продолжается с точки "
"останова самого последнего анализа, а размер шага при этом выбирается таким, "
"чтобы он соответствовал производимому преобразованию Фурье. По этим причинам "
"анализ Фурье, выполняемый программой gnucap, гораздо точнее, чем в SPICE."

#. type: Plain text
#: manual/commands/fourier.txt:22
msgid ""
"Three parameters are normally needed for a Fourier analysis: start "
"frequency, stop frequency and step size, in this order."
msgstr ""
"Обычно для анализа Фурье нужны три параметра: начальная частота, конечная "
"частота и размер шага, в указанном порядке."

#. type: Plain text
#: manual/commands/fourier.txt:24
msgid ""
"If the start frequency is omitted it is assumed to be 0. The two remaining "
"parameters are stop and step, such that stop > step."
msgstr ""
"Если начальная частота не указана, она принимается равной нулю. Два "
"оставшихся параметра --- конечная частота и шаг, где конечная частота больше "
"шага."

#. type: Plain text
#: manual/commands/fourier.txt:26
msgid ""
"If only one frequency is specified, it is assumed to be step size, which is "
"equivalent to the fundamental frequency. The start frequency is zero and the "
"stop frequency is set according the harmonics option (from the options "
"command. The default is 9 harmonics."
msgstr ""
"Если указана только одна частота, она будет считаться размером шага, который "
"эквивалентен основной частоте. Начальная частота равна нулю, а конечная "
"устанавливается в соответствии с параметром ''harmonics'' (количество "
"гармоник из команды [[options.ru|options]]).  По умолчанию задаётся 9 "
"гармоник."

#. type: Plain text
#: manual/commands/fourier.txt:28
msgid ""
"If two frequencies are specified, they are stop and step. The order doesn't "
"matter since stop is always larger than step."
msgstr ""
"Если указаны две частоты, они считаются конечной частотой и шагом. Порядок "
"указания не важен, так как конечная частота всегда больше шага."

#. type: Plain text
#: manual/commands/fourier.txt:30
msgid ""
"This command does a nonlinear time domain analysis, then performs a Fourier "
"transform on the data to get the frequency data. The transient analysis "
"parameters (start, stop, step) are determined by the program as necessary to "
"produce the desired spectral results. The internal time steps are selected "
"to match the Fourier points, so there is no interpolation done."
msgstr ""
"Данная команда выполняет нелинейный анализ во временной области, а затем для "
"нахождения частотных данных выполняет преобразование Фурье над его "
"результатами. Решение о параметрах временного анализа (начало, конец, шаг) "
"принимается программой на основе тех спектральных результатов, которые "
"хотелось бы получить. Внутренний шаг времени выбирается так, чтобы точки "
"соответствовали точкам Фурье, поэтому никакой интерполяции не производится."

#. type: Plain text
#: manual/commands/fourier.txt:32
msgid ""
"The underlying transient analysis begins where the previous one left off. If "
"you specify the \"cold\" option, it begins at time = 0. Often repeating a "
"run will improve the accuracy by giving more time for initial transients to "
"settle out."
msgstr ""
"Временной анализ, лежащий в основе преобразования Фурье, начинается с точки "
"останова предыдущего анализа. Если указать параметр ''cold'', он начнётся в "
"момент времени равный 0. Частое повторение запуска приведёт к увеличению "
"точности, давая больше времени для стабилизации начальных переходных "
"процессов."

#. type: Plain text
#: manual/commands/fourier.txt:34
msgid "See also: [[gnucap:manual:commands:transient|Transient command]]."
msgstr "См. также: [[gnucap:manual:commands:transient.ru|Команда transient]]."

#. type: Plain text
#: manual/commands/fourier.txt:43 manual/commands/transient.txt:30
#, no-wrap
msgid ""
"|dtmax time      |The maximum internal time step.  (Default = stepsize/skip)  |\n"
"|dtmin time      |The minimum internal time step. (Default = option dtmin) Time cannot be resolved closer than this.  |\n"
"|dtratio number  |The minimum internal time step, as a ratio. (Default = option dtratio) This is the maximum number of internal time steps for every requested step.  |\n"
"|skip count      |Force at least count internal transient time steps for each one displayed. If the output is a table or ASCII plot, the extra steps are hidden, unless the trace option specifies to print them.  |\n"
msgstr ""
"|''dtmax //время//      ''| Максимальный внутренний шаг времени. (Значение по умолчанию равно ''//размер_шага//''/''skip'')  |\n"
"|''dtmin //время//      ''| Минимальный внутренний шаг времени. (Значение по умолчанию равно [[options.ru|опции]] ''dtmin''.) Разрешение времени не может быть точнее указанного  |\n"
"|''dtratio //число//    ''| Минимальный внутренний шаг времени в виде отношения. (Значение по умолчанию равно [[options.ru|опции]] ''dtratio''.) Это максимальное количество внутренних шагов времени на каждый запрошенный шаг.  |\n"
"|''skip //количество//  ''| Использовать по меньшей мере указанное ''//количество//'' внутренних шагов времени на каждый отображаемый шаг. Дополнительные шаги не отображаются при выводе в виде таблицы или ASCII-графика, если только их вывод не будет задан параметром ''trace''  |\n"

#. type: Plain text
#: manual/commands/fourier.txt:57 manual/commands/transient.txt:44
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace alltime     |Show all accepted internal time steps.  |\n"
"|trace rejected    |Show all internal time steps including rejected steps.  |\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""
"|''trace off         ''| Без вывода расширенной трассировочной информации                |\n"
"|''trace warnings    ''| Отображение расширенных предупреждений                          |\n"
"|''trace alltime     ''| Отображение всех разрешённых внутренних шагов времени           |\n"
"|''trace rejected    ''| Отображение всех внутренних шагов времени, включая отброшенные  |\n"
"|''trace iterations  ''| Отображение каждой итерации                                     |\n"
"|''trace verbose     ''| Расширенные диагностические сообщения                           |\n"

#. type: Plain text
#: manual/commands/fourier.txt:63
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC analysis. Instead, use the values specified with the IC = options on the various elements, and set everything else to zero.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"
"|''cold                     ''| Нулевые начальные условия. Холодный запуск с момента подачи питания  |\n"
"|''uic                      ''| Использовать начальные условия. Не проводить начальный статический анализ по постоянному току [[dc.ru|dc]]. Вместо этого использовать данные, указанные в параметрах ''IC'' разных элементов, а всё остальное устанавливать в ноль  |\n"

#. type: Plain text
#: manual/commands/fourier.txt:75
#, no-wrap
msgid ""
"  fourier 1Meg\n"
"Analyze the spectrum assuming a fundamental frequency of 1 mHz. Use the harmonics option to determine how many harmonics (usually 9) to display.\n"
"  fourier 40 20K 20\n"
"Analyze the spectrum from 40 Hz to 20 kHz in 20 Hz steps. This will result in a transient analysis with 25 micro-second steps. (1 / 40k). It will run for .05 second. (1 / 20).\n"
"  fourier 0 20K 20\n"
"Similar to the previous example, but show the DC and 20 Hz terms, also.\n"
"  fourier\n"
"No parameters mean use the same ones as the last time. In this case: from 0 to 20 kHz, in 20 Hz steps.\n"
"  fourier skip 10\n"
"Do 10 transient steps internally for every step that is used. In this case it means to internally step at 2.5 micro-second, or 10 steps for every one actually used.\n"
msgstr ""
"  fourier 1Meg\n"
"Анализ спектра с установкой основной частоты равной 1 МГц. Используйте параметр ''harmonics'' для определения количества выводимых гармоник (обычно 9).\n"
"  fourier 40 20K 20\n"
"Анализ спектра от 40 Гц до 20 кГц с шагом в 20 Гц. Результатом будет временной анализ с шагами в 25 микросекунд (1/40k). Он будет длиться 0,05 секунды (1/20).\n"
"  fourier 0 20K 20\n"
"Подобно предыдущему примеру, но показать также статический режим по постоянному току и периоды 20 Hz.\n"
"  fourier\n"
"Отсутствие параметров означает использование тех же самых параметров, что и в прошлый раз. В данном случае: от 0 до 20 кГц с шагом в 20 Гц.\n"
"  fourier skip 10\n"
"Делать по 10 внутренних временных шагов на каждый используемый шаг. В данном случае это означает внутренние шаги по 2,5 микросекунды или 10 внутренних шагов на каждый шаг, который будет использоваться фактически.\n"

#. type: Title ======
#: manual/commands/freeze.txt:1
#, no-wrap
msgid "\"freeze, unfreeze\" commands"
msgstr "Команды «freeze», «unfreeze»"

#. type: Plain text
#: manual/commands/freeze.txt:6
msgid "\"Freeze\" to a point in time.  Remember circuit voltages and currents."
msgstr "«Заморозка» в точке времени. Запоминание напряжений и токов схемы."

#. type: Plain text
#: manual/commands/freeze.txt:11
#, no-wrap
msgid ""
"  freeze\n"
"  unfreeze\n"
msgstr ""
"|''**freeze  **''|\n"
"|''**unfreeze**''|\n"

#. type: Plain text
#: manual/commands/freeze.txt:15
msgid ""
"After the freeze command, the transient and fourier analysis will continue "
"from the values that were kept by the freeze command, instead of progressing "
"every time."
msgstr ""
"После команды **freeze** [[transient.ru|временной анализ]] и [[fourier.ru|"
"анализ Фурье]] продолжатся с тех значений, которые были запомнены этой "
"командой, вместо продолжения каждый раз дальше."

#. type: Plain text
#: manual/commands/freeze.txt:17
msgid ""
"This allows reruns from the same starting point, which may be at any time, "
"not necessarily 0."
msgstr ""
"Это даёт возможность перезапуска анализа с одной и той же стартовой точки "
"времени, которая может быть в любой момент, не обязательно в 0 секунд."

#. type: Plain text
#: manual/commands/freeze.txt:35
#, no-wrap
msgid ""
"  transient 0 1 .01\n"
"A transient analysis starting at zero, running until 1 second, with step size .01 seconds. After this run, the clock is at 1 second.\n"
"  freeze\n"
"Remember the time, voltages, currents, etc.\n"
"  transient\n"
"Another transient analysis. It continues from 1 second, to 2 seconds. (It spans 1 second, as before.) This command was not affected by the freeze command.\n"
"  transient\n"
"This will do exactly the same as the last one. From 1 second to 2 seconds. If it were not for freeze, it would have started from 2 seconds.\n"
"  transient 1.5 .001\n"
"Try again with smaller steps. Again, it starts at 1 second.\n"
"  unfreeze\n"
"Release the effect of freeze.\n"
"  transient\n"
"Exactly the same as the last time, as if we didn't unfreeze. (1 to 1.5 seconds.)\n"
"  transient\n"
"This one continues from where the last one left off: at 1.5 seconds. From now on, time will move forward.\n"
msgstr ""
"  transient 0 1 .01\n"
"Временной анализ, начинающийся в нулевое время, работающий 1 секунду с шагом .01 секунды. После его выполнения, часы установлены в точку 1 секунда.\n"
"  freeze\n"
"Запоминание времени, напряжений, токов и т. д.\n"
"  transient\n"
"Другой временной анализ. Он продолжается от 1 секунды до 2 секунд. (Его длительность, как и прежде, составляет 1 секунду.) На эту команду команда **freeze** не повлияла..\n"
"  transient\n"
"Эта команда делает ровно то же самое, что и предыдущая команда. Работа от 1 секунды до 2 секунд. Если бы она не была после **freeze**, она бы стартовала с 2 секунд.\n"
"  transient 1.5 .001\n"
"Попробовать ещё раз с меньшим шагом. Снова анализ начинается в момент времени 1 секунда.\n"
"  unfreeze\n"
"Отключить эффект заморозки от команды **freeze**.\n"
"  transient\n"
"Ровно то же самое, что и в последний раз, как будто заморозка не отключена (от 1 до 1.5 секунд.)\n"
"  transient\n"
"Эта команда продолжает работу с того места, где была остановлена последняя: в 1.5 секунды. С этой поры время будет идти вперёд.\n"

#. type: Title ======
#: manual/commands/generator.txt:1
#, no-wrap
msgid "\"generator\" command"
msgstr "Команда «generator»"

#. type: Plain text
#: manual/commands/generator.txt:6
msgid ""
"Sets up an input waveform for transient and Fourier analysis. Emulates a "
"laboratory type function generator."
msgstr ""
"Настройка формы входного сигнала для [[transient.ru|временного анализа]] и "
"[[fourier.ru|анализа Фурье]]. Эмуляция функционального генератора "
"лабораторного типа."

#. type: Plain text
#: manual/commands/generator.txt:10
#, no-wrap
msgid "  generator {option-name=value ...}\n"
msgstr "|''**generator** {//имя_опции=значение ...//}''|\n"

#. type: Plain text
#: manual/commands/generator.txt:14
msgid ""
"This command sets up a singal source that is conceptually separate from the "
"circuit. To use it, make the value of a component \"generator(1)\", or "
"substitute a scale factor for the parameter."
msgstr ""
"Данной командой настраивается источник сигнала, концептуально отделённый от "
"схемы. Для его использования необходимо задать для какого-либо компонента "
"значение в виде ''generator(1)'', или заменить указанный параметр "
"коэффициентом масштабирования."

#. type: Plain text
#: manual/commands/generator.txt:16
msgid ""
"The SPICE style input functions also work, but are considered to be part of "
"the circuit, instead of part of the test equipment."
msgstr ""
"Входные функции в стиле SPICE тоже будут работать, но они считаются частью "
"схемы, а не тестового оборудования."

#. type: Plain text
#: manual/commands/generator.txt:18
msgid ""
"The parameters available are designed to emulate the controls on a function "
"generator. There are actually two generators here: sine wave and pulse. If "
"both are on (by setting non-zero parameters) the sine wave is modulated by "
"the pulse, but either can be used alone."
msgstr ""
"Имеющиеся в распоряжении параметры спроектированы для эмуляции элементов "
"управления функционального генератора. Фактически здесь имеется два "
"генератора: синусоиды и прямоугольных импульсов (меандра). Если включены оба "
"(установкой ненулевых параметров), синусоидальная волна модулируется "
"импульсами, но любой из указанных сигналов может использоваться и сам по "
"себе."

#. type: Plain text
#: manual/commands/generator.txt:20
msgid ""
"Unless you change it, it is a unit-step function at time 0. The purpose of "
"the command is to change it."
msgstr ""
"Если команда не менялась пользователем, она определяет единичную ступенчатую "
"функцию в момент времени равный 0. Цель данной команды состоит в изменении "
"этой функции."

#. type: Plain text
#: manual/commands/generator.txt:22
msgid ""
"This command does not affect AC or DC analysis in any way. It is only for "
"transient and Fourier analysis. In AC analysis, the input signal is always a "
"sine wave at the analysis frequency."
msgstr ""
"Данная команда никоим образом не влияет на анализы [[ac.ru|ac]] или [[dc.ru|"
"dc]]. Она предназначена только для [[transient.ru|временного анализа]] и "
"[[fourier.ru|анализа Фурье]]. Для анализа [[ac.ru|ac]] входной сигнал всегда "
"представляет собой синусоиду заданной для этого анализа частоты."

#. type: Plain text
#: manual/commands/generator.txt:24
msgid ""
"Typical usage is the name of the control followed by its value, or just "
"plain Generator to display the present values."
msgstr ""
"При обычном использовании указываются имена управляющих параметров и их "
"значения, либо просто **''Generator''** без параметров для отображения их "
"текущих значений."

#. type: Plain text
#: manual/commands/generator.txt:26
msgid ""
"The actual time when switching takes place is ambiguous by one time step. If "
"precise time switching is necessary, use the Skip option on the transient "
"analysis command, to force more resolution. This ambiguity can usually be "
"avoided by specifying finite rise and fall times."
msgstr ""
"В пределах одного шага времени фактическое время переключения не определено. "
"Если необходимо прецизионное переключение во времени, воспользуйтесь опцией "
"''Skip'' команды временного анализа [[transient.ru|transient]] для "
"принудительного задания большего разрешения. Этой неопределённости обычно "
"можно избежать, указав конечное время для переднего и заднего фронтов."

#. type: Title ====
#: manual/commands/generator.txt:27 manual/commands/options.txt:25
#: manual/devices/basic/exp.txt:33 manual/devices/basic/fit.txt:50
#: manual/devices/basic/poly.txt:27 manual/devices/basic/posy.txt:40
#: manual/devices/basic/pulse.txt:43 manual/devices/basic/sffm.txt:26
#: manual/devices/basic/sin.txt:44 manual/devices/basic/tanh.txt:27
#: manual/measure/at.txt:10 manual/measure/cross.txt:10
#: manual/measure/mean.txt:15 manual/measure/minmax.txt:11
#: manual/measure/slope.txt:11 manual/tech/plugins/devices/parameters.txt:3
#, no-wrap
msgid "Parameters"
msgstr "Параметры"

#. type: Plain text
#: manual/commands/generator.txt:41
#, no-wrap
msgid ""
"|frequency  |The frequency of the sine wave generator for a transient analysis. The sine wave is modulated by the pulse generator. A frequency of zero puts the pulse generator on line directly.  |\n"
"|amplitude  |The overall amplitude of the pulse and sine wave. A scale factor. It applies to everything except the offset and initial values.  |\n"
"|phase      |The phase of the sine wave, at the instant it is first turned on.  |\n"
"|max        |The amplitude of the pulse, when it is `on'. (During the width time) If the sine wave is on (frequency not zero) this is the amplitude of the sine wave during the first part of the period. The max is scaled by amplitude.  |\n"
"|min        |The amplitude of the pulse, when it is `off'. (After it falls, but before the next period begins.) Although we have called these min and max, there is no requirement that max be larger than min. If the sine wave is on, this is its amplitude during the second part of the period. The min is scaled by amplitude.  |\n"
"|offset     |The DC offset applied to the entire signal, at all times after the initial delay. The offset is not scaled by amplitude.  |\n"
"|initial    |The initial value of the pulse generator output. It will have this value starting at time 0, until delay time has elapsed. It will never return to this value, unless you restart at time 0.  |\n"
"|rise       |The rise time, or the time it takes to go from min to max, or for the first rise, initial to max. The rise is linear.  |\n"
"|fall       |The fall time. (The time required to go from max back to min.)  |\n"
"|delay      |The waiting time before the first rise.  |\n"
"|width      |The length of time the output of the generator has the value max. A width of zero means that the output remains high for the remainder of the period. If you really want a width of zero, use a very small number, less than the step size.  |\n"
"|period     |The time for repetition of the pulse. It must be greater than the sum of rise + fall + width. A period of zero means that the signal is not periodic and so will not repeat.  |\n"
msgstr ""
"|''frequency''  | Частота генератора синусоиды для [[transient.ru|временного анализа]]. Синусоида модулируется генератором импульсов. При частоте равной нулю импульсы накладываются непосредственно на прямую линию.  |\n"
"|''amplitude''  | Общая амплитуда импульсов и синусоиды. Коэффициент масштабирования. Он применяется ко всем параметрам, за исключением значений ''offset'' и ''initial''.  |\n"
"|''phase''      | Фаза синусоиды в момент её включения.  |\n"
"|''max''        | Амплитуда импульса, когда он «включен». (В течение времени ширины импульса ''width''.) Если синусоида включена (частота не равна нулю) это амплитуда синусоиды в течение первой части периода. Значение ''max'' масштабируется параметром ''amplitude''.  |\n"
"|''min''        | Амплитуда импульса, когда он «отключен». (После нисходящего фронта и до начала следующего периода.) Хотя эти параметры и называются ''min'' и ''max'', не обязательно задавать ''max'' больше, чем ''min''. Если синусоида включена, это её амплитуда в течение второй части периода. Значение ''min'' масштабируется параметром ''amplitude''.  |\n"
"|''offset''     | Постоянное смещение, прикладываемое к сигналу как целому на всё время после начальной задержки ''delay''. Это смещение не масштабируется параметром ''amplitude''.  |\n"
"|''initial''    | Исходное значение выхода генератора импульсов. Генератор будет выдавать это значение с нулевого момента времени до тех пор, пока не пройдёт время ''delay''. Он никогда не вернётся к этому значению, если только не перезапустить моделирование с момента времени равного 0.  |\n"
"|''rise''       | Время восходящего фронта: или время перехода от ''min'' до ''max'', или, для первого фронта, от ''initial'' до ''max''. Восходящий фронт изменяется линейно.  |\n"
"|''fall''       | Время нисходящего фронта. (Время, нужное для перехода от ''max'' обратно к ''min''.)  |\n"
"|''delay''      | Выдержка времени перед первым восходящим фронтом.  |\n"
"|''width''      | Ширина импульса, то есть длительность времени, когда выход генератора имеет значение ''max''. Значение ''width'' равное 0 означает, что выход генератора останется высоким всю оставшуюся часть периода. Если вам на самом деле нужна нулевая ширина импульса, используйте очень маленькое число, меньше размера шага.  |\n"
"|''period''     | Время повторения импульсов. Оно должно быть больше суммы ''rise + fall + width''. Период равный нулю означает, что сигнал не периодический и поэтому повторяться не будет.  |\n"

#. type: Plain text
#: manual/commands/generator.txt:57
#, no-wrap
msgid ""
"The generator command ...\n"
"  gen\n"
"Display the present settings.\n"
"  gen freq=1k\n"
"Sets the sine wave to 1 kHz. All other parameters are as they were before.\n"
"  gen freq=0\n"
"Turns off the sine wave, leaving only the pulse.\n"
"  gen ampl=0\n"
"Sets the amplitude to zero, which means the circuit has no input, except for possibly a DC offset.\n"
"  gen period=.001 freq=1Meg\n"
"Sets the period back to 1 millisecond. Applies 1 mHz modulation to the pulse, resulting in a pulsed sine wave. In this case, a 100 microsecond 10 volt burst, repeating every millisecond. Between bursts, you will get 2.5 volts, with reversed phase. The old values, in this case from 2 lines back (above) are kept. (Ampl 5 Rise 10u Fall 10u ...)\n"
"  gen freq=60 phase=90 delay=.1\n"
"The sine wave frequency is 60 Hertz. Its phase is 90 degrees when it turns on, at time .1 seconds. It turns on sharply at the peak.\n"
msgstr ""
"Команда запуска генератора ...\n"
"  gen\n"
"Показать существующие настройки.\n"
"  gen freq=1k\n"
"Задать синусоиду частотой 1 кГц. Все прочие параметры остаются теми же, что и прежде.\n"
"  gen freq=0\n"
"Отключить синусоиду, оставив только импульсы.\n"
"  gen ampl=0\n"
"Установить амплитуду равной нулю, то есть для схемы не будет входного сигнала, за исключением, может быть, смещения по постоянному току.\n"
"  gen period=.001 freq=1Meg\n"
"Снова установить период равным 1 миллисекунде. Применить к импульсам модуляцию с частотой 1 МГц, что в итоге даст пульсирующую синусоиду. В данном случае возникают 100-микросекундные броски в 10 вольт, повторяющиеся каждую миллисекунду. Между бросками будет 2,5 вольта с противоположной фазой.  Старые значения, в данном случае на 2 строки назад (см. выше) сохраняются. (Амплитуда 5, нарастание 10 мкс, спад 10 мкс ...)\n"
"  gen freq=60 phase=90 delay=.1\n"
"Частота синусоиды составляет 60 Гц. Её фаза при включении в момент времени равный 0,1 секунды равна 90 градусам. Она включается резко на пике.\n"

#. type: Plain text
#: manual/commands/generator.txt:64
#, no-wrap
msgid ""
"A component using it ...\n"
"  V12 1 0 generator(1)\n"
"Use the generator as the circuit input through this voltage source. The DC and AC values are 0.\n"
"  V12 1 0 tran generator(1) ac 10 dc 5\n"
"Same as before, except that the AC value is 10 and DC value is 5.\n"
"  Rinput 1 0 tran generator(1)\n"
"Unlike SPICE, the functions can be used on other components. The resistance varies in time according to the \"generator\".\n"
msgstr ""
"Компонент, использующий эту команду ...\n"
"  V12 1 0 generator(1)\n"
"Использовать генератор как входной сигнал схемы, подаваемый через этот источник напряжения. Значения для анализов [[ac.ru|ac]] и [[dc.ru|dc]] равны нулю.\n"
"  V12 1 0 tran generator(1) ac 10 dc 5\n"
"То же, что и прежде, но значение для [[ac.ru|ac]] равно 10, а для [[dc.ru|dc]] 5.\n"
"  Rinput 1 0 tran generator(1)\n"
"В отличие от SPICE эти функции могут использоваться для других компонентов. Сопротивление меняется во времени в соответствии с функцией ''generator''.\n"

#. type: Title ======
#: manual/commands/get.txt:1
#, no-wrap
msgid "\"get\" command"
msgstr "Команда «get»"

#. type: Plain text
#: manual/commands/get.txt:7
msgid ""
"Gets an existing circuit file, but does not run it, after clearing memory. "
"Start over.  Set up for interactive operation."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:11
#, no-wrap
msgid "  get filename\n"
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:15
msgid ""
"The first comment line of the file being read is taken as the `title'. See "
"the title command."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:17
msgid ""
"Comments in the circuit file are stored, unless they start with *+ in which "
"case they are thrown away."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:19
msgid ""
"`Dot cards' are set up, but not executed. This means that variables and "
"options are changed, but simulation commands are not actually done. As an "
"example, the options command is actually performed, since it only sets up "
"variables. The ac card is not performed, but its parameters are stored, so "
"that a plain ac command will perform the analysis specified in the file."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:21
msgid ""
"Any circuit already in memory will be erased before loading the new circuit."
msgstr ""

#. type: Plain text
#: manual/commands/get.txt:29
#, no-wrap
msgid ""
"  get amp.ckt\n"
"Get the circuit file amp.ckt from the current directory.\n"
"  get /usr/foo/ckt/amp.ckt\n"
"Get the file amp.ckt from the /usr/foo/ckt directory.\n"
"  get npn.mod\n"
"Get the file npn.mod.\n"
msgstr ""

#. type: Title ======
#: manual/commands/include.txt:1
#, no-wrap
msgid "\"include\" command"
msgstr "Команда «include»"

#. type: Plain text
#: manual/commands/include.txt:6
msgid "Include a file, directly, as is."
msgstr "Включение файла непосредственно как есть."

#. type: Plain text
#: manual/commands/include.txt:10
#, no-wrap
msgid "  include filename\n"
msgstr "  include имя_файла\n"

#. type: Plain text
#: manual/commands/include.txt:14
msgid "The file is included as is."
msgstr "Файл включается как есть."

#. type: Plain text
#: manual/commands/include.txt:16
msgid ""
"If you are running interactive, it is as if you typed in what is in the file."
msgstr ""
"При интерактивной работе это тождественно тому, как будто бы вы набрали на "
"клавиатуре то, что находится в файле."

#. type: Plain text
#: manual/commands/include.txt:18
msgid ""
"If you are running in a batch mode, or including a file from another file, "
"it is as if you did a copy and paste into that file."
msgstr ""
"При запуске в пакетном режиме или при включении файла из другого файла это "
"тождественно тому, как будто бы вы скопировали и вставили содержимое в этот "
"файл."

#. type: Plain text
#: manual/commands/include.txt:22
#, no-wrap
msgid ""
"  include npn.mod\n"
"Include the file npn.mod.\n"
msgstr ""
"  include npn.mod\n"
"Вставка файла npn.mod.\n"

#. type: Title ======
#: manual/commands/lib.txt:1
#, no-wrap
msgid "\"lib\" command"
msgstr "Команда «lib»"

#. type: Plain text
#: manual/commands/lib.txt:6
msgid "Selective \"library\" include, and mark sections of a library."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:11
#, no-wrap
msgid ""
"  lib section-name\n"
"  lib file-name section-name\n"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:15
msgid "This command takes two forms:"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:17
msgid ""
"The first form is to mark a section of a file, with a name, so it can be "
"selectively included.  The section ends with a line \".endl\"."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:26
#, no-wrap
msgid ""
"  .lib high\n"
"  R1 (1 2) 10k\n"
"  R2 (2 0) 10k\n"
"  .endl\n"
"  .lib low\n"
"  R1 (1 2) 1k\n"
"  R2 (2 0) 1k\n"
"  .endl\n"
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:28
msgid ""
"The second form has two arguments.  It is a special case of \"include\", "
"that only includes matching sections of the file."
msgstr ""

#. type: Plain text
#: manual/commands/lib.txt:29
#, no-wrap
msgid "  .lib libfile high\n"
msgstr ""

#. type: Title ======
#: manual/commands/list.txt:1
#, no-wrap
msgid "\"list\" command"
msgstr "Команда «list»"

#. type: Plain text
#: manual/commands/list.txt:6
msgid "Lists the circuit in memory."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:11
#, no-wrap
msgid ""
"  list {label ...}\n"
"  list {label - label}\n"
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:15
msgid "Plain list will list the whole circuit on the console."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:17
msgid ""
"List with a component label asks for that one only. Wildcards are "
"supported: ? matches any character, once. * matches zero or more of any "
"character."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:19
msgid "For several components, list them."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:21
msgid "For a range, specify two labels separated by a dash."
msgstr ""

#. type: Plain text
#: manual/commands/list.txt:31
#, no-wrap
msgid ""
"  list\n"
"List the entire circuit to the console.\n"
"  list R11\n"
"Show the component R11.\n"
"  list D12 - C5\n"
"List the part of the netlist from M12 to C5, inclusive. D12 must be before C5 in the list.\n"
"  list D* C*\n"
"List all diodes and capacitors.\n"
msgstr ""

#. type: Title ======
#: manual/commands/load.txt:1
#, no-wrap
msgid "\"load\" and \"unload\" commands"
msgstr "Команды «load» и «unload»"

#. type: Plain text
#: manual/commands/load.txt:6
msgid "Load and unload plugins."
msgstr "Загрузка и выгрузка плагинов."

#. type: Plain text
#: manual/commands/load.txt:12
#, no-wrap
msgid ""
"  load public-model.so\n"
"  load ./my-model.so\n"
"  unload ./my-model.so\n"
msgstr ""
"  load public-model.so\n"
"  load ./my-model.so\n"
"  unload ./my-model.so\n"

#. type: Plain text
#: manual/commands/load.txt:16
msgid ""
"The load command loads a compiled plugin module.  Plugins can be used to "
"arbitrarily extend gnucap.  You can add models, commands, functions, "
"measurements, and anything else."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:21
#, no-wrap
msgid ""
"Warning messages such as:\n"
"  M: already installed, replacing\n"
"  stashing as M:0\n"
"are harmless, and only indicate that something that was already installed is hidden by loading the plugin.\n"
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:24
msgid ""
"Plugins are shared-object files in a format that is determined by the "
"system.  Plugins must be compiled with the same compiler and same headers "
"that compiled the main executable."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:26
msgid ""
"It is intended to maintain source compatibility between stable releases of "
"gnucap, but no guarantee is made about binary compatibility."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:28
msgid ""
"The load command must be available as a built-in command, because without "
"it, you cannot load any plugins.  It is possible to override it with a "
"plugin."
msgstr ""

#. type: Plain text
#: manual/commands/load.txt:34
#, no-wrap
msgid ""
"  load ./bsim463.so\n"
"Load the plugin from the current directory.\n"
"  load bsim463.so\n"
"Load it from the public area, as defined by LD_LIBRARY_PATH.\n"
msgstr ""

#. type: Title ======
#: manual/commands/log.txt:1
#, no-wrap
msgid "\"log\" command"
msgstr "Команда «log»"

#. type: Plain text
#: manual/commands/log.txt:6
msgid "Saves a copy of your keyboard entries in a file."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:12
#, no-wrap
msgid ""
"  log file\n"
"  log >> file\n"
"  log\n"
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:16
msgid ""
"The `>>' option appends to an existing file, if it exists, otherwise it "
"creates one."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:18
msgid ""
"Files can be nested. If you open one while another is already open, both "
"will contain all the information."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:20
msgid ""
"A bare log closes the file. Because of this, the last line of this file is "
"always log. Ordinarily, this will not be of any consequence, but if a log "
"file is open when you use this file as command input, this will close it. If "
"more than one log file is open, they will be closed in the reverse of the "
"order in which they were opened, maintaining nesting."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:22
msgid "See also: `>' and `<' commands."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:24
msgid ""
"The file is an exact copy of what you type, so it is suitable for gnucap "
"<file from the shell. It is NOT suitable for the < command in gnucap or the "
"Spice-like mode gnucap file without <."
msgstr ""

#. type: Plain text
#: manual/commands/log.txt:34
#, no-wrap
msgid ""
"  log today\n"
"Save the commands in a file today in the current directory. If today already exists, the old one is gone.\n"
"  log >> doit\n"
"Save the commands in a file doit. If doit already exists, it is kept, and the new data is added to the end.\n"
"  log runit.bat\n"
"Use the file runit.bat.\n"
"  log\n"
"Close the file. Stop saving.\n"
msgstr ""

#. type: Title ====
#: manual/commands/measure.txt:1
#: manual/tech/plugins/parameter_functions_and_measurements.txt:9
#, no-wrap
msgid "\"measure\" command"
msgstr "Команда «measure»"

#. type: Plain text
#: manual/commands/measure.txt:6
msgid "Make measurements on a circuit, based on stored data."
msgstr "Выполнение измерений в схеме на основе сохранённых данных."

#. type: Plain text
#: manual/commands/measure.txt:10
#, no-wrap
msgid "  measure param-name = measurefunction(args)\n"
msgstr "  measure имя_параметра = функция_измерения(аргументы)\n"

#. type: Plain text
#: manual/commands/measure.txt:13
msgid ""
"The \"measure\" command sets parameters, like the \"parameter\" command, but "
"the value after a measure is a number."
msgstr ""
"Команда «measure» подобно команде «parameter» устанавливает параметры, но "
"значением после измерений является число."

#. type: Plain text
#: manual/commands/measure.txt:15
msgid ""
"It is used to make measurements on a circuit, such as slew rate, crossings, "
"or average value."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:17
msgid ""
"Before using a \"measure\" command, you need to store the data for the probe "
"points you might want to measure.  This is done with the [[gnucap:manual:"
"commands:store]] command.  If you don't specify, no data is stored."
msgstr ""
"Перед использованием команды «measure» необходимо сохранить те данные для "
"точек измерения, которые вам хотелось бы измерить. Это производится командой "
"[[gnucap:manual:commands:store.ru|store]].  Если вы её не укажете, никакие "
"данные сохранены не будут."

#. type: Plain text
#: manual/commands/measure.txt:19
msgid ""
"Then you need to do some kind of analysis, such as [[gnucap:manual:commands:"
"transient]] or [[gnucap:manual:commands:ac]]."
msgstr ""
"Затем нужно сделать какой-то из анализов, такой как [[gnucap:manual:commands:"
"transient.ru|transient]] или [[gnucap:manual:commands:ac.ru|ac]]."

#. type: Plain text
#: manual/commands/measure.txt:21
msgid ""
"For better accuracy of measurements, it is best to specify the option "
"\"trace all\" on a transient command."
msgstr ""
"Для большей точности измерений лучше всего указать параметр «trace all» для "
"команды transient."

#. type: Title =====
#: manual/commands/measure.txt:22 manual/measure/at.txt:16
#: manual/measure/cross.txt:28
#, no-wrap
msgid "Diagnostics"
msgstr "Диагностика"

#. type: Plain text
#: manual/commands/measure.txt:25
msgid ""
"The message \"no match\" means that the probe you selected was not stored."
msgstr ""
"Сообщение «no match» означает, что данные для точки измерения, которую вы "
"выбрали, не были сохранены."

#. type: Title =====
#: manual/commands/measure.txt:28 manual/howto/measure.txt:1
#, no-wrap
msgid "Measurements"
msgstr "Измерения"

#. type: Plain text
#: manual/commands/measure.txt:31 manual/howto/measure.txt:4
msgid ""
"\"Point\" here refers to time, frequency, or whatever is the independent \"x"
"\" value."
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:40 manual/howto/measure.txt:12
#, no-wrap
msgid ""
"|[[gnucap:manual:measure:at]]     |The value of a wave at a point, or its derivative.  |\n"
"|[[gnucap:manual:measure:mean|average]]\\\\ [[gnucap:manual:measure:mean]]              |Average or mean value.  |\n"
"|[[gnucap:manual:measure:cross]]  |Find crossings.  |\n"
"|[[gnucap:manual:measure:mean|integrate]]\\\\ [[gnucap:manual:measure:mean|area]]  |The area under the curve.  |\n"
"|[[gnucap:manual:measure:minmax|max]]    |Maximum value, or its point.  |\n"
"|[[gnucap:manual:measure:minmax|min]]    |Minimum value, or its point.  |\n"
"|[[gnucap:manual:measure:mean|rms]]    |The RMS value.  |\n"
"|[[gnucap:manual:measure:slope|slewrate]]\\\\ [[gnucap:manual:measure:slope]]\\\\ [[gnucap:manual:measure:slope|ddt]]  |Slew rate or slope.  |\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:46
#, no-wrap
msgid ""
"Before making measurements, you need to store the data to measure:\n"
"  gnucap> store tran v(*) id(m*) gm(m*)\n"
"Then do the analysis\n"
"  gnucap> transient 0 100u 1u trace all\n"
msgstr ""
"Перед измерениями необходимо сохранить данные для измерений:\n"
"  gnucap> store tran v(*) id(m*) gm(m*)\n"
"Затем выполнить анализ:\n"
"  gnucap> transient 0 100u 1u trace all\n"

#. type: Plain text
#: manual/commands/measure.txt:48
msgid "Now you are ready to measure:"
msgstr "Теперь вы готовы измерять:"

#. type: Plain text
#: manual/commands/measure.txt:56
#, no-wrap
msgid ""
"  gnucap> measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  gnucap> measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  gnucap> param period = {t2-t1}\n"
"  gnucap> param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:61
#, no-wrap
msgid ""
"  gnucap> measure meanvalue = mean(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the mean value of v(out) over one cycle.\n"
"  gnucap> measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:64
#, no-wrap
msgid ""
"  gnucap> measure area = integrate(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the area under the curve of v(out) over one cycle.  The area might be zero.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:67
#, no-wrap
msgid ""
"  gnucap> measure rms = rms(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the RMS value of v(out) over one cycle.\n"
msgstr ""

#. type: Plain text
#: manual/commands/measure.txt:70
#, no-wrap
msgid ""
"  gnucap> measure rmsin = rms(probe=\"bar(in)\")\n"
"  no match: bar(in)\n"
"You didn't store the probe \"bar(in)\".\n"
msgstr ""

#. type: Title ======
#: manual/commands/op.txt:1
#, no-wrap
msgid "\"op\" command"
msgstr "Команда «op»"

#. type: Plain text
#: manual/commands/op.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, with no input. If a "
"temperature range is given, it sweeps the temperature."
msgstr ""
"Выполнение нелинейного расчёта статического режима по постоянному току при "
"отсутствии входного сигнала. При задании температуры расчёт производится с "
"изменением температуры."

#. type: Plain text
#: manual/commands/op.txt:10
#, no-wrap
msgid "  op start stop stepsize {options ...} \n"
msgstr "|''**op** //начало конец размер_шага// {//параметры ...//}''|\n"

#. type: Plain text
#: manual/commands/op.txt:14
msgid ""
"There are substantial extensions beyond the capabilities of the SPICE op "
"command."
msgstr ""
"Возможности команды **op** существенно расширены по сравнению с аналогичной "
"командой в SPICE."

#. type: Plain text
#: manual/commands/op.txt:16
msgid ""
"If there are numeric arguments, they represent a temperature sweep. They are "
"the start and stop temperatures in degrees Celsius, and the step size, in "
"order. They are saved between commands, so no arguments will repeat the "
"previous sweep."
msgstr ""
"Если заданы числовые аргументы, они представляют собой диапазон развёртки "
"температуры. Это начальная и конечная температура в градусах Цельсия, и "
"размер шага, в указанном порядке. Они сохраняются между командами, поэтому "
"ни при каких аргументах предыдущая развёртка повторяться не будет."

#. type: Plain text
#: manual/commands/op.txt:18
msgid ""
"This command will use the op probe set, instead of automatically printing "
"all nodes and source currents, so you must do \"print op ....\" before "
"running op. We did it this way because we believe that printing everything "
"all the time is usually unnecessary clutter. All of the information "
"available from SPICE and more is available here. See the print command and "
"the device descriptions for more details."
msgstr ""
"Вместо автоматического вывода всех узлов и токов источников для этой команды "
"будет использоваться набор датчиков **op**, поэтому до запуска команды "
"**op** вам необходимо задать **''print op ...''**. В таком виде это сделано "
"из-за того, что нам кажется, что постоянный вывод всех данных приводит "
"обычно лишь к ненужному беспорядку. Вся информация, доступная в SPICE, и "
"даже сверх того, доступна и здесь. Подробности см. в описании команды "
"[[print.ru|print]] и в [[..:devices.ru|описаниях устройств]]."

#. type: Plain text
#: manual/commands/op.txt:20
msgid ""
"A single parameter represents a single temperature. Two parameters instruct "
"the computer to analyze for those two points only."
msgstr ""
"Одним параметром задаётся одна температура. Двумя параметрами компьютеру "
"даётся приказ анализировать только указанные две точки."

#. type: Plain text
#: manual/commands/op.txt:22
msgid ""
"This command also sets up the quiescent point for subsequent AC analysis. It "
"is necessary to do this for nonlinear circuits. The last step in the sweep "
"determines the quiescent point for the AC analysis."
msgstr ""
"Этой командой также настраивается статическая точка для последующего анализа "
"[[ac.ru|ac]]. Это необходимо для анализа нелинейных схем. Статическая точка "
"для анализа [[ac.ru|ac]] определяется последним шагом в диапазоне."

#. type: Plain text
#: manual/commands/op.txt:63
#, no-wrap
msgid ""
"  op 27\n"
"Do a DC operating point simulation at temperature 27 degrees Celsius.\n"
"  op -50 200 25\n"
"Sweep the temperature from -50 to 200 in 25 degree steps. Do a DC operating point simulation at each step.\n"
"  op\n"
"With no parameters, it uses the same ones as the last time. In this case, from -50 to 200 in 25 degree steps.\n"
"  op 200 -50 -25\n"
"You can sweep downward, by asking for a negative increment.\n"
"  op temperature=75\n"
" Simulate at 75 degrees, this time. This isn't remembered for next time.\n"
"  op\n"
"Since the last time used the temperature option, go back one more to find what the sweep parameters were. In this case, downward from 200 to -50 in 25 degree steps.\n"
msgstr ""
"  op 27\n"
"Произвести статический расчёт рабочей точки по постоянному току при температуре 27 градусов Цельсия.\n"
"  op -50 200 25\n"
"Изменять температуру от -50 до 200 с шагом в 25 градусов. Для каждого шага производить статический расчёт рабочей точки по постоянному току.\n"
"  op\n"
"Если параметры не указаны, будут использоваться те же самые параметры, что были заданы последний раз. В данном случае моделирование от -50 до 200 с шагом 25 градусов.\n"
"  op 200 -50 -25\n"
"Можно произвести развёртку в обратную сторону, запросив отрицательное приращение.\n"
"  op temperature=75\n"
"В этот раз произвести моделирование для 75 градусов. Параметр запоминаться не будет, и не будет использоваться для следующего моделирования.\n"
"  op\n"
"Так как последний раз использовалась опция ''temperature'', вернуться ещё на одну команду назад, чтобы узнать параметры развёртки. В данном случае это развёртка от 200 вниз до -50 с шагом 25 градусов.\n"

#. type: Title ======
#: manual/commands/options.txt:1
#, no-wrap
msgid "\"options\" command"
msgstr "Команда «options»"

#. type: Plain text
#: manual/commands/options.txt:6 manual/commands/options.txt:14
msgid "Sets options, iteration parameters, global data."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:10
#, no-wrap
msgid ""
"  options\n"
"  options option-name value ...\n"
msgstr ""
"  options\n"
"  options имя_опции значение ...\n"

#. type: Plain text
#: manual/commands/options.txt:18
msgid "Typical usage is the name of the item to set followed by the value."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:20
msgid "The bare command `options' displays the values."
msgstr "Команда ''options'' без параметров выводит эти значения."

#. type: Plain text
#: manual/commands/options.txt:22
msgid ""
"These options control the simulation by specifying how to handle marginal "
"circumstances, how long to wait for convergence, etc."
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:24
msgid "Most of the SPICE options are supported, more have been added."
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:26
#, no-wrap
msgid "i/o"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:40
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|acct         |false    |Turns on accounting. When enabled, print the CPU time used after each command, and a summary on exit in batch more.  |\n"
"|list         |false    |Turns on echo input.  |\n"
"|clobber      |true     |Allow clobber of files.  |\n"
"|out          |9999     |Output width.  Sets the output print width for tables and character graphics.  |\n"
"|ydivisions   |4.       |Y axis divisions. Sets the number of divisions on the Y axis for ASCII plotting.  |\n"
"|phase        |degrees  |In AC analysis, print phase in \"degrees\", \"+degrees\", \"-degrees\" or \"radians\".\\\\  \"degrees\" wraps phase to the range of -180 to +180.\\\\  \"+degrees\" wraps phase to the range of 0 to +360.\\\\  \"-degrees\" wraps phase to the range of -360 to 0.  |\n"
"|harmonics    |9        |Harmonics in Fourier analysis. The number of harmonics to display in a Fourier analysis, unless specified otherwise.  |\n"
"|edit         |true     |Enable command line editing.  |\n"
"|language     |acs      |Simulation language selection.  As supplied, the supported values are \"acs\", \"spice\", \"spectre\", and \"verilog\".  |\n"
"|insensitive  |         |Case sensitivity.  Whether it is true or false by default depends on the language.  |\n"
"|units        |spice    |Floating point units.  Supported values are \"spice\" and \"si\".  |\n"
"|recursion    |20       |Limit recursion in expresion evaluation to x levels.  The purpose is to trap infinite recursion in user expressions.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:42
#, no-wrap
msgid "accuracy, i/o"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:48
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|numdgt       |5        |Number of significant digits to print for analysis results.  It is silently limited to 3 to 20.  |\n"
"|floor        |1.E-21   |Effective zero value.  Results values less than floor are shown as zero. Other small numbers are rounded to the nearest floor.  |\n"
"|vfloor       |1.f      |Effective zero value for voltage probes.  Results values less than vfloor are shown as zero. Other small numbers are rounded to the nearest vfloor.  |\n"
"|roundofftol  |100.f    |Numeric rounding tolerance.  Some internal calculations can result in cancellations, with a result near zero even though the operands are large. The number is converted to zero if it is less than roundofftol*theoperand.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:49
#, no-wrap
msgid "accuracy, tolerances"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:61
#, no-wrap
msgid ""
"^key         ^default  ^description  ^\n"
"|gmin        |1.p      |Minimum conductance allowed by the program.  Every node must have a net minimum conductance of GMIN to ground. If effective open circuits are found during the solution process (leading to a singular matrix) a conductance of GMIN is forced to ground, after printing an \"open circuit\" error message.  |\n"
"|short       |10.uΩ    |Resistance of voltage source or short. Sets the default resistance of voltage sources. In some cases, inductors are replaced by resistors, if so, this is the value. It is also the resistance used to replace short circuits anywhere they are not allowed and the program finds one.  |\n"
"|reltol      |0.001    |Relative error tolerance allowed.  If the ratio of successive values in iteration are within RELTOL of one, this value is considered to have converged.  |\n"
"|abstol      |1.p      |Absolute error tolerance allowed.  If successive values in iteration are within ABSTOL of each other, this value is considered to have converged.  |\n"
"|vntol       |1.u      |Absolute voltage error required to force model re-evaluation.  If the voltage at the terminals of a model is within VNTOL of the previous iteration, the model is not re-evaluated. The old values are used directly.  |\n"
"|trtol       |7.       |Transient error “tolerance”.  This parameter is an estimate of the factor by which the program overestimates the actual truncation error.  For critical applications, it should be set to 1.  |\n"
"|chgtol      |10.f     |Charge tolerance.  It is used in step size control in transient analysis.  |\n"
"|pivtol      |100.f    |Pivot tolerance.  Sets a threshold for printing an \"open circuit\" warning.  |\n"
"|bypasstol   |0.1      |Tolerance multiplier for evaluation bypass checking.  |\n"
"|loadtol     |0.1      |Tolerance multiplier for matrix load bypass checking.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:62
#, no-wrap
msgid "accuracy, algorithms"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:75
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|method        |trap     |Differentiation method.  Incorrectly called “integration” method in SPICE. Possible values are euler, gear, and trap.  |\n"
"|bypass        |true     |Bypass model evaluation if appropriate. If the last two iterations indicate that an element is converged or dormant, do not evaluate it but use its old values directly.  |\n"
"|incmode       |true     |Incrementally update the matrix. Instead of rebuilding the matrix on every iteration, keep as much of the old matrix as possible and make incremental changes.  |\n"
"|lcbypass      |true     |Bypass evaluation of linear inductors and capacitors when possible. When set, they are evaluated only on the first iteration of a time step.  |\n"
"|lubypass      |true     |Bypass parts of LU decomposition if appropriate. If only a few elements of the matrix were changed solve only those parts of the LU matrix that depend on them.  |\n"
"|fbbypass      |true     |Skip matrix solution the last iteration. In theory, it reduces accuracy slightly, but specified tolerances will still be met. Time saving can be significant.  |\n"
"|traceload     |true     |Use a queue to only load changed elements to the matrix. This results in faster loading and has no known drawbacks.  |\n"
"|order         |auto     |Equation ordering.  Determines how external node numbers are mapped to internal numbers. The values are forward, reverse, and auto.  |\n"
"|mode          |mixed    |Simulation mode selection.  Values are analog, digital, and mixed. In analog mode, logic elements (type U) are replaced by their subcircuits as if they were type X. In digital mode, logic elements are simulated as digital regardless of whether the signals are proper or not, as in traditional mixed-mode simulation. In mixed mode, logic elements may be simulated as analog or digital depending on the signals present.  |\n"
"|transits      |2        |Mixed mode transition count.  Sets the number of “good” transitions for a supposedly digital signal to be accepted as digital.  |\n"
"|quitconvfail  |false    |Quit on convergence failure in transient analysis. Do not adjust time step, just stop.  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:75
#, no-wrap
msgid "iteration limiting and heuristics"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:91
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|itl1          |100      |DC iteration limit.  Sets the maximum number of iterations in a DC, OP, or initial transient analysis allowed before stopping and reporting that it did not converge.  |\n"
"|itl2          |50       |DC transfer curve iteration limit.  SPICE option accepted but not implemented. Use itl1 instead.  |\n"
"|itl3          |6        |Lower transient iteration limit.  If the number of iterations is more than itl3 the step size is limited by trstephold. Otherwise, it can grow by trstepgrow.  |\n"
"|itl4          |20       |Upper transient iteration limit.  Sets the maximum number of iterations on a step in transient analysis. If the circuit fails to converge in this many iterations the step size is reduced (by option trstepshrink), time is backed up, and the calculation is repeated.  |\n"
"|itl5          |0        |Transient analysis total iteration limit.  SPICE option accepted but not implemented. Actual behavior is the same as itl5 = 0, in SPICE, which omits this test.  |\n"
"|itl6          |5000     |Homotopy iteration limit.  Sets the maximum number of iterations to allow for homotopy methods of recovering from a convergence failure.  Setting itl6 to 0 disables homotopy.  |\n"
"|itl7          |1        |Worst case analysis iteration limit.  Sets the maximum number of iterations for the individual element trials in a DC or bias worst case analysis. If more iterations than this are necessary, the program silently goes on to the next step, as if nothing was wrong, which is usually the case.  |\n"
"|itl8          |99       |Convergence diagnostic iteration threshold.  If the iteration count on a step exceeds itl8 diagnostic messages are printed in an attempt to aid the user in solving the convergence problem.  |\n"
"|itermin       |1        |Number of extra iterations after convergence.  After convergence tolerances are met, do itermin extra iterations to be sure. This provides protection against false indication of convergence. Setting itermin = 0 is equivalent to SPICE, with improved simulation speed.  |\n"
"|vmin          |-5.      |Initial negative node voltage limit.  All node voltages may be limited to −x to aid in convergence and prevent numeric overflow. This is intended as a convergence aid only. It may or may not help. This number is used as a starting point. It is adjusted as the simulation progresses.  |\n"
"|vmax          |5.       |Initial positive node voltage limit.  All node voltages may be limited to +x to aid in convergence and prevent numeric overflow. This is intended as a convergence aid only. It may or may not help. This number is used as a starting point. It is adjusted as the simulation progresses.  |\n"
"|dampmax       |1.       |Normal Newton damping factor.  Sets the damping factor for iteration by damped Newton's method, used when all is well. It must be between 0 and 1, as close to 1 as possible and still achieve convergence. The useful range is from .9 to 1. Setting dampmax too low will probably cause convergence to a nonsense result.  |\n"
"|dampmin       |0.5      |Newton damping factor in problem cases.  Sets the damping factor for iteration by damped Newton's method, used when there are problems. It must be between 0 and 1, and is usually set somewhat less than dampmax. The useful range is from .5 to .9. Setting it lower than .5 may cause convergence to a nonsense result. Aside from that, a lower value (but less than dampmax) tends to improve robustness at the expense of convergence speed.  |\n"
"|dampstrategy  |0        |Damping strategy.  The actual damping factor to use is determined by heuristics. Normally the damping factor is dampmax. It is reduced to dampmin when certain conditions occur, then it drifts back up on subsequent iterations.  The strategy used is determined by the sum of the following factors:\\\\  1: initial step: Use dampmin on the second iteration.\\\\  2: range:  Use dampmin if an iteration voltage would be out of range (vmin, vmax).\\\\  4: device limiting:  Use dampmin when device based voltage or current limiting limits.  (If supported by the device.)\\\\  10: device region:  Use dampmin when a device passes a region boundary (If supported by the device.)\\\\  20:  device reverse:  Use dampmin when a device is reversed.  (If supported by the device.)  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:93
#, no-wrap
msgid "time step control"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:105
#, no-wrap
msgid ""
"^key           ^default     ^description  ^\n"
"|dtmin         |1.p         |Minimum time step.  The smallest internal time step in transient analysis. The transient command dtmin option and the dtratio option override it if it is bigger.  |\n"
"|dtratio       |1.G         |The ratio between minimum and maximum time step.  |\n"
"|trstepgrow    |1.E+99      |The maximum internal step size growth in transient analysis. Default = 1e99, which allows arbitrary changes in step size.  |\n"
"|trstephold    |1.E+99      |The maximum internal step size growth in transient analysis, when the iteration count exceeds itl3 but still converges.   |\n"
"|trstepshrink  |2.          |The amount to decrease the transient step size by when convergence fails.  |\n"
"|trreject      |0.5         |Transient error rejection threshold.  Controls how bad the truncation error must be to reject a time step. A value of .5 means that if the step reqested is smaller than .5 times the step size used, the current step will be rejected. If the new step is .8 times the old step size it will be adjusted but the step just calculated will not be rejected.  |\n"
"|trsteporder   |3           |Control time steps according to \"trsteporder\" order interpolation.  Supported values are 1, 2, 3.  |\n"
"|trstepcoef1   |0.25        |Coefficient used in order 1 step control  |\n"
"|trstepcoef2   |0.04166667  |Coefficient used in order 2 step control  |\n"
"|trstepcoef3   |0.00520833  |Coefficient used in order 3 step control  |\n"
msgstr ""

#. type: Title ====
#: manual/commands/options.txt:106
#, no-wrap
msgid "circuit environment"
msgstr ""

#. type: Plain text
#: manual/commands/options.txt:115
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|tnom         |27.      |Nominal temperature, Celsius.  All components have their nominal value at this temperature.  |\n"
"|temperature  |27.      |Simulation temperature.  Sets the ambient temperature, in degrees Celsius. This is the temperature at which the simulation takes place, unless changed by some other command.  |\n"
"|rstray       |true     |Include series resistance in device models. This creates internal nodes and results in a significant speed and memory penalty. It also makes convergence characteristics worse.  |\n"
"|cstray       |true     |Include capacitance in device models. This may create internal nodes and result in a significant speed and memory penalty. It also may make convergence characteristics worse.  |\n"
"|defl         |100.u    |MOSFET default channel length in meters.  |\n"
"|defw         |100.u    |MOSFET default channel width in meters.  |\n"
"|defad        |0.       |MOSFET default drain diffusion area in square meters.  |\n"
"|defas        |0.       |MOSFET default source diffusion area in square meters.  |\n"
msgstr ""

#. type: Title ======
#: manual/commands/outfile.txt:1
#, no-wrap
msgid "\">\" command"
msgstr "Команда «>»"

#. type: Plain text
#: manual/commands/outfile.txt:6
msgid "Saves a copy of all program output (except help) in a file."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:12
#, no-wrap
msgid ""
"  > file\n"
"  >> file\n"
"  >\n"
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:16
msgid ""
"''>'' creates a new file for this output. If the file already exists, the "
"old one is lost, and replaced by the new one."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:18
msgid ""
"''>''''>'' appends to an existing file, if it exists, otherwise it creates "
"one."
msgstr ""

#. type: Plain text
#: manual/commands/outfile.txt:20
#, fuzzy
#| msgid "A bare ''>'' closes the file.\n"
msgid "A bare ''>'' closes the file."
msgstr "Команда ''>'' без параметров закрывает файл.\n"

#. type: Plain text
#: manual/commands/outfile.txt:28
#, no-wrap
msgid ""
"  > run1\n"
"Save everything in a file run1 in the current directory. If run1 already exists, the old one is gone.\n"
"  >> allof\n"
"Save everything in a file allof. If allof already exists, it is kept, and the new data is added to the end.\n"
"  >\n"
"Close the file. Stop saving.\n"
msgstr ""

#. type: Title ====
#: manual/commands/parameter.txt:1
#: manual/tech/plugins/parameter_functions_and_measurements.txt:17
#, no-wrap
msgid "\"parameter\" command"
msgstr "Команда «parameter»"

#. type: Plain text
#: manual/commands/parameter.txt:6
msgid "Set and view parameters."
msgstr "Установка и просмотр параметров."

#. type: Plain text
#: manual/commands/parameter.txt:13
#, no-wrap
msgid ""
"  param\n"
"  parameter\n"
"  param param-name value ...\n"
"  parameter param-name value ...\n"
msgstr ""
"  param\n"
"  parameter\n"
"  param имя_параметра значение ...\n"
"  parameter имя_параметра значение ...\n"

#. type: Plain text
#: manual/commands/parameter.txt:17
msgid "The bare command param lists all defined parameters and their values."
msgstr ""
"Команда ''param'' без указания параметров выводит все определённые параметры "
"и их значения."

#. type: Plain text
#: manual/commands/parameter.txt:19
msgid ""
"The value may be a number, the name of another parameter, or an expression. "
"If it is another parameter, eventually it must resolve to a number. This "
"depth can be set by the option recursion which has a default value of 20. "
"The depth is limited to prevent infinite recursion."
msgstr ""
"Значение может быть числом, именем другого параметра или выражением. Если "
"это другой параметр, то в конце концов он должен разрешиться как число.  "
"Глубина разрешения может быть установлена опцией recursion, значение которой "
"по умолчанию равно 20.  Глубина ограничена для предотвращения бесконечной "
"рекурсии."

#. type: Plain text
#: manual/commands/parameter.txt:21
msgid ""
"All component values, numeric lists such as in PWL, component and model "
"parameters can be numbers or expressions.  Numeric arguments to most "
"commands can also be parameters or expressions."
msgstr ""
"Все значения компонентов, числовые списки, такие как PWL, параметры "
"компонентов и моделей могут быть числами либо выражениями. Числовые "
"аргументы большинства команд таже могут быть параметрами или выражениями."

#. type: Plain text
#: manual/commands/parameter.txt:23
msgid ""
"If the same parameter is set more than once, the most recent one prevails. "
"All instances of the parameter will take the new value."
msgstr ""
"Если тот же самый параметр устанавливается более чем однажды, приоритет "
"имеет самое последнее действие. Все экземпляры параметра примут новое "
"значение."

#. type: Plain text
#: manual/commands/parameter.txt:25
msgid ""
"When a parameter name is used as a value, it may be enclosed by quotes or "
"curly braces."
msgstr ""
"Когда имя параметра используется как значение, оно может заключаться в "
"кавычки или фигурные скобки."

#. type: Plain text
#: manual/commands/parameter.txt:27
msgid ""
"Parameter expressions use late evaluation and dynamic scoping, like a "
"functional language."
msgstr ""
"В выражениях параметров используются отложенные вычисления и динамический "
"контекст, как в функциональных языках программирования."

#. type: Plain text
#: manual/commands/parameter.txt:29
msgid ""
"For more information on parameter expressions, look [[gnucap:manual:howto:"
"expressions|here]]."
msgstr ""
"Более подробную информацию о выражениях параметров см. [[gnucap:manual:howto:"
"expressions.ru|здесь]]."

#. type: Plain text
#: manual/commands/parameter.txt:68
#, no-wrap
msgid ""
"Suppose we have this circuit:\n"
"  .model small npn (bf=beta)\n"
"  Vpower (vcc 0) dc vcc\n"
"  Vin    (in  0) generator\n"
"  Q1 (c b e) small\n"
"  Rc (vcc c) rc\n"
"  Re (e 0) re\n"
"  Rb1 (vcc b) rb1\n"
"  Rb2 (b 0)   rb2\n"
"If I try to simulate it now, it will not be very useful. We need to give our circuit some values:\n"
"  gnucap> param vcc=10 beta=100 rc=10k re=1k rb1=100k rb2=rc\n"
"Let's see what it does:\n"
"  gnucap> print op v(nodes)\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.8941   8.3513   0.16652  0.       10.\n"
"What happens if I change beta?\n"
"  gnucap> param beta=200\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.90128  8.2822   0.17264  0.       10.\n"
"Not much changes. Let's try to lower v(''''c). About 6 should be better.\n"
"  gnucap> param rb1=68k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.2602   4.9866   0.50385  0.       10.\n"
"Too low, try again:\n"
"  gnucap> param rb1=82k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.0724   6.7437   0.32726  0.       10.\n"
"Too high...\n"
"  gnucap> param rb1=75k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.1586   5.9433   0.4077   0.       10.\n"
"Close enough.\n"
msgstr ""
"Предположим у нас есть такая схема:\n"
"  .model small npn (bf=beta)\n"
"  Vpower (vcc 0) dc vcc\n"
"  Vin    (in  0) generator\n"
"  Q1 (c b e) small\n"
"  Rc (vcc c) rc\n"
"  Re (e 0) re\n"
"  Rb1 (vcc b) rb1\n"
"  Rb2 (b 0)   rb2\n"
"Если я попробую её сейчас промоделировать, она не будет очень\n"
"полезной. Нам надо задать для своей схемы некоторые значения:\n"
"  gnucap> param vcc=10 beta=100 rc=10k re=1k rb1=100k rb2=rc\n"
"Посмотрим, что она делает:\n"
"  gnucap> print op v(nodes)\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.8941   8.3513   0.16652  0.       10.\n"
"Что будет, если я поменяю beta?\n"
"  gnucap> param beta=200\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.90128  8.2822   0.17264  0.       10.\n"
"Не слишком много изменений. Давайте попробуем уменьшить v(''''c).\n"
"Около 6 должно быть лучше.\n"
"  gnucap> param rb1=68k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.2602   4.9866   0.50385  0.       10.\n"
"Слишком мало, пробуем ещё раз:\n"
"  gnucap> param rb1=82k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.0724   6.7437   0.32726  0.       10.\n"
"Слишком много...\n"
"  gnucap> param rb1=75k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.1586   5.9433   0.4077   0.       10.\n"
"Достаточно близко.\n"

#. type: Title ======
#: manual/commands/pause.txt:1
#, no-wrap
msgid "\"pause\" command"
msgstr "Команда «pause»"

#. type: Plain text
#: manual/commands/pause.txt:6
msgid "Suspend batch mode. Wait for the user to hit a key."
msgstr ""
"Приостановка работы в пакетном режиме. Ожидание нажатия клавиши "
"пользователем."

#. type: Plain text
#: manual/commands/pause.txt:10
#, no-wrap
msgid "  pause comment\n"
msgstr "  pause комментарий\n"

#. type: Title ======
#: manual/commands/pause.txt:11 manual/commands/plot.txt:14
#: manual/languages/spectre.txt:120 manual/languages/verilog.txt:132
#, no-wrap
msgid "Status"
msgstr ""

#. type: Plain text
#: manual/commands/pause.txt:14
msgid ""
"This command does not work on all systems, due to buffering of console i/o."
msgstr ""
"Данная команда работает не на всех системах из-за буферизации консольного "
"ввода/вывода."

#. type: Plain text
#: manual/commands/pause.txt:18
msgid ""
"Prints Continue? and waits for a key hit. Type `n', `N', escape or control-c "
"to terminate the batch mode. Type anything else to continue."
msgstr ""
"Выводит Continue? и ожидает следующего нажатия клавиши. Для завершения "
"работы в пакетном режиме следует нажать `n', `N', escape или control-c. "
"Нажатие других клавиш ведёт к продолжению."

#. type: Plain text
#: manual/commands/pause.txt:20
msgid "Any comment is ignored."
msgstr "Любые комментарии игнорируются."

#. type: Plain text
#: manual/commands/pause.txt:25
#, no-wrap
msgid ""
"  pause Try more gain\n"
"  pause\n"
"These both work the same. Ask to continue, wait for a key hit, then go on.\n"
msgstr ""
"  pause Пробуем больший коэффициент усиления\n"
"  pause\n"
"Обе эти команды работают одинаково. Запрашивается продолжение,\n"
"ожидается нажатия клавиши, затем работа продолжается.\n"

#. type: Title ======
#: manual/commands/plot.txt:1
#, no-wrap
msgid "\"plot\" command"
msgstr "Команда «plot»"

#. type: Plain text
#: manual/commands/plot.txt:6
msgid "Select points in the circuit for graphic output. Select graphic output."
msgstr "Выбор точек схемы для графического вывода. Выбор графического вывода."

#. type: Plain text
#: manual/commands/plot.txt:13
#, no-wrap
msgid ""
"  plot\n"
"  plot mode points ... ...\n"
"  plot mode + points ... ...\n"
"  plot mode - points ... ...\n"
"  plot mode CLEAR\n"
msgstr ""
"  plot\n"
"  plot режим точки ... ...\n"
"  plot режим + точки ... ...\n"
"  plot режим - точки ... ...\n"
"  plot режим CLEAR\n"

#. type: Plain text
#: manual/commands/plot.txt:17
msgid ""
"The plotting leaves something to be desired. Only two signals can be plotted "
"at a time. The output file is corrupt when plotting is on."
msgstr ""
"Вывод графиков оставляет желать лучшего. Только два сигнала можно печатать "
"за раз. Выходной файл портится, когда включено построение графиков."

#. type: Plain text
#: manual/commands/plot.txt:21
msgid ""
"The `plot' command selects where to look at the circuit, or where to hook "
"the oscilloscope probe."
msgstr ""
"Команда `plot' выбирает, на что смотреть в схеме, или куда подцепить щуп "
"осциллографа."

#. type: Plain text
#: manual/commands/plot.txt:25
msgid "To list the probe points, use the bare command `plot'."
msgstr ""
"Для вывода перечня точек измерения используйте команду ''plot'' без "
"параметров."

#. type: Plain text
#: manual/commands/plot.txt:36
msgid ""
"You must set the scaling. If you do not, the default range is fixed at -5 to "
"5. Gnucap cannot auto-scale because it generates the plot during simulation, "
"so the necessary information is not available yet. Spice can auto-scale only "
"because it waits for the simulation to complete before producing any output."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:38
msgid ""
"Plot uses the same variables as print. See the print command for a list of "
"what is available."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:40 manual/commands/print.txt:30
msgid ""
"The options plot and noplot on any analysis command turn plotting on and off "
"a single run. The plot command turns plotting on and tabular output off. The "
"print command turns plotting off and tabular output on."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:42
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"plot ac + v(3) adds v(3) to the existing set of AC probes. plot ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами + или -, их можно добавлять в существующий список "
"или удалять из него. plot ac + v(3) добавит v(3) в существующий набор точек "
"измерения AC. plot ac - q(c5) удалит q(c5) из списка. При удалении можно "
"использовать метасимволы * и ?."

#. type: Plain text
#: manual/commands/plot.txt:44
msgid "Plotting is limited to 2 items."
msgstr ""

#. type: Plain text
#: manual/commands/plot.txt:58
#, no-wrap
msgid ""
"  plot ac vm(12)(0,5) vm(13)(-5,5)\n"
"The magnitude of the voltage at node 12 with a range of 0 to 5, and node 13 with a range of -5 to 5 for AC analysis.\n"
"  plot dc v(r26)\n"
"The voltage across R26 for DC analysis. Since there is no range, default values will be used.\n"
"  plot tran v(r83)(0,5) p(r83)(0,1u)\n"
"Plot the voltage and power of R83 in the next transient analysis. The voltage scale is 0 to 5. The power scale is 0 to 1 microwatt.\n"
"  plot\n"
"List all the probes for all modes.\n"
"  plot dc\n"
"Display the DC plot list.\n"
"  plot ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/print.txt:1
#, no-wrap
msgid "\"print\" command"
msgstr "Команда «print»"

#. type: Plain text
#: manual/commands/print.txt:6
msgid "Select points in the circuit for tabular output. Select tabular output."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:14
#, no-wrap
msgid ""
"  print\n"
"  print mode points ... ...\n"
"  print mode + points ... ...\n"
"  print mode - points ... ...\n"
"  print mode CLEAR\n"
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:18
msgid ""
"The `print' command selects where to look at the circuit, or where to hook "
"the voltmeter (ammeter, watt meter, ohm meter, etc.) probe."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:22
msgid "To list the probe points, use the bare command `print'."
msgstr ""
"Для вывода перечня точек измерения используйте команду ''print'' без "
"параметров."

#. type: Plain text
#: manual/commands/print.txt:24
msgid ""
"On start-up, probes are not set. You must do the command `print op v(nodes)' "
"or put `.print op v(nodes)' in the circuit file to get any output from the "
"op command."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:26
msgid ""
"Syntax for each point is parameter(node), parameter(componentlabel), or "
"parameter(index). Some require a dummy index."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:28
msgid ""
"If the component does not exist, you will get an error message. If the "
"component exists but the parameter is not valid for that type, there will be "
"no error message but the value printed will be obviously bogus."
msgstr ""

#. type: Plain text
#: manual/commands/print.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"print ac + v(3) adds v(3) to the existing set of AC probes. print ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами + или -, их можно добавлять в существующий список "
"или удалять из него. print ac + v(3) добавит v(3) в существующий набор точек "
"измерения AC. print ac - q(c5) удалит q(c5) из списка. При удалении можно "
"использовать метасимволы * и ?."

#. type: Plain text
#: manual/commands/print.txt:50
#, no-wrap
msgid ""
"  print ac v(12) v(13) v(14)\n"
"The voltage at nodes 12, 13, and 14 for AC analysis.\n"
"  print dc v(r26)\n"
"The voltage across R26, for DC analysis.\n"
"  print tran v(r83) p(r83)\n"
"Voltage and power of R83, for transient analysis.\n"
"  print dc i(c8) p(r5) z(r5)\n"
"The current through C8, power dissipated in R5, and the impedance seen looking into the circuit across R5.\n"
"  print op v(nodes)\n"
"The voltage at all nodes for the op command.\n"
"  print\n"
"List all the probes, for all modes.\n"
"  print op\n"
"Display the OP probe list.\n"
"  print ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/save.txt:1
#, no-wrap
msgid "\"save\" command"
msgstr "Команда «save»"

#. type: Plain text
#: manual/commands/save.txt:6
msgid "Saves the circuit to a file."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:10
#, no-wrap
msgid "  save filename {options ...}\n"
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:14
msgid ""
"The file is in an ASCII format, so the list may be used as part of a report."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:16
msgid ""
"The format used depends on the \"language\" option, which could use a plugin "
"to provide any format.  \"Spice\", \"Spectre\" and \"Verilog\" formats are "
"supported in the standard installation."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:18
msgid ""
"You can save a part of a circuit. See the list command for more details."
msgstr ""

#. type: Plain text
#: manual/commands/save.txt:28
#, no-wrap
msgid ""
"  save works.ckt\n"
"Save the circuit in the file works.ckt, in the current directory.\n"
"  save\n"
"Save the circuit. Since you did not specify a file name, it will ask for one.\n"
"  save partof.ckt R*\n"
"Save a partial circuit, just the resistors, to the file partof.ckt. (See the List command.)\n"
"  save /client/sim/ckt/no33\n"
"You can specify a path name.\n"
msgstr ""

#. type: Title ======
#: manual/commands/status.txt:1
#, no-wrap
msgid "\"status\" command"
msgstr "Команда «status»"

#. type: Plain text
#: manual/commands/status.txt:6
msgid "Shows information on how the system resources are being utilized."
msgstr ""

#. type: Plain text
#: manual/commands/status.txt:11
#, no-wrap
msgid ""
"  status\n"
"  status notime\n"
msgstr ""

#. type: Plain text
#: manual/commands/status.txt:14
msgid "The notime option omits times but prints everything else."
msgstr ""

#. type: Title ======
#: manual/commands/store.txt:1
#, no-wrap
msgid "\"store\" command"
msgstr "Команда «store»"

#. type: Plain text
#: manual/commands/store.txt:6
msgid "Select points in the circuit to store for postprocessing."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:14
#, no-wrap
msgid ""
"  store\n"
"  store mode points ... ...\n"
"  store mode + points ... ...\n"
"  store mode - points ... ...\n"
"  store mode CLEAR\n"
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:18
msgid ""
"The \"store\" command selects probes to store for postprocessing, such as "
"measures."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:20
msgid "There are separate lists of points for each type of analysis."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:22
msgid "To list the points, use the bare command \"store\"."
msgstr ""
"Для вывода перечня точек измерения используйте команду ''store'' без "
"параметров."

#. type: Plain text
#: manual/commands/store.txt:24
msgid ""
"On start-up, probes are not set. You must do the command \"store op v"
"(nodes)\", \"store tran v(nodes)\" or whatever you want, to store any data "
"for post-processing."
msgstr ""

#. type: Plain text
#: manual/commands/store.txt:26
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"store ac + v(3) adds v(3) to the existing set of AC probes. store ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами + или -, их можно добавлять в существующий список "
"или удалять из него. store ac + v(3) добавит v(3) в существующий набор точек "
"измерения AC. store ac - q(c5) удалит q(c5) из списка. При удалении можно "
"использовать метасимволы * и ?."

#. type: Plain text
#: manual/commands/store.txt:40
#, no-wrap
msgid ""
"  store ac v(nodes)\n"
"The voltage at all nodes for AC analysis.\n"
"  store dc v(nodes) id(M*)\n"
"The voltage at all nodes and the parameter \"id\" on all devices witl labels starting with \"M\", for DC analysis.\n"
"  store tran v(*) p(*)\n"
"All parameters named \"v\", which probably means all node voltages and the most common voltage for all devices.  All parameters named \"p\", which is usually power.\n"
"  store\n"
"List all probes stored, for all modes.\n"
"  store op\n"
"Display the OP store list.\n"
"  store ac clear\n"
"Clear the AC list.\n"
msgstr ""

#. type: Title ======
#: manual/commands/sweep.txt:1
#, no-wrap
msgid "\"sweep\" command"
msgstr "Команда «sweep»"

#. type: Plain text
#: manual/commands/sweep.txt:6
msgid ""
"Sweep a component (or group of components) over a range. Set up a loop for "
"iteration."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:10
#, no-wrap
msgid "  sweep {stepcount} partlabel=range ...\n"
msgstr "  sweep {количество_шагов} обозначение_компонента=диапазон ...\n"

#. type: Plain text
#: manual/commands/sweep.txt:14
msgid ""
"This command is considered obsolete, but the replacement is not working yet."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:16
msgid ""
"This command begins a loop which will sweep a component or group of "
"components."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:18
msgid ""
"When this command is given, the only apparent actions will be a change in "
"the prompt from `gnucap>' to `>>>', and some disk action."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:20
msgid ""
"The different prompt means that commands are not executed immediately, but "
"are stored in a temporary file."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:22
msgid ""
"The bare command will repeat the same command sequence as the last time "
"sweep was run, and not prompt for anything else."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:24
msgid ""
"Additional components can be swept at the same time by entering a `FAult' "
"command at the `>>>' prompt. The `fault' behaves differently here: It "
"accepts a range, which is the sweep limits."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:26
msgid ""
"The `go' command will end the entry sequence, and make it all happen. After "
"this, the values are restored. (Also, all faults are restored, as if by the "
"`restore' command.)"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:28
msgid ""
"All commands can be used in this mode. Of course, some of them are not "
"really useful (quit) because they work as usual."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:30
msgid ""
"Only linear, ordinary parts can be swept. (No semiconductor devices, or "
"elements using behavioral modeling.) The tolerance remains unchanged. If you "
"attempt to sweep a nonlinear or otherwise strange part, it becomes ordinary "
"and linear during the sweep."
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:38
#, no-wrap
msgid ""
"  gnucap> sweep  5   R14=1,100k   R15=100k,1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
"This sequence of commands says to simultaneously sweep R14 and R15 in 5 steps, in opposite directions, list the circuit and do an AC analysis for each step.\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:58
#, no-wrap
msgid ""
"Assuming the circuit was:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
"The result of this sequence would be:\n"
"  R14  1   0   1\n"
"  R15  2   0   100k\n"
"an AC analysis\n"
"  R14  1   0   25.75k\n"
"  R15  2   0   75.25k\n"
"an AC analysis\n"
"  R14  1   0   50.5k\n"
"  R15  2   0   50.5k\n"
"an AC analysis\n"
"  R14  1   0   75.25k\n"
"  R15  2   0   25.75k\n"
"an AC analysis\n"
"  R14  1   0   100k\n"
"  R15  2   0   1\n"
"an AC analysis\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:62
#, no-wrap
msgid ""
"After all this is done, the circuit is restored, so list would show:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
msgstr ""

#. type: Plain text
#: manual/commands/sweep.txt:69
#, no-wrap
msgid ""
"You could accomplish the same thing by entering fault commands at the `>>>' prompt.\n"
"  gnucap>sweep  5\n"
"  >>>fault  R14=1, 100k\n"
"  >>>fault  R15=100k, 1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
msgstr ""
"Того же самого вы могли бы достичь вводом команд fault после приглашения ''>>>''.\n"
"  gnucap>sweep  5\n"
"  >>>fault  R14=1, 100k\n"
"  >>>fault  R15=100k, 1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"

#. type: Title ======
#: manual/commands/temp.txt:1
#, no-wrap
msgid "\"temperature\" command"
msgstr "Команда «temperature»"

#. type: Plain text
#: manual/commands/temp.txt:6
msgid "Views and sets the temperature, with SPICE compatible syntax."
msgstr ""
"Просмотр и установка температуры, используя SPICE-совместимый синтаксис."

#. type: Plain text
#: manual/commands/temp.txt:11
#, no-wrap
msgid ""
"  temperature\n"
"  temperature value\n"
msgstr ""
"  temperature\n"
"  temperature значение\n"

#. type: Plain text
#: manual/commands/temp.txt:15
msgid "With no value, it prints the temperature."
msgstr "При задании без указания значения команда выводит температуру."

#. type: Plain text
#: manual/commands/temp.txt:17
msgid "With a value, it is equivalent to “.option temperature=value”."
msgstr ""
"При задании значения это эквивалентно заданию “.option temperature=value”."

#. type: Plain text
#: manual/commands/temp.txt:18
msgid "The real purpose of this command is Spice compatibility."
msgstr "Подлинное назначение этой команды --- совместимость со SPICE."

#. type: Title ======
#: manual/commands/title.txt:1
#, no-wrap
msgid "\"title\" command"
msgstr "Команда «title»"

#. type: Plain text
#: manual/commands/title.txt:6
msgid "View and create the heading line for printouts and files."
msgstr "Просмотр и создание строки заголовка для вывода на печать и в файлы."

#. type: Plain text
#: manual/commands/title.txt:11
#, no-wrap
msgid ""
"  title\n"
"  title a line of text\n"
msgstr ""
"  title\n"
"  title текстовая строка\n"

#. type: Plain text
#: manual/commands/title.txt:15
msgid ""
"There is a header line at the beginning of every file, to help you identify "
"it in the future. This command sets up what it says. It also sets up a "
"heading for printouts and graphs."
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:17
msgid ""
"When you use the `get' command to bring in a new circuit, it replaces the "
"title with the one in the file. The `title' command lets you change it, for "
"the next time it is written out."
msgstr ""

#. type: Plain text
#: manual/commands/title.txt:23
#, no-wrap
msgid ""
"  title This is a test.\n"
"Sets the file heading to `This is a test.' In the future, all files written will have `This is a test.' as their first line.\n"
"  title\n"
"Displays the file heading. In this case, it prints `This is a test.'\n"
msgstr ""
"  title This is a test.\n"
"Задаёт в качестве заголовка файла строку `This is a test.' В\n"
"будущем во всех записываемых файлах первой будет идти строка `This\n"
"is a test.'\n"
"  title\n"
"Выводит заголовок файла. В данном случае печатает `This is a test.'\n"

#. type: Title ======
#: manual/commands/transient.txt:1
#, no-wrap
msgid "\"transient\" command"
msgstr "Команда «transient»"

#. type: Plain text
#: manual/commands/transient.txt:6
msgid "Performs a nonlinear time domain (transient) analysis."
msgstr ""
"Выполнение нелинейного анализа во временной области (временной анализ)."

#. type: Plain text
#: manual/commands/transient.txt:11
#, no-wrap
msgid ""
"  transient start stop stepsize {options ...}\n"
"  transient stepsize stop start {options ...} \n"
msgstr ""
"|''**transient** //начало конец размер_шага// {//параметры ...//}''|\n"
"|''**transient** //размер_шага конец начало// {//параметры ...//}''|\n"

#. type: Plain text
#: manual/commands/transient.txt:14
msgid ""
"The probes to look at must have been previously selected by the print or "
"plot command."
msgstr ""
"Датчики, значения которых нужно посмотреть, должны быть заранее выбраны "
"командами [[print.ru|print]] или [[plot.ru|plot]]."

#. type: Plain text
#: manual/commands/transient.txt:16
msgid ""
"Three parameters are normally needed for a Transient analysis: start time, "
"stop time and step size, in this order. The SPICE order (step size, stop, "
"start) is also acceptable. An optional fourth parameter is the maximum "
"internal time step."
msgstr ""
"Для временного анализа обычно нужно три параметра: начальное время, конечное "
"время и размер шага, в указанном порядке. Обратный порядок, как в SPICE "
"(размер шага, конец, начало), тоже приемлем. Дополнительным четвёртым "
"параметром задаётся максимальный внутренний шаг времени."

#. type: Plain text
#: manual/commands/transient.txt:18
msgid ""
"If all of these are omitted, the simulation will continue from where the "
"most recent one left off, with the same step size, unless the circuit "
"topology has been changed. It will run for the same length of time as the "
"previous run."
msgstr ""
"Если ни один из параметров не указан, будет продолжено самое последнее "
"моделирование с той точки, где оно было остановлено, с тем же размером шага, "
"если только топология схемы не изменилась. Длительность его выполнения будет "
"той же самой, что и при предыдущем запуске."

#. type: Plain text
#: manual/commands/transient.txt:20
#, no-wrap
msgid "Do not use a step size too large as this will result in errors in the results. If you suspect that the results are not accurate, try a larger argument to skip. This will force a smaller internal step size. If the results are close to the same, they can be trusted. If not, try a still larger skip argument until they appear to match close enough.   \n"
msgstr ""
"Не используйте слишком большой размер шага, так как это приведёт к\n"
"ошибкам в результатах. Если вы подозреваете, что результаты\n"
"неточны, попробуйте задать больший аргумент для ''skip''. Это приведёт\n"
"к установке меньшего размера внутреннего шага. Если результаты\n"
"близки к тем же самым, им можно верить. Если нет, пробуйте ещё\n"
"больший аргумент для ''skip'' и продолжайте до тех пор, пока последние\n"
"результаты не будут выглядеть достаточно близко совпадающими друг\n"
"с другом.\n"

#. type: Plain text
#: manual/commands/transient.txt:22
msgid ""
"The most obvious error of this type is aliasing. You must select sample "
"frequency at least twice the highest signal frequency that exists anywhere "
"in the circuit. This frequency can be very high, when you use the default "
"step function as input. The signal generator does not have any filtering."
msgstr ""
"Наиболее очевидной ошибкой этого типа является алиасинг (наложение спектров "
"дискретизованного сигнала). Частоту дискретизации необходимо выбирать по "
"крайней мере вдвое выше наибольшей частоты сигнала, присутствующего в любом "
"месте схемы. При использовании в качестве входного сигнала стандартной "
"ступенчатой функции эта частота может быть очень высокой. [[generator.ru|"
"Генератор сигналов]] не производит никакой фильтрации."

#. type: Plain text
#: manual/commands/transient.txt:49
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC analysis. Instead, use the values specified with the IC = options on the various elements, and set everything else to zero.  In most cases, UIC is not recommended.  Improper use of UIC causes more problems than it solves.  It is the way it is for Spice compatibility.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"
"|''cold                     ''| Нулевые начальные условия. Холодный запуск с момента подачи питания  |\n"
"|''uic                      ''| Использовать начальные условия. Не проводить начальный статический анализ по постоянному току [[dc.ru|dc]]. Вместо этого использовать данные, указанные в параметрах ''IC'' разных элементов, а всё остальное устанавливать в ноль. В большинстве случаев ''uic'' не рекомендуется. Неправильное использование ''uic'' вносит больше проблем, чем решает. В таком виде, в каком он представлен сейчас, этот параметр присутствует для совместимости со SPICE  |\n"

#. type: Plain text
#: manual/commands/transient.txt:61
#, no-wrap
msgid ""
"  transient 0 100u 10n\n"
"Start at time 0, stop after 100 micro-seconds. Simulate using 10 nanosecond steps.\n"
"  transient\n"
"No parameters mean to continue from the last run. In this case it means to step from 100 us to 200 us in 10 ns steps. (The same step size and run length, but offset to start where the last one stopped.\n"
"  transient skip 10\n"
"Do 10 extra steps internally for every step that would be done otherwise. In this case it means to internally step at 1 nanosecond. If the output is in tabular form, the extra steps are hidden.\n"
"  transient 0\n"
"Start over at time = 0. Keep the same step size and run length.\n"
"  transient >arun\n"
"Save the results of this run in the file \"arun\".\n"
msgstr ""
"  transient 0 100u 10n\n"
"Запустить во время 0, остановить через 100 микросекунд.\n"
"Моделировать с шагом 10 наносекунд.\n"
"  transient\n"
"Отсутствие параметров означает продолжение работы с момента останова при последнем запуске. В\n"
"данном случае это значит идти от 100 мкс до 200 мкс с шагом 10 нс.\n"
"(Тот же размер шага и та же длительность выполнения, но начало\n"
"моделирования смещается в ту точку, где оно последний раз было\n"
"остановлено.)\n"
"  transient skip 10\n"
"Делать 10 дополнительных внутренних шагов на каждый шаг, который\n"
"был бы сделан в противном случае. В данном случае это значит\n"
"использовать внутренний шаг в 1 наносекунду. Если вывод\n"
"производится в табличной форме, дополнительные шаги не\n"
"отображаются.\n"
"  transient 0\n"
"Запустить снова во время равное 0. Сохранить тот же размер шага и\n"
"длительность выполнения.\n"
"  transient >arun\n"
"При этом запуске сохранить результаты в файл ''arun''.\n"

#. type: Title ======
#: manual/commands/width.txt:1
#, no-wrap
msgid "\"width\" command"
msgstr "Команда «width»"

#. type: Plain text
#: manual/commands/width.txt:6
msgid "Set input and output width."
msgstr ""

#. type: Plain text
#: manual/commands/width.txt:10
#, no-wrap
msgid "  width {IN=value} {OUT=value}\n"
msgstr ""

#. type: Plain text
#: manual/commands/width.txt:13
msgid ""
"The `width' command is the same as the `options' command. It is provided for "
"SPICE compatibility. SPICE uses width to set two parameters: in and out, "
"which we set with the options command."
msgstr ""

#. type: Title ======
#: manual/compatibility.txt:1
#: manual/compatibility/subcircuit_with_parameters.txt:1
#, no-wrap
msgid "Compatibility"
msgstr "Совместимость"

#. type: Plain text
#: manual/compatibility.txt:4
msgid ""
"This section documents compatibility issues, including syntax and feature "
"differences compared to other simulators.  In some cases, a workaround is "
"suggested.  In almost all cases, there are plans to provide exact "
"compatibility in the future."
msgstr ""

#. type: Bullet: '  * '
#: manual/compatibility.txt:5
#, no-wrap
msgid "[[.:compatibility:subcircuit with parameters|subcircuit with parameters, Pspice, LTspice]]\n"
msgstr ""

#. type: Title =====
#: manual/compatibility/subcircuit_with_parameters.txt:2
#, fuzzy, no-wrap
#| msgid "Set and view parameters."
msgid "Subcircuit with parameters"
msgstr "Установка и просмотр параметров."

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:5
msgid ""
"Some simulators (LTspice, Pspice) accept a syntax for subcircuits that is "
"incompatible with gnucap."
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:7
msgid "The Gnucap syntax is compatible with other simulators such as Hspice."
msgstr ""

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:7
#, no-wrap
msgid "Subcircuit instantiation syntax"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:10
#: manual/compatibility/subcircuit_with_parameters.txt:25
msgid "LTspice syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:13
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack params: ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance params: ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:16
msgid ""
"The key ''params:'' should be omitted.  Parentheses are optional.\\\\ Gnucap "
"syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:19
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack vr=10  vi=1  on=1 vfactor=1.732\n"
"  Ximp v1r v1i 0 0  impedance r=1 xl=10 xc=2 length=1 zfactor=1\n"
msgstr ""

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid "Subcircuit declaration syntax"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:27
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i params: on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:33
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + params:\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:36
msgid ""
"The key params: should be omitted.  It is not necessary to declare "
"parameters, but you may do it for documentation or to specify default "
"values.  Parameters can be on the same line or in .param statements on "
"following lines.\\\\ Gnucap syntax:"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:38
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:43
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:45
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i (on = 1 r = 100 xl = 0)\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:48
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param on = 1 r = 100 xl = 0\n"
msgstr ""

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:53
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""

#. type: Title ======
#: manual/devices.txt:1
#, no-wrap
msgid "Devices"
msgstr ""

#. type: Plain text
#: manual/devices.txt:4
msgid ""
"Gnucap devices are defined by plugins. This section defines all commands "
"supplied in the main tarball, and also the optional \"models\" tarballs."
msgstr ""
"Устройства gnucap определяются посредством плагинов. В настоящем разделе "
"определяются все команды, поставляемые в основном tar-архиве, а также "
"дополнительные tar-архивы «моделей»."

#. type: Plain text
#: manual/devices.txt:6
msgid ""
"Your installation may not have all of these, and may have others in addition "
"to these. It depends on which plugins you have installed."
msgstr ""
"В вашей установке может не быть всех представленных ниже устройств, или "
"могут быть другие в дополнение к указанным. Это зависит от того, какие у вас "
"установлены плагины."

#. type: Plain text
#: manual/devices.txt:8
msgid ""
"The main tarball contains simple models, including most models that are "
"included with Spice-2g6, and some that are in Spice-3.  This should be "
"adequate for beginning academic work and most hobby work.  The other "
"tarballs contain specific models from a variety of sources.  Some are exact "
"industry standard models.  Some are from other simulators and are provided "
"for compatibility.  Some are new research oriented models.  Some are of "
"primarily historical interest."
msgstr ""
"В основном tar-архиве содержатся простые модели, включая большинство "
"моделей, входящих в Spice-2g6, и некоторые из имеющихся в Spice-3. Этого "
"должно быть достаточно для начала учебной работы и большей части "
"любительской практики. В других tar-архивах содержатся специфические модели "
"из множества источников. Некоторые из них представляют собой точные "
"стандартные промышленные модели.  Некоторые взяты из других программ "
"моделирования и приводятся для совместимости. Некоторые являются новыми "
"моделями, предназначенными для исследований. Некоторые представляют главным "
"образом исторический интерес."

#. type: Plain text
#: manual/devices.txt:10
msgid ""
"The Gnucap plugin system allows anyone to develop new models and add them, "
"without recompiling or reinstalling the main simulator.  There are several "
"options for doing this, including a model compiler and a wrapper that allows "
"the use of unmodified Spice C models."
msgstr ""
"Система плагинов gnucap позволяет любому разрабатывать новые модели и "
"добавлять их без перекомпиляции или переустановки основной программы "
"моделирования. Для этого существует несколько возможностей, в то числе "
"компилятор моделей и оболочка, позволяющая использовать C-модели Spice без "
"модификации."

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:basic|Basic passive devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:other|Other \"spice\" devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:semi|Semiconductor devices]]\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic.txt:1
#, no-wrap
msgid "Basic passive devices"
msgstr "Базовые пассивные приборы"

#. type: Plain text
#: manual/devices/basic.txt:4
msgid ""
"Gnucap includes the usual basic Spice devices, and some others that are "
"found in commercial versions of Spice."
msgstr ""
"Gnucap включает обычные базовые устройства Spice и несколько других, "
"найденных в коммерческих версиях Spice."

#. type: Plain text
#: manual/devices/basic.txt:6
msgid ""
"All of them are designed as plugins, but are included in the base "
"distribution and loaded by default."
msgstr ""
"Все они реализованы в виде плагинов, но включаются в основной дистрибутив и "
"загружаются по умолчанию."

#. type: Plain text
#: manual/devices/basic.txt:8
msgid ""
"All of them can be extended by simple behavioral expressions, in some cases "
"beyond what is available in any Spice."
msgstr ""
"Все они могут быть расширены с помощью простых поведенческих выражений, в "
"некоторых случаях сверх того, что доступно в любой из версий Spice."

#. type: Plain text
#: manual/devices/basic.txt:10
msgid "All of them have extended probes, more than any Spice."
msgstr "Все они имеют расширенные точки измерения, больше чем в любом Spice."

#. type: Title ====
#: manual/devices/basic.txt:11
#, no-wrap
msgid "The basic devices"
msgstr "Базовые приборы"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "capacitor (C)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "inductor (L)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "resistor (R)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed voltage source (V)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed current source (I)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled voltage source (E)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled current source (G)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled voltage source (H)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled current source (F)\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic.txt:22
#, no-wrap
msgid "Less common basic devices"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "admittance (Y)\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled resistor\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled capacitor\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled admittance\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "trans-capacitor\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic.txt:30
#, no-wrap
msgid "More info"
msgstr "Дополнительная информация"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:basic syntax]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:inline behavioral modeling]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:spice-style models]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:probes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:capacitor|.]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/basic_syntax.txt:1
#, no-wrap
msgid "Basic device syntax"
msgstr "Синтаксис базовых устройств"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:4
msgid ""
"This page applies to the simple \"Spice\" basic devices, and some extended "
"forms of them."
msgstr ""
"На данной странице приводятся простые базовые устройства SPICE и несколько "
"их расширенных форм."

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:4 manual/devices/capacitor.txt:5
#, no-wrap
msgid "Spice format"
msgstr "Формат SPICE"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:7
#: manual/devices/basic/basic_syntax.txt:57
#: manual/devices/basic/basic_syntax.txt:71
msgid "The format for simple devices is:"
msgstr "Формат записи для простых устройств:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:9
#, no-wrap
msgid "  label  (connections)  value\n"
msgstr "  обозначение  (соединения)  значение\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:11
msgid "Parentheses around the connections are optional."
msgstr "Скобки вокруг соединений необязательны."

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:13
#: manual/devices/basic/basic_syntax.txt:61
#: manual/devices/basic/basic_syntax.txt:77
msgid "Examples:"
msgstr "Примеры:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:18
#, no-wrap
msgid ""
"  Vin     (in 0)   10\n"
"  Lseries (in out) .01\n"
"  Cshunt  (out 0)  100u\n"
"  Rload   (out 0)  100\n"
msgstr ""
"  Vin     (in 0)   10\n"
"  Lseries (in out) .01\n"
"  Cshunt  (out 0)  100u\n"
"  Rload   (out 0)  100\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:20
msgid "The first letter of the label determines the type:"
msgstr "Первая буква обозначения определяет тип:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:30
#, fuzzy, no-wrap
msgid ""
"^2 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|C      |capacitor                         |capacitance q/v   |Cxxxx (p n) capacitance       |\n"
"|L      |inductor                          |inductance flux/i |Lxxxx (p n) inductance        |\n"
"|R      |resistor                          |resistance v/i    |Rxxxx (p n) resistance        |\n"
"|Y      |admittance                        |admittance i/v    |Yxxxx (p n) admittance        |\n"
"|V      |fixed voltage source              |DC voltage        |Vxxxx (p n) voltage           |\n"
"|I      |fixed current source              |DC current        |Ixxxx (sink src) current      |\n"
msgstr ""
"^ Устройства с 2 выводами ^^^^\n"
"^ Буква ^  Тип                              ^ Значение              ^ Синтаксис                    ^\n"
"| C     | конденсатор                       | ёмкость       Q/U     |Cxxxx (p n) ёмкость           |\n"
"| L     | катушка индуктивности             | индуктивность Ф/I     |Lxxxx (p n) индуктивность     |\n"
"| R     | резистор                          | сопротивление U/I     |Rxxxx (p n) сопротивление     |\n"
"| Y     | проводимость                      | проводимость  I/U     |Yxxxx (p n) проводимость      |\n"
"| V     | fixed voltage source (FIXME:)     | постоянное напряжение |Vxxxx (p n) напряжение        |\n"
"| I     | fixed current source (FIXME:)     | постоянный ток        |Ixxxx (sink src) ток          |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:37
#, fuzzy, no-wrap
msgid ""
"^4 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|E      |voltage controlled voltage source |gain vout/vin     |Exxxx (p n ps ns) gain        |\n"
"|G      |voltage controlled current source |gm   iout/vin     |Gxxxx (sink src ps ns) gm     |\n"
"|H      |current controlled voltage source |rm   vout/iin     |Hxxxx (p n control) gain      |\n"
"|F      |current controlled current source |gain iout/iin     |Fxxxx (sink src control) gain |\n"
msgstr ""
"^ Устройства с 4 выводами ^^^^\n"
"^ Буква ^ Тип                                          ^ Значение                                      ^ Синтаксис                              ^\n"
"| E     | источник напряжения, управляемый напряжением | K<sub>U</sub> U<sub>вых</sub>/U<sub>вх</sub>  | Exxxx (p n ps ns) K<sub>U</sub>        |\n"
"| G     | источник тока,       управляемый напряжением | gm   I<sub>вых</sub>/U<sub>вх</sub> (FIXME: добавить русское обозначение физ. величины)    |Gxxxx (sink src ps ns) gm     |\n"
"| H     | источник напряжения, управляемый током       | rm   U<sub>вых</sub>/I<sub>вх</sub> (FIXME: добавить русское обозначение физ. величины)    |Hxxxx (p n control) gain (FIXME: добавить замечание, что здесь должно быть rm, а не gain)    |\n"
"| F     | источник тока,       управляемый током       | K<sub>I</sub> I<sub>вых</sub>/I<sub>вх</sub>  | Fxxxx (sink src control) K<sub>I</sub> |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:44
#, fuzzy, no-wrap
msgid ""
"^devices with special syntax ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|G      |voltage controlled resistor       |R/vc              |Gxxxx (p n ps ns) vcr value   |\n"
"|G      |voltage controlled admittance     |Y/vc              |Gxxxx (p n ps ns) vcg value   |\n"
"|G      |voltage controlled capacitor      |C/vc              |Gxxxx (p n ps ns) vccap value |\n"
"|C      |trans-capacitor                   |Qout/vin          |Cxxxx (p n ps ns) tcap value  |\n"
msgstr ""
"^ Устройства с особым синтаксисом ^^^^\n"
"^ Буква ^ Тип                              ^ Значение                       ^ Синтаксис                       ^\n"
"|G      |voltage controlled resistor   FIXME: в словарь  |R/U<sub>у</sub>                 |Gxxxx (p n ps ns) vcr   значение |\n"
"|G      |voltage controlled admittance FIXME: в словарь  |Y/U<sub>у</sub>                 |Gxxxx (p n ps ns) vcg   значение |\n"
"|G      |voltage controlled capacitor  FIXME: в словарь  |C/U<sub>у</sub>                 |Gxxxx (p n ps ns) vccap значение |\n"
"|C      |проходная ёмкость             |Q<sub>вых</sub>/U<sub>вх</sub>  |Cxxxx (p n ps ns) tcap  значение |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:53
#, fuzzy, no-wrap
msgid ""
"^Port names ^^\n"
"|p       |positive node or positive output        |\n"
"|n       |negative node or negative output        |\n"
"|sink    |current sink or current sink output     |\n"
"|source  |current source or current source output |\n"
"|ps      |positive input or control voltage node  |\n"
"|ns      |negative input or control voltage node  |\n"
"|control |current probe controlling element       |\n"
msgstr ""
"^ Имена портов ^^\n"
"|p       | положительный узел или положительный выход          |\n"
"|n       | отрицательный узел или отрицательный выход          |\n"
"|sink    |current sink or current sink output     FIXME: добавить перевод для (current) sink |\n"
"|source  |current source or current source output FIXME: добавить перевод для (current) source |\n"
"|ps      | положительный вход или узел управляющего напряжения |\n"
"|ns      | отрицательный вход или узел управляющего напряжения |\n"
"|control |current probe controlling element  FIXME: добавить перевод для current probe      |\n"
"FIXME: в этой таблице и выше по тексту привести обозначения\n"
"source-src к общему знаменателю --- выбрать один и применить\n"
"везде, также добавить замечание на страницу замечаний\n"

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:54 manual/devices/capacitor.txt:11
#, no-wrap
msgid "Spectre format"
msgstr "Формат Spectre"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:59
#, no-wrap
msgid "  label  (connections)  type  parameter=value\n"
msgstr "  обозначение  (соединения)  тип  параметр=значение\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:66
#, no-wrap
msgid ""
"  Vin     (in 0)   vsource   dc=10\n"
"  Lseries (in out) inductor  l=.01\n"
"  Cshunt  (out 0)  capacitor c=100u\n"
"  Rload   (out 0)  resistor  r=100\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:68
msgid ""
"The device type is determined by the type field.  The first letter of the "
"label doesn't matter."
msgstr ""
"Тип устройства определяется полем «тип».  Первая буква обозначения не несёт "
"особого смысла."

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:68 manual/devices/capacitor.txt:17
#, no-wrap
msgid "Verilog format"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:75
#, no-wrap
msgid ""
"  type #(.parameter(value)) label (connections);\n"
"or\n"
"  type #(value) label (connections);\n"
msgstr ""
"  тип #(.параметр(значение)) обозначение (соединения);\n"
"или\n"
"  тип #(значение) обозначение (соединения);\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:82
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (.p(in), .n(0));\n"
"  inductor  #(.l(.01))  Lseries (.p(in), .n(out));\n"
"  capacitor #(.c(100u)) Cshunt  (.p(out), .n(0));\n"
"  resistor  #(.r(100))  Rload   (.p(out), .n(0));\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:87
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (in, 0);\n"
"  inductor  #(.l(.01))  Lseries (in, out);\n"
"  capacitor #(.c(100u)) Cshunt  (out, 0);\n"
"  resistor  #(.r(100))  Rload   (out, 0);\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:90
#, no-wrap
msgid ""
"  vsource   #(10)   Vin     (in, 0);\n"
"  inductor  #(.01)  Lseries (in, out);\n"
"  capacitor #(100u) Cshunt  (out, 0);\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/complex.txt:1
#, no-wrap
msgid "\"complex\" Complex value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:6
#, no-wrap
msgid "  complex ( realpart imaginarypart options )\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:10
msgid "Complex component value, using a real and imaginary part.  AC only."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:15
msgid ""
"Strictly, this adds no functionality over the polar option on any function, "
"except notational convenience."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:18
msgid ""
"It is only meaningful in AC analysis.  Others take the real part and ignore "
"the imaginary part.  No warning is issued."
msgstr ""

#. type: Title =====
#: manual/devices/basic/complex.txt:18 manual/devices/basic/exp.txt:43
#: manual/devices/basic/fit.txt:67 manual/devices/basic/poly.txt:33
#: manual/devices/basic/pulse.txt:52 manual/devices/basic/sffm.txt:37
#: manual/devices/basic/sin.txt:55 manual/devices/basic/tanh.txt:32
#: manual/devices/lossless_transmission_line.txt:41
#, no-wrap
msgid "Step control"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:21
msgid ""
"This function does have any role in time step control.  The notion of "
"complex values does not work in transient analysis."
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:26
#, no-wrap
msgid ""
"  V12 (2 0) complex(1,2)\n"
"A voltage source with a value of 1 + j2 volts.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/complex.txt:28
#, no-wrap
msgid ""
"  R12 (2 4) complex(50,-10)\n"
"A \"resistor\" with a value of 50 - j10 ohms.\n"
msgstr ""
"  R12 (2 4) complex(50,-10)\n"
"«Резистор» с номиналом 50 - j10 Ом.\n"

#. type: Title ======
#: manual/devices/basic/exp.txt:1
#, fuzzy, no-wrap
#| msgid "For other components, it gives a time dependent value."
msgid "\"exp\" Exponential time dependent value"
msgstr "Для прочих компонентов она задаёт значение, зависимое от времени."

#. type: Plain text
#: manual/devices/basic/exp.txt:7
#, no-wrap
msgid ""
"  exp (args)\n"
"  exp (iv pv td1 tau1 td2 tau2 period)\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:11
msgid "The component value is an exponential function of time."
msgstr "Значением компонента является функция экспоненты времени."

#. type: Plain text
#: manual/devices/basic/exp.txt:14
msgid ""
"For voltage and current sources, this is the same as the Spice \"exp\" "
"function, with some extensions."
msgstr ""
"Для источников тока и напряжения это то же самое, что и функция \"exp\" в "
"SPICE с несколькими расширениями."

#. type: Plain text
#: manual/devices/basic/exp.txt:16 manual/devices/basic/sin.txt:24
msgid "The shape of the waveform is described by the following algorithm:"
msgstr "Форма сигнала описывается следующим алгоритмом:"

#. type: Plain text
#: manual/devices/basic/exp.txt:28
#, no-wrap
msgid ""
"<code>\n"
"ev = _iv;\n"
"for (reltime=time; reltime>=0; reltime-=_period){\n"
"  if (reltime > _td1){\n"
"    ev += (_pv - _iv) * (1. - Exp(-(reltime-_td1)/_tau1));\n"
"  }\n"
"  if (reltime > _td2){\n"
"    ev += (_iv - _pv) * (1. - Exp(-(reltime-_td2)/_tau2));\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:30 manual/devices/basic/pulse.txt:40
#: manual/devices/basic/sffm.txt:22 manual/devices/basic/sin.txt:39
msgid "For other components, it gives a time dependent value."
msgstr "Для прочих компонентов она задаёт значение, зависимое от времени."

#. type: Plain text
#: manual/devices/basic/exp.txt:33 manual/devices/basic/pulse.txt:43
#: manual/devices/basic/sffm.txt:24 manual/devices/basic/sin.txt:42
msgid ""
"As an extension beyond Spice, you may specify the parameters as name=value "
"pairs in any order."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:42
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)             |\n"
"|pv      |Pulsed value.  (required)              |\n"
"|td1     |Rise time delay.  (Default = 0.)       |\n"
"|tau1    |Rise time constant.  (Default = 0.)    |\n"
"|td2     |Fall time delay.  (Default = 0.)       |\n"
"|tau2    |Fall time constant.  (Default = 0.)    |\n"
"|period  |Repeat period.  (Default = infinity.)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:46
msgid ""
"This function influences time step control through both smoothness control "
"and analog events."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:48
msgid ""
"The time step is limited by the active time constant, either tau1 or tau2, "
"depending on whether it is rising or falling."
msgstr ""

#. type: Plain text
#: manual/devices/basic/exp.txt:49
msgid ""
"The corners in as exp waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""

#. type: Title ======
#: manual/devices/basic/fit.txt:1
#, no-wrap
msgid "\"fit\" Fit a curve   \"pwl\" Piece-wise linear"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:6
#, no-wrap
msgid ""
"  fit x1,y1 x2,y2 ... args\n"
"  pwl x1,y1 x2,y2 ... args\n"
msgstr ""
"  fit x1,y1 x2,y2 ... args\n"
"  pwl x1,y1 x2,y2 ... args\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:9
msgid "FIT fits a set of data using piecewise polynomials, or splines."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:11
msgid ""
"PWL is a a special case of FIT, it defines a piecewise linear transfer "
"function or time dependent value."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:14
msgid ""
"The \"fit\" function fits a set of piecewise polynomials to a set of data."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:16
msgid ""
"The \"pwl\" function is a special case of \"fit\", forcing \"order\" to 1.  "
"It is designed for Spice compatibility."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:18 manual/devices/basic/posy.txt:23
msgid "For fixed sources, it defines voltage or current as a function of time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:20
msgid ""
"The meaning of the //x// and //y// values depends on the component type:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:36
#, fuzzy, no-wrap
msgid ""
"^component          ^X        ^Y            ^\n"
"|C (capacitor)      |voltage  |charge       |\n"
"|E (VCVS)           |voltage  |voltage      |\n"
"|F (CCCS)           |current  |current      |\n"
"|G (VCCS)           |voltage  |current      |\n"
"|H (CCVS)           |current  |voltage      |\n"
"|I (current source) |time     |current      |\n"
"|L (inductor)       |current  |flux         |\n"
"|R (resistor)       |current  |voltage      |\n"
"|V (voltage source) |time     |voltage      |\n"
"|Y (admittance)     |voltage  |current      |\n"
"|VCCAP              |voltage  |capacitance  |\n"
"|VCG                |voltage  |conductance  |\n"
"|VCR                |voltage  |resistance   |\n"
"|trans-capacitor    |voltage  |charge       |\n"
msgstr ""
"^компонент                ^X            ^Y             ^\n"
"|C (конденсатор)          |напряжение   |заряд         |\n"
"|E (ИНУН)                 |напряжение   |напряжение    |\n"
"|F (ИТУТ)                 |ток          |ток           |\n"
"|G (ИТУН)                 |напряжение   |ток           |\n"
"|H (ИНУТ)                 |ток          |напряжение    |\n"
"|I (источник тока)        |время        |ток           |\n"
"|L (катушка индуктивности)|ток          |поток         |\n"
"|R (резистор)             |ток          |напряжение    |\n"
"|V (источник напряжения)  |время        |напряжение    |\n"
"|Y (проводимость)         |напряжение   |ток           |\n"
"|VCCAP (??)               |напряжение   |ёмкость       |\n"
"|VCG (??)                 |напряжение   |проводимость  |\n"
"|VCR (??)                 |напряжение   |сопротивление |\n"
"|С (проходная ёмкость)    |напряжение   |заряд         |\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:39
msgid "The values of //x// must be in increasing order."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:43
msgid ""
"For \"fit\" if //order// is 1, it is the same as \"pwl\".  If //order// is "
"3, it will use cubic splines.  The result and its first two derivatives are "
"continuous."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:49
msgid ""
"Outside the specified range, it uses linear extrapolation.  The behavior "
"depends on the parameters //below// and //above//.  The value of //below// "
"or //above// is the derivative to use, which is a resistance for resistors, "
"voltage gain for a VCVS, and so on.  If it is not specified, the value is "
"automatically determined."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:53
msgid "These parameters apply to the \"fit\" function only, not \"pwl\"."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:57
msgid ""
"|order |The order of the polynomial to fit, within the supplied data.  "
"(Default = 3) Legal values are 0, 1, 2, and 3, only.  For \"pwl\" a value of "
"1 is assumed.  | |below |The value of the derivative to use below or before "
"the specified range.  | |above |The value of the derivative to use above or "
"after the specified range.  |"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:59
msgid ""
"For \"fit\" only, the properties are determined by the value of //order//.  "
"For \"pwl\", order is assumed to be 1."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:61
msgid ""
"If \"above\" or \"below\" are not specified, out of range behavior is "
"determined as follows:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:66
msgid ""
"|Order = 3\\\\ cubic_splines |The default is to use \"natural\" splines, "
"which sets the second derivative to zero at the boundary.  If a value of //"
"below// or //above// is specified, \"clamped\" splines will be used.  In any "
"case, there will be a smooth transition at the boundaries.  When using "
"\"clamped\" splines, the second derivative may have a discontinuity at the "
"boundaries.  | |Order = 2\\\\ quadratic_splines |By default, the derivative "
"at the upper end is determined by the slope of the last segment.  This is "
"also the derivative above the range.  Below the range, the derivative "
"determined at the lower bound is used.  It is recommended that only one of //"
"below// and //above// be specified.  If both are specified, the splines are "
"determined using //above//, and there will be a discontinuity in the "
"derivative at the lower bound.  | |Order = 1\\\\ piecewise_linear |For first "
"order (linear) interpolation, the default slope outside the range is the "
"extension of the slope in the end segments.  The parameters //below// and //"
"above// have no effect inside the range.  | |Order = 0\\\\ "
"piecewise_constant |The resulting value is constant over the interval, and "
"hasdiscontinuities at the specified points.  The parameters //below// and //"
"above// are ignored.  The slope is always 0.  |"
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:70
msgid ""
"The \"pwl\" function participates in time step control only if the device is "
"a fixed source.  In this case, the corners in are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:72
msgid ""
"For devices that are not fixed sources, the fit or pwl describes a nonlinear "
"transfer function.  Finding the corresponding times requires analysis of "
"\"cross\" events, which is more difficult and not done yet.  This is "
"considered to be a deficiency, and may be addressed in the future."
msgstr ""

#. type: Plain text
#: manual/devices/basic/fit.txt:83
#, no-wrap
msgid ""
"  C1 (2 0) fit (-5,-5u 0,0 1,1u 4,2u 5,2u) order=1\n"
"This \"capacitor\" stores 5 microcoulombs at -5 volts (negative,\n"
"corresponding to the negative voltage, as expected).  The charge\n"
"varies linearly to 0 at 0 volts, acting like a 1 microfarad capacitor.\n"
"(C = dq/dv).  This continues to 1 volt.  The 0,0 point could have been\n"
"left out.  The charge increases only to 2 microcoulombs at 4 volts,\n"
"for an incremental capacitance of 1u/3 or .3333 microfarads.  The same\n"
"charge at 5 volts indicates that it saturates at 2 microcoulombs.  For\n"
"negative voltages, the slope continues.\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/generator.txt:1
#, no-wrap
msgid "\"generator\" Signal Generator time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:6
#, no-wrap
msgid "  generator  scale\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:11
msgid ""
"The component \"value\" is dependent on a \"signal generator\", manipulated "
"by the \"generator\" command."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:18
msgid ""
"For transient analysis, the \"value\" is determined by a signal generator, "
"which is considered to be external to the circuit and part of the test "
"bench.  See the \"generator\" command for more information."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:20
msgid "For AC analysis, the value here is the amplitude."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:25
msgid ""
"Strictly, all of the functionality and more is available through the Spice-"
"like behavioral modeling functions, but this one provides a user interface "
"closer to the function generator that an analog designer would use on a real "
"bench.  It is mainly used for interactive operation."
msgstr ""

#. type: Plain text
#: manual/devices/basic/generator.txt:27
msgid ""
"It also provides backward compatibility with predecessors to Gnucap, which "
"used a different netlist format."
msgstr ""

#. type: Title ======
#: manual/devices/basic/inline_behavioral_modeling.txt:1
#, fuzzy, no-wrap
#| msgid "  eval expression\n"
msgid "Device behavioral expressions"
msgstr "  eval выражение\n"

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:2
#: manual/tech/plugins/coding.txt:9
#, no-wrap
msgid "Basics"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:5
msgid ""
"All simple components can have a behavioral description, with syntax "
"designed as an extension of the Spice time dependent sources.  They are not "
"necessarily physically realizable, but provide useful modeling capability.  "
"Some only work on particular types of analysis, or over a small range of "
"values.  Some can be used together, some cannot."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:7
msgid ""
"As of July 2009, these functions only work with Spice or ACS syntax.  They "
"do not work with Verilog or Spectre syntax."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:9
msgid ""
"All simple components are considered to have simple transformations.  A "
"function returns one parameter as a function of one other, as an extension "
"of their linear behavior.  For behavioral modeling or nonlinear values, "
"replace the constant times input by an arbitrary function."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:19
#, no-wrap
msgid ""
"^Type        ^Linear                              ^Nonlinear                            ^\n"
"|Capacitor   |q = C v                             |q = f(v)                             |\n"
"|Inductor    |Φ = L i                             |Φ = f(i)                             |\n"
"|Resistor    |v = I r                             |v = f(i)                             |\n"
"|Admittance  |i = Y v                             |i = f(v)                             |\n"
"|VCVS        |v<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = f(v<sub>in</sub>)  |\n"
"|VCCS        |i<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = f(v<sub>in</sub>)  |\n"
"|CCVS        |v<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = f(i<sub>in</sub>)  |\n"
"|CCCS        |i<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = f(i<sub>in</sub>)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:21
msgid ""
"Gnucap also has some other simple components, which are compatible with some "
"versions of Spice that also have them:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:26
#, fuzzy, no-wrap
msgid ""
"|voltage controlled resistor    |R = k v<sub>c</sub>                 |R = f(v<sub>c</sub>)   |\n"
"|voltage controlled capacitor   |C = k v<sub>c</sub>                 |C = f(v<sub>c</sub>)   |\n"
"|voltage controlled admittance  |Y = k v<sub>c</sub>                 |Y = f(v<sub>c</sub>)   |\n"
"|trans-capacitor                |q<sub>out</sub> = k v<sub>in</sub>  |q = f(v<sub>in</sub>)  |\n"
msgstr ""
"|voltage controlled resistor    |R = k v<sub>c</sub>                 |R = f(v<sub>c</sub>)   |\n"
"|voltage controlled capacitor   |C = k v<sub>c</sub>                 |C = f(v<sub>c</sub>)   |\n"
"|voltage controlled admittance  |Y = k v<sub>c</sub>                 |Y = f(v<sub>c</sub>)   |\n"
"| проходная ёмкость             | Q<sub>вых</sub> = k U<sub>вх</sub> |Q = f(U<sub>вх</sub>)  |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:28
msgid "Sources are defined as functions of time:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:31
msgid "|Voltage source |v = f(t)  | |Current source |i = f(t)  |"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:32
#, no-wrap
msgid "Verilog and Spectre syntax workaround"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:35
msgid ""
"These functions do not fit with the style of Verilog or Spectre, so they "
"don't work with that syntax.  As a workaround, you can build a subcircuit "
"with Spice syntax, then call it as a component in any syntax."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:42
#, no-wrap
msgid ""
"<code>\n"
"spice\n"
".subckt vsin (p n)\n"
"Vsrc (p n) sin {offset} {amplitude} {frequency} {delay} {damping}\n"
".ends\n"
"verilog\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:45
msgid "vsin #(.frequency(1K)) vinput (in, 0); </code>"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:47
#, no-wrap
msgid "Conditionals"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:50
msgid ""
"Gnucap behavioral modeling conditionals are an extension of the \"AC\" and "
"\"DC\" Spice source parameters."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:55
#, no-wrap
msgid ""
"The extensions ...\n"
"  * There are more choices, including an \"else\".\n"
"  * They apply to all elements (primitive components).\n"
"  * Each section can contain functions and options.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:57
msgid "The following are available:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:65
#, no-wrap
msgid ""
"|AC    |AC analysis only.         |\n"
"|DC    |DC (steady state) value.  |\n"
"|OP    |OP analysis.              |\n"
"|TRAN  |Transient analysis.       |\n"
"|FOUR  |Fourier analysis only.    |\n"
"|ELSE  |Anything not listed.      |\n"
"|ALL   |Anything not listed.      |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:67
msgid ""
"A value or function with no conditional keyword is equivalent to \"ALL\".  "
"For SPICE compatibility, use only \"DC\", \"AC\", or nothing."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:69
msgid ""
"They are interpreted like a \"switch\" statement.  In case of a conflict, "
"the last one applies.  A set of precedence rules applies when some keys are "
"missing.  It is SPICE compatible to the extent the features overlap."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:71
msgid "The following table describes the precedence rules:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:78
#, no-wrap
msgid ""
"|OP analysis                  |OP, DC, ALL, TRAN, 0        |\n"
"|DC analysis                  |DC, ALL, OP, TRAN, 0        |\n"
"|Transient analysis           |TRAN, ALL, DC, OP, 0        |\n"
"|Fourier analysis             |FOUR, TRAN, ALL, DC, OP, 0  |\n"
"|AC analysis, fixed sources   |AC, 0                       |\n"
"|AC analysis, other elements  |AC, ALL, 0                  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:83
#, no-wrap
msgid ""
"  V12 (1 0) AC 1 DC 3\n"
"This voltage source has a value of 1 for AC analysis, 3 for DC.  OP, Transient, and Fourier inherit the DC value.\n"
msgstr ""
"  V12 (1 0) AC 1 DC 3\n"
"Этот источник напряжения имеет значение 1 для анализа AC, 3 для DC.  OP, Transient и Fourier наследуют значение анализа DC.\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:86
#, no-wrap
msgid ""
"  R44 (2 3) OP 1 ELSE 1g\n"
"This resistor has a value of 1 ohm for the \"OP\" analysis, 1 gig-ohm for anything else.  This might be useful as the feedback resistor on an op-amp.  Set it to 1 ohm to set the operating point, then 1 gig to measure its open loop characteristics, hiding the fact that the op-amp would probably saturate if it was really left open loop.\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:87
#: manual/howto/expressions.txt:56
#, no-wrap
msgid "Functions"
msgstr "Функции"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:90
msgid ""
"Gnucap behavioral modeling functions are an extension of the Spice source "
"time dependent values."
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:90
#, no-wrap
msgid "The extensions"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They apply to all elements (primitive components).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "All accept either Spice compatible order dependent parameters, or easier keyword=value notation.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "The syntax is identical for all supported components.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They work a little different, depending on the type of device:\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:101
msgid ""
"|Fixed sources |Time dependent functions are voltage or current as a "
"function of time. They are mostly Spice compatible, with extensions.\\\\ "
"Nonlinear transfer functions use time as the independent variable.  Some may "
"not make sense, but they are there anyway.  | |Capacitors and inductors |"
"Time dependent functions are capacitance or inductance as a function of "
"time.  They are voltage/current conserving, not charge/flux conserving.\\\\ "
"Nonlinear transfer functions are charge or flux as a function of input "
"(voltage or current).  Charge and flux are conserved, and can be probed.  | |"
"Resistors and conductances |Time dependent functions are resistance or "
"conductance as a function of time.\\\\ Nonlinear transfer functions are "
"current or voltage as a function of input (voltage or current).  Resistors "
"define voltage as a function of current.  Conductances define current as a "
"function of voltage.  | |Controlled sources |Time dependent functions are "
"gain (v/v, transconductance, etc) function of time.\\\\ Nonlinear transfer "
"functions are output (voltage or current) as a function of input (voltage or "
"current).  |"
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:101
#, no-wrap
msgid "Available functions"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:complex]]  Complex (re, im) value.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:exp]] Spice Exp source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit]] Fit a curve with splines.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:generator]] Value from Generator command.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:poly]] Polynomial (Spice style).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:posy]] Posynomial (Like poly, non-integer powers).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:pulse]] Spice Pulse source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit|pwl]] Piece-wise linear.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sffm]] Spice Frequency Modulation (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sin]] Spice Sin source.  (time dependent value).\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:tanh]] Hyperbolic tangent transfer function.\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:117
msgid ""
"In addition, you may name a \"function\" defined by a \".model\" statement.  "
"The following \".model\" types may be used here:"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:table]] Fit a curve with splines.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:cap]] Spice semiconductor \"capacitor\" model.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:res]] Spice semiconductor \"resistor\" model.\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:122
#, no-wrap
msgid "Parameters that apply to all functions"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:125
msgid ""
"These parameters are available with all functions.  Some may not make sense "
"in some cases, but they are available anyway."
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:138
#, no-wrap
msgid ""
"|Bandwidth  |AC analysis bandwidth.  (Default = infinity.)  The transfer function is frequency dependent, with a 3 DB point at this frequency.  There is frequency dependent phase shift ranging from 0 degrees at low frequencies to 90 degrees at high frequencies.  The phase shift is 45 degrees at the specified frequency.  AC ANALYSIS ONLY.  |\n"
"|Delay  |AC analysis delay.  (Default = 0.) The signal is delayed by x seconds, effectively by a frequency dependent phase shift.  AC ANALYSIS ONLY.  |\n"
"|Phase  |AC analysis phase.  (Default = 0.)  A fixed phase shift is applied.  This is primarily intended for sources, but applies to all elements.  AC ANALYSIS ONLY.  |\n"
"|IOffset  |Input offset.  (Default = 0.)  A DC offset is added to the \"input\" of the element, before evaluating the function.  |\n"
"|OOffset  |Output offset.  (Default = 0.)  A DC offset is added to the \"output\" of the element, after evaluating the function.  |\n"
"|Scale  |Transfer function scale factor.  (Default = 1.)  The transfer function is multiplied by a constant.  |\n"
"|TNOM  |Nominal temperature.  (Default = .option TNOM) The nominal values apply at this temperature.  |\n"
"|TEMP  |Actual temperature.  (Default = current global simulation temperature.  This is the actual device temperature.  |\n"
"|DTEMP  |Temperature rise over ambient.  (Default = 0.)  The actual device temperature is the global simulation temperature plus \"dtemp\".  |\n"
"|TC1  |First order temperature coefficient.  (Default = 0.)  |\n"
"|TC2  |Second order temperature coefficient.  (Default = 0.)  |\n"
"|IC   |Initial condition.  An initial value, to force at time=0.  The actual parameter applied depends on the component.  (Capacitor voltage, inductor current.  All others ignore it.)  You must use the \"UIC\" option for it to be used.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:141
msgid "Temperature adjustments and scaling use the following formula:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:142
#, no-wrap
msgid "  value *= _scale * (1 + _tc1*tempdiff + _tc2*tempdiff*tempdiff)\n"
msgstr ""

#. type: Title ======
#: manual/devices/basic/poly.txt:1
#, no-wrap
msgid "\"poly\" Polynomial nonlinear transfer function"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:7
#, no-wrap
msgid ""
"  poly  c0 c1 c2 c3 ...\n"
"  poly  c0 c1 c2 c3 ... args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:11
msgid "Defines a transfer function by a one dimensional polynomial."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:19
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current.  If you have "
"the coefficients defining capacitance or inductance, prepending a \"0\" to "
"the list will turn it into the correct form for Gnucap."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:22
msgid ""
"For fixed sources, it defines voltage or current as a polynomial function of "
"time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:24 manual/devices/basic/posy.txt:31
msgid "The transfer function is defined by:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:26
#, no-wrap
msgid "  out = c0 + (c1*in) + (c2*in^2) + ....\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:32
msgid ""
"|min |Minimum output value (clipping).  (Default = -infinity)  | |max |"
"Maximum output value (clipping).  (Default = infinity)  | |abs |Absolute "
"value, truth value.  (Default = false).  If set to true, the result will be "
"always positive.  |"
msgstr ""

#. type: Plain text
#: manual/devices/basic/poly.txt:35
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise."
msgstr ""

#. type: Title ======
#: manual/devices/basic/posy.txt:1
#, no-wrap
msgid "\"posy\" Polynomial with non-integer powers"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:7
#, no-wrap
msgid ""
"  posy  c1,p1 c2,p2 ...\n"
"  posy  c1,p1 c2,p2 ... args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:12
msgid ""
"Defines a transfer function by a one dimensional ``posynomial'', like a "
"polynomial, except that the powers are arbitrary, and usually non-integer."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:16
msgid "There is no corresponding capability in any SPICE that I know of."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:20 manual/devices/basic/tanh.txt:20
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:29
msgid ""
"Normal use of this function required positive input (voltage or current).  "
"The result is zero if the input is negative.  Raising a negative number to a "
"non-integer power would produce a complex result, which implies a non-causal "
"result, which cannot be represented in a traditional transient analysis."
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:39
#, no-wrap
msgid ""
"<code>\n"
"if (in >= 0){\n"
"  out = (c1*in^p1) + (c2*in^p2) + ....\n"
"}else{\n"
"  out = 0.\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:47
#, no-wrap
msgid ""
"|min   |Minimum output value (clipping).  (Default  = -infinity)  |\n"
"|max   |Maximum output value (clipping).  (Default  = infinity)  |\n"
"|abs   |Absolute value, truth value.  (Default = false).  If set to true, the result will be always positive.  |\n"
"|odd   |Make odd function, truth value.  (Default = false).  If set to true, negative values of x will be evaluated as out = -f(-x), giving odd symmetry.  |\n"
"|even  |Make even function, truth value.  (Default = false).  If set to true, negative values of x will be evaluated as out = f(-x), giving even symmetry.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/posy.txt:51
#, no-wrap
msgid ""
"  E1 (2 0 1 0) posy(1 .5)\n"
"The output of E1 is the square root of its input.\n"
msgstr ""

#. type: Title ====
#: manual/devices/basic/probes.txt:1
#: manual/devices/lossless_transmission_line.txt:37 manual/howto/probes.txt:1
#: manual/tech/plugins/devices/probes.txt:3
#, no-wrap
msgid "Probes"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:2
#, no-wrap
msgid "All basic elements"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:5 manual/howto/probes.txt:50
msgid ""
"Most two node elements (capacitors, inductors, resistors, sources) and four "
"terminal elements (controlled sources) have at least the following "
"parameters available. Others are available for some elements."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:7 manual/howto/probes.txt:52
msgid ""
"Some of these probes do not work for all devices, or all analysis.  It will "
"print \"??\" as the value when it doesn't work."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:34
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second port.  |\n"
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for four terminal devices. The first node in the net list is assumed positive.  |\n"
"|vin       |Input voltage.  The voltage across the “input” terminals. For two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power indicates that the part is supplying power. Its value is the same as (PD - PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is always positive and does not consider its own dissipation.  |\n"
"|input     |The “input” of the device. It is the current through a resistor or inductor, the voltage across a capacitor or admittance, etc. It is the value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is the voltage across a resistor, the charge stored in a capacitor, the flux in an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is also the effective value of the part, in its units. If the part is ordinary, it will just show its value, but if it is time variant or nonlinear, it shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|z         |Circuit impedance seen by this device, with this device not counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this device.  Prints a meaningless number in transient analysis.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|errortime |Suggestion of next time point based on truncation or interpolation error.  |\n"
"|eventtime |Suggestion of next time point based on movable events.  |\n"
"|timefuture |Suggestion of next time point, the sooner of errortime and eventtime.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:37 manual/howto/probes.txt:89
msgid ""
"AC power probes:\\\\ In addition to those listed here, you can add a suffix "
"(M, P, R, I and DB) for magnitude, phase, real part, imaginary part, and "
"decibels, to any valid probe. Negative phase is capacitive. Positive phase "
"is inductive."
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:42 manual/howto/probes.txt:93
#, no-wrap
msgid ""
"|p   |Real power.  Watts.  |\n"
"|pi  |Reactive (imaginary) power, VAR.  |\n"
"|pm  |Volt amps.  Complex power.  |\n"
"|pp  |Power phase.  Angle between voltage and current.  |\n"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:42
#, no-wrap
msgid "Capacitors"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:51
msgid ""
"|method |A number corresponding to what differentiation method is now being "
"used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = "
"Gear, 4 = trapeuler | |q\\\\ qcap\\\\ charge |The charge stored in this "
"capacitor, in Coulombs. | |c\\\\ capacitance |The effective capacitance of "
"this device. For a fixed capacitor, it be its value. For a nonlinear "
"capacitor, it is the effective capacitance at this time, or ∂q/∂v. | |dcdt |"
"The time derivative of capacitance. For a linear capacitor it will be zero. "
"| |dc |The change in capacitance compared to the previous sample. Its "
"primary use is in debugging models and numerical problems. For a linear "
"capacitor it will be zero. | |dqdt |The time derivative of charge. Hopefully "
"this is the same as current, but it is calculated a different way and can be "
"used as an accuracy check. | |dq |The change in charge compared to the "
"previous sample. Its primary use is in debugging models and numerical "
"problems. |"
msgstr ""

#. type: Title =====
#: manual/devices/basic/probes.txt:52
#, no-wrap
msgid "Inductors"
msgstr ""

#. type: Plain text
#: manual/devices/basic/probes.txt:60
msgid ""
"|method |A number corresponding to what differentiation method is now being "
"used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = "
"Gear, 4 = trapeuler | |flux |The flux linkages stored in this inductor, in "
"Weber-turns. | |L\\\\ inductance |The effective inductance of this device. "
"For a fixed inductor, it be its value. For a nonlinear inductor, it is the "
"effective inductance at this time, or ∂ϕ/∂v. | |dldt |The time derivative of "
"inductance. For a linear inductor it will be zero. | |dl |The change in "
"inductance compared to the previous sample. Its primary use is in debugging "
"models and numerical problems. For a linear inductor it will be zero. | |"
"dfdt |The time derivative of flux. Hopefully this is the same as voltage, "
"but it is calculated a different way and can be used as an accuracy check. | "
"|dflux |The change in flux linkages compared to the previous sample. Its "
"primary use is in debugging models and numerical problems. |"
msgstr ""

#. type: Title ======
#: manual/devices/basic/pulse.txt:1
#, no-wrap
msgid "\"pulse\" Pulsed time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:7
#, no-wrap
msgid ""
"  pulse args\n"
"  pulse iv pv delay rise fall width period\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:11
msgid "The component value is a pulsed function of time."
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice \"pulse\" "
"function, with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:17
msgid "The shape of a single pulse is described by the following algorithm:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:38
#, no-wrap
msgid ""
"<code>\n"
"if (time > _delay+_rise+_width+_fall){\n"
"  // past pulse\n"
"  ev = _iv;\n"
"}else if (time > _delay+_rise+_width){\n"
"  // falling\n"
"  interp=(time-(_delay+_rise+_width))/_fall;\n"
"  ev = _pv + interp * (_iv - _pv);\n"
"}else if (time > _delay+_rise){\n"
"  // pulsed value\n"
"  ev = _pv;\n"
"}else if (time > _delay){\n"
"  // rising\n"
"  interp = (time - _delay) / _rise;\n"
"  ev = _iv + interp * (_pv - _iv);\n"
"}else{\n"
"  // initial value\n"
"  ev = _iv;\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:52
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)  |\n"
"|pv      |Pulsed value.  (required)  |\n"
"|delay   |Rise time delay, seconds.  (Default = 0.)  |\n"
"|rise    |Rise time, seconds.  (Default = 0.)  |\n"
"|fall    |Fall time, seconds.  (Default = 0.)  |\n"
"|width   |Pulse width, seconds.  (Default = 0.)  |\n"
"|period  |Repeat period, seconds.  (Default = infinity.)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/pulse.txt:54
msgid ""
"The corners in a pulse waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""

#. type: Title ======
#: manual/devices/basic/sffm.txt:1
#, no-wrap
msgid "\"sffm\" Frequency Modulation time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:7
#, no-wrap
msgid ""
"  sffm args\n"
"  sffm offset amplitude carrier modindex signal\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:11
msgid ""
"The component value is a sinusoid, frequency modulated by another sinusoid."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SFFM "
"function, with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:17
msgid "The shape of the waveform is described by the following equations:"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:20
#, no-wrap
msgid ""
"  mod = (_modindex * sin(2*PI*_signal*time));\n"
"  ev = _offset + _amplitude * sin(2*PI*_carrier*time + mod);\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:26 manual/devices/basic/sin.txt:44
msgid ""
"The non-Spice parameters (samples, zero, peak) assist in time step control.  "
"The defaults are usually appropriate."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:36
#, no-wrap
msgid ""
"|offset     |Output offset.  (Default = 0.)  |\n"
"|amplitude  |Amplitude.  (Default = 1.)  |\n"
"|carrier    |Carrier frequency, Hz.  (required)  |\n"
"|modindex   |Modulation index.  (required)  |\n"
"|signal     |Signal frequency.  (required)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  (Default = true)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = true)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:40
msgid ""
"The ability to accurately determine instantaneous frequency is important, so "
"SFFM plays a significant role in time step control.  When using SFFM, "
"frequency is always changing, which can make step control difficult."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:42
msgid ""
"By default, both zero crossings and peaks are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times.  This means, by default, there will be at "
"least 4 time steps per cycle, synchronized with zero crossings and peaks."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:44
msgid ""
"There is also, a smoothness requirement, controlled by the parameter "
"\"samples\".  By default, there will be at least 4 samples per cycle.  This "
"is independent of the placement of samples at zeros and peaks, but usually "
"does not add samples."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:46
msgid ""
"If exact timing is not critical, you can often improve run speed by setting "
"\"zero\" or \"peak\" or both to false.  Doing this allows the time stepping "
"to be more consistent, which is usually faster even if the number of steps "
"is not reduced."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sffm.txt:47 manual/devices/basic/sin.txt:66
msgid ""
"If you need improved waveform smoothness, you can do this by increasing "
"\"samples\"."
msgstr ""

#. type: Title ======
#: manual/devices/basic/sin.txt:1
#, no-wrap
msgid "\"sin\" Sinusoidal time dependent value"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:7
#, no-wrap
msgid ""
"  sin args\n"
"  sin offset amplitude frequency delay damping\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:11
msgid ""
"The component value is a sinusoidal function of time, with optional "
"exponential decay."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SIN function, "
"with some extensions."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:17
msgid "It generates either a steady sinusoid, or a damped sinusoid."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:22
msgid ""
"If //delay// and //damping// are both zero, you get a steady sine wave at "
"the specified //frequency//.  Otherwise, you get a damped pulsed sine wave, "
"starting after //delay// and damping out with a time constant of 1/damping."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:37
#, no-wrap
msgid ""
"<code>\n"
"reltime = time - _delay\n"
"if (reltime > 0.) {\n"
"  ev = _amplitude * sin(2*PI*_freq*reltime);\n"
"  if (_damping != 0.){\n"
"    ev *= exp(-reltime*_damping);\n"
"  }\n"
"  ev += _offset;\n"
"}else{\n"
"  ev = _offset;\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:54
#, no-wrap
msgid ""
"|offset     |DC offset.  (Default = 0.)  |\n"
"|amplitude  |Peak amplitude.  (Default = 1.)  |\n"
"|frequency  |Frequency, Hz.  (required)  |\n"
"|delay      |Turn on delay, seconds.  (Default = 0.)  |\n"
"|damping    |Damping factor, 1/seconds.  (Default = 0.)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  (Default = false)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = false)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:58
msgid ""
"For SIN, frequency is constant, so the default settings give preference to "
"waveform smoothness over timing."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:60
msgid ""
"There is a smoothness requirement, controlled by the parameter \"samples\".  "
"By default, there will be at least 4 samples per cycle.  This is independent "
"of the placement of samples at zeros and peaks, but usually does not add "
"samples."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:62
msgid ""
"If you set the parameters \"zero\" and \"peak\" to true, both zero crossings "
"and peaks are considered to be analog events.  The transient analysis will "
"attempt to control timing accuracy of these analog events.  If it is "
"reasonable, a time step should be scheduled at these times exactly.  In any "
"case, there should be a time step within option::dtmin of these times. These "
"steps are forced regardless of steps required for smoothness."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:64
msgid ""
"\"Zero\" and \"peak\" are false by default, which allows time stepping to be "
"more consistent, improving run speed."
msgstr ""

#. type: Plain text
#: manual/devices/basic/sin.txt:67
msgid "If you need timing accuracy, set \"zero\" and/or \"peak\" to true."
msgstr ""

#. type: Title ======
#: manual/devices/basic/tanh.txt:1
#, no-wrap
msgid "\"tanh\" Hyperbolic tangent transfer function"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:7
#, no-wrap
msgid ""
"  tanh gain limit\n"
"  tanh args\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:11
msgid "Defines a hyperbolic tangent, or soft limiting, transfer function."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:16
msgid ""
"There is no corresponding capability in any SPICE that I know of, but you "
"can get close with POLY."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:23
msgid ""
"For fixed sources, it defines voltage or current as a function of time, "
"which is probably not useful."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:27
msgid ""
"This function describes a hyperbolic tangent transfer function similar to "
"what you get with a single stage push-pull amplifier, or a simple CMOS "
"inverter acting as an amplifier."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:31
#, no-wrap
msgid ""
"|gain   |The small signal gain at 0 bias.  (Required)  |\n"
"|limit  |Maximum output value (soft clipping).  (Required)  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:35
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise.  This is considered to be a deficiency, and may "
"be addressed in the future."
msgstr ""

#. type: Plain text
#: manual/devices/basic/tanh.txt:42
#, no-wrap
msgid ""
"  E1 (2 0 1 0) tanh gain=-10 limit=2 ioffset=2.5 ooffset=2.5\n"
"This gain block has a small signal gain of -10.  The input is\n"
"centered around 2.5 volts.  The output is also centered at 2.5 volts.\n"
"It \"clips\" softly at 2 volts above and below the output center, or\n"
"at .5 volts (2.5 - 2) and 4.5 volts (2.5 + 2).\n"
msgstr ""

#. type: Title ======
#: manual/devices/capacitor.txt:1
#, no-wrap
msgid "Capacitor, advanced"
msgstr ""

#. type: Title =====
#: manual/devices/capacitor.txt:3
#, no-wrap
msgid "Syntax: instance"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:10
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n– value\n"
"  Cxxxxxxx n+ n– expression\n"
"  Cxxxxxxx n+ n– value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:16
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n– capacitor C=value\n"
"  Cxxxxxxx n+ n– capacitor expression\n"
"  Cxxxxxxx n+ n– capacitor C=value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:23
#, no-wrap
msgid ""
"  capacitor #(.c(value))\n"
"  Cxxxxxxx n+ n– value\n"
"  Cxxxxxxx n+ n– expression\n"
"  Cxxxxxxx n+ n– value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:31
#, no-wrap
msgid ""
"  .capacitor label n+ n– expression\n"
"Model (optional)\n"
".model mname C {args}\n"
" .model mname TABLE {args}\n"
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:35
msgid "Capacitor, or general charge storage element."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:38
msgid ""
"N+ and n– are the positive and negative element nodes, respectively. Value "
"is the capacitance in Farads."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:40
msgid ""
"The (optional) initial condition is the initial (time = 0) value of the "
"capacitor voltage (in Volts). Note that the initial conditions (if any) "
"apply only if the UIC option is specified on the transient command."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:43
msgid ""
"You may specify the value in any of these forms: A simple value. This is the "
"capacitance in Farads."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:45
msgid ""
"An expression, as described in the behavioral modeling chapter. The "
"expression can specify the charge as a function of voltage, or the "
"capacitance as a function of time."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:47
msgid ""
"A model, as described in the behavioral modeling chapter. The table model "
"describes a table of charge vs. voltage."
msgstr ""

#. type: Plain text
#: manual/devices/capacitor.txt:48
msgid ""
"A model, which calculates the capacitance as a function of length and width, "
"referencing a .model statement of type C. This is compatible with the "
"Spice-3 “semiconductor capacitor”."
msgstr ""

#. type: Title ======
#: manual/devices/lossless_transmission_line.txt:1
#, no-wrap
msgid "Transmission Line"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:6
#, no-wrap
msgid "  Txxxxxxx (n1+ n1- n2+ n2-) args\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:10
msgid "Lossless transmission line."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:14
msgid ""
"n1+ and n1- are the nodes at one end.  n2+ and n2- are the nodes at the "
"other end."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:21
msgid ""
"The parameters TD, Freq, and NL determine the length of the line.  Either "
"{\\tt TD} or {\\tt Freq} and {\\tt NL} must be specified.  If only {\\tt "
"Freq} is specified, {\\tt NL} is assumed to be .25.  The other will be "
"calculated based on the one you specify.  If you specify too many "
"parameters, {\\tt Freq} and {\\tt NL} dominate, and a warning is issued."
msgstr ""

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:21
#, no-wrap
msgid "Element Parameters"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:26
msgid ""
"Many parameters are offered.  You should not specify them all.  ^Parameters "
"that always work.  ^^ |len |Length multiplier.  (Default = 1) The effective "
"length, regardless of its method of calculation is multiplied by this "
"number.  |"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:32
#, no-wrap
msgid ""
"^Direct specification of electrical characteristics.  ^^\n"
"|z0    |Characteristic impedance.  If not specified, it is calculated by sqrt(L/C).  If neither //z0// nor //L// and //C// are specified, the default value is 50 Ohms.  |\n"
"|td    |Time delay.  If not specified, it will be calculated, either by nl/freq or by sqrt(L*C).  |\n"
"|freq  |Frequency for //nl//.  |\n"
"|nl    |Number of wavelengths at //freq//.  |\n"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:36
msgid ""
"^Physical parameters ^^ |L |Inductance per unit length.  This value is used "
"only if //z0// and //td// are both not specified.  | |C |Capacitance per "
"unit length.  This value is used only if //z0// and //td// are both not "
"specified.  |"
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:40
msgid "The standard probes for all basic elements are all available."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:44
msgid ""
"Transient time steps are limited to be no larger than the delay of the "
"transmission line.  Aside from this, there is no attempt to synchronize, "
"because synchronization would result in a significant run speed penalty."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:46
msgid "There is significant room for improvement, if there is demand for it."
msgstr ""

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:47
#: manual/devices/switches.txt:82
#, no-wrap
msgid "Convergence"
msgstr "Сходимость"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:50
msgid ""
"Transmission lines are linear devices, so it would seem they would not be a "
"factor in convergence."
msgstr ""

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:51
msgid ""
"Transmission lines can be used to decouple problem circuits.  If a circuit "
"is having convergence problems, sometimes inserting a short transmission "
"line in an appropriate place can solve the problem by adding a small delay.  "
"Parts of circuits separated by transmission lines are considered to be "
"separate circuits.  Convergence problems in one part do not influence the "
"other part."
msgstr ""

#. type: Title ======
#: manual/devices/mutual_inductance.txt:1
#, no-wrap
msgid "Coupled (Mutual) Inductors"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:6
#, no-wrap
msgid "  Kxxxxxxx Lyyyyyyy Lzzzzzzz value\n"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:10
msgid "Coupled mutual inductance."
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:14
msgid ""
"K couples two inductors.  The value is the coefficient of coupling.  Using "
"the dot convention, place a dot on the first node of each inductor."
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:16
msgid ""
"The coefficient of coupling is given by K = m[i][j] / sqrt(L[i] L[j]).  K is "
"always positive and less than 1."
msgstr ""

#. type: Title =====
#: manual/devices/mutual_inductance.txt:17
#, no-wrap
msgid "Bugs"
msgstr ""

#. type: Plain text
#: manual/devices/mutual_inductance.txt:19
msgid ""
"This version of mutual inductance is only supported in Spice syntax, because "
"the connections are inductors.  If you are using any other syntax, you can "
"make a Spice subcircuit containing the entire transformer."
msgstr ""

#. type: Title ======
#: manual/devices/other.txt:1
#, no-wrap
msgid "Other \"spice\" devices"
msgstr "Прочие «spice»-устройства"

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:mutual inductance]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:switches]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:Lossless transmission line]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/semi.txt:1
#, no-wrap
msgid "Semiconductor devices"
msgstr "Полупроводниковые устройства"

#. type: Plain text
#: manual/devices/semi.txt:4
msgid ""
"Gnucap supports both native and industry standard semiconductor devices."
msgstr ""

#. type: Plain text
#: manual/devices/semi.txt:6
msgid ""
"Native models are optimized models compiled with the \"gnucap-modelgen\" "
"model compiler.  A BJT, diode, and several MOSFET models are available as "
"native models."
msgstr ""

#. type: Plain text
#: manual/devices/semi.txt:8
msgid ""
"C-models designed for Spice can also be used as plugins.  Several variants "
"of spice models are supported, including 3e, 3f, NGspice, and Jspice.  "
"Usually, the models can be used without any modifications."
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:13
#, no-wrap
msgid "[[.:semi:diode]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:13
#, no-wrap
msgid "[[.:semi:bjt]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:13
#, no-wrap
msgid "[[.:semi:jfet]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:13
#, no-wrap
msgid "[[.:semi:mosfet]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi.txt:13
#, no-wrap
msgid "[[.:semi:mesfet]]\n"
msgstr ""

#. type: Title ======
#: manual/devices/semi/bjt.txt:1 manual/devices/semi/diode.txt:1
#, no-wrap
msgid "Semiconductor models"
msgstr "Модели полупроводниковых устройств"

#. type: Title =====
#: manual/devices/semi/bjt.txt:3
#, no-wrap
msgid "BJT's"
msgstr ""

#. type: Title ====
#: manual/devices/semi/bjt.txt:5 manual/devices/semi/diode.txt:5
#, no-wrap
msgid "Native models"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi/bjt.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man076.html|bjt]]\n"
msgstr ""

#. type: Title ====
#: manual/devices/semi/bjt.txt:8 manual/devices/semi/diode.txt:9
#, no-wrap
msgid "Spice models"
msgstr "Модели SPICE"

#. type: Plain text
#: manual/devices/semi/bjt.txt:11 manual/devices/semi/diode.txt:12
msgid ""
"Several Spice diode models are available.  They are not documented here."
msgstr ""

#. type: Plain text
#: manual/devices/semi/bjt.txt:17
#, no-wrap
msgid ""
"^Gnucap tarball      ^Name  ^Level  ^Origin        ^Status              ^Comments             ^\n"
"|models-spice3f5     |bjt   |       |Spice 3f5     |+++++ supported     |The standard model   |\n"
"|models-jspice3-2.5  |bjt   |       |Jspice 3-2.5  |+++-  inconsistent  |Not recommended      |\n"
"|models-ngspice17    |bjt   |1      |NGspice-17    |++++  works         |similar to standard  |\n"
"|models-ngspice17    |bjt2  |2      |NGspice-17    |+++   works         |similar to standard  |\n"
"|models-ngspice17    |vbic  |4      |NGspice-17    |++++  works         |Colin McAndrew's VBIC model  |\n"
msgstr ""

#. type: Title =====
#: manual/devices/semi/diode.txt:3
#, no-wrap
msgid "Diodes"
msgstr ""

#. type: Bullet: '  * '
#: manual/devices/semi/diode.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man063.html|diode]]\n"
msgstr ""

#. type: Plain text
#: manual/devices/semi/diode.txt:16
#, no-wrap
msgid ""
"^Gnucap tarball      ^Origin        ^Status           ^Comments  ^\n"
"|models-spice3f5     |Spice 3f5     |+++++ supported  |The standard model  |\n"
"|models-ngspice17    |NGspice-17    |+++++ supported  |Enhanced, with some additional parameters  |\n"
"|models-jspice3-2.5  |Jspice 3-2.5  |+++++ supported  |The standard model  |\n"
msgstr ""

#. type: Title ======
#: manual/devices/switches.txt:1
#, no-wrap
msgid "Switches"
msgstr ""

#. type: Title ==
#: manual/devices/switches.txt:5
#, no-wrap
msgid "Voltage controlled switch"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:8
msgid "Device:"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:10
#, no-wrap
msgid "  Sxxxxxxx (n+ n- nc+ nc-) modelname ic\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:12 manual/devices/switches.txt:22
msgid "Model (required):"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:14
#, no-wrap
msgid "  .model modelname SW args\n"
msgstr ""

#. type: Title ==
#: manual/devices/switches.txt:16
#, no-wrap
msgid "Current controlled switch"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:20
#, no-wrap
msgid ""
"Device:\n"
"  Wxxxxxxx (n+ n- ce) modelname ic\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:24
#, no-wrap
msgid "  .model modelname CSW args\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:28
msgid "Voltage or current controlled switch."
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:29
#, fuzzy, no-wrap
#| msgid "===== Comments ======"
msgid "Comments ======"
msgstr "Описание"

#. type: Plain text
#: manual/devices/switches.txt:32
msgid ""
"//N+// and //n-// are the positive and negative element nodes, respectively."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:34
msgid ""
"For voltage controlled switch, //Nc+// and //nc-// are the controlling nodes."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:36
msgid ""
"For current controlled switch, //ce// is the name of a controlling element."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:38
msgid "//Modelname// is the model name."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:41
msgid ""
"A switch is a resistor between //n+// and //n-//.  The value of the resistor "
"is determined by the state of the switch."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:46
#, no-wrap
msgid ""
"^control                 ^resistance  ^\n"
"|vc > von\\\\  ic > ion    |Ron         |\n"
"|vc < voff\\\\  ic < ioff  |Roff        |\n"
"|otherwise               |no change   |\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:50
msgid ""
"You may specify ''ON'' or ''OFF'' to indicate the initial state of the "
"switch when the controlling voltage is in the hysteresis region."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:52
msgid "The parameters //ron// and //roff// must have finite positive values."
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:52
#, fuzzy, no-wrap
#| msgid "Set and view parameters."
msgid "Model Parameters"
msgstr "Установка и просмотр параметров."

#. type: Plain text
#: manual/devices/switches.txt:61
#, no-wrap
msgid ""
"^Voltage controlled switch  ^^\n"
"|vt    |Threshold voltage.  (Default = 0.)         |\n"
"|vh    |Hysteresis voltage.  (Default = 0.)        |\n"
"|von   |On control voltage.  (Default = vt + vh)   |\n"
"|voff  |Off control voltage.  (Default = vt - vh)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:69
#, no-wrap
msgid ""
"^Current controlled switch  ^^\n"
"|it    |Threshold current.  (Default = 0.)         |\n"
"|ih    |Hysteresis current.  (Default = 0.)        |\n"
"|ion   |On control current.  (Default = it + ih)   |\n"
"|ioff  |Off control current.  (Default = it - ih)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""

#. type: Title =====
#: manual/devices/switches.txt:70
#, no-wrap
msgid "Time step control"
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:75
msgid ""
"A change of state is considered to be an analog event.  An input crossing a "
"threshold is a \"cross event\".  Cross events will generate extra time steps "
"so the switch timing is accurate."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:78
msgid ""
"A switch can be used anywhere in a circuit to improve timing accuracy by "
"sensing cross events."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:81
msgid ""
"Switches also influence time step control as resistors, which control "
"smoothness by curve fitting."
msgstr ""

#. type: Plain text
#: manual/devices/switches.txt:84
msgid ""
"Switches are linear devices that do not iterate unless there is a state "
"change."
msgstr ""

#. type: Title ======
#: manual/examples.txt:1
#, no-wrap
msgid "Examples, tutorial"
msgstr ""

#. type: Title =====
#: manual/examples.txt:2
#, no-wrap
msgid "Hosted here"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Hello world]]\n"
msgstr "[[gnucap:manual:examples:Hello world.ru|Привет, мир]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Resistors and sources]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Things that can go wrong]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Nonlinear devices -- diodes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Multiplying two voltages using diode nonlinearity]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Using the generator in transient analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Experimentally finding model parameters]]\n"
msgstr "[[gnucap:manual:examples:Experimentally finding model parameters.ru|Экспериментальное нахождение параметров модели]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Simple Power supply]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Phase shift oscillator]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:FM spectrum analysis]]\n"
msgstr ""

#. type: Title =====
#: manual/examples.txt:14
#, no-wrap
msgid "Hosted elsewhere"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, fuzzy, no-wrap
msgid "[[http://www.johannes-bauer.com/electronics/]] [[http://www.johannes-bauer.com/electronics/|gEDA and Gnucap, getting started, by Johannes Bauer]]\n"
msgstr ""
"  * [[http://www.johannes-bauer.com/electronics/]] [[http://www.johannes-bauer.com/electronics/|gEDA and Gnucap, getting started, by Johannes Bauer]]\n"
"  * [[http://geekwentfreak.wordpress.com/2009/12/11/spice-gschem-gnetlist-gnucap-gwave-gspiceui-linux/]]\n"
"FIXME: добавить ссылку на свой перевод\n"

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, no-wrap
msgid "[[http://geekwentfreak.wordpress.com/2009/12/11/spice-gschem-gnetlist-gnucap-gwave-gspiceui-linux/]]\n"
msgstr ""

#. type: Title ======
#: manual/examples/experimentally_finding_model_parameters.txt:1
#, no-wrap
msgid "Experimentally finding model parameters"
msgstr "Экспериментальное нахождение параметров модели"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:4
msgid ""
"Sometimes you need to determine model parameters, based on having no real "
"information."
msgstr ""
"Иногда необходимо определить параметры модели, не имея никакой реальной "
"информации."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:6
msgid ""
"In this example, we find the parameter \"IS\" of a diode, based on its "
"forward voltage."
msgstr ""
"В данном примере мы найдём параметр «IS» диода, взяв за основу прямое "
"падение напряжения на нём."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:8
msgid "We would like to have a diode..."
msgstr "Нам хотелось бы иметь диод..."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:10
#, no-wrap
msgid "  D2 (a k) 1n4004\n"
msgstr "  D2 (a k) 1n4004\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:12
msgid "Now you need a model statement ..."
msgstr "Теперь нужен оператор для модели ..."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:14
#, no-wrap
msgid "  .model 1n4004 d (a whole bunch of parameters)\n"
msgstr "  .model 1n4004 d (целая куча параметров)\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:17
msgid ""
"You could do a web search for a detailed model, but usually you can just do "
"some experimenting.."
msgstr ""
"Подробную модель можно было бы поискать во всемирной паутине, но обычно "
"можно просто немного поэкспериментировать.."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:21
msgid ""
"If you are at the stage where you are asking about this, the detail will "
"only confuse you, most likely of the worst kind of confusion, where you "
"don't realize it."
msgstr ""
"Если вы на том этапе, когда интересуетесь об этом, эта деталь лишь собьёт "
"вас с толку, и скорее всего очень сильно, там, где вы это себе не "
"представляете."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:24
msgid ""
"Most of the time, the only parameter you need for a diode is saturation "
"current, which of course isn't in the data sheet."
msgstr ""
"Чаще всего единственный параметр, который вам нужен для диода, это ток "
"насыщения, которого, конечно, в спецификации нет."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:26
msgid "ok .. so how do I figure that out??"
msgstr "Хорошо .. итак, как же мне его выяснить??"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:29
msgid ""
"Well ...  Look at the specs, or measure it.  Let's say we found that the "
"forward voltage at 1 amp is .7 volts."
msgstr ""
"Ну ...  глянуть в спецификацию, или измерить его. Допустим, мы нашли, что "
"прямое напряжение при токе 1 А составляет 0.7 В."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:31
msgid "Use the simulator to build a test circuit .."
msgstr "Используем программу моделирования для построения схемы проверки.."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:34
#, no-wrap
msgid ""
"  I1 (0 1) dc 1\n"
"  D1 (1 0) my_diode\n"
msgstr ""
"  I1 (0 1) dc 1\n"
"  D1 (1 0) my_diode\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:37
#, no-wrap
msgid ""
"You need a model statement ..\n"
"  .model my_diode d (is=something)\n"
msgstr ""
"Нам нужно выражение для модели ..\n"
"  .model my_diode d (is=something)\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:39
msgid "but I don't know what the value of something is."
msgstr "но я не знаю, чему это сколько-то (something) равно."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:41
msgid "With gnucap .. try this......."
msgstr "Берём gnucap .. и пробуем так......."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:85
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >i1 (0 1) dc 1\n"
"  >d1 (1 0) my_diode\n"
"  >.model my_diode d is=something\n"
"  >                   ******** blank line to exit build mode\n"
"  gnucap> probe  op  v(1)\n"
"  parameter something has no value\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.83376                    **** using default IS\n"
"  gnucap> param something=1u\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.35733\n"
"  gnucap> param something=1n\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.53599\n"
"  gnucap> param something=1p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.71465\n"
"  gnucap> param something=2p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69673\n"
"  gnucap> param something=1.5p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70417\n"
"  gnucap> param something=1.8p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69945\n"
"  gnucap> param something=1.7p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70093\n"
"  gnucap> param something=1.75p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70018\n"
"  gnucap> exit\n"
msgstr ""
"  gnucap> build\n"
"  >i1 (0 1) dc 1\n"
"  >d1 (1 0) my_diode\n"
"  >.model my_diode d is=something\n"
"  >                   ******** пустая строка для выхода из режима build\n"
"  gnucap> probe  op  v(1)\n"
"  parameter something has no value\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.83376     **** используется значение IS по умолчанию\n"
"  gnucap> param something=1u\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.35733\n"
"  gnucap> param something=1n\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.53599\n"
"  gnucap> param something=1p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.71465\n"
"  gnucap> param something=2p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69673\n"
"  gnucap> param something=1.5p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70417\n"
"  gnucap> param something=1.8p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69945\n"
"  gnucap> param something=1.7p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70093\n"
"  gnucap> param something=1.75p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70018\n"
"  gnucap> exit\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:89
msgid "There ..  close enough ,,, Now use the value 1.75p for IS."
msgstr ""
"Ну вот ..  довольно близко ,,, Теперь для IS используем значение 1.75p."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:91
#, no-wrap
msgid ""
"Here's your model statement:\n"
"  .model my_diode d is=1.75p\n"
msgstr ""
"Вот и оператор для нашей модели:\n"
"  .model my_diode d is=1.75p\n"

#. type: Title ======
#: manual/examples/fm_spectrum_analysis.txt:1
#, no-wrap
msgid "FM spectrum analysis"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:4
msgid ""
"In this demo, we will look at the spectrum of a frequency modulated signal, "
"with the intent of exploring the effect of overmodulation on bandwidth."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:6
msgid ""
"The circuit is simple, just a voltage source, with a Spice-style \"SFFM\" "
"waveform.  We will use parameters to tinker with the signal, and the Fourier "
"command to display the spectrum.  You could calculate the spectrum using "
"Bessel functions, but we will look at it with simulation."
msgstr ""

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:6
#: manual/examples/phase_shift_oscillator.txt:56
#, no-wrap
msgid "Setting up"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:9
msgid "First, the circuit.  Enter it with the \"build\" command:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:14
#, no-wrap
msgid ""
"  gnucap> build\n"
"  > v1 ( 1 0 ) sffm (carrier={carrier} modindex={mod/signal} signal={signal})\n"
"  >       **** blank line exits build mode\n"
"  gnucap>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:16
msgid "Now, set up the parameters:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:20
#, no-wrap
msgid ""
"  gnucap> param carrier=10Meg\n"
"  gnucap> param signal=10K\n"
"  gnucap> param mod=75K\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:22
msgid ""
"This sets up a signal of 10 KHz with the usual maximum deviation of 75 KHz.  "
"This is not overmodulated.  I chose a carrier frequency of 10 MHz for "
"convenience.  100 MHz would be more realistic but would take longer to run.  "
"It doesn't really matter, and 10 MHz is close to the usual intermediate "
"frequency of 10.7 MHz."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:24
msgid "Now, set up the sweep parameters:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:28
#, no-wrap
msgid ""
"  gnucap> param start={carrier-2*(mod+signal)}\n"
"  gnucap> param stop={carrier+2*(mod+signal)}\n"
"  gnucap> param step={signal}\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:30
msgid ""
"Carson's rule estimates the bandwidth to be 2*(mod+signal), so we will cover "
"a range of twice that, in steps equal to the modulating frequency.  If you "
"look at the Bessel functions, you will see that this is corresponds to the "
"actual signal."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:32
msgid "Now, set up a probe:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:34
#, no-wrap
msgid "  gnucap> probe fourier v(1)\n"
msgstr "  gnucap> probe fourier v(1)\n"

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:35
#, no-wrap
msgid "The first run"
msgstr "Первый запуск"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:38
msgid "Try one .. look at the spectrum:"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:40
#, no-wrap
msgid "  gnucap> fourier {start} {stop} {step}\n"
msgstr "  gnucap> fourier {начало} {конец} {шаг}\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:42
msgid ""
"You will see the time points of a transient run, then the spectrum over the "
"range you asked for."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:83
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.83Meg    7.2578u   -102.78   93.604  20.494u    -93.77 -179.033\n"
" 9.84Meg    31.322u    -90.08  -86.484  88.446u    -81.07    0.879\n"
" 9.85Meg    126.38u    -77.97   93.428  356.88u    -68.95 -179.209\n"
" 9.86Meg    474.21u    -66.48  -86.660  0.0013391  -57.46    0.703\n"
" 9.87Meg    0.001644   -55.68   93.252  0.0046423  -46.67 -179.385\n"
" 9.88Meg    0.005225   -45.64  -86.836  0.014754   -36.62    0.527\n"
" 9.89Meg    0.015076   -36.43   93.076  0.042571   -27.42 -179.561\n"
" 9.9Meg     0.038998   -28.18  -87.012  0.11012    -19.16    0.352\n"
" 9.91Meg    0.088919   -21.02   92.900  0.25108    -12.00 -179.736\n"
" 9.92Meg    0.17441    -15.17  -87.188  0.49248     -6.15    0.176\n"
" 9.93Meg    0.28315    -10.96   92.725  0.79954     -1.94 -179.912\n"
" 9.94Meg    0.35414     -9.02  -87.363  1.           0.00   -0.000\n"
" 9.95Meg    0.28347    -10.95   92.549  0.80046     -1.93  179.912\n"
" 9.96Meg    0.023825   -32.46  -87.539  0.067275   -23.44   -0.176\n"
" 9.97Meg    0.25806    -11.77  -87.627  0.7287      -2.75   -0.264\n"
" 9.98Meg    0.23027    -12.76   92.285  0.65023     -3.74  179.648\n"
" 9.99Meg    0.13525    -17.38   92.197  0.38191     -8.36  179.561\n"
" 10.Meg     0.26634    -11.49  -87.891  0.75207     -2.47   -0.527\n"
" 10.01Meg   0.13525    -17.38  -87.979  0.38191     -8.36   -0.615\n"
" 10.02Meg   0.23027    -12.76   91.934  0.65023     -3.74  179.297\n"
" 10.03Meg   0.25806    -11.77   91.846  0.7287      -2.75  179.209\n"
" 10.04Meg   0.023825   -32.46  -88.242  0.067275   -23.44   -0.879\n"
" 10.05Meg   0.28347    -10.95  -88.330  0.80046     -1.93   -0.967\n"
" 10.06Meg   0.35414     -9.02  -88.418  1.          -0.00   -1.055\n"
" 10.07Meg   0.28315    -10.96  -88.506  0.79954     -1.94   -1.143\n"
" 10.08Meg   0.17441    -15.17  -88.594  0.49248     -6.15   -1.230\n"
" 10.09Meg   0.088919   -21.02  -88.682  0.25108    -12.00   -1.318\n"
" 10.1Meg    0.038998   -28.18  -88.770  0.11012    -19.16   -1.406\n"
" 10.11Meg   0.015076   -36.43  -88.857  0.042571   -27.42   -1.494\n"
" 10.12Meg   0.005225   -45.64  -88.945  0.014754   -36.62   -1.582\n"
" 10.13Meg   0.001644   -55.68  -89.033  0.0046423  -46.67   -1.670\n"
" 10.14Meg   474.22u    -66.48  -89.121  0.0013391  -57.46   -1.758\n"
" 10.15Meg   126.38u    -77.97  -89.209  356.88u    -68.95   -1.846\n"
" 10.16Meg   31.323u    -90.08  -89.297  88.447u    -81.07   -1.934\n"
" 10.17Meg   7.2581u   -102.78  -89.385  20.495u    -93.77   -2.021\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:85
msgid ""
"As a quick check ..  For a modulation index of 7.5, the fourth sideband "
"should have a null, or close to it.  It does."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:87
msgid ""
"Another quick check .. Carson's rule says the bandwidth should be about 2*"
"(mod+signal) or 2*(10K+75K), or 85K on each side.  It's pretty close.  It "
"looks like the real bandwidth is probably a little more."
msgstr ""

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:87
#, no-wrap
msgid "Now experiment"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:90
msgid ""
"Let's try a modulating frequency of 50 KHz, roughly the top of the stereo "
"subcarrier."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:98
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=50k\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.0025    -0.99968\n"
" 0.0025     0.8\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:116
#, no-wrap
msgid ""
"<code>\n"
" 0.0025199  0.76861\n"
" 0.00252   -0.99968\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.75Meg    0.0017994  -54.90   94.307  0.0032251  -49.83    1.758\n"
" 9.8Meg     0.011768   -38.59  -86.133  0.021092   -33.52 -178.682\n"
" 9.85Meg    0.060964   -24.30   93.428  0.10927    -19.23    0.879\n"
" 9.9Meg     0.23209    -12.69  -87.012  0.41598     -7.62 -179.561\n"
" 9.95Meg    0.55794     -5.07   92.549  1.           0.00    0.000\n"
" 10.Meg     0.51183     -5.82  -87.891  0.91736     -0.75  179.561\n"
" 10.05Meg   0.55794     -5.07  -88.330  1.          -0.00  179.121\n"
" 10.1Meg    0.23209    -12.69  -88.770  0.41598     -7.62  178.682\n"
" 10.15Meg   0.060964   -24.30  -89.209  0.10927    -19.23  178.242\n"
" 10.2Meg    0.011768   -38.59  -89.648  0.021092   -33.52  177.803\n"
" 10.25Meg   0.0017994  -54.90  -90.088  0.0032251  -49.83  177.363\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:118
msgid ""
"Mod index is 1.5, so the spectrum is simpler, Carson's rule predicts 50K"
"+75K, or 125K each side.  Again, it seems the real signal takes more space.  "
"Check the Bessel functions, from a graph ...  about .55, .55, .2 ..  it "
"matches as well as I read the graph."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:120
msgid "The signal is really pretty wide.  Try half of the deviation .."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:127
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param mod=37.5K\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.00252   -0.99952\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:142
#, no-wrap
msgid ""
"<code>\n"
" 0.0025399  0.75896\n"
" 0.00254   -0.99952\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.85Meg    0.0084844  -41.43   93.428  0.0098171  -40.16 -178.682\n"
" 9.9Meg     0.067074   -23.47  -87.012  0.07761    -22.20    0.879\n"
" 9.95Meg    0.34924     -9.14   92.549  0.4041      -7.87 -179.561\n"
" 10.Meg     0.86424     -1.27  -87.891  1.           0.00   -0.000\n"
" 10.05Meg   0.34924     -9.14  -88.330  0.4041      -7.87   -0.439\n"
" 10.1Meg    0.067074   -23.47  -88.770  0.07761    -22.20   -0.879\n"
" 10.15Meg   0.0084844  -41.43  -89.209  0.0098171  -40.16   -1.318\n"
" 10.2Meg    801.07u    -61.93  -89.648  926.9u     -60.66   -1.758\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:144
msgid ""
"So now you see why the FCC limit on deviation is lower for higher modulation "
"frequencies."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:146
msgid "Let's try overmodulating."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:152
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=10K\n"
"gnucap> param mod=150K\n"
"gnucap> fourier\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:222
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.68Meg    6.6294n   -163.57    0.001  23.786n   -152.47 -179.999\n"
" 9.69Meg    26.707n   -151.47  180.000  95.822n   -140.37   -0.000\n"
" 9.7Meg     103.74n   -139.68    0.000  372.23n   -128.58 -180.000\n"
" 9.71Meg    388.29n   -128.22  180.000  1.3931u   -117.12   -0.000\n"
" 9.72Meg    1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 9.73Meg    4.8295u   -106.32  180.000  17.328u    -95.23   -0.000\n"
" 9.74Meg    15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 9.75Meg    50.597u    -85.92  180.000  181.54u    -74.82   -0.000\n"
" 9.76Meg    152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 9.77Meg    437.95u    -67.17  180.000  0.0015713  -56.07   -0.000\n"
" 9.78Meg    0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 9.79Meg    0.0030538  -50.30  180.000  0.010957   -39.21   -0.000\n"
" 9.8Meg     0.0073602  -42.66   -0.000  0.026408   -31.57 -180.000\n"
" 9.81Meg    0.016574   -35.61  180.000  0.059464   -24.51    0.000\n"
" 9.82Meg    0.034626   -29.21   -0.000  0.12423    -18.12 -180.000\n"
" 9.83Meg    0.066529   -23.54  180.000  0.2387     -12.44    0.000\n"
" 9.84Meg    0.11617    -18.70   -0.000  0.41682     -7.60 -180.000\n"
" 9.85Meg    0.18131    -14.83  180.000  0.65051     -3.73    0.000\n"
" 9.86Meg    0.24644    -12.17   -0.000  0.8842      -1.07 -180.000\n"
" 9.87Meg    0.27871    -11.10  180.000  1.           0.00    0.000\n"
" 9.88Meg    0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 9.89Meg    0.09995    -20.00  180.000  0.35861     -8.91   -0.000\n"
" 9.9Meg     0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 9.91Meg    0.22005    -13.15   -0.000  0.7895      -2.05  180.000\n"
" 9.92Meg    0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 9.93Meg    0.034464   -29.25  180.000  0.12365    -18.16   -0.000\n"
" 9.94Meg    0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 9.95Meg    0.13046    -17.69  180.000  0.46806     -6.59   -0.000\n"
" 9.96Meg    0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 9.97Meg    0.19402    -14.24   -0.000  0.69612     -3.15  180.000\n"
" 9.98Meg    0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 9.99Meg    0.2051     -13.76  180.000  0.73589     -2.66   -0.000\n"
" 10.Meg     0.014224   -36.94  180.000  0.051036   -25.84   -0.000\n"
" 10.01Meg   0.2051     -13.76   -0.000  0.73589     -2.66  180.000\n"
" 10.02Meg   0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 10.03Meg   0.19402    -14.24  180.000  0.69612     -3.15   -0.000\n"
" 10.04Meg   0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 10.05Meg   0.13046    -17.69   -0.000  0.46806     -6.59  180.000\n"
" 10.06Meg   0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 10.07Meg   0.034464   -29.25   -0.000  0.12365    -18.16  180.000\n"
" 10.08Meg   0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 10.09Meg   0.22005    -13.15  180.000  0.7895      -2.05   -0.000\n"
" 10.1Meg    0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 10.11Meg   0.09995    -20.00   -0.000  0.35861     -8.91  180.000\n"
" 10.12Meg   0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 10.13Meg   0.27871    -11.10   -0.000  1.          -0.00  180.000\n"
" 10.14Meg   0.24644    -12.17   -0.000  0.8842      -1.07  180.000\n"
" 10.15Meg   0.18131    -14.83   -0.000  0.65051     -3.73  180.000\n"
" 10.16Meg   0.11617    -18.70   -0.000  0.41682     -7.60  180.000\n"
" 10.17Meg   0.066529   -23.54   -0.000  0.2387     -12.44  180.000\n"
" 10.18Meg   0.034626   -29.21   -0.000  0.12423    -18.12  180.000\n"
" 10.19Meg   0.016574   -35.61   -0.000  0.059464   -24.51  180.000\n"
" 10.2Meg    0.0073602  -42.66   -0.000  0.026408   -31.57  180.000\n"
" 10.21Meg   0.0030538  -50.30   -0.000  0.010957   -39.21  180.000\n"
" 10.22Meg   0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 10.23Meg   437.95u    -67.17   -0.000  0.0015713  -56.07 -180.000\n"
" 10.24Meg   152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 10.25Meg   50.597u    -85.92    0.000  181.54u    -74.82 -180.000\n"
" 10.26Meg   15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 10.27Meg   4.8295u   -106.32    0.000  17.328u    -95.23 -180.000\n"
" 10.28Meg   1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 10.29Meg   388.29n   -128.22    0.000  1.3932u   -117.12 -180.000\n"
" 10.3Meg    103.75n   -139.68    0.000  372.26n   -128.58 -180.000\n"
" 10.31Meg   26.712n   -151.47    0.000  95.838n   -140.37 -180.000\n"
" 10.32Meg   6.6384n   -163.56    0.001  23.818n   -152.46 -179.999\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:224
msgid "As expected, the bandwidth is a a little more than 2*160k."
msgstr ""

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:225
msgid "That's enough for now."
msgstr ""

#. type: Title ======
#: manual/examples/hello_world.txt:1
#, no-wrap
msgid "Hello world"
msgstr "Привет, мир"

#. type: Plain text
#: manual/examples/hello_world.txt:4
msgid "Copyright 1999 Telford Tendys (with mods by Albert Davis)"
msgstr "Copyright 1999 Telford Tendys (с изменениями от Albert Davis)"

#. type: Plain text
#: manual/examples/hello_world.txt:12
msgid ""
"This is not an alternative to reading the manual. The manual is very nicely "
"presented in LaTeX and you should print it out and keep it handy when "
"working. This document is organised starting from easy and working towards "
"difficult and presumes that you have some idea of what electrical circuits "
"are but don't know much about simulators.  The manual is organised in "
"alphabetical order and in groups of concepts and it presumes that you know "
"SPICE already."
msgstr ""
"Чтение настоящего документа не заменит чтения руководства. Руководство, со "
"вкусом свёрстанное в LaTeX, желательно распечатать и в процессе работы "
"держать под рукой. Настоящий документ построен на постепенном переходе от "
"простого к сложному, и здесь предполагается, что вы имеете некоторое "
"представление о том, что такое электрические схемы, но недостаточно "
"разбираетесь в программах схемотехнического моделирования. Руководство "
"построено в алфавитном порядке и организовано по группам понятий, исходя из "
"предположения, что вы уже знакомы с программой SPICE."

#. type: Title =====
#: manual/examples/hello_world.txt:13
#, no-wrap
msgid "The basic concept of a nodal analysis"
msgstr "Основные понятия анализа цепей методом узловых потенциалов"

#. type: Plain text
#: manual/examples/hello_world.txt:20
msgid ""
"Using nodes is one way to describe a lumped element circuit.  Lumped "
"elements are used because there is no consideration of what is occurring "
"inside a given component, only what is happening on the terminals of the "
"component. For example, this analysis makes no attempt to find the voltage "
"in the middle of a resistor, only at the ends of the resistor."
msgstr ""
"Использование узлов --- это один из способов описания цепей из элементов с "
"сосредоточенными параметрами (дискретных элементов). Использование "
"дискретных элементов обусловлено тем, что здесь не ставится задача "
"рассмотрения процессов, идущих внутри заданных компонентов, но "
"рассматривается только то, что происходит на их выводах. К примеру, в этом "
"анализе даже не рассматривается поиск напряжения в середине резистора, "
"ищутся напряжения только на его концах."

#. type: Plain text
#: manual/examples/hello_world.txt:27
msgid ""
"The whole circuit model consists of \"nodes\" and \"components\".  A node is "
"(electrically speaking) a single point, it has exactly one voltage value at "
"any given time value. A component will connect to two or more nodes (usually "
"two) and represents some method by which the voltages at those nodes affect "
"one another. Describing which components connect to which nodes will "
"completely describe the structure of the circuit."
msgstr ""
"Полная модель схемы состоит из «узлов» и «компонентов». Узел (с "
"электрической точки зрения) представляет собой одну точку, которая имеет "
"одно единственное значение величины напряжения для любого конкретного "
"значения времени. Компонент обычно соединяется с двумя или более узлами "
"(обычно с двумя) и является представлением некоторого метода взаимовлияния "
"напряжений указанных узлов друг на друга. Описание того, какие компоненты "
"присоединяются к каким узлам, будет полным описанием структуры схемы."

#. type: Plain text
#: manual/examples/hello_world.txt:33
msgid ""
"One additional concept is a \"branch\". The current though a branch is the "
"amount of current flowing from a node into a component that connects to that "
"node. Some branch currents (such as the current through a voltage source)  "
"are explicitly calculated, others (such as the current through a resistor) "
"are implicitly calculated as a result of calculating the node voltages."
msgstr ""
"Одним из вспомогательных понятий является «ветвь». Током ветви называется "
"величина тока, текущего из узла в компонент, присоединённый к этому узлу. "
"Токи некоторых ветвей (такие как токи через источники напряжения) "
"рассчитываются явно, другие (такие как токи через резисторы) рассчитываются "
"косвенно как результат расчёта напряжений узлов."

#. type: Title =====
#: manual/examples/hello_world.txt:33
#, no-wrap
msgid "The basic concept of a circuit file"
msgstr "Общее представление о файлах схем"

#. type: Plain text
#: manual/examples/hello_world.txt:39
msgid ""
"Tradition has it that Gnucap input files have the extension \"''.ckt''\". "
"The format is similar to that used by version 2 of the SPICE simulator; it "
"is a line oriented format with items separated by whitespace. The overall "
"file structure is:"
msgstr ""
"Традиционно входные файлы gnucap имеют расширение «''.ckt''». Формат сродни "
"тому, что используется в версии 2 программы моделирования SPICE; это строчно-"
"ориентированный формат, в котором элементы разделяются пробельными "
"символами. Общая структура файла выглядит так:"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "Header line (first line of the file) usually contains the name of the circuit.  It should be marked as a comment.\n"
msgstr "Строка заголовка (первая строка файла) обычно содержит название схемы. Она должна быть помечена как комментарий.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "blank lines do nothing\n"
msgstr "Пустые строки ни на что не влияют.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "comment lines are any line beginning with a star \"''*''\".  These can be anywhere in the file except the header line.\n"
msgstr "К комментариям относятся только строки, начинающиеся со звёздочки «''*''».  Они могут находиться где угодно в файле, за исключением строки заголовка.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "component lines begin with a letter and represent some component that is in the circuit. The order that components are listed does not matter because the topology is described by the nodes that the components are connected to.\n"
msgstr "Строки компонентов начинаются с буквы и являются представлением каких-нибудь компонентов в схеме. Порядок перечисления компонентов роли не играет, потому что топология схемы описывается узлами, к которым эти компоненты присоединены.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "continuation lines begin with a plus \"''+''\" and continue the previous line so that long lines can be written neatly.\n"
msgstr "Строки-расширения начинаются со знака плюс «''+''» и служат продолжением предшествующих строк, позволяя более аккуратную запись длинных строк.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "command lines begin with a dot \"''.''\" and are not considered to be part of the circuit, they cause the simulator to execute some analysis or change some options. They are also used to delimit special parts of the file such as subcircuits.\n"
msgstr "Строки команд начинаются с точек «''.''» и частью схемы не считаются, они заставляют программу моделирования выполнить какой-либо анализ или изменить какие-нибудь параметры. Кроме того, они используются для определения границ особых частей файла, таких как подсхемы.\n"

#. type: Title =====
#: manual/examples/hello_world.txt:47
#, no-wrap
msgid "Building a simple circuit"
msgstr "Построение простой схемы"

#. type: Plain text
#: manual/examples/hello_world.txt:50
msgid "The \"build\" command lets you enter a circuit from the keyboard."
msgstr ""
"Команда [[..:commands:build.ru|build]] позволяет ввести схему с клавиатуры."

#. type: Plain text
#: manual/examples/hello_world.txt:56
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >Vsupply 0 2 10\n"
"  >R1 0 2 1k\n"
"  >\n"
"  gnucap>\n"
msgstr ""
"  gnucap> build\n"
"  >Vsupply 0 2 10\n"
"  >R1 0 2 1k\n"
"  >\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:58
msgid "A blank line exits the build mode."
msgstr "Ввод пустой строки приводит к выходу из режима построения схемы."

#. type: Plain text
#: manual/examples/hello_world.txt:60
msgid "See what you have with the \"list\" command."
msgstr "Посмотрим, что у нас есть, командой [[..:commands:list.ru|list]]."

#. type: Plain text
#: manual/examples/hello_world.txt:65
#, no-wrap
msgid ""
"  gnucap> list\n"
"  Vsupply ( 0 2 )  DC  10.\n"
"  R1 ( 0 2 )  1.K\n"
"  gnucap>\n"
msgstr ""
"  gnucap> list\n"
"  Vsupply ( 0 2 )  DC  10.\n"
"  R1 ( 0 2 )  1.K\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:67
msgid "Do a quick check of the voltages:"
msgstr "Быстрая проверка напряжений:"

#. type: Plain text
#: manual/examples/hello_world.txt:73
#, no-wrap
msgid ""
"  gnucap> probe op v(nodes)\n"
"  gnucap> op\n"
"  #           v(2)\n"
"   27.       -10.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> probe op v(nodes)\n"
"  gnucap> op\n"
"  #           v(2)\n"
"   27.       -10.\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:75
msgid "You can save it to a file now:"
msgstr "Теперь схему можно сохранить в файл:"

#. type: Plain text
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid ""
"  gnucap> save eg1.ckt\n"
"  gnucap>\n"
msgstr ""
"  gnucap> save eg1.ckt\n"
"  gnucap>\n"

#. type: Title =====
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid "The simplest possible circuit file"
msgstr "Файл самой простой возможной схемы"

#. type: Plain text
#: manual/examples/hello_world.txt:83
#, no-wrap
msgid ""
"  #RESISTOR DRIVEN BY VOLTAGE SOURCE\n"
"  Vsupply 0 2 10\n"
"  R1 0 2 1k\n"
msgstr ""
"  #РЕЗИСТОР, ПОДКЛЮЧЕННЫЙ К ИСТОЧНИКУ НАПРЯЖЕНИЯ\n"
"  Vsupply 0 2 10\n"
"  R1 0 2 1k\n"

#. type: Plain text
#: manual/examples/hello_world.txt:91
msgid ""
"This file defines a circuit containing two nodes and two components.  The "
"components have the names \"Vsupply\" and \"R1\", the first letter of the "
"component name tells what that component is so \"Vsupply\" is a voltage "
"source and \"R1\" is a resistor. Each component has a value, the voltage "
"source is 10 volts and the resistor is 1000 ohms. The nodes have the numbers "
"\"0\" and \"2\". Note that there is no node \"1\" but this doesn't matter, "
"not every node number needs to be used."
msgstr ""
"В этом файле определена электрическая цепь, содержащая два компонента. Эти "
"компоненты называются \"Vsupply\" и \"R1\", первая буква имени компонента "
"определяет тип компонента, поэтому \"Vsupply\" является источником "
"напряжения («**V**oltage source»), а \"R1\" --- это резистор "
"(«**R**esistor»). Для каждого компонента указано значение, для источника "
"напряжения 10 вольт, а для резистора 1000 ом. Узлы имеют номера \"0\" и "
"\"2\". Заметьте, что узла \"1\" здесь нет, но это не важно, для номеров "
"узлов не обязательно использовать последовательную нумерацию."

#. type: Plain text
#: manual/examples/hello_world.txt:93
#: manual/examples/phase_shift_oscillator.txt:59
msgid "Run it interactively ..."
msgstr "Запустим это в интерактивном режиме..."

#. type: Plain text
#: manual/examples/hello_world.txt:107
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2009.02.02 RCS 26.109\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get eg1.ckt\n"
"  '\n"
"  gnucap>\n"
msgstr ""
"  $$$$$$$gnucap\n"
"  Gnucap 2009.02.02 RCS 26.109\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get eg1.ckt\n"
"  '\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:111
msgid ""
"From the interactive mode it is possible to exercise the circuit model, "
"firstly by putting a probe on the node that needs measuring (using the print "
"statement) then by starting the simulation:"
msgstr ""
"В интерактивном режиме можно поупражняться с моделью схемы, сначала задав "
"датчик для узла, для которого нужно произвести измерение (с помощью "
"оператора [[..:commands:print.ru|print]]), затем, запустив моделирование:"

#. type: Plain text
#: manual/examples/hello_world.txt:117
#, no-wrap
msgid ""
"  gnucap> print dc v(2)\n"
"  gnucap> dc\n"
"  #           v(2)\n"
"   0.        -10.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc v(2)\n"
"  gnucap> dc\n"
"  #           v(2)\n"
"   0.        -10.\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:132
msgid ""
"Needless to say, \"dc\" is a steady state direct current analysis and the "
"\"print\" command used here is saying, \"when you do a DC analysis, tell me "
"the voltage at node 2\". The result should be -10 volts. At first glance, it "
"might seem like it should be 10 volts... but (same as SPICE)  the voltage "
"sources are listed with their positive terminal first, then their negative "
"terminal. Node 0 is the ground node (or reference node) which is always 0 "
"volts so node 2 is at -10 volts. Wiring \"Vsupply\" the other way around "
"would change the answer to 10 volts. Things get trickier when dealing with "
"current sources where the node at the tail end of the current source arrow "
"is listed first (and called \"+\") and the pointy head end of the arrow is "
"listed second (and called \"-\"). Although this convention may seem "
"disorienting to someone who was brought up testing their circuits with "
"batteries or a bench power supply and poking their meter probes into things, "
"it is a well established SPICE convention and probably never going to change."
msgstr ""
"Излишне говорить, что [[..:commands:dc.ru|dc]] --- это расчёт статического "
"режима по постоянному току, и используемая здесь команда [[..:commands:print."
"ru|print]] говорит: «когда произведёшь расчёт статического режима, скажи мне "
"напряжение узла 2». В результате должно быть -10 вольт. На первый взгляд "
"могло показаться, будто должно было быть +10 вольт... но (так же, как и в "
"SPICE) для источников напряжения первым указывается их положительный зажим, "
"а затем уже отрицательный. Узел 0 является узлом земли (или опорным узлом), "
"потенциал которого всегда равен 0 вольт, поэтому напряжение узла 2 "
"составляет -10 вольт. При обратном подключении ''Vsupply'' результат "
"изменился бы на +10 вольт. Всё становится ещё сложнее при работе с "
"источниками тока, где узел со стороны хвоста стрелки источника тока "
"считается первым (и называется «''+''»), а узел с той стороны, куда стрелка "
"указывает, считается вторым (и называется «''-''»). Хотя это соглашение и "
"может показаться сбивающим с толку для кого-то, кто возмужал и заматерел, "
"исследуя свои схемы с питанием от батарей или от стендового источника "
"питания и тыкая щупами в разные точки, это хорошо устоявшееся соглашение "
"SPICE, и поэтому, наверно, оно никогда не изменится."

#. type: Plain text
#: manual/examples/hello_world.txt:136
msgid ""
"However, the voltage of the node may not be the answer required. What about "
"the current going through the source? We can move our probe to look at "
"current instead:"
msgstr ""
"Однако, напряжение узла может и не быть искомым решением. Как насчёт тока, "
"протекающего через источник? Мы можем выбрать другой датчик и взглянуть "
"вместо напряжения на ток:"

#. type: Plain text
#: manual/examples/hello_world.txt:142
#, no-wrap
msgid ""
"  gnucap> print dc i(R1) i(Vsupply)\n"
"  gnucap> dc\n"
"  #           i(R1)      i(Vsupply)\n"
"   0.         0.01      -0.01\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc i(R1) i(Vsupply)\n"
"  gnucap> dc\n"
"  #           i(R1)      i(Vsupply)\n"
"   0.         0.01      -0.01\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:157
msgid ""
"Now we can see 10 milliamps going through both components, note the sign "
"convention when probing current; once more this is something that you must "
"simply learn, you might draw diagrams of the main components and mark the "
"important conventions of [+] terminal, [-] terminal and current flow.  You "
"might also realise that this convention does have its own logical "
"consistency which makes it easier to remember. For example, consider a "
"resistor: the terminal called [+] is listed first and the internal current "
"flow is positive when current flows into the [+] terminal, through the "
"resistor and out of the [-] terminal. In the case of a resistor this sounds "
"quite sensible because the [+] terminal WOULD be more positive when the "
"current flows in this manner. The sources merely maintain the same "
"convention as is applied to a resistor, what is important to remember is "
"that [+] and [-] terminals are just names that provide a sign convention "
"they don't insist that one terminal is a higher voltage than the other."
msgstr ""
"Теперь мы можем видеть 10 миллиампер, текущие через оба компонента, с учётом "
"соглашения о знаке при контроле тока. Ещё раз, это то, что вы просто должны "
"выучить, можете даже нарисовать диаграммы основных компонентов и отметить "
"для них эти важные соглашения, связывающие обозначения выводов «+» и «-» и "
"направление тока. Вы также сможете понять, что это соглашение имеет свою "
"логику, позволяющую легче его запомнить. Например, рассмотрим резистор: "
"вывод под названием «+» считается первым, и внутреннее направление тока "
"положительно, когда ток течёт через резистор от вывода «+» к выводу «-». В "
"случае резистора это звучит вполне разумно, так как вывод «+» БУДЕТ более "
"положительным, когда ток течёт таким образом. Для источников напряжения и "
"тока просто поддерживается то же самое соглашение, которое применяется к "
"резистору, и что важно запомнить, так это то, что «+» и «-» --- это просто "
"обозначения выводов, обеспечивающие лишь поддержку соглашения о знаке, и не "
"требующие, чтобы один вывод имел большее напряжение, чем другой."

#. type: Plain text
#: manual/examples/hello_world.txt:161
msgid ""
"This example should provide enough information for analysis of any network "
"of voltage sources and resistors and for inspection of any current or "
"voltage in such a circuit. The power and resistance of each component can be "
"measured:"
msgstr ""
"Данный пример должен был дать вам достаточно информации для анализа любых "
"цепей, состоящих из источников напряжения и резисторов, и для контроля любых "
"токов или напряжений в подобного рода схемах. Для каждого из компонентов "
"можно измерить их мощность и сопротивление:"

#. type: Plain text
#: manual/examples/hello_world.txt:167
#, no-wrap
msgid ""
"  gnucap> print dc p(R1) p(Vsupply) r(R1) r(Vsupply)\n"
"  gnucap> dc\n"
"  #           p(R1)      p(Vsupply) r(R1)      r(Vsupply)\n"
"   0.         0.1       -0.1        1.K        Inf\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc p(R1) p(Vsupply) r(R1) r(Vsupply)\n"
"  gnucap> dc\n"
"  #           p(R1)      p(Vsupply) r(R1)      r(Vsupply)\n"
"   0.         0.1       -0.1        1.K        Inf\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:173
msgid ""
"Note that the supply shows negative power to it is putting power into the "
"system while the resistor shows positive power meaning that it is taking "
"power out of the system. Also notice that the resistance measurement will "
"attempt to find the resistance of the source without error but the resulting "
"value is huge (this seems wrong, I would expect it to be zero)."
msgstr ""
"Обратите внимание, что источник питания, величина мощности которого "
"отрицательна, выдаёт мощность в систему, в то время как мощность, "
"рассчитанная для резистора, положительна, а это значит, что он потребляет "
"мощность из системы. Также заметьте, что при измерении сопротивления "
"программа попытается найти сопротивление источника напряжения без ошибок, но "
"результирующее значение огромно (это кажется неправильным, я бы ожидал, что "
"оно должно быть нулевым)."

#. type: Plain text
#: manual/examples/hello_world.txt:175
msgid "All done, for now."
msgstr "Вот и всё на этот раз."

#. type: Plain text
#: manual/examples/hello_world.txt:177
#, no-wrap
msgid ""
"  gnucap> quit\n"
"  $$$$$$$\n"
msgstr ""
"  gnucap> quit\n"
"  $$$$$$$\n"

#. type: Title ======
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:1
#, no-wrap
msgid "Multiplying Two Voltages Using Diode Nonlinearity"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:11
msgid ""
"The above example shows diode voltage drop behaviour but the diode can also "
"be used as an exponential function. In this example, a group of diodes are "
"used to construct a voltage multiplier. Most circuit components add and "
"subtract voltages and currents but multiplication is a bit special.  What is "
"done in this circuit is to use the exponential behaviour of the diodes to "
"take the logarithm of two input voltages, then add those up and use another "
"diode to find the exponential of the sum. This works in the same way as a "
"slide rule does."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:13
msgid "eg7.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:16
#, no-wrap
msgid ""
"<code>\n"
"MULTILPLY TWO NUMBERS\n"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:37
#, no-wrap
msgid ""
".subckt multiplier 1 2 3\n"
"*                        1 = input A (voltage)\n"
"*                        2 = input B (voltage)\n"
"*                        3 = output  (voltage)\n"
"* Note that there are scaling factors on inputs and output to keep\n"
"* diodes in the exponential region.\n"
".model dexp D EG=0 CJ=0 FC=0 gparallel=0\n"
"G1 0 4 1 0 1e-3\n"
"D1 4 0 dexp\n"
"G2 0 5 2 0 1e-3\n"
"D2 5 0 dexp\n"
"I3 0 6 1\n"
"D3 6 0 dexp\n"
"E1 7 0 4 0 1\n"
"E2 8 7 5 0 1\n"
"E3 8 9 6 0 1\n"
"V1 9 10 0\n"
"D4 10 0 dexp\n"
"H1 3 0 V1 1e6\n"
".ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:42
msgid "V1 1 0 0 V2 2 0 0.5 X1 1 2 3 multiplier R1 3 0 1"
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:52
#, fuzzy
#| msgid ""
#| ".options vmin=-1e5 vmax=1e5\n"
#| ".print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1.E3)\n"
#| ".!rm eg7_1.dat eg7_2.dat eg7_3.dat\n"
#| ".dc v1 0 1 0.01 > eg7_1.dat\n"
#| ".modify V2=100\n"
#| ".dc v1 0 1 0.01 > eg7_2.dat\n"
#| ".dc v1 0 1000 1 > eg7_3.dat\n"
#| ".end\n"
#| "</code>\n"
msgid ""
".options vmin=-1e5 vmax=1e5 .print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1."
"E3)  .!rm eg7_1.dat eg7_2.dat eg7_3.dat .dc v1 0 1 0.01 > eg7_1.dat .modify "
"V2=100 .dc v1 0 1 0.01 > eg7_2.dat .dc v1 0 1000 1 > eg7_3.dat .end </code>"
msgstr ""
".options vmin=-1e5 vmax=1e5\n"
".print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1.E3)\n"
".!rm eg7_1.dat eg7_2.dat eg7_3.dat\n"
".dc v1 0 1 0.01 > eg7_1.dat\n"
".modify V2=100\n"
".dc v1 0 1 0.01 > eg7_2.dat\n"
".dc v1 0 1000 1 > eg7_3.dat\n"
".end\n"
"</code>\n"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:60
msgid ""
"This example does not attempt to go beyond the multiplication of two "
"numbers, using the DC sweep to test a few ranges of the inputs.  The output "
"files can be plotted to check the linearity of the outputs.  If you wanted "
"to build a real circuit to perform analog multiplication, you would need "
"something a lot more complex than the above example because the dependent "
"voltage and current sources used in this example would not be possible to "
"construct in a real circuit."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:65
msgid ""
"Even with those ideal simulator components available, this example will "
"still only multiply correctly within a limited range. Using it outside that "
"range requires adjustment of the input and output scaling factors so that "
"the diodes themselves stay close to exponential functions."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:74
msgid ""
"This example introduces the concept of a subcircuit which is like a macro "
"facility for circuit simulation. The subcircuit is contained between the \"."
"subckt\" and \".ends\" lines and nodes within the subcircuit can use their "
"own numbering, independent of the outside world. The subcircuit gets a name "
"(in this case \"multiplier\") and the component \"X1\" becomes an instance "
"of that subcircuit. Note the way that probes can be put on devices inside "
"the subcircuit, for example \"X1.E1\" refers to the sub-component named "
"\"E1\" inside the subcircuit \"X1\"."
msgstr ""

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:79
msgid ""
"Another new command here is \".modify\". In this example, we want to test "
"the multiplier on a few DC sweeps but want to change the value of \"V2\" "
"between the sweeps. This allows a single batch run to test multiple "
"possibilities, or it can also be used interactively to trim a component "
"value into the value that gives the desired operating point."
msgstr ""

#. type: Title ======
#: manual/examples/nonlinear_devices_--_diodes.txt:1
#, no-wrap
msgid "Nonlinear Devices -- Diodes"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:11
msgid ""
"All of the previous circuits have been linear. This is to say that all the "
"devices (voltage sources, current sources, dependent source and resistors) "
"are linear devices and the overall \"shape\" of the problem does not change "
"as the values of the system are scaled up or down.  For example, if a "
"circuit is solved once, then after that all of the voltage sources in the "
"circuit are doubled, the circuit doesn't need to be solved a second time "
"because all the node voltages will merely be double those of the first "
"solution. Try it yourself if you disbelieve."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:18
msgid ""
"Linear circuits also obey the principle of \"superposition\" which is to say "
"that the circuit can be solved for each source separately and then all of "
"those solutions can be added up to get the solution of a circuit containing "
"many sources. A textbook in basic circuit theory will explain superposition "
"in linear circuits and you can try working through the textbook examples on "
"the simulator using what has been explained so far."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:22
msgid ""
"At this point, we take the step into nonlinear circuits which do NOT obey "
"superposition and do NOT scale. The most elementary nonlinear component is a "
"diode."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:24
msgid "eg6.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:27
#, no-wrap
msgid ""
"<code>\n"
"DIODE CASCADE\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:29
msgid ".model 1N414 D IS=2e-14"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:37
#, no-wrap
msgid ""
"Vcc  1   0   5\n"
"Dx   1  10   1N414\n"
"Dy  10  20   1N414\n"
"Dz  20  30   1N414\n"
"Rd1 10   0   1k\n"
"Rd2 20   0   1k\n"
"Rd3 30   0   1k\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:42
msgid ".print dc v(10) v(20) v(30)  .dc Vcc 0 5 0.5 >eg6.dat .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:45
msgid "You can run this example and look at the results like so:"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:51
#, no-wrap
msgid ""
"\tgnucap -b eg6.ckt\n"
"\tgnuplot\n"
"\tset style data lines\n"
"\tplot 'eg6.dat' using 1:2, 'eg6.dat' using 1:3, 'eg6.dat' using 1:4\n"
"\texit\n"
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:61
msgid ""
"You may not like using gnuplot and may prefer some other plotting program "
"such as gwave or gle. Gnucap output can be used by most plotting programs in "
"much the same manner as above by using the redirection arrow on the command "
"that runs the simulation (\"dc\" in this case). Note that it usually won't "
"work to redirect the normal output to a file using your shell and then cut "
"and paste that output into your plotting program because the normal output "
"does not use standard scientific notation, using the internal redirection "
"option provided also guarantees you get a nice, portable data file in "
"standard exponential notation."
msgstr ""

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:69
msgid ""
"If the above did work you should have been able to see the node voltages as "
"a function of supply voltage and see the diodes move into their conductive "
"band one by one. And see the traditional 0.7 volt drop across each diode.  "
"However, various diodes behave differently so gnucap needs to know what sort "
"of diode you are using. That is what the \".model\" command line is doing "
"for you -- it associated parameters in the diode model with a name that you "
"choose to assign to your diodes. (By the way, I have no idea what the true "
"measured parameters are for a real 1N414)."
msgstr ""

#. type: Title ======
#: manual/examples/phase_shift_oscillator.txt:1
#, no-wrap
msgid "Phase shift oscillator"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:3
#: manual/examples/simple_power_supply.txt:3
#, no-wrap
msgid "Getting started"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:6
msgid ""
"In this example, we will analyze a phase shift oscillator.  It was designed "
"in a hurry, so the specs are not expected to be very good.  We will see."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:8
msgid ""
"It uses a single BJT, plus an emitter follower, and runs on a single-ended "
"12 volt supply."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:10
msgid "Some measurements might include:"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Oscillation frequency\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Start-up time (how long it takes to stabilize)\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Distortion\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:16
msgid "Of course, we will look at the waveform."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:18
msgid ""
"I did this on the 2008-07-07 development snapshot, using some new features.  "
"I am not showing some of the mistake and trial steps, so your results may be "
"a little different."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:20
msgid ""
"I am using an external waveform viewer \"gwave\" to display the waveforms."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:22
msgid "That's enough for now, let's go..."
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:23
#, no-wrap
msgid "The circuit"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:26
msgid "{{gnucap:pso.tar.gz|Here's a netlist for the circuit:}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:43
#, no-wrap
msgid ""
"  ' phase shift oscillator\n"
"  .model npn npn bf=100\n"
"  Vcc (vcc 0) pulse(iv=0 pv=12 rise=.01)\n"
"  Rb1 (vcc b) 100k\n"
"  Rb2 (b 0)   10k\n"
"  Rc  (vcc c) 10k\n"
"  Re  (e 0)   1k\n"
"  Ce  (e 0)   5000u\n"
"  Re2 (e2 0)  1k\n"
"  Q1  (c b e)    npn\n"
"  Q2  (vcc c e2) npn\n"
"  C1  (e2 f1) .01u\n"
"  C2  (f1 f2) .01u\n"
"  C3  (f2 b)  .01u\n"
"  Rf1 (f1 0)  10k\n"
"  Rf2 (f2 0)  10k\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:45
msgid "There are some tricks here .."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:47
msgid ""
"First, the power supply (Vcc).  It is a voltage source, but instead of just "
"saying \"DC=12\" to make it a constant 12 volt supply, I made it a pulse.  "
"It starts at zero, and waits until time=.01 to switch on.  I did this "
"because I want to see how it starts."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:49
msgid ""
"With just plain \"DC=12\" it would still oscillate, but I cannot be sure of "
"the actual start waveform.  For one, the emitter bypass would already be "
"charged."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:51
msgid "Next, I used a simple model of the BJT, specifying only the beta."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:53
msgid ""
"The emitter bypass gives a time constant of 5 seconds, which should make the "
"start-up nice and slow."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:55
msgid ""
"Finally, to show some contempt for good design, I just picked R and C for "
"the filter arbitrarily, with no real idea what the frequency would be."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:72
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2008.07.07 RCS 26.86\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get pso.ckt\n"
"  ' phase shift oscillator\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:74
msgid "Load the circuit .. it echos the title line."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:76
msgid "As a check, list it, see if it is what you expected."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:95
#, no-wrap
msgid ""
"  gnucap> list\n"
"  .model npn npn ( level=1 kf=NA( 0.) af=NA( 1.) bf= 100. br=NA( 1.) is=NA( 100.E-18) nf=NA( 1.) nr=NA( 1.) isc=NA(\n"
"   0.) re=NA( 0.) rc=NA( 0.) cjc=NA( 0.) cje=NA( 0.) cjs=NA( 0.) fc=NA( 0.5) mjc=NA( 0.33) mje=NA( 0.33) mjs=NA( 0.)\n"
"   tf=NA( 0.) tr=NA( 0.) xtf=NA( 0.) xtb=NA( 0.) xti=NA( 3.) eg=NA( 1.11))\n"
"  Vcc ( vcc 0 ) pulse iv= 0. pv= 12. delay=NA( 0.) rise= 0.01 fall=NA( 0.) width=NA( Inf) period=NA( Inf)\n"
"  Rb1 ( vcc b )  100.K\n"
"  Rb2 ( b 0 )  10.K\n"
"  Rc ( vcc c )  10.K\n"
"  Re ( e 0 )  1.K\n"
"  Ce ( e 0 )  0.005\n"
"  Re2 ( e2 0 )  1.K\n"
"  Q1 ( c b e )  npn NA( 1.)\n"
"  Q2 ( vcc c e2 )  npn NA( 1.)\n"
"  C1 ( e2 f1 )  10.n\n"
"  C2 ( f1 f2 )  10.n\n"
"  C3 ( f2 b )  10.n\n"
"  Rf1 ( f1 0 )  10.K\n"
"  Rf2 ( f2 0 )  10.K\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:97
msgid ""
"Looks good ..  note the \"NA\" fields ....  NA(5) means that the value is "
"unspecified, but assumed to be 5.  You can see what parameters were "
"specified, and which took the defaults."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:99
msgid "Before making a run, you need to set a few things up ..."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:102
#, no-wrap
msgid ""
"Pick the points you want to view (all node voltages):\n"
"  gnucap> print tran v(nodes)\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:105
#, no-wrap
msgid ""
"Pick the points you want to be able to do things like \"measure\" on (all probes named \"v\" on anything, including nodes, devices, etc):\n"
"  gnucap> store tran v(*)\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:114
#, no-wrap
msgid ""
"Now, check the options.  We may want to change some:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7\n"
"  0  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6  itl4=20  itl5=5000\n"
"  er  dampmax= 1.  dampmin= 0.5  dampstrategy=0  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  s\n"
"  ansits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtm\n"
"  old= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2= 0.04166667  trstepcoe\n"
"   units=spice\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:117
#, no-wrap
msgid ""
"The only one I will change now is the printing precision .. Set it to 8 digits.  Starting an oscillator takes a long time.\n"
"  gnucap> opt numdgt=8\n"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:118
#, no-wrap
msgid "Get started, run to steady state"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:121
msgid ""
"For starters, let's run it for 10 seconds, with a trial time step of .01.  "
"\"trace all\" says to output all of the internal time steps too.  Otherwise, "
"you will just get the ones you asked for."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:123
msgid ""
"I directed it to a file, boringly called \"z\".  Then look at it with \"gwave"
"\".  The bang (!) says to run a command through the shell.  The ampersand "
"(&) says to leave it running and return, just like a shell command.  That "
"way we can keep the waveforms on the screen and keep going."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:126
#, no-wrap
msgid ""
"  gnucap> tran 0 10 .01 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:132
msgid ""
"Here's the waveform.  It looks like it doesn't start oscillating until about "
"1 second.  Then takes until about 5 seconds to settle.  It looks like 10 "
"seconds was a good guess."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:134
msgid "{{gnucap:w1.png}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:136
msgid "Here's an expanded view just as it starts to oscillate:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:138
msgid "{{gnucap:w7.png}}"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:140
msgid "The last few cycles at the end of the run:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:142
msgid "{{gnucap:w8.png}}"
msgstr ""

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:143
#, no-wrap
msgid "The measurements we want"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:146
msgid ""
"Now, tighten the tolerance, so we can get good measurements.  The default "
"settings are fine most of the time, but for this we need better."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:156
#, no-wrap
msgid ""
"See what they are:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7.  chgtol= 10.f  pivtol= 100.f\n"
"  pivrel= 0.001  numdgt=8  tnom= 27.  cptime=30000  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6\n"
"  itl4=20  itl5=5000  itl6=0  itl7=1  itl8=99  defl= 100.u  defw= 100.u  defad= 0.  defas= 0.  clobber  dampmax= 1.  dampmin= 0.5  dampstrategy=0\n"
"  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  short= 10.u  out=9999  ydivisions= 4.  phase=degrees  order=auto  mode=mixed\n"
"  transits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtmin= 1.p  dtratio= 1.G  rstray\n"
"  cstray  harmonics=9  trstepgrow= 1.E+99  trstephold= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2=\n"
"  0.04166667  trstepcoef3= 0.005208333  noquitconvfail  edit  recursion=20  language=acs  insensitive  units=spice\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:159
#, no-wrap
msgid ""
"Now tighten \"reltol\" and \"trtol\".\n"
"  gnucap> opt reltol=.0001 trtol=1\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:163
#, no-wrap
msgid ""
"and run for another .01 seconds, continuing...\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:172
#, no-wrap
msgid ""
"and make some measurements...\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.00943\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.00778\n"
"  gnucap> param frequency={1/(t2-t1)}\n"
"  gnucap> eval frequency\n"
"  frequency= 606.060606060714\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:174
msgid ""
"For the Fourier analysis, pick a fundamental of half of the real "
"fundamental, as an indicator of accuracy.  We all know, there should be "
"nothing there.  If the component at the odd frequencies is too big, it means "
"the frequency we specified is slightly in error, and we need to tighten "
"tolerances and fine tune."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:183
#, no-wrap
msgid ""
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 303.030303030357\n"
"  gnucap> print fourier v(e2)\n"
"  gnucap> fourier 0 10k 303.030303030357\n"
"  #Time          v(e2)\n"
"   10.0133       8.9974012\n"
"   10.013326     8.7969959\n"
"   10.013352     8.5847199\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:197
#, no-wrap
msgid ""
"   10.016574     9.0517243\n"
"   10.0166       8.8549586\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0656      16.98   90.000  2.2861       7.18  -44.748\n"
"   303.03     0.034076   -29.35  118.607  0.011025   -39.15  -16.141\n"
"   606.06     3.0907       9.80  134.748  1.           0.00    0.000\n"
"   909.09     0.040746   -27.80  -43.182  0.013183   -37.60 -177.930\n"
"   1.2121K    0.3894      -8.19  -94.915  0.12599    -17.99  130.337\n"
"   1.5152K    0.017954   -34.92   17.761  0.0058088  -44.72 -116.987\n"
"   1.8182K    0.15704    -16.08    4.083  0.05081    -25.88 -130.665\n"
"   2.1212K    0.0042367  -47.46   67.220  0.0013708  -57.26  -67.528\n"
"   2.4242K    0.079307   -22.01   94.762  0.02566    -31.82  -39.986\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:199
msgid "303 Hz has a relative amplitude of -39 db.  Not very good."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:201
msgid "Tighten the tolerances and measure again:"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:206
#, no-wrap
msgid ""
"  gnucap> opt reltol=.00001 trtol=1\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= Inf\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:208
msgid ""
"Error ....  we already went past 10.01 seconds ..  Move ahead and try again."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:224
#, no-wrap
msgid ""
"  gnucap> tran 10.03 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.02911\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.02747\n"
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 304.878048780472\n"
"  gnucap> eval frequency\n"
"  frequency= 609.756097560944\n"
"  gnucap> fourier 0 10k 304.878048780472\n"
"  #Time          v(e2)\n"
"   10.029986     6.3978311\n"
"   10.030012     6.1507251\n"
"   10.030037     5.9090503\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:248
#, no-wrap
msgid ""
"   10.033189     7.1588976\n"
"   10.033215     6.9059126\n"
"   10.03324      6.6531773\n"
"   10.033266     6.4023893\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0581      16.97   90.000  2.2836       7.17 -104.675\n"
"   304.88     256.82u    -71.81   -1.240  83.092u    -81.61  164.086\n"
"   609.76     3.0908       9.80 -165.325  1.           0.00    0.000\n"
"   914.63     0.0011098  -59.09 -171.143  359.08u    -68.90   -5.817\n"
"   1.2195K    0.38362     -8.32   21.927  0.12412    -18.12 -172.748\n"
"   1.5244K    103.52u    -79.70  178.156  33.493u    -89.50  -16.518\n"
"   1.8293K    0.14832    -16.58 -177.459  0.047988   -26.38  -12.133\n"
"   2.1341K    357.2u     -68.94 -179.519  115.57u    -78.74  -14.193\n"
"   2.439K     0.079273   -22.02  -23.966  0.025648   -31.82  141.360\n"
"   2.7439K    132.94u    -77.53 -126.976  43.011u    -87.33   38.350\n"
"   3.0488K    0.049584   -26.09  126.722  0.016043   -35.89  -67.952\n"
"   3.3537K    168.29u    -75.48  163.828  54.45u     -85.28  -30.847\n"
"   3.6585K    0.033637   -29.46  -84.750  0.010883   -39.27   80.575\n"
"   3.9634K    163.24u    -75.74 -138.899  52.816u    -85.54   26.426\n"
"   4.2683K    0.024012   -32.39   63.711  0.0077689  -42.19 -130.964\n"
"   4.5732K    52.818u    -85.54  168.840  17.089u    -95.35  -25.834\n"
"   4.878K     0.018021   -34.88 -148.890  0.0058308  -44.69   16.435\n"
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:250
msgid "That's better.  Noise is -68 db or better.  305 Hz is -81 db."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:252
msgid ""
"As I said, the oscillator isn't very good.  The second harmonic is only 18 "
"db below the fundamental."
msgstr ""

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:253
msgid "Enough for now..."
msgstr ""

#. type: Title ======
#: manual/examples/resistors_and_sources.txt:1
#, no-wrap
msgid "Resistors and sources"
msgstr "Резисторы и источники напряжения и тока"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:6
msgid ""
"The previous example covers enough concepts to model arbitrarily complex "
"networks of resistors and sources. These are essentially linear circuits "
"that have no relation to time. A more elaborate example is presented below:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:8
msgid "eg2.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:21
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND VOLTAGE SOURCES\n"
"V1 2 1 10\n"
"V2 4 3 5\n"
"V3 0 3 3\n"
"R1 1 2 220\n"
"R2 2 3 4.7k\n"
"R3 4 5 3.3k\n"
"R4 3 5 10k\n"
"R5 0 1 22k\n"
"R6 0 5 15k\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:23
msgid "Run this with:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:32
#, no-wrap
msgid ""
"<code>\n"
"gnucap> get eg2.ckt\n"
"gnucap> print dc v(1) v(2) v(3) v(4) v(5)\n"
"gnucap> dc\n"
"#           v(1)       v(2)       v(3)       v(4)       v(5)\n"
" 0.        -10.712    -0.71161   -3.         2.         0.65161\n"
"gnucap>\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:34
msgid ""
"Note that this is about the limit of what can be done with these two "
"components. Other components that offer further possibilities are the "
"current source (any component with a name that begins with \"I\" is a "
"current source) and the dependent sources:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:40
#, no-wrap
msgid ""
"|first letter of name |output type |input type |\n"
"|E                    |voltage     |voltage    |\n"
"|F                    |current     |current    |\n"
"|G                    |current     |voltage    |\n"
"|H                    |voltage     |current    |\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:49
msgid ""
"Each of these has a gain value expressing the relation between its output "
"and its input and they allow the modeling of linear amplifiers and other "
"such devices. As mentioned above, none of these components understand time "
"nor can they be used to represent a nonlinear device.  Thus, any network "
"constructed from the components that have been seen so far will be reducible "
"to a Thevenin or Norton equivalent circuit when considered from the point of "
"view of one particular node and the ground node 0."
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:51
msgid "eg3.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:77
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND DEPENDENT SOURCES\n"
"*\n"
"* Reduce this complicated collection of dependencies\n"
"* down to a single Thevenin equivalent between node 2 and\n"
"* the ground node 0\n"
"*\n"
"I1 1 4 2\n"
"V1 1 0 5\n"
"E1 5 2 1 3 0.4\n"
"F1 5 6 R1 3e-2\n"
"G1 2 3 4 6 1.3\n"
"H1 3 0 R3 1\n"
"R1 4 5 2.2\n"
"R2 1 2 470\n"
"R3 0 2 330\n"
"R4 3 6 1k\n"
"R5 5 6 1e4\n"
"*\n"
"* Look at the voltage at node 2 and the impedance looking into node 2\n"
"*\n"
".print dc v(2) z(2)\n"
".dc\n"
".end\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:86
msgid ""
"Notice that this example file contains some lines that begin with a dot.  "
"These are command lines and behave exactly like the commands you type in "
"interactive mode. These command lines are dotted because of the old SPICE "
"tradition of executing all of the component lines first and then the command "
"lines, gnucap doesn't bother with this, it executes every line in the order "
"that it sees them, but it still follows the old idea of dotting the command "
"lines as a little tribute to SPICE and to make it easier to see what is "
"going on when you read a .ckt file."
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:88
msgid "When you run this example, you might try:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:90
#, no-wrap
msgid "  gnucap -b eg3.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:97
msgid ""
"And (all going well) you will see that node 2 is equivalent to a source of "
"54.343 volts in series with an 0.83888 ohm resistor.  You should also notice "
"that gnucap never goes into interactive command mode.  This is because of "
"the \".end\" command that tells gnucap to finish at this point.  You may "
"want to use this example circuit in interactive mode, to achieve this you "
"could either delete the \".end\" command, or (from the system prompt) type:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:100
#, no-wrap
msgid ""
"  gnucap\n"
"  get eg3.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:104
msgid ""
"Then you can use other interactive commands. Note that you can modify the "
"circuit interactively too. Consider adding another resistor by typing the "
"following at the interactive prompt:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:108
#, no-wrap
msgid ""
"  build R3\n"
"  R6 3 4 12k\n"
"  <blank line>\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:114
msgid ""
"Which allows you to adjust the topology of the circuit in memory. This "
"includes adding components and modifying existing components. You can "
"interactively remove components from the circuit using the \"delete\" "
"command or you can wipe out the entire circuit using the \"clear\" command.  "
"To put the adjusted topology into a file you use the save command:"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:118
#, no-wrap
msgid ""
"  save eg3_mod.ckt\n"
"  quit\n"
"  cat eg3_mod.ckt\n"
msgstr ""

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:124
msgid ""
"Looking at what you have saved you will probably notice a few things: "
"firstly, gnucap has remembered your comment lines and command lines and "
"saved them too; secondly, your extra line was inserted into the file before "
"the line containing component \"R3\", this is caused by the argument on the "
"\"build\" command and allows you to insert your build lines where you want "
"them."
msgstr ""

#. type: Title ======
#: manual/examples/simple_power_supply.txt:1
#, no-wrap
msgid "A simple power supply"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:6
msgid "In this example, we will analyze a simple power supply."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:8
msgid ""
"The power supply consists of a \"lump\" power transformer with fairly loose "
"coupling for short circuit protection, a full wave bridge rectifier, and a "
"filter capacitor.  The desired output is about 50 volts at .5 amps (100 Ohm "
"load), with less than 1 volt of ripple.  The power supply should be able to "
"handle a short with no damage, with no fuse."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:10
msgid ""
"An inexperienced engineer has chosen a transformer with primary inductance "
"of 1 Henry, secondary inductance of .1 Henry, a turns ratio of 3.16:1.  The "
"stock transformer has a coefficient of coupling of .9.  He has also chosen "
"1N4004 diodes, and a 5000 uf filter capacitor."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:12
msgid ""
"The first goal of simulation is to validate the design.  Then, make "
"adjustments to the design to meet the specs."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:14
msgid ""
"To validate the design, the following measurements need to be made, not "
"necessarily in this order."
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "DC output voltage, loaded (100 Ohm) and unloaded.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Ripple voltage.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Current in diodes: waveform, average, steady state peak, power-on surge, AC.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Current in filter cap: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input current: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input power, VAR, and power factor: as above\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Above currents and power for load = nominal (100 Ohm), unloaded, and shorted (.01 Ohm)\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Diode voltages, PIV, etc.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Transformer voltages\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Impact of high line (132 volts) and low line (108 volts)\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:27
msgid ""
"This example will show how to do some of these.  The rest are left as an "
"exercise.  You can make all of these measurements with gnucap."
msgstr ""

#. type: Title =====
#: manual/examples/simple_power_supply.txt:29
#, no-wrap
msgid "Building the circuit"
msgstr ""

#. type: Title ====
#: manual/examples/simple_power_supply.txt:31
#, no-wrap
msgid "Models"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:34
msgid "First, let's make subcircuits for the transformer and diode bridge:"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:40
#, no-wrap
msgid ""
"  .subckt transformer (p1 p2 s1 s2)\n"
"  L1 (p1 p2) 1\n"
"  L2 (s1 s2) .1\n"
"  K1 (L1 L2) .9\n"
"  .ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:48
#, no-wrap
msgid ""
"  .subckt bridge (in1 in2 minus plus)\n"
"  .model 1n4004 d is=1n\n"
"  D1 (in1 plus) 1n4004\n"
"  D2 (in2 plus) 1n4004\n"
"  D3 (minus in1) 1n4004\n"
"  D4 (minus in2) 1n4004\n"
"  .ends\n"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:50
msgid "Save it in the file \"models\"."
msgstr ""

#. type: Title ====
#: manual/examples/simple_power_supply.txt:51
#, no-wrap
msgid "Main circuit"
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:54
msgid "Now, let's run it interactively..  Type in the circuit..."
msgstr ""

#. type: Plain text
#: manual/examples/simple_power_supply.txt:68
#, no-wrap
msgid ""
"  $ gnucap\n"
"  ..... (signs on)\n"
"  gnucap> include models\n"
"  gnucap> list\n"
"     ..... (list of circuit so far)\n"
"  gnucap> spice\n"
"  gnucap-spice>Vin (in 0) sin (freq=60 ampl=170) ac 120\n"
"  gnucap-spice>X1 (in 0 s1 s2) transformer\n"
"  gnucap-spice>X2 (s1 s2 0 out) bridge\n"
"  gnucap-spice>Rload (out 0) rload\n"
"  gnucap-spice>Cfilter (out 0) cfilter\n"
"  gnucap-spice>.control\n"
"  gnucap>\n"
msgstr ""

#. type: Title =====
#: manual/examples/simple_power_supply.txt:69
#, no-wrap
msgid "Simulate"
msgstr ""

#. type: Title ====
#: manual/examples/simple_power_supply.txt:71
#, no-wrap
msgid "Set up and first run"
msgstr ""

#. type: Title ======
#: manual/examples/things_that_can_go_wrong.txt:1
#, no-wrap
msgid "Things that can go wrong"
msgstr ""

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:3
#, no-wrap
msgid "Voltage sources in parallel"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:6
msgid "eg4.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:9
#, no-wrap
msgid ""
"<code>\n"
"VOLTAGE SOURCES IN PARALLEL\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:16
msgid "V1 1 0 10.0 V2 1 0 10.2 .print dc v(1) i(V1) i(V2)  .dc .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:26
msgid ""
"Here we have V1 and V2 both driving the same node at about 10 volts.  "
"Actually, V2 is very slightly higher than 10 volts so there will be some "
"argument between V1 and V2 as to exactly what the final voltage at node 1 "
"really is. You should see that huge currents are flowing through the "
"supplies (10,000 amps) just due to this small voltage difference. Also note "
"that gnucap does not throw in the towel and give up, nor does it fail to "
"converge... the answer that it gets for v(1)  is a compromise, halfway "
"between the two sources."
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:31
msgid ""
"What is does is introduce a slight imperfection in the voltage sources so "
"that they do have a small internal series resistor. This allows it to make "
"the best guess that it can in a difficult situation. How much is this "
"resistance? You can find out like so:"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:34
#, no-wrap
msgid ""
"\tacs\n"
"\toptions\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:41
msgid ""
"Look at the value of the option called \"short\" (near the middle of the "
"block of options), this is the value (in ohms) of the internal resistance of "
"a voltage source. The \"u\" character means \"micro\" or 1e-6 so the default "
"value of a short circuit is 1e-5 ohms. You might decide that a different "
"short circuit value is more appropriate for running the above circuit so you "
"can type (from the prompt):"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:46
#, no-wrap
msgid ""
"\toptions short=0.5\n"
"\tget eg4.ckt\n"
"\tdc\n"
"\texit\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:53
msgid ""
"Which should show you the same voltage (10.1) but now the current has "
"reduced to only one fifth of an Amp (still not small but a lot more "
"reasonable if you were building this with real supplies).  Other option "
"values can be altered in much the same way and input files can contain \"."
"options\" command lines in order to set these options whenever the circuit "
"is loaded."
msgstr ""

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:54
#, no-wrap
msgid "Current sources in series"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:57
msgid "eg5.ckt"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:60
#, no-wrap
msgid ""
"<code>\n"
"CURRENT SOURCES IN SERIES\n"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:67
msgid "I1 0 1 2.0001 I2 1 0 2.0 .print dc v(1) i(I1) i(I2)  .dc .end </code>"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:77
msgid ""
"The case of putting two current sources in series is much the same concept "
"as two voltage sources in parallel. However notice that gnucap copes with it "
"in a different manner. It cannot find a compromise current that is partway "
"between the two sources and it always gives a huge value for the voltage at "
"node 1. At least it doesn't crash and it does give results that give some "
"suggestion as to where the problem might be. There is an option \"gmin\" "
"that introduces resistance into a current source, or you can explicitly add "
"these resistors if you like by putting the resistor in parallel with the "
"current source."
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:82
msgid ""
"What if you had a big, complex circuit, you messed up by putting two current "
"sources in series but you never thought about checking the strange node? How "
"would you ever know that the circuit was broken? Try this exercise:"
msgstr ""

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:88
#, no-wrap
msgid ""
"\tacs\n"
"\tget eg5.ckt\n"
"\talarm dc v(*)(-1e3,1e3)\n"
"\tdc\n"
"\tquit\n"
msgstr ""
"\tacs\n"
"\tget eg5.ckt\n"
"\talarm dc v(*)(-1e3,1e3)\n"
"\tdc\n"
"\tquit\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:93
msgid ""
"Now you get a warning whenever any component gets more that 1000 volts "
"across it. This can be used to test component breakdown if you know that you "
"are using components that cannot tolerate high voltages. It can also be used "
"to ensure that your simulated circuit stays within what you might expect to "
"be the absolute maximum values."
msgstr ""

#. type: Title ======
#: manual/howto.txt:1
#, no-wrap
msgid "How to"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:probes]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:expressions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:measure|measurements]]\n"
msgstr ""

#. type: Title ======
#: manual/howto/expressions.txt:1
#, fuzzy, no-wrap
#| msgid "  eval expression\n"
msgid "Parameter expressions"
msgstr "  eval выражение\n"

#. type: Plain text
#: manual/howto/expressions.txt:4
msgid "Gnucap supports expressions for almost all parameters."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:6
msgid ""
"Ideally, the usual syntax is supported.  Actually, in some cases you must "
"enclose the expression in quotes or curly braces."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:8
msgid ""
"Expressions use late evaluation and dynamic scoping, like a functional "
"language."
msgstr ""
"В выражениях используются отложенные вычисления и динамический контекст, как "
"в функциональных языках программирования."

#. type: Plain text
#: manual/howto/expressions.txt:10
msgid ""
"The \"eval\" command evaluates and prints the present value of an expression."
msgstr ""
"Команда [[..:commands:eval.ru|eval]] оценивает и выводит текущее значение "
"выражения."

#. type: Plain text
#: manual/howto/expressions.txt:12
msgid ""
"The \"measure\" command evaluates and assigns the present value of an "
"expression.  For now, it only takes simple function calls used in "
"measurements."
msgstr ""
"Команда [[measure.ru|measure]] оценивает и присваивает текущее значение "
"выражения. На данный момент она принимает только простые вызовы функций, "
"используемые в измерениях."

#. type: Plain text
#: manual/howto/expressions.txt:21
#, no-wrap
msgid ""
"  gnucap> param a=5\n"
"  gnucap> param b=a+3\n"
"  gnucap> eval a\n"
"  a= 5.\n"
"  gnucap> eval b\n"
"  b= 8.\n"
msgstr ""
"  gnucap> param a=5\n"
"  gnucap> param b=a+3\n"
"  gnucap> eval a\n"
"  a= 5.\n"
"  gnucap> eval b\n"
"  b= 8.\n"

#. type: Plain text
#: manual/howto/expressions.txt:23
msgid "Now change the value of \"a\"."
msgstr "Теперь изменим значение «a»."

#. type: Plain text
#: manual/howto/expressions.txt:27
#, no-wrap
msgid ""
"  gnucap> param a=9\n"
"  gnucap> eval b\n"
"  b= 12.\n"
msgstr ""
"  gnucap> param a=9\n"
"  gnucap> eval b\n"
"  b= 12.\n"

#. type: Plain text
#: manual/howto/expressions.txt:29
msgid "Thanks to late evaluation, the value of \"b\" also changed."
msgstr "Благодаря отложенным вычислениям значение «b» также изменилось."

#. type: Plain text
#: manual/howto/expressions.txt:31
msgid "This is so you can do things like this:"
msgstr "Поэтому вы можете делать следующее:"

#. type: Plain text
#: manual/howto/expressions.txt:34
#, no-wrap
msgid ""
"  r1 (in out) resistor r={rtotal*ratio}\n"
"  r2 (out 0)  resistor r={rtotal*(1-ratio)}\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:37
#, no-wrap
msgid ""
"  param rtotal=100k\n"
"  param ratio=.5\n"
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:39
msgid "r1 and r2 are both 50k."
msgstr "r1 и r2 оба по 50k."

#. type: Plain text
#: manual/howto/expressions.txt:41
#, no-wrap
msgid "  param rtotal=10k\n"
msgstr "  param rtotal=10k\n"

#. type: Plain text
#: manual/howto/expressions.txt:43
msgid "r1 and r2 are both 5k."
msgstr "r1 и r2 оба по 5k."

#. type: Plain text
#: manual/howto/expressions.txt:45
#, no-wrap
msgid "  param ratio = .3\n"
msgstr "  param ratio = .3\n"

#. type: Plain text
#: manual/howto/expressions.txt:47
msgid "r1 is 3k.  r2 is 7k."
msgstr "Сопротивление r1 равно 3k,  r2 равно 7k."

#. type: Title =====
#: manual/howto/expressions.txt:48
#, no-wrap
msgid "Operators"
msgstr "Операторы"

#. type: Plain text
#: manual/howto/expressions.txt:51
msgid ""
"The usual binary operators (+ - * /) are supported in the usual way with the "
"usual precedence."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:53
msgid ""
"The usual comparison operators ( < > <''''= >= == != ) are supported.  The "
"result is 1 if it evaluates to true, 0 if it evaluates to false."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:55
msgid "The binary operators (&& ||) are supported, and evaluate to 1 or 0."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:59
msgid ""
"These functions are included by default.  More functions can be added as "
"plugins."
msgstr ""

#. type: Plain text
#: manual/howto/expressions.txt:73
#, no-wrap
msgid ""
"|abs(x)    |Magnitude of x.  |\n"
"|cos(x)    |Cosine of x.  |\n"
"|cosh(x)   |Hyperbolic cosine of x.  |\n"
"|eval(x)   |Evaluate x.  |\n"
"|exp(x)    |e raised to the x power.  |\n"
"|int(x)    |Integer part of x.  |\n"
"|log(x)    |Natural log of x.  |\n"
"|na(x)     |\"Not available\".  Returns \"NA\" regardless of its argument.  |\n"
"|pow(x,y)  |x raised to the y power.  |\n"
"|sin(x)    |Sine of x.  |\n"
"|sinh(x)   |Hyperbolic sine of x.  |\n"
"|sqrt(x)   |Square root of x.  |\n"
"|tan(x)    |Tangent of x.  |\n"
"|tanh(x)   |Hyperbolic tangent of x.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:4
msgid ""
"Gnucap offers a comprehensive set of probes.  This section lists system "
"probes, node probes, and common element probes."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:6
msgid ""
"Probes always have the syntax name_of_probe(device_or_node).  Example: vdd"
"(m1)."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:8
msgid ""
"You can access components in subcircuits by connecting the names with dots. "
"For example: Xone.X67.R56 is R56 in X67 in Xone. Some built-in elements, "
"including diodes, transistors, and mosfets, contain subcircuits with "
"internal elements. M12.Cgd is the gate to drain capacitor of mosfet M12."
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:9
#, no-wrap
msgid "System probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:12
msgid "For system probes, use the device name \"0\"."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:21
#, no-wrap
msgid ""
"|iter       |The number of iterations needed for convergence for this printed step including any hidden steps.  |\n"
"|bypass     |Prints a code indicating whether model evaluation can be bypassed.\\\\  0=bypass turned off by user.\\\\  1=bypass enabled by user, but not active now.\\\\  11=bypass is possible.  |\n"
"|control    |A number indicating why the simulator chose this time to simulate at.\\\\  1=The user requested it. One of the steps in a sweep.\\\\  2=A scheduled discrete event. An element required a solution at this time.\\\\  3=The effect of the “skip” parameter.\\\\  4=The iteration count exceeded ITL4 so the last step was rejected and is being redone at a smaller time step.\\\\  5=The iteration count exceeded ITL3 so the increase in time step is limited.\\\\  6=Determined by local truncation error or some other device dependent approximation in hopes of controlling accuracy.\\\\  7=Determined by a movable analog event. An element required a solution at this time.\\\\  8=The step size was limited due to iteration count.\\\\  9=This is an initial step. The size was arbitrarily set to 1/100 of the user step size.\\\\  10+x=The previous step was rejected.\\\\  20+x=A zero time step was replaced by mrt.\\\\  30+x=The required step size less than mrt, so it was replaced by mrt.  |\n"
"|damp       |Newton damping factor.  |\n"
"|generator  |The output of the “signal generator”. In a transient analysis, it shows the output of the signal generator, as set up by the generator command. In a DC analysis, it shows the DC input voltage (not the power supply). In an OP analysis, it shows the DC input, normally zero.  |\n"
"|hidden     |The number of hidden steps.  |\n"
"|temp       |The simulation temperature in degrees Celsius.  |\n"
"|time       |The current time in a transient analysis. In AC analysis it shows the time at which the bias point was set, 0 if it was set in a DC or OP analysis, or -1 if it is the bias was not set (power off).  |\n"
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:22
#, no-wrap
msgid "Node probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:25
msgid "All modes."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:30
#, no-wrap
msgid ""
"|v    |Voltage.  |\n"
"|z    |Impedance looking into the node.  |\n"
"|mdy  |Matrix diagonal \"y\".  |\n"
"|mdz  |Matrix diagonal \"z\".  (1/mdy)  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:32
msgid "Transient, DC, OP, only."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:38
#, no-wrap
msgid ""
"|logic  |A numeric interpretation of the logic value at the node. The value is displayed encoded in a number of the form a.bc where\\\\ \\\\ a is the logic state:\\\\ 0 = logic 0\\\\ 1 = rising\\\\ 2 = falling\\\\ 3 = logic 1\\\\ \\\\ b is an indication of the quality of the digital signal.\\\\ 0 is a fully valid logic signal.\\\\ Nonzero indicates it does not meet the criteria for logic simulation.\\\\ \\\\ c indicates how the node was calculated:\\\\ 0 indicates logic simulation.\\\\ 1 indicates analog simulation of a logic device.\\\\ 2 indicates analog simulation of analog devices.  |\n"
"|lastchange  |The most recent time at which the logic state changed.  |\n"
"|finaltime   |The scheduled time a pending logic state change will occur.  |\n"
"|diter       |Iteration number for last digital update.  |\n"
"|aiter       |Iteration number for last analog update.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:40
msgid "AC only."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:42
msgid ""
"In addition to those listed here, you can add a suffix (M, P, R, I and db) "
"for magnitude, phase, real part, imaginary part, and decibels, to any valid "
"probe."
msgstr ""

#. type: Title =====
#: manual/howto/probes.txt:43
#, no-wrap
msgid "Element probes"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:46
msgid ""
"Each element type has several parameters that can be probed. In general, the "
"form is Parameter(element). Wild cards are allowed in element names to allow "
"probing the same parameter of a group of elements."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:48
msgid ""
"For components in a subcircuit, the names are connected with dots. For "
"example X13.R12 is R12 in the subcircuit X13."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:54
msgid "All devices:"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:59
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second port.  |\n"
"|errortime      |Suggestion of next time point based on truncation or interpolation error.  |\n"
"|eventtime      |Suggestion of next time point based on movable events.  |\n"
"|timefuture     |Suggestion of next time point, the sooner of errortime and eventtime.  |\n"
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:63
msgid ""
"Most elements,\\\\ devices that do not have an internal subcircuit,\\\\ "
"devices that can be defined simply by y=f(x)."
msgstr ""

#. type: Plain text
#: manual/howto/probes.txt:86
#, no-wrap
msgid ""
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for four terminal devices. The first node in the net list is assumed positive.  |\n"
"|vin       |Input voltage.  The voltage across the “input” terminals. For two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power indicates that the part is supplying power. Its value is the same as (PD - PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is always positive and does not consider its own dissipation.  |\n"
"|input     |The “input” of the device. It is the current through a resistor or inductor, the voltage across a capacitor or admittance, etc. It is the value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is the voltage across a resistor, the charge stored in a capacitor, the flux in an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is also the effective value of the part, in its units. If the part is ordinary, it will just show its value, but if it is time variant or nonlinear, it shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|z         |Circuit impedance seen by this device, with this device not counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this device.  Prints a meaningless number in transient analysis.  |\n"
msgstr ""

#. type: Title ======
#: manual/languages.txt:1
#, no-wrap
msgid "Languages"
msgstr ""

#. type: Plain text
#: manual/languages.txt:4
msgid ""
"By use of plugins, Gnucap gives you a choice of simulation languages.  The "
"following are the simulation languages supported in this release."
msgstr ""
"Использование плагинов в Gnucap позволяет вам выбрать язык моделирования. В "
"настоящей версии программы поддерживаются следующие языки:"

#. type: Plain text
#: manual/languages.txt:8
msgid ""
"[[gnucap:manual:languages:Verilog]]\\\\ [[gnucap:manual:languages:Spectre]]\\"
"\\ [[gnucap:manual:languages:Spice]]\\\\ [[gnucap:manual:languages:ACS]]"
msgstr ""
"[[gnucap:manual:languages:Verilog.ru|Verilog]]\\\n"
"[[gnucap:manual:languages:Spectre.ru|Spectre]]\\\n"
"[[gnucap:manual:languages:Spice.ru|Spice]]\\\n"
"[[gnucap:manual:languages:ACS.ru|ACS]]\n"

#. type: Title ======
#: manual/languages/spectre.txt:1
#, no-wrap
msgid "Language : Spectre"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:4
msgid ""
"The Spectre language plugin attempts to support the syntax of the Cadence "
"Spectre simulator."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:6
msgid ""
"Not all features of Spectre are supported, but those that work will work "
"with Spectre syntax.  Wherever possible, Gnucap features will work in "
"Spectre mode, even if they don't work in Spectre."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:8
msgid "The Spectre mode is case sensitive, and uses \"SI\" units."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:10 manual/languages/verilog.txt:10
msgid ""
"The \"SI\" units are case sensitive.  1p is 1e-12.  1P is 1e15.  1m is "
"1e-3.  1M is 1e6."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:12 manual/languages/verilog.txt:12
msgid "Comments are preceded by /****/ and extend to the end of the line."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:14
msgid ""
"The format is line oriented.  A newline terminates a statement.  You can "
"extend a line by ending it with \\ ."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:16
msgid "From startup, you can set Spectre mode with the command line:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:18
#, no-wrap
msgid "  simulator lang=spectre\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:20
msgid "or"
msgstr "или"

#. type: Plain text
#: manual/languages/spectre.txt:22
#, no-wrap
msgid "  spectre\n"
msgstr "  spectre\n"

#. type: Title ======
#: manual/languages/spectre.txt:23 manual/languages/verilog.txt:24
#, no-wrap
msgid "Components"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:26 manual/languages/verilog.txt:27
msgid "All components have the same syntax:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:28
#, no-wrap
msgid "  label (port list) type arguments\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 manual/languages/verilog.txt:34
#, no-wrap
msgid "**Label** : a string.  The first letter has no significance.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33
#, no-wrap
msgid "**Port list** : A list of the ports (connections), whitespace delimited.  Mapping is determined by order.  The port list should be surrounded by parentheses.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33
#, no-wrap
msgid "**Type** : The type of component.  If there is a \"model\" statement, this is the name in the model statement.  Otherwise, it could be the name of a \"subckt\", a Verilog \"module\" or \"paramset\", or a standard device.  This is called \"master\" in the Spectre manual.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name = value pairs, of the form \"name = value\", whitespace delimited.  The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:36
#, no-wrap
msgid ""
"  Rload (out 0) resistor r=10K\n"
"  X1 (out in vc) amp rload=100K\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:38
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Spectre mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:41
#, no-wrap
msgid ""
"  Vcc (vc  0) vsource  dc=15 // Spice-style source arguments are not supported.\n"
"  Vin (in  0) vsource  ac=1  // Spice-style source arguments are not supported.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:44 manual/languages/verilog.txt:46
msgid "But you can switch modes, to one that does support the syntax:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:53
#, no-wrap
msgid ""
"  // assume it is starting in Spectre mode\n"
"  - spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .spectre\n"
"  // Now it is back in Spectre mode.\n"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:54 manual/languages/verilog.txt:58
#, no-wrap
msgid "Top-level blocks"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:57
msgid "Two top level blocks are supported: model and subckt."
msgstr ""

#. type: Title =====
#: manual/languages/spectre.txt:58
#, no-wrap
msgid "model"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:61
msgid ""
"A \"model\" statement sets parameters based on an existing compiled model.  "
"This will be extended to cover all \"masters\".  It becomes a \"master\" "
"that can be instantiated later.  It is equivalent to a spice \".model\" or a "
"Verilog \"paramset\"."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:64
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"model\" newname itsmaster parameters\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69
#, fuzzy, no-wrap
#| msgid "Now you need a model statement ..."
msgid "**model** : Keyword identifies a model statement.\n"
msgstr "Теперь нужен оператор для модели ..."

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75
#, no-wrap
msgid "**newtype** : The new type being defined.  This can be used as a device type later.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75
#, no-wrap
msgid "**itsmaster** : The type it is derived from.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \"name = value\", whitespace delimited.  The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:71
#, no-wrap
msgid "  model gp_npn npn bf=150\n"
msgstr ""

#. type: Title =====
#: manual/languages/spectre.txt:72
#, no-wrap
msgid "subckt"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:88
#, no-wrap
msgid ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1   (base vcc)      resistor  r=1M  // 1 megohm\n"
"  Rb2   (base 0  )      resistor  r=100k\n"
"  Rc    (col  vcc)      resistor  r=100k\n"
"  Re    (emit 0  )      resistor  r=10k\n"
"  Ce    (emit 0  )      capacitor c=1m  // 1 millifarad\n"
"  Cin   (base in )      capacitor c=1u\n"
"  Q1    (col base emit) gp-npn\n"
"  Q2    (vcc col e2)    gp-npn\n"
"  Re2   (e2   0  )      resistor  r=1k\n"
"  Cout  (e2   out)      capacitor c=10u\n"
"  Rload (out 0  )       resistor  r=rload\n"
"  ends amp\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:93
#, no-wrap
msgid ""
"  X1    (out in vc)     amp      rload=100k\n"
"  Vcc   (vc  0)         vsource  dc=15\n"
"  Vin   (in  0)         vsource  ac=1\n"
"  Rload (out 0)         resistor r=10k\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:97
msgid ""
"Commands usually have the same syntax as components, but there is no port "
"list."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:99
msgid ""
"The Spectre mode does not introduce any new commands.  The only change is "
"the syntax."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:101
msgid ""
"In Spectre mode, there is a label before the command, like a component.  The "
"label names a file which will contain the results of the command.  The "
"filename extension is the command."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:103
msgid ""
"As an non-standard extension, using a dash '-' as the label sends the "
"command output to the standard output."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:105
msgid "Commands are executed in the order given."
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:109
#, no-wrap
msgid ""
"  setbias op\n"
"  response ac start=20 stop=20K dec=10\n"
"  - ac\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:111
msgid "This is equivalent to the native mode:"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:115
#, no-wrap
msgid ""
"  op >setbias.op\n"
"  ac start=20 stop=20K dec=10 >response.ac\n"
"  ac\n"
msgstr ""

#. type: Title ======
#: manual/languages/spectre.txt:116 manual/languages/verilog.txt:126
#, no-wrap
msgid "Extras"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:119
#, no-wrap
msgid "You can switch languages any time with the appropriate command.  The command must be in spectre syntax, with a label or dash first.  The command to switch back must be issued in the language you switched to.\n"
msgstr ""

#. type: Plain text
#: manual/languages/spectre.txt:123
msgid ""
"The current implementation in gnucap differs slightly from the Cadence "
"product."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid "The \"master\" must be defined before it is referenced.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127
#, no-wrap
msgid "The devices and commands are whatever gnucap has installed, which are probably different from what Spectre (the simulator) provides.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid "The circuit must be defined before any commands using it, unless you want to simulate a partial circuit.  Scripted and interactive modifications to the circuit are done the way gnucap usually does.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127
#, fuzzy, no-wrap
#| msgid "Builds a new circuit, with Spice syntax."
msgid "There is an interactive mode, with spectre syntax.\n"
msgstr "Построение новой схемы, используя синтаксис SPICE."

#. type: Title ======
#: manual/languages/verilog.txt:1
#, no-wrap
msgid "Language : Verilog"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:4
msgid ""
"The Verilog language plugin attempts to support the syntax of the Verilog-"
"AMS language."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:6
msgid ""
"Not all features of Verilog-AMS are supported, but those that work will work "
"with Verilog-AMS syntax.  Wherever possible, Gnucap features will work in "
"Verilog-AMS mode, even if they don't work in Verilog-AMS."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:8
msgid "The Verilog mode is case sensitive, and uses \"SI\" units."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:14
msgid ""
"The format is not line oriented.  A semicolon terminates a statement.  You "
"can extend a line by ending it with \\ ."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:16
msgid ""
"In gnucap, for now, you must have one statement per line.  This is non-"
"standard."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:18
msgid "From startup, you can set Verilog mode with the command line:"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:20
#, no-wrap
msgid "  simulator lang=verilog\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:23
#, no-wrap
msgid ""
"or\n"
"  verilog\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:29
#, no-wrap
msgid "  type #(arguments) label (port list) ;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Type** : The type of component.  If there is a \"paramset\" statement, this is the name in the paramset statement.  Otherwise, it could be the name of a \"subckt\", \"model\", or a standard device.  This is called \"master\" in the Spectre manual.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \".name(value)\", separated by a comma.  The value may be an expression.  In some cases, a principal value can be given just by value, without its name.  The argument list is surrounded by parentheses, and prefixed by \"#\".\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Port list** : A list of the ports (connections), separated by a comma.  Mapping can be determined by order or by name.  The port list should be surrounded by parentheses.  By order, list them, comma separated.  By name, they use the same syntax as arguments.  .name(value)\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:37
#, no-wrap
msgid ""
"  resistor #(10K)     Rload (out, 0);         // one unnamed argument, ports by order\n"
"  resistor #(.r(10K)) Rload (.p(out), .n(0)); // the same component, arguments by name, ports by name\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:39
#, no-wrap
msgid "  amp #(.rload(100K)) X1 (.out(out), .in(in), .vcc(vc));\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:41
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Verilog mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:44
#, no-wrap
msgid ""
"  // vsource  #(.dc(15)) Vcc (.p(vc), .n(0)); // Spice-style source arguments are not supported.\n"
"  // vsource  #(.ac(1))  Vin (.p(in), .n(0)); // Spice-style source arguments are not supported.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:55
#, no-wrap
msgid ""
"  // assume it is starting in Verilog mode\n"
"  spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .verilog\n"
"  // Now it is back in Verilog mode.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:61
msgid "Two top level blocks are supported: module and paramset."
msgstr ""

#. type: Title =====
#: manual/languages/verilog.txt:62
#, no-wrap
msgid "paramset"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:65
msgid ""
"A \"paramset\" statement sets parameters based on an existing compiled "
"model.  This will be extended to cover all \"masters\".  It becomes a "
"\"master\" that can be instantiated later.  It is equivalent to a spice \"."
"model\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:70
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"paramset\" newname itsmaster \";\"\n"
"    parameters\n"
"  \"endparamset\"\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid "**paramset** : Keyword identifies a paramset statement.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid "**Parameters** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \".name = value;\".  (dot name equals value semicolon) The value may be an expression.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:79
#, no-wrap
msgid ""
"  paramset gp_npn npn;\\\n"
"    .bf=150;\\\n"
"  endparamset\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:81
msgid ""
"According to the standard, lines are not significant.  In gnucap, for now, "
"all must be on one line or lines extended by ending with \"\\\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:83
msgid ""
"Note that the parameter syntax in paramset is different from the parameter "
"syntax instantiating a device."
msgstr ""

#. type: Title =====
#: manual/languages/verilog.txt:83
#, no-wrap
msgid "module"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:86
msgid ""
"The basic building block is called a \"module\".  Modules are descriptions "
"of individual components.  Gnucap directly supports only the structural "
"subset of Verilog, so a \"module\" here is equivalent to a Spice \"subckt\"."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:88
msgid "Modules take the form:"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:98
#, no-wrap
msgid ""
"  * A header line\n"
"    * Keyword \"module\".\n"
"    * The name of the new module being defined.\n"
"    * The list of ports, separated by commas, in parentheses\n"
"    * semicolon \";\"\n"
"  * Parameter statements.\n"
"  * The \"netlist\".\n"
"  * A closing line\n"
"    * Keyword \"endmodule\".\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:114
#, no-wrap
msgid ""
"  module amp (out, in, vcc);\n"
"    parameter rload=10k;\n"
"    resistor  #(.r(1M))   Rb1  (base, vcc);        // 1 megohm\n"
"    resistor  #(.r(100K)) Rb2  (base, 0  );\n"
"    resistor  #(100K)     Rc   (col,  vcc);\n"
"    resistor  #(.r(10K))  Re   (.p(emit), .n(0));\n"
"    capacitor #(.c(1m))   Ce   (.p(emit), .n(0));  // 1 millifarad\n"
"    capacitor #(.c(1u))   Cin  (base, in );\n"
"    gp_npn                Q1   (.c(col), .b(base), .e(emit));\n"
"    gp_npn                Q2   (.c(vcc), .b(col), .e(e2));\n"
"    resistor  #(.r(1K))   Re2  (e2,  0  );\n"
"    capacitor #(.c(10u))  Cout (e2,  out);\n"
"    resistor  #(.r(rload))Rload(out, 0 );\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:119
#, no-wrap
msgid ""
"  amp      #(.rload(100K)) X1    (.out(out), .in(in), .vcc(vc));\n"
"  vsource  #(.dc(15))      Vcc   (.p(vc), .n(0));\n"
"  vsource  #(.ac(1))       Vin   (.p(in), .n(0));\n"
"  resistor #(10K)          Rload (out, 0);\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:123
msgid "The Verilog language has no concept of commands."
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:125
msgid ""
"In gnucap, commands are executed at top level the same as the native mode."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can switch languages any time with the appropriate command.  In most cases, just name the language you want to switch to.  More generally, you can do \".option lang=xxx\".  The command to switch back must be issued in the language you switched to.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can define a top-level circuit in Verilog syntax.  The Verilog standard provides no way to define a top level circuit.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can include commands, which work the same as the Gnucap native mode.\n"
msgstr ""

#. type: Plain text
#: manual/languages/verilog.txt:135
msgid "The current implementation in gnucap is a very preliminary subset."
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "The devices and commands are whatever gnucap has installed, not necessarily what is defined in any standard.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "The main circuit can also be in Verilog syntax.  The Verilog standard has no concept of components at top level.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "To simulate, there must be a component at top level.  Uninstantiated modules do nothing.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Port direction statements like \"inout\" are not supported.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Discipline statements like \"electrical\" are not supported.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Some components, and some types of arguments, are not supported in Verilog mode, but you can switch modes at any time.\n"
msgstr ""

#. type: Title ======
#: manual/measure/at.txt:1
#, no-wrap
msgid "\"at\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:6
msgid "Measure a signal at a time or frequency."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:10
#, no-wrap
msgid "  at(probe=\"p(d)\"  at=time  derivative)\n"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:15
#, no-wrap
msgid ""
"|probe       |The name of a probe to measure.  |\n"
"|at\\\\ x      |Measure the value here.  |\n"
"|derivative  |Flag: measure the derivative instead of the value.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:19
msgid ""
"If you specify x to be out of range, it returns the value at the end, with a "
"derivative of zero."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:21 manual/measure/cross.txt:33
msgid ""
"If you didn't store the waveform (see store command), it throws a \"no match"
"\" exception, which prints \"no match\"."
msgstr ""

#. type: Plain text
#: manual/measure/at.txt:27
#, no-wrap
msgid ""
"  measure sample = at(probe=\"v(out)\", at=4u)\n"
"Measure the value of \"v(out)\" at 4 microseconds.\n"
"  measure sample = at(probe=\"v(out)\", at=4u, derivative)\n"
"Measure the derivative of \"v(out)\" at 4 microseconds.\n"
msgstr ""

#. type: Title ======
#: manual/measure/cross.txt:1
#, no-wrap
msgid "\"cross\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:6
msgid "Find the time or frequency where a probed value crosses a reference."
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:10
#, no-wrap
msgid "  cross(probe=\"p(d)\" cross=value begin=time end=time rise fall last first)\n"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:21
#, no-wrap
msgid ""
"^arg name       ^default  ^description  ^\n"
"|probe          |required   |The name of a probe to measure.  |\n"
"|cross          |0          |The value it crosses.  |\n"
"|begin\\\\ after  |-infinity  |The window begins at this time or frequency.  |\n"
"|end\\\\ before   |+infinity  |The window ends at this time or frequency.  |\n"
"|first          |true       |Find the first crossing in the window.  (Cancels last.)  |\n"
"|last           |false      |Find the last crossing in the window.  (Cancels first.)  |\n"
"|rise           |true       |Consider only rising crossings.  (Cancels fall.)  |\n"
"|fall           |false      |Consider only falling crossings.  (Cancels rise.)  |\n"
msgstr ""

#. type: Title =====
#: manual/measure/cross.txt:21
#, no-wrap
msgid "Caveats"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:27
#, no-wrap
msgid ""
"For this function to detect a crossing, it must actually cross.\n"
"  * A steady state at the cross value is not a crossing.\n"
"  * Being at the cross value and leaving is not a crossing.\n"
"  * Merely touching (becoming equal to) the cross value and leaving from the same side is not a crossing.\n"
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:31
msgid ""
"If there is no crossing within the specified range, it returns \"Inf"
"\" (infinity)."
msgstr ""

#. type: Plain text
#: manual/measure/cross.txt:42
#, no-wrap
msgid ""
"  measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
msgstr ""

#. type: Title ======
#: manual/measure/mean.txt:1
#, no-wrap
msgid "\"mean\", \"integrate\", \"rms\" measures"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:8
#, no-wrap
msgid ""
"| mean      |Find the mean or average value of a waveform.  |\n"
"|integrate  |Find the integral of a waveform, the area under the curve.  |\n"
"|rms        |Find the RMS (root mean square) value of a waveform.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:14
#, no-wrap
msgid ""
"  mean(probe=\"p(d)\"  begin=time  end=time)\n"
"  integrate(probe=\"p(d)\"  begin=time  end=time)\n"
"  rms(probe=\"p(d)\"  begin=time  end=time)\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:21
#, no-wrap
msgid ""
"^arg name  ^default  ^description  ^\n"
"|probe     |required    |The name of a probe to measure.  |\n"
"|begin     |- infinity  |Start averaging at this time or frequency.  |\n"
"|end       |+ infinity  |Stop averaging at this time or frequency.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:25
msgid ""
"The \"mean\" measure gives you the true average or mean value.  The mean "
"value of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:27
msgid ""
"The \"integrate\" measure gives you the integral, or area under the curve, "
"signed.  The integral of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:29
msgid "The \"rms\" measure gives you the RMS (root mean square) value."
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:38
#, no-wrap
msgid ""
"  measure sample = mean(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the mean value of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
"  measure sample = mean(probe=\"v(out)\" begin=4u)\n"
"Find the mean value of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Plain text
#: manual/measure/mean.txt:44
#, no-wrap
msgid ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the area under the curve of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Find the area under of v(out) for an entire run.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Find the area under of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Title ======
#: manual/measure/minmax.txt:1
#, no-wrap
msgid "\"min\", \"max\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:6
msgid ""
"Find the time or frequency where a probed value hits a maximum or minimum."
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:10
#, no-wrap
msgid "  min(probe=\"p(d)\" begin=time end=time last first arg)\n"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:20
#, no-wrap
msgid ""
"^arg name  ^default    ^description  ^\n"
"|probe     |required   |The name of a probe to measure.  |\n"
"|arg       |false      |Find the time or frequency at which the min or max occurs. (instead of the value)  |\n"
"|begin     |-infinity  |The window begins at this time or frequency.  |\n"
"|end       |+infinity  |The window ends at this time or frequency.  |\n"
"|first     |true       |Find the first min or max in the window.  (Cancels last.)  |\n"
"|last      |false      |Find the last min or max in the window.  (Cancels first.)  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/minmax.txt:34
#, no-wrap
msgid ""
"  measure maxvalue = max(probe=\"v(out)\" cross=0 last)\n"
"Find the maximum value of v(out).\n"
"  measure t2 = max(probe=\"v(out)\" last arg)\n"
"Find the last time when a maximum occurred.\n"
"  measure t1 = max(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a maximum occurred before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
"  measure t0 = min(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a minimum occurred before t2.\n"
"  param risetime = {t2-t0}\n"
msgstr ""

#. type: Title ======
#: manual/measure/slope.txt:1
#, no-wrap
msgid "\"slope\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:6
msgid "Find the slope or slew rate of a waveform."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:10
#, no-wrap
msgid "  slope(probe=\"p(d)\" initial=value final=value begin=time end=time expression)\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:22
#, no-wrap
msgid ""
"^arg name    ^default  ^description  ^\n"
"|probe       |required   |The name of a probe to measure.  |\n"
"|initial     |0          |The initial value.  |\n"
"|final       |0          |The final value.  |\n"
"|begin       |-infinity  |The window begins at this time or frequency.  |\n"
"|end         |+infinity  |The window ends at this time or frequency.  |\n"
"|first       |true       |Find the first crossing in the window.  (Cancels last.)  |\n"
"|last        |false      |Find the last crossing in the window.  (Cancels first.)  |\n"
"|expression  |false      |The result is an unreduced expression.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:26
msgid ""
"Ordinarily, the result is a number.  If the probe is a voltage probe the "
"units would be volts per second."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:28
msgid ""
"If the \"expression\" keyword is given the result is an unreduced expression."
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:34
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as a number.\n"
"  sr= 30.15738K\n"
msgstr ""

#. type: Plain text
#: manual/measure/slope.txt:37
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last expression)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as an unreduced expression.\n"
"  sr={( 2.--2.)/( 0.001066319- 933.6812u)}\n"
msgstr ""

#. type: Title ======
#: manual/tech.txt:1
#, no-wrap
msgid "Tech notes"
msgstr ""

#. type: Plain text
#: manual/tech.txt:4
msgid "This section describes technical aspects of Gnucap."
msgstr "В данном разделе рассматриваются технические аспекты gnucap."

#. type: Plain text
#: manual/tech.txt:6
msgid ""
"Here, you will find information that will help you understand how it works "
"and to extend it."
msgstr ""
"Здесь вы найдёте информацию, которая поможет вам понять, как программа "
"работает и каким образом можно расширить её функциональность."

#. type: Bullet: '  * '
#: manual/tech.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:9
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man105.html|adding models (old)]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech.txt:9
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man107.html|old tech notes]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins.txt:1 manual/tech/plugins/coding.txt:1
#: manual/tech/plugins/files.txt:1
#, no-wrap
msgid "Plugins"
msgstr ""

#. type: Plain text
#: manual/tech/plugins.txt:4
msgid "This section describes the Gnucap plugin system, for programmers."
msgstr ""

#. type: Title =====
#: manual/tech/plugins.txt:5 manual/tech/plugins/coding.txt:3
#: manual/tech/plugins/files.txt:3
#, no-wrap
msgid "Concepts"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Files]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Coding]]\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "Plugin types"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:15
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:commands]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:15
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:devices]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:15
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:languages]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:15
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:behavioral functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:15
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:parameter functions and measurements]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/devices.txt:1
#: manual/tech/plugins/devices/ac_analysis.txt:1
#: manual/tech/plugins/devices/allocation_and_setup.txt:1
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:1
#: manual/tech/plugins/devices/parameters.txt:1
#: manual/tech/plugins/devices/ports.txt:1
#: manual/tech/plugins/devices/probes.txt:1
#: manual/tech/plugins/devices/query.txt:1
#, no-wrap
msgid "Device plugins"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/devices.txt:3 manual/tech/plugins/commands.txt:3
#: manual/tech/plugins/parameter_functions_and_measurements.txt:3
#, no-wrap
msgid "Framework"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:6
msgid ""
"Devices, model definitions, commands, and subcircuit definitions are all "
"stored in a linked list, and are defined by classes derived from \"CARD\".  "
"The container is a CARD_LIST."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:8
msgid ""
"Device instances are derived from COMPONENT, which is derived from CARD."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:10
msgid ""
"Model and paramset statements are derived from MODEL_CARD, which is derived "
"from CARD."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:12
msgid "There are special classes of devices that are derived from COMPONENT."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:17
#, no-wrap
msgid ""
"|COMPONENT   |e_compon.h |all devices, including those defined by subcircuit expansion. |\n"
"|BASE_SUBCKT |e_subckt.h |devices that are defined in terms of other devices, as subcircuits, with an internal hierarchy. |\n"
"|ELEMENT     |e_elemnt.h |devices that are not defined in terms of other devices. |\n"
"|STORAGE     |e_storag.h |elements that store some historical information, such as previous states. |\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:19
msgid ""
"Devices do not contain any parsing or printing code, but do contain methods "
"for setting and reading parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:21
msgid ""
"Some devices do contain parsing or printing code in methods with a name that "
"includes \"obsolete_callback\".  That is not documented here, and will "
"eventually be removed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:23
msgid ""
"One static object of every type is created at program startup or when a "
"plugin is loaded.  A pointer to that static object is installed in a "
"dispatcher, and later accessed by name or through that pointer.  This is the "
"only interface."
msgstr ""

#. type: Title =====
#: manual/tech/plugins/devices.txt:23 manual/tech/plugins/commands.txt:16
#: manual/tech/plugins/devices/ac_analysis.txt:2
#: manual/tech/plugins/devices/allocation_and_setup.txt:2
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:2
#: manual/tech/plugins/devices/parameters.txt:2
#: manual/tech/plugins/devices/ports.txt:2
#: manual/tech/plugins/devices/probes.txt:2
#: manual/tech/plugins/devices/query.txt:2
#: manual/tech/plugins/parameter_functions_and_measurements.txt:24
#, no-wrap
msgid "Implementation"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices.txt:26
msgid ""
"Device plugins need to include at least one file, defining its base class.  "
"Often, that is the only include file needed."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:query|Simple query functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Ports]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Parameters]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Allocation and setup]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:DC and transient analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:AC analysis]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:probes]]\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:5
#, no-wrap
msgid "Coding"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:8
msgid ""
"This section describes the internals of a plugin, including how it "
"interfaces to the core simulator."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:12
msgid ""
"The interface to plugins is through C++ derived classes, virtual functions, "
"and a dispatcher."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:14
msgid ""
"There are several types of plugins.  The type is determined by the base "
"class that is used.  When a plugin is loaded, a single static object is "
"created, and registered with a dispatcher.  The dispatcher allows a lookup "
"by name."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:23
#, no-wrap
msgid ""
"Plugin types may include:\n"
"  * devices and models\n"
"  * commands\n"
"  * measurements\n"
"  * languages\n"
"  * functions for use in expressions\n"
"  * I/O interface\n"
"  * compatibility\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:25
msgid ""
"It is intended that the entire interface, all models, and almost all "
"functionality will determined by plugins."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:28
msgid ""
"Most plugins will create new subtypes of something.  To explain how it "
"works, I will use parameter functions as an example."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:30
msgid "We have a base class:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:37
#, no-wrap
msgid ""
"<code>\n"
"class FUNCTION {\n"
"public:\n"
"  virtual double eval(double arg)const = 0;\n"
"};\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:39
msgid "This is in a header file \"u_function.h\""
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:41
msgid ""
"This base class is simple.  It has one member function, which a number as "
"input, performs some operation on it, and returns the result."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:44
msgid ""
"Let's make a function to take the absolute value of a numeric argument, as a "
"plugin.  You need to include the header:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:48
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_function.h\"\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:50
msgid "Then make a derived class, and create one instance of it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:60
#, no-wrap
msgid ""
"<code>\n"
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return std::abs(arg);\n"
"  }\n"
"} p;\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:62
msgid "Now, register it with the dispatcher so we can find it:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:66
#, no-wrap
msgid ""
"<code>\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"abs\", &p);\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:68
msgid "If you want to also access it by another name, you can do that too:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:70
#, no-wrap
msgid "<code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:73
msgid ""
"DISPATCHER<FUNCTION>::INSTALL d2(&function_dispatcher, \"absolute_value\", "
"&p); </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:75
msgid ""
"That's all.  The names of the class and instances don't matter because they "
"are local to the plugin.  You find it through the dispatcher, with the name "
"you use to INSTALL it.  In this case, either \"abs\" or \"absolute_value\" "
"will find this plugin."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:77
msgid ""
"If you want to also be able to static-link this plugin, enclose the class "
"and dispatcher installs in an anonymous namespace."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:78
#, no-wrap
msgid "Another Example"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:81
msgid ""
"Here's an example of another one with the same base, all together so you can "
"see it as a unit:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:84
#, no-wrap
msgid ""
"<code>\n"
"#include \"fake_function.h\"\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:94
#, no-wrap
msgid ""
"class square : public FAKE_FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return arg * arg;\n"
"  }\n"
"} p;\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"square\", &p);\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:96
msgid "That's all!"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/coding.txt:97
#, no-wrap
msgid "Compiling it"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:100
msgid ""
"The procedure for compiling it is system dependent, and is usually set up "
"when you install the main simulator."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:102
msgid ""
"In general, you need to make a \"shared object\" or \"dynamic link\" module."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:104
msgid "On Linux, usually this works:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:108
#, no-wrap
msgid ""
"<code>\n"
"g++ -shared -fPIC -o outfile.so infile.cc\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:110
msgid ""
"This take a source file \"infile.cc\", and generates a plugin file \"outfile."
"so\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:112
msgid "Then you can load it:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/coding.txt:115
#, no-wrap
msgid ""
"<code>\n"
"gnucap> load ./outfile.so\n"
"</code>\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/commands.txt:1
#, fuzzy, no-wrap
#| msgid "Load and unload plugins."
msgid "Command plugins"
msgstr "Загрузка и выгрузка плагинов."

#. type: Plain text
#: manual/tech/plugins/commands.txt:6
msgid "Command plugins are called by a command interpreter, in a loop."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:8
msgid ""
"Usually, the main loop reads from the standard input or a file, line by "
"line.  Extension lines are combined when the file is read, so the command "
"code doesn't see them.  The string is converted to a \"command string\", an "
"object of type \"CS\", which is defined in \"ap.h\".  This command string "
"contains the data, an index showing how far it has been read, and some "
"status."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:10
msgid ""
"The command string begins with the name of the command.  This is looked up "
"in the \"command_dispatcher\" using the subscript operator.  The dispatcher "
"returns a pointer to a static object that will interpret the command, or a "
"NULL pointer if there is no match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:12
msgid ""
"Then, the method \"do_it\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current \"scope\" so parameter expressions can be evaluated correctly.  If "
"\"do_it\" returns, it is assumed to have correctly done what was requested.  "
"If something is wrong, it may throw an exception."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:14
msgid ""
"Each command defines a new class, derived from \"CMD\" which is defined in "
"\"c_comand.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:16
msgid ""
"The header file \"globals.h\" is needed because it contains the declaration "
"of the dispatcher."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:19
msgid "Plugins need to #include two files: \"c_comand.h\" and \"globals.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:21
msgid ""
"Only one method is needed for each command: \"''do_it(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:23
#: manual/tech/plugins/parameter_functions_and_measurements.txt:31
msgid ""
"Declare one static object of this new type, and INSTALL it in the DISPATCHER."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:27
#, no-wrap
msgid ""
"<code>\n"
"#include \"c_comand.h\"\n"
"#include \"globals.h\"\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/commands.txt:35
#, no-wrap
msgid ""
"class CMD_HELLO : public CMD {\n"
"  void do_it(CS& Cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // code goes here\n"
"  }\n"
"} so;\n"
"DISPATCHER<CMD>::INSTALL d(&command_dispatcher, \"hello\", &so);\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/ac_analysis.txt:3
#, no-wrap
msgid "AC analysis"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:6
msgid ""
"The AC functions in Gnucap correspond to a combination of the AC and PZ "
"functions in Spice.  Actually, they are more like the PZ functions, in the "
"sense that frequency (SIM::jomega) is complex."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:7
#, no-wrap
msgid "void ac_iwant_matrix()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:9
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:7
msgid "Notify the sparse matrix of what nodes this device uses."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:11
msgid ""
"AC analysis uses a single matrix \"acx\", which serves as both the nodal "
"admittance matrix and the LU factors.  This is likely to change in the "
"future to two matrices like in transient analysis."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:16
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node pairs that need allocating.\n"
"This line:\n"
"  acx.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and _n[1].  This is usually four places in the matrix.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:21
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * ac_iwant_matrix_passive(), for two-terminal elements like resistors, with a symmetric stamp\n"
"  * ac_iwant_matrix_active(), for controlled sources, with an asymmetric stamp\n"
"  * ac_iwant_matrix_extended(), the general case, allocates all combinations\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:22
#, no-wrap
msgid "void ac_begin()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:24
msgid ""
"This is called at the beginning of every AC analysis.  It should call BASE::"
"ac_begin() before doing anything else.  It sets the value of any AC "
"variables that remain constant through a run."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:25
#, no-wrap
msgid "void do_ac()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:27
msgid ""
"In most cases, the do_ac functions do the real work, or call the ac_eval "
"function to do it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:29
msgid ""
"If necessary, it evaluates the model. Calling this function more than once "
"on an iteration is harmless, except for the waste of time.  Usually, it uses "
"state variables from a previous DC or transient analysis to compute AC "
"values."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:31
msgid "Unlike Spice, Gnucap does not actually load the matrix here."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:32
#, no-wrap
msgid "void ac_load()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:34
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_ac."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:36
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:69
msgid ""
"The actual loading is done by one or more of a small group of general "
"functions, depending on whether the element is active, passive, poly, or a "
"source. Only certain patterns can be stamped. Complex devices use a "
"combination of these patterns."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:37
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:71
msgid "WARNING to model developers: DO NOT stamp the matrix directly!"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/allocation_and_setup.txt:3
#, no-wrap
msgid "Allocation and setup"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:5
#, no-wrap
msgid "default constructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:7
msgid ""
"A default constructor is required.  It is used to construct the static "
"object that is registered with the dispatcher.  It should do what a default "
"constructor usually does."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:8
#, no-wrap
msgid "copy constructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:10
msgid ""
"A copy constructor is required.  Most objects are created by the copy "
"constructor, as copies of the object registered with the dispatcher.  "
"Usually, it should do a SHALLOW copy.  In particular, a COMMON should be "
"linked and not copied.  A copy constructor must explicitly invoke the copy "
"constructor of the base class."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:11
#, no-wrap
msgid "destructor"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:13
msgid ""
"Usually a destructor is not required, but it is a good idea to provide one "
"anyway even if it is empty.  It must deallocate any dynamic memory that is "
"used."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:14
#, no-wrap
msgid "CARD* clone()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:16
msgid ""
"Create a new object as a copy of this one, using the copy constructor with "
"the argument \"*this\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:17
#, no-wrap
msgid "void expand()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:19
msgid ""
"The expand function expands subcircuits and models, as needed.  Unlike "
"Spice, it does not really flatten the circuit, but it allocate space for the "
"additional storage, attaches models, and related tasks.  It is called once "
"after reading the circuit, and possibly later when the topology of the "
"circuit is changed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:21
msgid ""
"It is possible that it may be called more than once.  If it is called twice "
"in succession, the result must be the same as if it were called once.  "
"Either it frees then re-expands, or (preferably) it keeps what it can and "
"checks to make sure it is correct."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:23
msgid ""
"Most simple elements do not have expand functions. Most advanced components "
"do."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:25
msgid ""
"It is not expected to compute any values, but it is allowed to call \"precalc"
"\" if needed in case the values affect topology.  It is preferred that the "
"action of expand is the same regardless of parameter values."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:27
msgid ""
"Expanding a subcircuit makes a copy of it, and remaps the nodes. Most "
"components use a shallow copy. That is, if something is attached through a "
"pointer, the value of the pointer is copied, not the attachment. Commons are "
"never copied when the owner components are copied, but commons may be "
"duplicated later if something changes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:28
#, no-wrap
msgid "void expand_first()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:30
msgid ""
"The expand_first function is an expand function that is done first, before "
"any plain expand functions.  Usually it is not needed, but sometimes there "
"are order dependencies, so this provides a way to control the calling "
"order.  As an example, for current controlled sources with a sense element, "
"the controlled source can send a message to the controlling element that can "
"result in a different expansion."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:31
#, no-wrap
msgid "void expand_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:33
msgid ""
"The expand_last function is an expand function that is done last, after any "
"plain expand functions.  Usually it is not needed, but sometimes there are "
"order dependencies, so this provides a way to control the calling order.  As "
"an example, for current controlled sources with a sense element, the "
"controlled source must be expanded after the sense element."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:34
#, no-wrap
msgid "void precalc_first(), void precalc_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:36
msgid ""
"The precalc functions attempt to pre-calculate anything that will remain "
"constant during a simulation run. This includes size dependent transistor "
"parameters and the stamp values for linear elements.  It also evaluates "
"parameter expressions."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:38
msgid ""
"It is possible that it may be called more than once.  It must not change its "
"input data in any way.  If it is called twice in succession, the result must "
"be the same as if it were called once."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:40
msgid ""
"Some values must be calculated before determining structure.  These go in "
"precalc_first."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:42
msgid ""
"Some values must be calculated after structure is determined.  These go in "
"precalc_last."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:46
msgid ""
"Some values don't matter whether they are calculated before or after "
"structure is determined.  It strictly doesn't matter whether they are in "
"precalc_first or precalc_last.  By convention, evaluation of parameter "
"expressions goes in precalc_first, calculation of other values that are done "
"only once goes in precalc_last."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:47
#, no-wrap
msgid "void map_nodes()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:48
msgid ""
"Map the user node names to internal node numbers.  Almost always, the "
"inherited function does what is needed, which is to loop over all nodes "
"(both ports and internal) and call their \"map\" function, and recursively "
"map subcircuits."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:3
#, no-wrap
msgid "DC and transient analysis"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:5
#, no-wrap
msgid "void tr_iwant_matrix()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:9
msgid ""
"Two matrices are used, \"aa\" and \"lu\".  The matrix \"aa\" is the nodal "
"admittance matrix.  The matrix \"lu\" is the LU factors of the admittance "
"matrix.  Both need to be notified, and have identical patterns."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:15
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node pairs that need allocating.\n"
"This line:\n"
"  aa.iwant(_n[0].m_(),_n[1].m_());\n"
"  lu.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and _n[1].  This is usually four places in the matrix.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:20
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * tr_iwant_matrix_passive(), for two-terminal elements like resistors, with a symmetric stamp\n"
"  * tr_iwant_matrix_active(), for controlled sources, with an asymmetric stamp\n"
"  * tr_iwant_matrix_extended(), the general case, allocates all combinations\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:21
#, no-wrap
msgid "void tr_begin()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:23
msgid ""
"This is called at the beginning of every DC or OP analysis, and transient "
"analysis unless it is continuing a previous run.  It initializes all state "
"variables, sets up the initial guess for nonlinear analysis, and fills in "
"reasonable values for historical states.  It should call BASE::tr_begin() "
"before doing anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:24
#, no-wrap
msgid "void tr_restore()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:26
msgid ""
"This is called when continuing a transient analysis.  It must restore state "
"variables and history to a consistent state if the previous analysis was "
"stopped uncleanly.  It should call BASE::tr_restore() before doing anything "
"else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:27
#, no-wrap
msgid "void dc_advance()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:29
msgid ""
"This is called first when moving to a new DC sweep point.  It saves old "
"values of state variables as needed, and advances local time.  It also sets "
"up the initial values for iteration if needed.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::dc_advance() before doing "
"anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:30
#, no-wrap
msgid "void tr_advance()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:32
msgid ""
"This is called first when moving to a new time step.  It saves old values of "
"state variables as needed, and advances local time.  It also sets up the "
"initial values for iteration at the new time.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::tr_advance() before doing "
"anything else."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:34
msgid ""
"For delay elements like logic devices and transmission lines, this function "
"does the real work. It takes previous results and applies them, generating "
"data that will be later loaded into the matrix."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:35
#, no-wrap
msgid "void tr_regress()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:37
msgid ""
"This is called instead of tr_advance() when moving backwards in time.  The "
"usual code throws away the most recent state variables, restores the values "
"from the previous step, and backs up all of the stored state data.  It "
"should call BASE::tr_regress() before doing anything else."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:38
#, no-wrap
msgid "bool tr_needs_eval()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:40
msgid ""
"Return a judgment of whether or not this device is in need of evaluation at "
"this time and this iteration.  In the simplest case, you can defer writing "
"this function by just returning \"true\", but that leads to needless full "
"evaluations.  The main purpose of this function is to wake up a latent "
"device.  For a general example of this function, look in spice_wrapper.cc."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:41
#, no-wrap
msgid "void tr_queue_eval()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:43
msgid ""
"Conditionally queue this component for evaluation.  In most cases, you can "
"omit this function and use the inherited version which does ''{if"
"(tr_needs_eval()){q_eval();}}''.  The function \"''q_eval()''\" "
"unconditionally queues this component for evaluation."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:44
#, no-wrap
msgid "bool do_tr()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:46
msgid ""
"In most cases, the do_tr functions do the real work, or call the tr_eval "
"function to do it. It evaluates the model, checks convergence, and queues it "
"for loading. Calling this function more than once on an iteration is "
"harmless, except for the waste of time."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:48
msgid ""
"Usually, it calculates the function and derivative. It may also do "
"integration, interpolation, iteration, or whatever is required. The result "
"is a set of values ready to stamp into the admittance matrix and current "
"vector."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:50
msgid "There are several distinct steps within this function."
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The first step is to gather the information necessary to make the computations. Usually, this is the node voltages, but it could be currents, temperature, charge, or something else.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The next step is to evaluate any attached function. This could be done in line, or by a call to tr_eval. The result of this evaluation is stored in _y0 (of type FPOLY1. The tr_eval function reads the value of x from _y0, and fills in the f0 with the result of function evaluation, and f1 with its derivative. The tr_eval function must also check for convergence by comparing the new _y0 with the old value, _y1. This attached function is generic in the sense that it is the same for all device types. This is the y = f(x) that is referred to in the behavioral modeling documentation.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "These values are stored for convergence checking and probing.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "After that, it must be converted to a current and admittance so it can be used in the system of nodal equations. This step is dependent on what type of device it is. For a conductance element, tr_eval directly returns the correct information, so nothing needs to be done here. For a capacitor, this step does numerical integration. Capacitors store this in _i0. Most other elements do not store this result directly.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "Then, it must be converted into CPOLY form to meet the requirements of the system of equations.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The device is queued for loading. Unlike Spice, Gnucap does not actually load the matrix here.\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:58
#, no-wrap
msgid "bool do_tr_last()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:60
msgid ""
"This is the same as do_tr, except that it is called last.  It is used when "
"there is a dependency on a do_tr of another device when it the other device "
"must be evaluated first, such as current controlled sources.  It is only "
"called if it is queued.  Most devices don't have a do_tr_last.  For devices "
"that do, the body of do_tr should be \"''{SIM::late_evalq.push_back(this); "
"return true;}''\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:61
#, no-wrap
msgid "void tr_load()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:63
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_tr."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:65
msgid ""
"Actually, it does much more. In most cases, it actually loads a correction "
"factor, assuming the old values are already loaded. To do this, it keeps "
"track of what values are actually loaded. Whether it loads a correction or "
"the actual value is determined first by the option incmode, then by status "
"information about the solution. If it is suspected that correcting would "
"cause too much roundoff error, it loads the actual value. The decision of "
"whether to do a full load or an update is global."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:67
msgid ""
"In addition, it may apply damping in hopes of improving convergence. This "
"means to load a value somewhere between the new and old values, in effect "
"taking a partial step. The decision to damp is semi-global. Groups of "
"elements are adjusted together."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:72
#, no-wrap
msgid "void tr_unload()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:74
msgid ""
"This function removes the component from the matrix, possibly by subtracting "
"off what was loaded. Usually, it sets the current values to 0 and calls "
"tr_load."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:75
#, no-wrap
msgid "TIME_PAIR tr_review()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:77
msgid ""
"The tr_review function checks errors and signal conditions after a time step "
"has converged. It returns two values of an approximate time that the element "
"wants for the next step, and stores that information in the instance "
"variable _time_by."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:79
msgid ""
"\"''_time_by._error_estimate''\" is an estimate of the desired next time "
"based on analog error estimate.  It is used to control truncation error, "
"curve fitting error, and overall smoothness of the result.  The actual next "
"time will probably be sooner than this number suggests, and is considered to "
"be more accurate.  Usually you would set it indirectly by ''_time_by."
"min_error_estimate(suggested_next_time);''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:81
msgid ""
"\"''_time_by._event''\" is an estimate of the desired next time based on "
"ambiguous events.  It is used to control accuracy of cross events and "
"situations where clusters of time steps are needed for accuracy.  The actual "
"time will try to match this as close as practical.  Shorter time steps do "
"not improve accuracy.  Usually you would set it indirectly by ''_time_by."
"min_event(suggested_next_time);''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:83
msgid ""
"It is usually appropriate to call BASE::tr_review before doing anything "
"else.  If not, you should call ''_time_by.reset()'' first."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:85
msgid ""
"If there is a tr_accept function, and you want it to be called, you must "
"queue it here by calling q_accept()."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:86
#, no-wrap
msgid "void tr_accept()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:89
msgid ""
"This function is called after the solution at a time step has been accepted. "
"For most devices, it does nothing. For devices having storage and delayed "
"propagation, it evaluates what signal will be propagated. For a transmission "
"line, it calculates and sends on the reflections."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:91
msgid ""
"It is called only when queued, so either tr_review or do_tr must call "
"q_accept() to queue it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:92
msgid ""
"Only tr_accept is allowed to add events to the event queue (SIM::new_event"
"())."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:6
msgid ""
"These methods provide all access to parameters.  Parameters are seen as "
"strings in this context, because it is more flexible.  Usually parameters "
"are accessed by index, as if in an array.  It is up to the implementer to "
"decide what type of storage to actually use."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:8
msgid ""
"Indexing starts at 0 in CARD, and counts up from there.  The indexing of "
"parameters should be consecutive.  For example, if the base class has "
"parameters numbered up to 16, you should start at 17.  The appropriate "
"starting number can be obtained by calling BASE::param_count().  The "
"preferred internal index method is to start at 0, and index from the value "
"BASE::param_count-1-i where i is the external index.  If the result of BASE::"
"param_count-1-i is out of range, call the matching BASE method, passing i "
"through.  In this section BASE:: refers to the most immediate base class.  "
"All of these methods are required, and will march through the class "
"hierarchy until the request is satisfied."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:10
msgid ""
"Some devices use another set of methods, \"obsolete_callback\".  This is not "
"documented here and not recommended for any new work.  Support for "
"\"obsolete_callback\" will be dropped at some time in the future."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:11
#, no-wrap
msgid "int param_count()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:13
msgid "Return (local_param_count + BASE::param_count())."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:14
#, no-wrap
msgid "bool param_is_printable(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:16
msgid ""
"Return true if it is appropriate to print the value of this parameter in a "
"netlist.  Some parameters should be printed regardless of their status, in "
"which case this function can just return true for that index.  You can "
"return false to always suppress the printing of a parameter and its value.  "
"Sometimes you might want to do some kind of test to determine whether or not "
"to print the parameter.  Usually, the function must determine a result for "
"its own, and return BASE::param_is_printable for others.  If you want to "
"suppress the printing of all base class parameters, return false for index "
"out of range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:17
#, no-wrap
msgid "std::string param_name(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:19
msgid ""
"Return the preferred name of a parameter given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:20
#, no-wrap
msgid "std::string param_name(int i,int j)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:22
msgid ""
"Return an alternative name of a parameter given an index i, and an alternate "
"index j.  When j == 0, it returns the preferred name.  When j > 0, it "
"returns either an alternative name or an empty string."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:23
#, no-wrap
msgid "std::string param_value(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:25
msgid ""
"Return the value of a parameter as a string given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:26
#, no-wrap
msgid "void set_param_by_name(std::string name, std::string value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:28
msgid ""
"Set the value of a parameter, by name.  Providing this method is optional.  "
"If you don't provide it, the base class provides a version that looks up the "
"index corresponding to the name and calls set_param_by_index.  It should "
"throw \"Exception_No_Match\" if there is no parameter corresponding to the "
"name."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:29
#, no-wrap
msgid "void set_param_by_index(int i, std::string&, int offset)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:31
msgid ""
"Set the value of a parameter, by index.  Providing this method is required "
"if set_param_by_name is not provided, or if you want to be able to accept a "
"list of unnamed parameters in an alternative syntax.  The usual procedure "
"for scanning down the base classes applies.  If you don't want to scan the "
"base classes, throw \"Exception_Too_Many\"."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:32
#, no-wrap
msgid "std::string value_name()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:33
msgid ""
"Return the name of the parameter to set when just a numeric value is given, "
"as in most Spice primitives.  If you don't want to accept any unnamed "
"parameters, return an empty string."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/ports.txt:3
#, no-wrap
msgid "Ports"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:5
#, no-wrap
msgid "void set_port_by_name(std::string& name, std::string& value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:7
msgid ""
"Make a connection between a port and the rest of the circuit, by name as in "
"Verilog.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:8
#, no-wrap
msgid "void set_port_by_index(int index, std::string& value)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:10
msgid ""
"Make a connection between a port and the rest of the circuit, by position as "
"in Spice.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:11
#, no-wrap
msgid "std::string port_name(int i)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:13
msgid ""
"Return the name of a port given its index.  This is required, because all "
"devices have unique port names."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/ports.txt:14
#, no-wrap
msgid "Current ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:17
msgid ""
"Most devices do not have current ports, so these methods are usually not "
"needed."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:18
#, no-wrap
msgid "void set_current_port_by_index(int, const std::string&)"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:20
msgid ""
"Make a connection between a current port and the rest of the circuit, by "
"position as in Spice.  This is required if the device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:21
#, no-wrap
msgid "const std::string current_port_value(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:23
msgid ""
"Return the name of the element that a current port is connected to.  This is "
"required if the device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:24
#, no-wrap
msgid "std::string current_port_name(int)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:25
msgid ""
"Return the name of a current port given its index.  This is required if the "
"device has current ports."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:5
#, no-wrap
msgid "double tr_probe_num(const std::string&)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:8
msgid ""
"This function returns a probe value for DC, OP, and transient analysis, "
"selected by a string argument.  Any state variable or parameter may be "
"selected."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:10
msgid ""
"Usually the code consists of a string of if - elseif statements.  If none "
"match, in most cases it should call BASE::tr_probe_num and return its result."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:23
#, no-wrap
msgid ""
"<code>\n"
"double DEV_CAPACITANCE::tr_probe_num(const std::string& x)const\n"
"{\n"
"  if (Umatch(x, \"q{cap} |ch{arge} \")) {\n"
"    return _y[0].f0;\n"
"  }else if (Umatch(x, \"c{apacitance} \")) {\n"
"    return _y[0].f1;\n"
"  }else{\n"
"    return STORAGE::tr_probe_num(x);\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:24
#, no-wrap
msgid "XPROBE ac_probe_ext(const std::string&)const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:28
msgid ""
"This function returns a probe value for AC analysis, selected by a string "
"argument.  Any state variable or parameter may be selected."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:30
msgid "It returns an XPROBE object:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:41
#, no-wrap
msgid ""
"<code>\n"
"enum mod_t {mtNONE, mtMAG, mtPHASE, mtREAL, mtIMAG};\n"
"class XPROBE{\n"
"private:\n"
"  COMPLEX _value;\n"
"  mod_t   _modifier; // default\n"
"  double  _dbscale;  // 20 for voltage, 10 for power, etc.\n"
"// .....\n"
"}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:42
msgid ""
"Usually, the returned value is made by a constructor with one argument, "
"using defaults for _modifier and _dbscale.  The value is a COMPLEX number."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/devices/query.txt:3
#, no-wrap
msgid "Simple query functions"
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:5
#, no-wrap
msgid "Used by parser"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:7
#, no-wrap
msgid "int max_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:9
msgid ""
"Return the maximum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it returns a "
"constant."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:10
#, no-wrap
msgid "int min_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:12
msgid ""
"Return the minimum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it is the same as "
"max_nodes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:13
#, no-wrap
msgid "int_num_current_ports()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:15
msgid ""
"Return the required number of current ports.  There are ports in a netlist "
"that are really branch elements used as current probes.  If omitted, the "
"inherited method returns zero.  If this function returns a non-zero value, "
"the device may not work with all netlist formats."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:16
#, no-wrap
msgid "int tail_size()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:18
msgid ""
"Return the minimum number of non-ports following the ports.  It is a hack to "
"help the Spice format parser distinguish between a port name and the device "
"type.  If omitted, the inherited method returns 0 or 1, but usually 1 is the "
"correct value."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:19
#, no-wrap
msgid "Used by allocation functions and checking"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:21
#, no-wrap
msgid "int net_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:23
msgid ""
"Return the actual number of ports.  If max_nodes == min_nodes, the only "
"valid value is the same, so it is permissible to return that number.  "
"Otherwise, it is determined when the netlist is read.  If the syntax is "
"correct it will always be between min_nodes and max_nodes."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:24
#, no-wrap
msgid "int ext_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:26
msgid ""
"Return the number of external nodes.  If omitted, the inherited method "
"returns max_nodes()."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:27
#, no-wrap
msgid "int int_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:29
msgid ""
"Return the number of internal nodes.  If omitted, the inherited method "
"return 0."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:30
#, no-wrap
msgid "int_matrix_nodes()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:32
msgid ""
"Return the number of nodes that stamp into the matrix.  The value is usually "
"int_nodes() + ext_nodes()."
msgstr ""

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:33
#, no-wrap
msgid "Special simple element property flags (usually not needed)"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:35
#, no-wrap
msgid "bool has_inode()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:37
msgid ""
"Return true if the device has a hidden node that can be used as a current "
"probe.  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:38
#, no-wrap
msgid "bool has_iv_probe()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:40
msgid ""
"Return true if the device can be used as a current probe for current "
"controlled spice devices.  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:41
#, no-wrap
msgid "bool is_device()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:43
msgid ""
"Return true if the device is a device.  In this context, the inherited "
"method returns true, so it can always be omitted.  It is listed here because "
"a netlist can also include non-device objects, and this function identifies "
"the difference."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:44
#, no-wrap
msgid "bool is_source()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:46
msgid ""
"Return true if the device is a fixed source.  If omitted, the inherited "
"method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:47
#, no-wrap
msgid "bool f_is_value()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:49
msgid ""
"Return true if the result of evaluating a behavioral function is the \"value"
"\".  If omitted, the inherited method returns false."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:50
#, no-wrap
msgid "bool_makes_own_scope()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:51
msgid ""
"Return true if the device makes its own scope for searching.  This is used "
"for the header lines of subcircuits.  For normal devices, it can be omitted, "
"which will return false."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:5
#, no-wrap
msgid "Files"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:8
msgid ""
"Gnucap plugins are standard \"shared object\" or \"dynamic link\" files, "
"native to the environment."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:10
msgid ""
"Plugins must be compiled for the particular system, like shared libraries."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:11
#, no-wrap
msgid "System Requirements"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:14
msgid ""
"The host system must be capable of dynamic linking, and support the "
"POSIX.1-2001 system calls for loading and unloading dynamic libraries on "
"demand.  In particular, the calls \"dlopen\", \"dlclose\", and \"dlerror\" "
"are used.  The \"dlsym\" call is not used."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:16
msgid ""
"If the system does not support these calls directly, but does have the "
"functionality in a different form, a set of wrapper functions is needed."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:17
#, no-wrap
msgid "Interface"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:20
msgid ""
"Plugins are loaded by the \"load\" (or \"attach\") command, and unloaded by "
"the \"unload\" (or \"detach\") command.  These commands are defined in the "
"source file \"c_attach.cc\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:22
msgid ""
"As of when this is being written, the files must be compiled before "
"loading.  In the future, there will be changes to enable the ability to "
"compile plugins on demand."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:24
msgid ""
"As per the specification of \"dlopen\", when a plugin is loaded, "
"constructors for all of its static objects are run.  Normally, the linkage "
"is through derived classes and a dispatcher, but other interfaces are "
"possible by callbacks in the constructor.  Also, all callbacks are resolved "
"at this time.  A plugin will fail to load if callbacks cannot be resolved."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:26
msgid ""
"If it is desired to load a plugin in spite of unresolved callbacks, you can "
"load with the \"lazy\" option.  If you do this, the plugin is likely to work "
"partially but fail when it attempts to call the missing function.  This is "
"not recommended for released code and likely to not work with non-POSIX "
"systems.  It is provided as a debugging aid."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:28
msgid ""
"Likewise, when a plugin is unloaded, destructors for the static objects are "
"run."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:30
msgid ""
"The \"dlsym\" function is not needed, because the interface is through "
"derived classes."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:31
#, no-wrap
msgid "Microsoft-Windows Interface"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:34
msgid ""
"Microsoft-Windows does not support the needed POSIX system calls directly, "
"so a set of wrapper functions is used.  The MS functions are \"LoadLibrary"
"\", \"FreeLibrary\", and \"GetLastError\".  These wrapper functions are "
"defined in \"md.h\"."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:35
#, no-wrap
msgid "Namespaces"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:38
msgid ""
"Normally, each plugin has its own namespace, so its symbols are not visible "
"to the main program or to other plugins."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:40
msgid ""
"If it is desired to make the symbols visible outside, you can load with the "
"\"public\" option.  This is not recommended for released code and likely to "
"not work with non-POSIX systems.  It is provided as a debugging aid."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/files.txt:41
#, no-wrap
msgid "Static linking"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:44
msgid ""
"In some cases it is desirable to static link code modules that are designed "
"as plugins.  Usually, all that is needed is to add the file to the list."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/files.txt:45
msgid ""
"There may be a problem with name clashes, because static linked modules "
"share the main program's namespace.  If a plugin has only one source file, "
"you can enclose all of the code in an anonymous namespace to avoid name "
"clashes."
msgstr ""

#. type: Title ======
#: manual/tech/plugins/parameter_functions_and_measurements.txt:1
#, no-wrap
msgid "Parameter function and measurement plugins"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:6
msgid ""
"The \"measure\" command and \"parameter\" commands work differently because "
"of parsing problems.  This is will be fixed someday."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:8
msgid ""
"One important difference is that the \"measure\" command fully evaluates the "
"function call, and any expressions associated with it, at the time of the "
"command, but the \"parameter\" command defers evaluation to when the "
"parameter is actually used."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:12
msgid ""
"The \"measure\" command calls a single function for evaluation, and assigns "
"its result to a parameter.  It also prints the result.  The parameter may be "
"used in parameter expressions and as an argument to another measure command."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:14
msgid ""
"The command takes the form of an assignment statement.  The target name is "
"stashed.  The name of the function is looked up in the \"function_dispatcher"
"\", using the subscript operator. The dispatcher returns a pointer to a "
"static object, or a NULL pointer if there is no match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:16
msgid ""
"Then, the method \"eval\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current “scope” so parameter expressions can be evaluated correctly. If "
"\"eval\" returns, it is assumed to have correctly done what was requested. "
"If something is wrong, it may throw an exception.  \"eval\" returns a //"
"string// containing the result, which is a string representation of the "
"numeric value."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:20
msgid ""
"The \"parameter\" command simply reads and stores the arguments as a string."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:22
msgid ""
"Later, when the parameter is used, the string is evaluated, resulting in a "
"reduced version of the expression, also as a string.  Portions that cannot "
"be evaluated are preserved as expressions."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:24
msgid ""
"As with the \"measure\", the entire argument list is passed as a \"CS\".  "
"The scope will be the scope in which the parameter is used (dynamic scoping)."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:27
msgid ""
"Usually, plugins need to include two files: \"u_parameter.h\" and "
"\"u_function.h\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:29
msgid ""
"Only one method is needed for each command: \"''eval(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:33
msgid ""
"Parameter functions use the \"function_dispatcher\".  Measure functions use "
"the \"measure_dispatcher\"."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:34
#, no-wrap
msgid "Parameter functions"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:37
msgid ""
"The argument list is usually a list of expressions separated by commas, "
"similar to many programming languages."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:39
msgid "A simple function with one argument:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:42
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"\n"
"#include \"u_function.h\"\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:55
#, no-wrap
msgid ""
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x;\n"
"    Cmd >> x;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::abs(x));\n"
"  }\n"
"} p_abs;\n"
"DISPATCHER<FUNCTION>::INSTALL d_abs(&function_dispatcher, \"abs\", &p_abs);\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:57
msgid "A function with two arguments:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid ""
"<code>\n"
"class pow : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x, y;\n"
"    Cmd >> x >> y;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    y.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::pow(x,y));\n"
"  }\n"
"} p_pow;\n"
"DISPATCHER<FUNCTION>::INSTALL d_pow(&function_dispatcher, \"pow\", &p_pow);\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid "Measurement functions"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:74
msgid ""
"Measurement functions appear to be the same as parameter functions, but are "
"not interchangeable."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:76
msgid "Usually, the following additional includes are needed:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:83
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"  // parameter expressions\n"
"#include \"s__.h\"          // find the wave object\n"
"#include \"m_wave.h\"       // the \"wave\" object, containing the data to measure\n"
"#include \"u_function.h\"   // the base class\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:85
msgid ""
"Parameters are usually given as optional name=value pairs, with expressions, "
"in any order."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:96
#, no-wrap
msgid ""
"<code>\n"
"class MEASURE : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    std::string probe_name;\n"
"    PARAMETER<double> before(BIGBIG);\n"
"    PARAMETER<double> after(-BIGBIG);\n"
"    bool last = false;\n"
"    bool arg = false;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:105
#, no-wrap
msgid ""
"    unsigned here = Cmd.cursor();\n"
"    Cmd >> probe_name;\n"
"    WAVE* w = SIM::find_wave(probe_name);  // this is the wave to scan for the measurement\n"
"                                           // specified first, without saying \"probe=\"\n"
"    if (!w) { // didn't find it\n"
"      Cmd.reset(here);\n"
"    }else{\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:119
#, no-wrap
msgid ""
"    here = Cmd.cursor();                   // scan for parameters\n"
"    do {\n"
"      ONE_OF\n"
"\t|| Get(Cmd, \"probe\",  &probe_name)\n"
"\t|| Get(Cmd, \"before\", &before)\n"
"\t|| Get(Cmd, \"after\",  &after)\n"
"\t|| Get(Cmd, \"end\",    &before)\n"
"\t|| Get(Cmd, \"begin\",  &after)\n"
"\t|| Set(Cmd, \"arg\",    &arg, true)\n"
"\t|| Set(Cmd, \"last\",   &last, true)\n"
"\t|| Set(Cmd, \"first\",  &last, false)\n"
"\t;\n"
"    }while (Cmd.more() && !Cmd.stuck(&here));\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:124
#, no-wrap
msgid ""
"    if (!w) {                               // \"probe=\" .. the wave to scan\n"
"      w = SIM::find_wave(probe_name);\n"
"    }else{\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:128
#, no-wrap
msgid ""
"    if (w) {\n"
"      before.e_val(BIGBIG, Scope);          // evaluate parameters\n"
"      after.e_val(-BIGBIG, Scope);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:149
#, no-wrap
msgid ""
"      // find the min.\n"
"      double time = (last) ? -BIGBIG : BIGBIG;  // what to return if there's no min.\n"
"      double m = BIGBIG;\n"
"      WAVE::const_iterator begin = lower_bound(w->begin(), w->end(), DPAIR(after, -BIGBIG));\n"
"      WAVE::const_iterator end   = upper_bound(w->begin(), w->end(), DPAIR(before, BIGBIG));\n"
"      for (WAVE::const_iterator i = begin; i < end; ++i) {\n"
"\tdouble val = i->second;\n"
"\tif (val < m || (last && (val == m))) {\n"
"\t  time = i->first;\n"
"\t  m = val;\n"
"\t}else{\n"
"\t}\n"
"      }\n"
"      return to_string((arg) ? (time) : (m));\n"
"    }else{\n"
"      throw Exception_No_Match(probe_name);\n"
"    }\n"
"  }\n"
"} p2;\n"
"DISPATCHER<FUNCTION>::INSTALL d2(&measure_dispatcher, \"min\", &p2);\n"
"</code>\n"
msgstr ""

#~ msgid ""
#~ "  * [[gnucap:manual:Introduction]]\n"
#~ "  * [[gnucap:manual:Commands]]\n"
#~ "  * [[gnucap:manual:Devices]]\n"
#~ "  * [[gnucap:manual:Languages]]\n"
#~ "  * [[gnucap:manual:Howto|How to]]\n"
#~ "  * [[gnucap:manual:Compatibility]]\n"
#~ "  * [[gnucap:manual:Tech|Tech notes]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Building and Installation]]\n"
#~ "  * [[gnucap:manual:Examples]]\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:Introduction.ru |Введение            ]]\n"
#~ "  * [[gnucap:manual:Commands.ru     |Команды             ]]\n"
#~ "  * [[gnucap:manual:Devices.ru      |Устройства          ]]\n"
#~ "  * [[gnucap:manual:Languages.ru    |Языки               ]]\n"
#~ "  * [[gnucap:manual:Howto.ru        |Как сделать         ]]\n"
#~ "  * [[gnucap:manual:Compatibility.ru|Совместимость       ]]\n"
#~ "  * [[gnucap:manual:Tech.ru         |Технические заметки ]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Сборка и установка]]\n"
#~ "  * [[gnucap:manual:Examples.ru     |Примеры             ]]\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:edit]] Edit the circuit description using your editor.\n"
#~ "  * [[gnucap:manual:commands:fault|fault,unfault]] Temporarily change a component.\n"
#~ "  * [[gnucap:manual:commands:list]] List the circuit on the display.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:edit.ru  |edit         ]] Редактирование схемы в текстовом редакторе.\n"
#~ "  * [[gnucap:manual:commands:fault.ru |fault,unfault]] Временное изменение значения компонента.\n"
#~ "  * [[gnucap:manual:commands:list.ru  |list         ]] Вывод описания схемы на экран.\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:parameter]] Set or view parameters.\n"
#~ "  * [[gnucap:manual:commands:measure]] Make (post) measurements on your circuit.\n"
#~ "  * [[gnucap:manual:commands:eval]] Evaluate parameters.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:parameter.ru|parameter]] Установка или просмотр параметров.\n"
#~ "  * [[gnucap:manual:commands:measure.ru|measure]] Измерения (по окончании моделирования) в схеме.\n"
#~ "  * [[gnucap:manual:commands:eval.ru|eval]] Оценка параметров.\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:plot|plot, iplot]] Select points in the circuit (and their range) to plot.\n"
#~ "  * [[gnucap:manual:commands:print|print, iprint, probe]] Select points in the circuit to print as table.\n"
#~ "  * [[gnucap:manual:commands:store]] Select points in the circuit to store for post-processing.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:plot.ru|plot, iplot]] Выбор точек схемы (и их диапазона) для вывода графика.\n"
#~ "  * [[gnucap:manual:commands:print.ru|print, iprint, probe]] Выбор точек схемы для вывода таблицы значений.\n"
#~ "  * [[gnucap:manual:commands:store.ru|store]] Выбор точек схемы для сохранения с целью дальнейшей пост-обработки.\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:include]] Include a file from disk. Add it the what is already in memory.\n"
#~ "  * [[gnucap:manual:commands:lib]] Include parts of a library file.\n"
#~ "  * [[gnucap:manual:commands:load|load, unload]] Load a plugin.\n"
#~ "  * [[gnucap:manual:commands:get]] Get a circuit from a disk file. Deletes old one first for a fresh start. (deprecated)\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:include.ru|include]] Включение файла с диска. Добавление его к тому, что уже имеется в памяти.\n"
#~ "  * [[gnucap:manual:commands:lib.ru|lib]] Включение частей библиотечных файлов.\n"
#~ "  * [[gnucap:manual:commands:load.ru|load, unload]] Загрузка плагина.\n"
#~ "  * [[gnucap:manual:commands:get.ru|get]] Получение описания схемы из файла на диске. Сначала удаляется старый для свежего запуска. (Использовать не рекомендуется.)\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:save]] Save the circuit in a file.\n"
#~ "  * [[gnucap:manual:commands:log]] Create a log file.\n"
#~ "  * [[gnucap:manual:commands:outfile|>]] Send a copy of the screen output to a file.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:save.ru|save]] Сохранение описания схемы в файл.\n"
#~ "  * [[gnucap:manual:commands:log.ru|log]] Создание файла журнала.\n"
#~ "  * [[gnucap:manual:commands:outfile.ru|>]] Выдача копии экранного вывода в файл.\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:temp]] Set or view temperature.\n"
#~ "  * [[gnucap:manual:commands:width]] Set output width.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:temp.ru|temp]] Установка или просмотр температуры.\n"
#~ "  * [[gnucap:manual:commands:width.ru|width]] Установка ширины вывода.\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:sweep]] Sweep a component. (Loop function.) (deprecated)\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:sweep.ru|sweep]] Смена компонента. (Функция цикла.) (Использовать не рекомендуется.)\n"

#~ msgid ""
#~ "  * [[gnucap:manual:commands:chdir]] Change current directory.\n"
#~ "  * [[gnucap:manual:commands:pause]] Wait for key hit in batch mode.\n"
#~ "  * [[gnucap:manual:commands:status]] Display resource usage, etc.\n"
#~ "  * [[gnucap:manual:commands:title]] View and create the heading line for printouts and files.\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:commands:chdir.ru|chdir]] Смена текущего каталога.\n"
#~ "  * [[gnucap:manual:commands:pause.ru|pause]] Ожидания нажатия клавиши в пакетном режиме.\n"
#~ "  * [[gnucap:manual:commands:status.ru|status]] Вывод использования ресурсов и т. п.\n"
#~ "  * [[gnucap:manual:commands:title.ru|title]] Просмотр и создание строк заголовков для вывода на печать или в файл.\n"

#~ msgid ""
#~ "  * [[.:devices:basic|Basic passive devices]]\n"
#~ "  * [[.:devices:other|Other \"spice\" devices]]\n"
#~ "  * [[.:devices:semi|Semiconductor devices]]\n"
#~ msgstr ""
#~ "  * [[.:devices:basic.ru|Базовые пассивные приборы ]]\n"
#~ "  * [[.:devices:other.ru|Прочие «spice»-устройства ]]\n"
#~ "  * [[.:devices:semi.ru |Полупроводниковые приборы ]]\n"

#~ msgid ""
#~ "  * admittance (Y)\n"
#~ "  * voltage controlled resistor\n"
#~ "  * voltage controlled capacitor\n"
#~ "  * voltage controlled admittance\n"
#~ "  * trans-capacitor\n"
#~ msgstr ""
#~ "  * проводимость (Y)\n"
#~ "  * резистор, управляемый напряжением\n"
#~ "  * конденсатор, управляемый напряжением\n"
#~ "  * проводимость, управляемая напряжением\n"
#~ "  * проходная ёмкость\n"


#~ msgid ""
#~ "  * [[gnucap:manual:tech:plugins]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man105.html|adding models (old)]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man107.html|old tech notes]]\n"
#~ msgstr ""
#~ "  * [[gnucap:manual:tech:plugins.ru|Плагины]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man105.html|Добавление моделей (старая версия)]]\n"
#~ "  * [[http://gnucap.org/gnucap-man-html/gnucap-man107.html|Старые технические заметки]]\n"
