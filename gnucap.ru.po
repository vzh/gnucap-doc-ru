# Russian translations for gnucap package
# Copyright (C) 2013 Vladimir Zhbanov
# This file is distributed under the same license as the gnucap package.
#
msgid ""
msgstr ""
"Project-Id-Version: gnucap\n"
"POT-Creation-Date: 2013-10-25 14:28+0400\n"
"PO-Revision-Date: 2013-10-25 15:07+0400\n"
"Last-Translator: Vladimir Zhbanov <vzhbanov@gmail.com>\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: Title ======
#: manual.txt:1
#, no-wrap
msgid "Gnucap manual"
msgstr "Руководство по gnucap"

#. type: Plain text
#: manual.txt:4
msgid "This is a draft of the manual for the development version of gnucap."
msgstr "Это черновой набросок руководства для разрабатываемой версии gnucap."

#. type: Plain text
#: manual.txt:6
msgid "It attempts to describe the latest development release."
msgstr "Здесь мы пытаемся описать самую последнюю разрабатываемую версию."

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Introduction]]\n"
msgstr "[[gnucap:manual:Introduction.ru |Введение            ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Commands]]\n"
msgstr "[[gnucap:manual:Commands.ru     |Команды             ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Devices]]\n"
msgstr "[[gnucap:manual:Devices.ru      |Устройства          ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Languages]]\n"
msgstr "[[gnucap:manual:Languages.ru    |Языки               ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Howto|How to]]\n"
msgstr "[[gnucap:manual:Howto.ru        |Как сделать         ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Compatibility]]\n"
msgstr "[[gnucap:manual:Compatibility.ru|Совместимость       ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Tech|Tech notes]]\n"
msgstr "[[gnucap:manual:Tech.ru         |Техническая информация ]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Building and Installation]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man100.html|Сборка и установка]]\n"

#. type: Bullet: '  * '
#: manual.txt:16
#, no-wrap
msgid "[[gnucap:manual:Examples]]\n"
msgstr "[[gnucap:manual:Examples.ru     |Примеры             ]]\n"

#. type: Title ======
#: manual/commands.txt:1 manual/languages/spectre.txt:94
#: manual/languages/verilog.txt:120 about/plugins/commands.txt:3
#: spectre.txt:66
#, no-wrap
msgid "Commands"
msgstr "Команды"

#. type: Plain text
#: manual/commands.txt:4
msgid ""
"Gnucap commands are defined by plugins.  This section defines all commands "
"supplied in the main tarball."
msgstr ""
"Команды gnucap определяются посредством плагинов. В настоящем разделе "
"определяются все команды, поставляемые в основном tar-архиве."

#. type: Plain text
#: manual/commands.txt:6
msgid ""
"Your installation may not have all of these commands, and may have others in "
"addition to these.  It depends on which plugins you have installed."
msgstr ""
"В вашей установке может не быть всех представленных ниже команд, или могут "
"быть другие в дополнение к указанным. Это зависит от того, какие у вас "
"установлены плагины."

#. type: Title =====
#: manual/commands.txt:7
#, no-wrap
msgid "\"Simulation\" or \"analysis\" commands"
msgstr "Команды для моделирования или анализа"

#. type: Plain text
#: manual/commands.txt:10
msgid "These commands are the core simulation commands."
msgstr "Здесь представлены основные команды моделирования."

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:ac]] Performs a small signal AC (frequency domain) analysis. Sweeps frequency.\n"
msgstr "[[gnucap:manual:commands:ac.ru|ac]] Малосигнальный частотный анализ (в частотной области) при изменении частоты.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:dc]] Performs a nonlinear DC analysis, for determining transfer characteristics. Sweeps DC input or component values.\n"
msgstr "[[gnucap:manual:commands:dc.ru|dc]] Нелинейный анализ (расчёт статического режима) по постоянному току для определения передаточной характеристики при изменении входа по постоянному току или значений компонентов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:fourier]] Transient analysis, with results in frequency domain.\n"
msgstr "[[gnucap:manual:commands:fourier.ru|fourier]] Временной анализ с результатами в частотной области.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:op]] Performs a nonlinear DC analysis, for determining quiescent operating conditions. Sweeps temperature.\n"
msgstr "[[gnucap:manual:commands:op.ru|op]] Нелинейный анализ (расчёт статического режима) по постоянному току для определения статических условий работы при изменении температуры.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:16
#, no-wrap
msgid "[[gnucap:manual:commands:transient]] Performs a nonlinear transient (time domain) analysis. Sweeps time.\n"
msgstr "[[gnucap:manual:commands:transient.ru|transient]] Нелинейный временной анализ (во временной области) при изменении времени.\n"

#. type: Title =====
#: manual/commands.txt:17 user/command_plugins.txt:9
#, no-wrap
msgid "\"Data\" commands"
msgstr "Команды для работы с данными"

#. type: Plain text
#: manual/commands.txt:20
msgid "These commands manipulate the circuit."
msgstr "Данные команды служат для работы со схемами."

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:build]] Build a new circuit or change an existing one.\n"
msgstr "[[gnucap:manual:commands:build.ru |build        ]] Построение новой схемы или изменение уже существующей.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:delete|clear]] Delete the entire circuit, titles, etc.\n"
msgstr "[[gnucap:manual:commands:delete.ru|clear        ]] Удаление схемы полностью, заголовков и т. д.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:delete]] Delete a part, or group of parts.\n"
msgstr "[[gnucap:manual:commands:delete.ru|delete       ]] Удаление компонента, группы компонентов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:edit]] Edit the circuit description using your editor.\n"
msgstr "[[gnucap:manual:commands:edit.ru  |edit         ]] Редактирование схемы во внешнем редакторе.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:fault|fault,unfault]] Temporarily change a component.\n"
msgstr "[[gnucap:manual:commands:fault.ru |fault,unfault]] Временное изменение значения компонента.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:list]] List the circuit on the display.\n"
msgstr "[[gnucap:manual:commands:list.ru  |list         ]] Вывод описания схемы на экран.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:28
#, no-wrap
msgid "[[gnucap:manual:commands:alter|alter, modify]] Change a value, node, etc. For very simple changes.\n"
msgstr "[[gnucap:manual:commands:alter.ru |alter, modify]] Изменение значения компонента, узла и т. д. Для очень простых изменений.\n"

#. type: Title =====
#: manual/commands.txt:29 user/command_plugins.txt:24
#, no-wrap
msgid "\"Parameter\" and \"Measure\" commands"
msgstr "Команды для работы с параметрами и измерениями"

#. type: Plain text
#: manual/commands.txt:32
msgid "These commands work with parameters."
msgstr "Данные команды предназначены для работы с параметрами."

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:parameter]] Set or view parameters.\n"
msgstr "[[gnucap:manual:commands:parameter.ru|parameter]] Установка или просмотр параметров.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:measure]] Make (post) measurements on your circuit.\n"
msgstr "[[gnucap:manual:commands:measure.ru|measure]] Измерения (по окончании моделирования) в схеме.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:36
#, no-wrap
msgid "[[gnucap:manual:commands:eval]] Evaluate parameters.\n"
msgstr "[[gnucap:manual:commands:eval.ru|eval]] Оценка параметров.\n"

#. type: Title =====
#: manual/commands.txt:37
#, no-wrap
msgid "\"Probe\" commands"
msgstr "Команды для датчиков"

#. type: Plain text
#: manual/commands.txt:40
msgid "These commands set up probes for later use."
msgstr ""
"Данные команды предназначены для настройки «датчиков» для дальнейшего "
"использования."

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:alarm]] Select points in the circuit to check against limits.\n"
msgstr "[[gnucap:manual:commands:alarm.ru|alarm]] Выбор точек схемы для проверки на превышение пределов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:plot|plot, iplot]] Select points in the circuit (and their range) to plot.\n"
msgstr "[[gnucap:manual:commands:plot.ru|plot, iplot]] Выбор точек схемы (и их диапазона) для вывода графика.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:print|print, iprint, probe]] Select points in the circuit to print as table.\n"
msgstr "[[gnucap:manual:commands:print.ru|print, iprint, probe]] Выбор точек схемы для вывода таблицы значений.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:45
#, no-wrap
msgid "[[gnucap:manual:commands:store]] Select points in the circuit to store for post-processing.\n"
msgstr "[[gnucap:manual:commands:store.ru|store]] Выбор точек схемы, данные которых должны сохраняться для дальнейшей обработки.\n"

#. type: Title =====
#: manual/commands.txt:46 user/command_plugins.txt:32
#, no-wrap
msgid "\"File\" commands"
msgstr "Команды для работы с файлами"

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:include]] Include a file from disk. Add it the what is already in memory.\n"
msgstr "[[gnucap:manual:commands:include.ru|include]] Включение содержимого файла с диска. Добавление его к тому, что уже имеется в памяти.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:lib]] Include parts of a library file.\n"
msgstr "[[gnucap:manual:commands:lib.ru|lib]] Включение частей библиотечных файлов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:load|load, unload]] Load a plugin.\n"
msgstr "[[gnucap:manual:commands:load.ru|load, unload]] Загрузка плагинов.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:52
#, no-wrap
msgid "[[gnucap:manual:commands:get]] Get a circuit from a disk file. Deletes old one first for a fresh start. (deprecated)\n"
msgstr "[[gnucap:manual:commands:get.ru|get]] Считывание описания схемы из файла на диске. Сначала удаляется старый, чтобы начать всё заново. (Использовать не рекомендуется.)\n"

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:save]] Save the circuit in a file.\n"
msgstr "[[gnucap:manual:commands:save.ru|save]] Сохранение описания схемы в файл.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:log]] Create a log file.\n"
msgstr "[[gnucap:manual:commands:log.ru|log]] Создание файла журнала.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:56
#, no-wrap
msgid "[[gnucap:manual:commands:outfile|>]] Send a copy of the screen output to a file.\n"
msgstr "[[gnucap:manual:commands:outfile.ru|>]] Выдача копии экранного вывода в файл.\n"

#. type: Title =====
#: manual/commands.txt:57 user/command_plugins.txt:45
#, no-wrap
msgid "\"Other\" commands"
msgstr "Прочие команды"

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid "[[gnucap:manual:commands:end]] Perform analyses in queue. New circuit follows. (Implemented incorrectly.)\n"
msgstr "[[gnucap:manual:commands:end.ru|end]] Выполнение анализов по очереди. Далее следует описание новой схемы. (Реализовано неправильно.)\n"

#. type: Bullet: '  * '
#: manual/commands.txt:61
#, no-wrap
msgid "[[gnucap:manual:commands:exit|exit, quit]] Exits the program.\n"
msgstr "[[gnucap:manual:commands:exit.ru|exit, quit]] Выход из программы.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:options]] View and set system options. (Same as set.)\n"
msgstr "[[gnucap:manual:commands:options.ru|options]] Просмотр и установка системных опций. (То же самое, что и [[set.ru|set]].)\n"

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:temp]] Set or view temperature.\n"
msgstr "[[gnucap:manual:commands:temp.ru|temp]] Установка или просмотр температуры.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:65
#, no-wrap
msgid "[[gnucap:manual:commands:width]] Set output width.\n"
msgstr "[[gnucap:manual:commands:width.ru|width]] Установка ширины вывода.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:sweep]] Sweep a component. (Loop function.) (deprecated)\n"
msgstr "[[gnucap:manual:commands:sweep.ru|sweep]] Изменение значения компонента. (Функция цикла.) (Использовать не рекомендуется.)\n"

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:generator]] View and set the transient analysis function generator.\n"
msgstr "[[gnucap:manual:commands:generator.ru|generator]] Просмотр и настройка параметров функционального генератора для временного анализа.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:69
#, no-wrap
msgid "[[gnucap:manual:commands:freeze|freeze, unfreeze]] Mark this time point, so transient analysis will restart here.\n"
msgstr "[[gnucap:manual:commands:freeze.ru|freeze, unfreeze]] Отметка указанной точки времени для перезапуска в ней временного анализа.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:chdir]] Change current directory.\n"
msgstr "[[gnucap:manual:commands:chdir.ru|chdir]] Смена текущего каталога.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:pause]] Wait for key hit in batch mode.\n"
msgstr "[[gnucap:manual:commands:pause.ru|pause]] Ожидание нажатия клавиши при работе в пакетном режиме.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:status]] Display resource usage, etc.\n"
msgstr "[[gnucap:manual:commands:status.ru|status]] Вывод использования ресурсов и т. п.\n"

#. type: Bullet: '  * '
#: manual/commands.txt:73
#, no-wrap
msgid "[[gnucap:manual:commands:title]] View and create the heading line for printouts and files.\n"
msgstr "[[gnucap:manual:commands:title.ru|title]] Просмотр и создание строк заголовков для вывода на печать или в файл.\n"

#. type: Title ======
#: manual/commands/ac.txt:1
#, no-wrap
msgid "\"ac\" command"
msgstr "Команда «ac»"

#. type: Title =====
#: manual/commands/ac.txt:3 manual/commands/alarm.txt:3
#: manual/commands/alter.txt:3 manual/commands/build.txt:3
#: manual/commands/chdir.txt:3 manual/commands/dc.txt:3
#: manual/commands/delete.txt:3 manual/commands/edit.txt:3
#: manual/commands/eval.txt:3 manual/commands/exit.txt:4
#: manual/commands/fault.txt:3 manual/commands/fourier.txt:3
#: manual/commands/freeze.txt:3 manual/commands/generator.txt:3
#: manual/commands/get.txt:3 manual/commands/include.txt:3
#: manual/commands/lib.txt:3 manual/commands/list.txt:3
#: manual/commands/load.txt:3 manual/commands/log.txt:3
#: manual/commands/measure.txt:3 manual/commands/op.txt:3
#: manual/commands/options.txt:3 manual/commands/options.txt:11
#: manual/commands/outfile.txt:3 manual/commands/parameter.txt:3
#: manual/commands/pause.txt:3 manual/commands/plot.txt:3
#: manual/commands/print.txt:3 manual/commands/save.txt:3
#: manual/commands/status.txt:3 manual/commands/store.txt:3
#: manual/commands/sweep.txt:3 manual/commands/temp.txt:3
#: manual/commands/title.txt:3 manual/commands/transient.txt:3
#: manual/commands/width.txt:3 manual/devices/basic/complex.txt:7
#: manual/devices/basic/exp.txt:8 manual/devices/basic/fit.txt:6
#: manual/devices/basic/generator.txt:7 manual/devices/basic/poly.txt:8
#: manual/devices/basic/posy.txt:8 manual/devices/basic/pulse.txt:8
#: manual/devices/basic/sffm.txt:8 manual/devices/basic/sin.txt:8
#: manual/devices/basic/tanh.txt:8 manual/devices/capacitor.txt:32
#: manual/devices/lossless_transmission_line.txt:7
#: manual/devices/mutual_inductance.txt:7 manual/devices/switches.txt:26
#: manual/measure/at.txt:3 manual/measure/cross.txt:3
#: manual/measure/mean.txt:3 manual/measure/minmax.txt:3
#: manual/measure/slope.txt:3 manual/measure/integrate.txt:3
#, no-wrap
msgid "Purpose"
msgstr "Назначение"

#. type: Plain text
#: manual/commands/ac.txt:6
msgid "Performs a small signal, steady state, AC analysis. Sweeps frequency."
msgstr ""
"Выполнение малосигнального частотного анализа в установившемся режиме при "
"изменении частоты."

#. type: Title =====
#: manual/commands/ac.txt:7 manual/commands/alarm.txt:7
#: manual/commands/alter.txt:7 manual/commands/build.txt:7
#: manual/commands/chdir.txt:7 manual/commands/dc.txt:7
#: manual/commands/delete.txt:7 manual/commands/edit.txt:7
#: manual/commands/eval.txt:7 manual/commands/exit.txt:8
#: manual/commands/fault.txt:7 manual/commands/fourier.txt:7
#: manual/commands/freeze.txt:7 manual/commands/generator.txt:7
#: manual/commands/get.txt:8 manual/commands/include.txt:7
#: manual/commands/lib.txt:7 manual/commands/list.txt:7
#: manual/commands/load.txt:7 manual/commands/log.txt:7
#: manual/commands/measure.txt:7 manual/commands/op.txt:7
#: manual/commands/options.txt:7 manual/commands/outfile.txt:7
#: manual/commands/parameter.txt:7 manual/commands/pause.txt:7
#: manual/commands/plot.txt:7 manual/commands/print.txt:7
#: manual/commands/save.txt:7 manual/commands/status.txt:7
#: manual/commands/store.txt:7 manual/commands/sweep.txt:7
#: manual/commands/temp.txt:7 manual/commands/title.txt:7
#: manual/commands/transient.txt:7 manual/commands/width.txt:7
#: manual/devices/basic/complex.txt:3 manual/devices/basic/exp.txt:3
#: manual/devices/basic/fit.txt:2 manual/devices/basic/generator.txt:3
#: manual/devices/basic/poly.txt:3 manual/devices/basic/posy.txt:3
#: manual/devices/basic/pulse.txt:3 manual/devices/basic/sffm.txt:3
#: manual/devices/basic/sin.txt:3 manual/devices/basic/tanh.txt:3
#: manual/devices/lossless_transmission_line.txt:3
#: manual/devices/mutual_inductance.txt:3 manual/devices/switches.txt:4
#: manual/measure/at.txt:7 manual/measure/cross.txt:7
#: manual/measure/mean.txt:9 manual/measure/minmax.txt:7
#: manual/measure/slope.txt:7 manual/measure/integrate.txt:7
#, no-wrap
msgid "Syntax"
msgstr "Синтаксис"

#. type: Plain text
#: manual/commands/ac.txt:10
#, no-wrap
msgid "  ac {//options// ...} //start stop stepsize// {//options// ...}\n"
msgstr "| ''**ac** {//опции// ...} //начало конец размер_шага// {//опции// ...}'' |\n"

#. type: Title =====
#: manual/commands/ac.txt:11 manual/commands/alarm.txt:14
#: manual/commands/alter.txt:12 manual/commands/build.txt:11
#: manual/commands/chdir.txt:12 manual/commands/dc.txt:12
#: manual/commands/delete.txt:14 manual/commands/edit.txt:12
#: manual/commands/eval.txt:11 manual/commands/exit.txt:13
#: manual/commands/fault.txt:12 manual/commands/fourier.txt:13
#: manual/commands/freeze.txt:12 manual/commands/generator.txt:11
#: manual/commands/get.txt:12 manual/commands/include.txt:11
#: manual/commands/lib.txt:12 manual/commands/list.txt:12
#: manual/commands/load.txt:13 manual/commands/log.txt:13
#: manual/commands/measure.txt:10 manual/commands/op.txt:11
#: manual/commands/options.txt:15 manual/commands/outfile.txt:13
#: manual/commands/parameter.txt:14 manual/commands/pause.txt:15
#: manual/commands/plot.txt:18 manual/commands/print.txt:15
#: manual/commands/save.txt:11 manual/commands/status.txt:12
#: manual/commands/store.txt:15 manual/commands/sweep.txt:11
#: manual/commands/temp.txt:12 manual/commands/title.txt:12
#: manual/commands/transient.txt:11 manual/commands/width.txt:11
#: manual/devices/basic/complex.txt:11 manual/devices/basic/exp.txt:11
#: manual/devices/basic/fit.txt:11 manual/devices/basic/generator.txt:12
#: manual/devices/basic/poly.txt:12 manual/devices/basic/posy.txt:13
#: manual/devices/basic/pulse.txt:12 manual/devices/basic/sffm.txt:12
#: manual/devices/basic/sin.txt:12 manual/devices/basic/tanh.txt:12
#: manual/devices/capacitor.txt:35
#: manual/devices/lossless_transmission_line.txt:11
#: manual/devices/mutual_inductance.txt:11 manual/measure/mean.txt:22
#: manual/measure/slope.txt:23 manual/measure/integrate.txt:18
#, no-wrap
msgid "Comments"
msgstr "Описание"

#. type: Plain text
#: manual/commands/ac.txt:14
msgid ""
"The \"ac\" command does a linear analysis about an operating point. It is "
"absolutely necessary to do an \"op\" analysis first on any nonlinear "
"circuit. Not doing this is the equivalent of testing it with the power off."
msgstr ""
"Команда **ac** служит для выполнения линейного анализа в области рабочей "
"точки. Для любой нелинейной схемы абсолютно необходимо сначала выполнить "
"анализ [[op.ru|op]]. Его невыполнение эквивалентно тестированию схемы с "
"отключенным питанием."

#. type: Plain text
#: manual/commands/ac.txt:16
msgid ""
"Three parameters are normally needed for an AC analysis: start frequency, "
"stop frequency and step size, in this order. If all of these are omitted, "
"the values from the most recent AC analysis are used."
msgstr ""
"Обычно для частотного анализа нужно три параметра: начальная частота, "
"конечная частота и размер шага, в указанном порядке. Если ничего из этого не "
"задано, будут использоваться значения самого последнего анализа."

#. type: Plain text
#: manual/commands/ac.txt:18
msgid ""
"If only one frequency is specified, a single point analysis will be done."
msgstr "Если указана только одна частота, будет сделан анализ в одной точке."

#. type: Plain text
#: manual/commands/ac.txt:20
msgid ""
"If only a new step size is specified, the old start and stop are kept and "
"only the step size is changed. This is indicated by a keyword: by, times, "
"decade or octave, or a symbol: + or *."
msgstr ""
"Если указан только новый размер шага, старые значения начальной и конечной "
"частоты будут сохранены и изменится только размер шага. Шаг задаётся с "
"помощью ключевых слов ''by'', ''times'', ''decade'' или ''octave'' или одним "
"из символов ''+'' или ''*''."

#. type: Plain text
#: manual/commands/ac.txt:22
msgid ""
"If the start frequency is zero, the program will still do an AC analysis. "
"The actual frequency can be considered to be the limit as the frequency "
"approaches zero. It is, therefore, still possible to have a non-zero phase "
"angle, but delays are not shown because they may be infinite."
msgstr ""
"Если начальная частота равна нулю, программа всё же выполнит частотный "
"анализ. За фактическую начальную частоту может приниматься предельное, очень "
"близкое к нулю значение. Поэтому угол фазы всё же может быть ненулевым, но "
"задержки не отображаются, поскольку они могут быть бесконечными."

#. type: Plain text
#: manual/commands/ac.txt:24
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command. This is different from Spice."
msgstr ""
"Контролируемые узлы должны быть заранее выбраны командами [[print.ru|print]] "
"или [[plot.ru|plot]]. Это отличие от SPICE."

#. type: Title =====
#: manual/commands/ac.txt:25 manual/commands/dc.txt:28
#: manual/commands/fourier.txt:36 manual/commands/op.txt:23
#: manual/commands/transient.txt:23
#, no-wrap
msgid "Options"
msgstr "Опции"

#. type: Title ====
#: manual/commands/ac.txt:27 manual/commands/dc.txt:30
#: manual/commands/fourier.txt:38 manual/commands/op.txt:25
#: manual/commands/transient.txt:25
#, no-wrap
msgid "Sweep control"
msgstr "Настройка развёртки"

#. type: Plain text
#: manual/commands/ac.txt:36
#, no-wrap
msgid ""
"|start //frequency//   |Sweep start //frequency//.  |\n"
"|stop //frequency//    |Sweep stop //frequency//.  |\n"
"|+ //stepsize//        |Linear sweep. Add //stepsize// to get the next step. Same as by.  |\n"
"|* //multiplier//      |Log sweep. Multiply by //multiplier// to get the next step.  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next step. Same as +.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|octave //steps//      |Log sweep. Use //steps// steps per octave.  |\n"
"|times //multiplier//  |Log sweep. Multiply by //multiplier// to get the next step.  |\n"
msgstr ""
"|''start //частота//            ''|Начальная ''//частота//'' диапазона.  |\n"
"|''stop //частота//             ''|Конечная  ''//частота//'' диапазона.  |\n"
"|''+ //шаг//                    ''|Линейная развёртка. Для получения следующей частоты добавляется ''//шаг//''. То же самое, что ''by''.  |\n"
"|''* //множитель//              ''|Логарифмическая развёртка. Следующий шаг получается умножением предыдущего значения на ''//множитель//''.  |\n"
"|''by //шаг//                   ''|Линейная развёртка. Для получения следующей частоты добавляется ''//шаг//''. То же самое, что ''+''.  |\n"
"|''decade //количество_шагов//  ''|Логарифмическая развёртка. Используется заданное ''//количество_шагов//'' на декаду.  |\n"
"|''octave //количество_шагов//  ''|Логарифмическая развёртка. Используется заданное ''//количество_шагов//'' на октаву.  |\n"
"|''times //множитель//          ''|Логарифмическая развёртка. Следующий шаг получается умножением предыдущего значения на ''//множитель//''.  |\n"

#. type: Title ====
#: manual/commands/ac.txt:37 manual/commands/dc.txt:39
#: manual/commands/fourier.txt:44 manual/commands/op.txt:34
#: manual/commands/transient.txt:31
#, no-wrap
msgid "Input / Output"
msgstr "Вход / Выход"

#. type: Plain text
#: manual/commands/ac.txt:43 manual/commands/dc.txt:45
#: manual/commands/fourier.txt:50 manual/commands/op.txt:40
#: manual/commands/transient.txt:37
#, no-wrap
msgid ""
"|> //file//   |Send results of analysis to file.  |\n"
"|>> //file//  |Append results to file.  |\n"
"|noplot       |Suppress plotting.  |\n"
"|plot         |Graphic output, when plotting is normally off.  |\n"
"|quiet        |Suppress console output.  |\n"
msgstr ""
"|''> //файл//       ''| Вывод результатов анализа в ''//файл//''      |\n"
"|''%%>>%% //файл//  ''| Добавление результатов в ''//файл//''         |\n"
"|''noplot           ''| Запрет построения графиков                    |\n"
"|''plot             ''| Разрешение вывода графиков, если он запрещён  |\n"
"|''quiet            ''| Запрет вывода на консоль                      |\n"

#. type: Title ====
#: manual/commands/ac.txt:44 manual/commands/dc.txt:51
#: manual/commands/fourier.txt:58 manual/commands/op.txt:41
#: manual/commands/transient.txt:44
#, no-wrap
msgid "Other"
msgstr "Прочие"

#. type: Plain text
#: manual/commands/ac.txt:47
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command. This does not apply to nonlinear components, which will inherit the temperature from the operating point analysis.|\n"
"|temperature //degrees//  |Temperature, degrees C. This does not apply to nonlinear components, which will inherit the temperature from the operating point analysis.|\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]]. Это не касается нелинейных компонентов, которые наследуют свою температуру из анализа [[op.ru|op]].|\n"
"|''temperature //градусы//  ''| Температура, °C. Это не касается нелинейных компонентов, которые наследуют свою температуру из анализа [[op.ru|op]].|\n"

#. type: Title =====
#: manual/commands/ac.txt:48 manual/commands/alarm.txt:33
#: manual/commands/chdir.txt:18 manual/commands/dc.txt:55
#: manual/commands/delete.txt:24 manual/commands/edit.txt:22
#: manual/commands/eval.txt:15 manual/commands/fourier.txt:64
#: manual/commands/freeze.txt:18 manual/commands/generator.txt:42
#: manual/commands/get.txt:22 manual/commands/include.txt:19
#: manual/commands/list.txt:22 manual/commands/load.txt:29
#: manual/commands/log.txt:25 manual/commands/measure.txt:40
#: manual/commands/op.txt:50 manual/commands/outfile.txt:21
#: manual/commands/parameter.txt:30 manual/commands/pause.txt:21
#: manual/commands/plot.txt:45 manual/commands/print.txt:33
#: manual/commands/save.txt:19 manual/commands/store.txt:27
#: manual/commands/title.txt:18 manual/commands/transient.txt:50
#: manual/devices/basic/inline_behavioral_modeling.txt:79
#: manual/measure/at.txt:22 manual/measure/cross.txt:34
#: manual/measure/mean.txt:30 manual/measure/minmax.txt:21
#: manual/measure/slope.txt:29 manual/measure/integrate.txt:22
#, no-wrap
msgid "Examples"
msgstr "Примеры"

#. type: Plain text
#: manual/commands/ac.txt:69
#, no-wrap
msgid ""
"  ac 10m\n"
"A single point AC analysis at 10 mHz.\n"
"  ac 1000 3000 100\n"
"Sweep from 1000 Hz to 3000 Hz in 100 Hz steps.\n"
"  ac start=1000 stop=3000 step=100\n"
"Same as the last one.\n"
"  ac 1000 3000 Octave\n"
"Sweep from 1000 Hz to 3000 Hz in octave steps. Since the sweep cannot end at 3000 Hz, in this case, the last step will really be 4000 Hz.\n"
"  ac by 250\n"
"Keep the same limits as before, but use 250 Hz steps. In this case, it means to sweep from 1000 to 3000 Hz, because that it what it was the last time.\n"
"  ac 5000 1000 -250\n"
"You can sweep downward, if you want. Remember that the increment would be negative.\n"
"  ac 20 20k *2\n"
"Double the frequency to get the next step.\n"
"  ac 20k 20 *.5\n"
"You can do a log sweep downward, too. A multiplier of less than one moves it down.\n"
"  ac\n"
"Do the same AC sweep again.\n"
"  ac >afile\n"
"Save the results in the file ''afile''. The file will look just like the screen. It will have all probe points. It will be a plot, if plotting is enabled.\n"
msgstr ""
"  ac 10m\n"
"Частотный анализ в одной точке при 10 мГц.\n"
"  ac 1000 3000 100\n"
"Изменение от 1000 Гц до 3000 Гц с шагом 100 Гц.\n"
"  ac start=1000 stop=3000 step=100\n"
"То же самое.\n"
"  ac 1000 3000 Octave\n"
"Изменение от 1000 Гц до 3000 Гц с шагом в октаву. Так как в данном случае\n"
"невозможно попасть в конечную точку диапазона 3000 Гц, последней точкой на\n"
"самом деле будет 4000 Гц.\n"
"  ac by 250\n"
"Изменять частоту в тех же самых пределах, что и прежде, но с шагом 250 Гц. В\n"
"данном случае это значит, что диапазон будет от 1000 до 3000 Гц, потому что\n"
"это тот самый диапазон, что был задан в последний раз.\n"
"  ac 5000 1000 -250\n"
"Если нужно, частоту можно менять в обратном направлении. Запомните, что шаг\n"
"может быть отрицательным.\n"
"  ac 20 20k *2\n"
"Для получения последующих шагов удваивать частоту.\n"
"  ac 20k 20 *.5\n"
"Можно изменять частоту по логарифмическому закону и в обратном направлении.\n"
"Для этого используется множитель меньше единицы.\n"
"  ac\n"
"Повторить тот же самый анализ.\n"
"  ac >afile\n"
"Сохранить результаты в файл ''afile''. Результаты в файле будут выглядеть\n"
"точно так же, как и на экране. Там будут результаты для всех датчиков.\n"
"Если разрешено построение графика, там будет график.\n"

#. type: Title ======
#: manual/commands/alarm.txt:1
#, no-wrap
msgid "\"alarm\" command"
msgstr "Команда «alarm»"

#. type: Plain text
#: manual/commands/alarm.txt:6
msgid "Select points in the circuit to check against user defined limits."
msgstr ""
"Выбор точек схемы для проверки на превышение установленных пользователем "
"пределов."

#. type: Plain text
#: manual/commands/alarm.txt:13
#, no-wrap
msgid ""
"  alarm\n"
"  alarm mode points ... ...\n"
"  alarm mode + points ... ...\n"
"  alarm mode - points ... ...\n"
"  alarm mode clear\n"
msgstr ""
"| ''**alarm**                              ''|\n"
"| ''**alarm** //режим       точки ... ...//''|\n"
"| ''**alarm** //режим// + //точки ... ...//''|\n"
"| ''**alarm** //режим// - //точки ... ...//''|\n"
"| ''**alarm** //режим//     clear          ''|\n"

#. type: Plain text
#: manual/commands/alarm.txt:17
msgid ""
"The `alarm' command selects points in the circuit to check against limits. "
"There is no output unless the limits are exceeded. If the limits are "
"exceeded a the value is printed."
msgstr ""
"Командой **alarm** выбираются точки схемы для проверки на превышение "
"пределов. Она ничего не выводит, пока пределы не превышены. При превышении "
"пределов выводится значение."

#. type: Plain text
#: manual/commands/alarm.txt:19 manual/commands/plot.txt:23
#: manual/commands/print.txt:20
msgid "There are separate lists of probe points for each type of analysis."
msgstr ""
"Для каждого вида анализа имеются отдельные списки [[..:howto:probes.ru|"
"датчиков]]."

#. type: Plain text
#: manual/commands/alarm.txt:21
msgid "To list the points, use the bare command `alarm'."
msgstr ""
"Для вывода перечня точек измерения используйте команду **''alarm''** без "
"параметров."

#. type: Plain text
#: manual/commands/alarm.txt:26 manual/commands/plot.txt:30
#, no-wrap
msgid ""
"Syntax for each point is:\n"
"  parameter(node)(limits)\n"
"  parameter(componentlabel)(limits)\n"
"  parameter(index)(limits)\n"
msgstr ""
"Синтаксис для каждой точки таков:\n"
"  параметр(узел)(пределы)\n"
"  параметр(обозначение_компонента)(пределы)\n"
"  параметр(индекс)(пределы)\n"

#. type: Plain text
#: manual/commands/alarm.txt:28 manual/commands/plot.txt:32
msgid "Some require a dummy index."
msgstr "Для некоторых параметров требуется фиктивный индекс."

#. type: Plain text
#: manual/commands/alarm.txt:30 manual/commands/plot.txt:34
msgid "For more information on the data available see the print command."
msgstr ""
"Более подробную информацию о доступных данных см. в [[print.ru|описании "
"команды print]]."

#. type: Plain text
#: manual/commands/alarm.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"alarm ac + v(3) adds v(3) to the existing set of AC probes. alarm ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами «''+''» или «''-''», их можно добавлять в "
"существующий список или удалять из него. **''alarm ac + v(3)''** добавит ''v"
"(3)'' в существующий набор датчиков для анализа [[ac.ru|ac]]. **''alarm ac - "
"q(c5)''** удалит ''q(c5)'' из списка. При удалении можно использовать "
"метасимволы «''*''» и «''?''»."

#. type: Plain text
#: manual/commands/alarm.txt:46
#, no-wrap
msgid ""
"  alarm ac vm(12)(0,5) vm(13)(-5,5)\n"
"Check magnitude of the voltage at node 12 against a range of 0 to 5, and node 13 against a range of -5 to 5 for AC analysis. Print a warning when the limits are exceeded.\n"
"  alarm op id(m*)(-100n,100n)\n"
"Check current in all mosfets. In op analysis, print a warning for any that are outside the range of -100 to +100 nanoamps. The range goes both positive and negative so it is valid for both N and P channel fets.\n"
"  alarm tran v(r83)(0,5) p(r83)(0,1u)\n"
"Check the voltage and power of R83 in the next transient analysis. The voltage range is 0 to 5. The power range is 0 to 1 microwatt. Print a warning when the range is exceeded.\n"
"  alarm\n"
"List all the probes for all modes.\n"
"  alarm dc\n"
"Display the DC alarm list.\n"
"  alarm ac clear\n"
"Clear the AC list.\n"
msgstr ""
"  alarm ac vm(12)(0,5) vm(13)(-5,5)\n"
"Проверять соответствие амплитуды напряжения узла 12 диапазону 0 ... 5, а узла 13 − диапазону -5 ... 5 для анализа [[ac.ru|ac]]. При превышении пределов выводить предупреждения.\n"
"  alarm op id(m*)(-100n,100n)\n"
"Проверять ток всех полевых транзисторов. При выполнении анализа [[op.ru|op]] выводить предупреждения для любого из них, ток которого вне диапазона -100 ... +100 наноампер.  Диапазон распространяется и в положительную, и в отрицательную сторону, поэтому это подходит как для транзисторов с n-, так и с p-каналом.\n"
"  alarm tran v(r83)(0,5) p(r83)(0,1u)\n"
"Проверять напряжение и мощность R83 в следующем [[transient.ru|временном анализе]]. Диапазон напряжения 0 ... 5. Диапазон мощности 0 ... 1 микроватт. При превышении диапазона вывести предупреждение.\n"
"  alarm\n"
"Вывести все датчики для всех режимов.\n"
"  alarm dc\n"
"Показать список точек сигнализации для [[dc.ru|dc]].\n"
"  alarm ac clear\n"
"Очистить список точек для [[ac.ru|ac]].\n"

#. type: Title ======
#: manual/commands/alter.txt:1
#, no-wrap
msgid "\"alter\", \"modify\" commands"
msgstr "Команды «alter», «modify»"

#. type: Plain text
#: manual/commands/alter.txt:6
msgid "Quickly change a component value."
msgstr "Быстрое изменение значения компонента."

#. type: Plain text
#: manual/commands/alter.txt:11
#, no-wrap
msgid ""
"  alter  partlabel=value ...\n"
"  modify partlabel=value ...\n"
msgstr ""
"|''**alter**  //обозначение_компонента=значение// ...''|\n"
"|''**modify** //обозначение_компонента=значение// ...''|\n"

#. type: Plain text
#: manual/commands/alter.txt:15
msgid ""
"This command quickly changes the value of a component. It is restricted to "
"simply changing the value."
msgstr ""
"Эта команда позволяет быстро изменить значение компонента. Её действие "
"ограничено только этим."

#. type: Plain text
#: manual/commands/alter.txt:17
msgid ""
"If several components have the same label or if wildcard characters are "
"used, all are changed."
msgstr ""
"Если обозначения нескольких компонентов одинаковы, а также при использовании "
"метасимволов, изменяются значения всех компонентов, соответствующих "
"заданному выражению."

#. type: Title ====
#: manual/commands/alter.txt:18 manual/commands/fault.txt:24
#: manual/commands/sweep.txt:31 manual/devices/basic/complex.txt:22
#: manual/devices/basic/fit.txt:73 manual/devices/basic/posy.txt:48
#: manual/devices/basic/tanh.txt:36 manual/howto/expressions.txt:13
#: manual/tech/plugins/coding.txt:25
#, no-wrap
msgid "Example"
msgstr "Пример"

#. type: Plain text
#: manual/commands/alter.txt:25
#, no-wrap
msgid ""
"  modify R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  modify C12=220p L1=1u\n"
"C12 is 220 pf and L1 is 1 uH.\n"
"  modify R*=22k\n"
"All resistors are now 22k.\n"
msgstr ""
"  modify R66=1k\n"
"R66 имеет теперь значение 1 кОм, независимо от того, каким оно было до того.\n"
"  modify C12=220p L1=1u\n"
"C12 теперь равно 220 пФ, а L1 --- 1 мкГн.\n"
"  modify R*=22k\n"
"Все резисторы теперь по 22 кОм.\n"

#. type: Title ======
#: manual/commands/build.txt:1
#, no-wrap
msgid "\"build\" command"
msgstr "Команда «build»"

#. type: Plain text
#: manual/commands/build.txt:6
msgid "Builds a new circuit, with Spice syntax."
msgstr "Построение новой схемы с использованием синтаксиса SPICE."

#. type: Plain text
#: manual/commands/build.txt:10
#, no-wrap
msgid "  build\n"
msgstr "|''**build**''|\n"

#. type: Plain text
#: manual/commands/build.txt:14
msgid ""
"\"Build\" lets you enter the circuit from the keyboard. The prompt changes "
"to > to show that the program is in the build mode."
msgstr ""
"Команда **build** позволяет ввести описание схемы с клавиатуры. Признаком "
"перехода в режим построения схемы является изменение приглашения программы "
"на ''>''."

#. type: Plain text
#: manual/commands/build.txt:16
msgid "At this point, type in the circuit components in Spice netlist format."
msgstr ""
"В этот момент можно вводить компоненты схем в формате списка соединений [[..:"
"languages:SPICE.ru|SPICE]]."

#. type: Plain text
#: manual/commands/build.txt:18
msgid ""
"Component labels must be unique. If not, the old one is modified according "
"to the new data, keeping old values where no new ones were specified."
msgstr ""
"Обозначения компонентов должны быть уникальными. В противном случае в "
"качестве новых компонентов будут использоваться одноимённые старые, "
"модифицированные в соответствии с новыми данными, и сохраняющие старые "
"значения для тех параметров, для которых не было указано новых."

#. type: Plain text
#: manual/commands/build.txt:20
msgid "Components are added to the end of the list."
msgstr "Компоненты добавляются к концу списка."

#. type: Plain text
#: manual/commands/build.txt:22
msgid ""
"Components being changed or replaced do not change their location in the "
"list."
msgstr ""
"Изменяемые или перемещаемые компоненты не меняют своего местоположения в "
"списке."

#. type: Plain text
#: manual/commands/build.txt:24
msgid ""
"If it is necessary to start over, \"delete all\" or \"clear\" will erase the "
"entire circuit in memory."
msgstr ""
"Если необходимо всё начать заново, полностью удалить схему из памяти можно "
"командами [[delete.ru|delete all]] или [[delete.ru|clear]]."

#. type: Plain text
#: manual/commands/build.txt:26
msgid "To exit this mode, enter a blank line."
msgstr "Для выхода из этого режима введите пустую строку."

#. type: Plain text
#: manual/commands/build.txt:27
msgid ""
"This command is deprecated, and may be removed in a future release.  You can "
"use the command \"spice\" instead."
msgstr ""
"Данную команду использовать не рекомендуется, в одной из будущих версий "
"программы она может быть удалена. Вместо неё можно использовать команду "
"[[spice.ru|spice]]."

#. type: Title ======
#: manual/commands/chdir.txt:1
#, no-wrap
msgid "\"chdir\" command"
msgstr "Команда «chdir»"

#. type: Plain text
#: manual/commands/chdir.txt:6
msgid "Changes or displays the current directory name."
msgstr "Смена текущего каталога и отображение его имени."

#. type: Plain text
#: manual/commands/chdir.txt:11
#, no-wrap
msgid ""
"  chdir {path}\n"
"  cd {path}\n"
msgstr ""
"|''**chdir** {//путь//}''|\n"
"|''**cd   ** {//путь//}''|\n"

#. type: Plain text
#: manual/commands/chdir.txt:15
msgid ""
"Change the current directory to that specified by path. See your system "
"manual for complete syntax."
msgstr ""
"Смена текущего каталога на заданный путь. Полный синтаксис команды см. в "
"руководстве по своей системе."

#. type: Plain text
#: manual/commands/chdir.txt:17
msgid "If no argument is given the current directory is displayed."
msgstr "Если аргумент не указан, выводится имя текущего каталога."

#. type: Plain text
#: manual/commands/chdir.txt:23
#, no-wrap
msgid ""
"  cd ../ckt\n"
"Change the current working directory to ../ckt.\n"
"  cd\n"
"Show the current working directory name.\n"
msgstr ""
"  cd ../ckt\n"
"Смена текущего рабочего каталога на ''../ckt''.\n"
"  cd\n"
"Показать имя текущего рабочего каталога.\n"

#. type: Title ======
#: manual/commands/dc.txt:1
#, no-wrap
msgid "\"dc\" command"
msgstr "Команда «dc»"

#. type: Plain text
#: manual/commands/dc.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, and sweeps the signal input, "
"or a component value."
msgstr ""
"Выполнение нелинейного расчёта статического режима по постоянному току при "
"изменении входного сигнала по постоянному току или значения физической "
"величины компонента."

#. type: Plain text
#: manual/commands/dc.txt:11
#, no-wrap
msgid ""
"  dc start stop stepsize {options ...}\n"
"  dc label start stop stepsize {options ...}\n"
msgstr ""
"|''**dc** //                       начало конец размер_шага// {//опции ...//}''|\n"
"|''**dc** //обозначение_компонента начало конец размер_шага// {//опции ...//}''|\n"

#. type: Plain text
#: manual/commands/dc.txt:15 manual/commands/fourier.txt:20
msgid ""
"The nodes to look at must have been previously selected by the print or plot "
"command."
msgstr ""
"Контролируемые узлы должны быть заранее выбраны командами [[print.ru|print]] "
"или [[plot.ru|plot]]."

#. type: Plain text
#: manual/commands/dc.txt:17
msgid ""
"If there are numeric arguments, without a part label, they represent a ramp "
"from the generator function. They are the start value, stop value and step "
"size, in order. They are saved between commands, so no arguments will repeat "
"the previous sweep."
msgstr ""
"Если указаны числовые аргументы без обозначения компонента, ими задаётся "
"линейная функция генератора сигнала. Это начальное значение, конечное "
"значение и размер шага, в указанном порядке. Они сохраняются между "
"командами, поэтому ни при каких аргументах предыдущая развёртка повторяться "
"не будет."

#. type: Plain text
#: manual/commands/dc.txt:19
msgid ""
"A single parameter represents a single input voltage. Two parameters "
"instruct the computer to analyze for those two points only."
msgstr ""
"Одним параметром задаётся одно входное напряжение. Двумя параметрами "
"компьютеру даётся приказ произвести расчёт только для двух указанных точек."

#. type: Plain text
#: manual/commands/dc.txt:21
msgid ""
"In some cases, you will get one more step outside the specified range of "
"inputs due to internal rounding errors. The last input may be beyond the end "
"point."
msgstr ""
"В некоторых случаях вследствие внутренних ошибок округления один шаг может "
"оказаться за пределами указанного диапазона значений входных данных. "
"Последнее значение может оказаться после конечной точки."

#. type: Plain text
#: manual/commands/dc.txt:23
msgid ""
"This command also sets up a movable operating point for subsequent AC "
"analysis, which can be helpful in distortion analysis."
msgstr ""
"Этой командой также настраивается подвижная рабочая точка для последующего "
"анализа [[ac.ru|ac]], которая может быть полезной при анализе искажений."

#. type: Plain text
#: manual/commands/dc.txt:25
msgid ""
"The program will sweep any simple component, including resistors, "
"capacitors, and controlled sources. SPICE sweeps only fixed sources (types V "
"and I)."
msgstr ""
"Программа будет производить развёртку с изменением значения любого простого "
"компонента, включая резисторы, конденсаторы и управляемые источники "
"напряжения и тока. SPICE может менять лишь значения независимых источников "
"напряжения и тока (типов V и I)."

#. type: Plain text
#: manual/commands/dc.txt:27
msgid "This command will sweep up to 4 components, nested."
msgstr ""
"Этой командой производится развёртка с изменением значений до 4 компонентов "
"рекурсивным способом."

#. type: Plain text
#: manual/commands/dc.txt:38 manual/commands/op.txt:33
#, no-wrap
msgid ""
"|* //multiplier//      |Log sweep. Multiply the input by //multiplier// to get the next step. Do not pass zero volts!!  |\n"
"|by //stepsize//       |Linear sweep. Add //stepsize// to get the next step.  |\n"
"|decade //steps//      |Log sweep. Use //steps// steps per decade.  |\n"
"|times //multiplier//  |Log sweep. Multiply the input by multiplier to get the next step. Do not pass zero volts!!  |\n"
"|continue              |Use the last step of a OP, DC or Transient analysis as the first guess.  |\n"
"|loop                  |Repeat the sweep, backwards.  |\n"
"|reverse               |Sweep in the opposite direction.  |\n"
msgstr ""
"|''* //множитель//         ''| Логарифмическая развёртка. Умножать входное значение на ''//множитель//'' для получения следующего шага. Не задавайте 0 вольт!  |\n"
"|''by //размер_шага//      ''| Линейная развёртка. Добавлять ''//размер_шага//'' для получения следующего шага.  |\n"
"|''decade //число_шагов//  ''| Логарифмическая развёртка. Использовать ''//число_шагов//'' на декаду.  |\n"
"|''times //множитель//     ''| Логарифмическая развёртка. Умножать входное значение на ''//множитель//'' для получения следующего шага. Не задавайте 0 вольт!  |\n"
"|''continue                ''| Использовать как первое приближение последний шаг анализа [[op.ru|op]], [[dc.ru|dc]] или [[transient.ru|transient]].  |\n"
"|''loop                    ''| Повторить развёртку в обратном направлении.  |\n"
"|''reverse                 ''| Развёртка в обратном направлении.  |\n"

#. type: Plain text
#: manual/commands/dc.txt:50 manual/commands/op.txt:49
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""
"|''trace off         ''| Без вывода расширенной трассировочной информации  |\n"
"|''trace warnings    ''| Отображение расширенных предупреждений            |\n"
"|''trace iterations  ''| Отображение каждой итерации                       |\n"
"|''trace verbose     ''| Расширенные диагностические сообщения             |\n"

#. type: Plain text
#: manual/commands/dc.txt:54 manual/commands/op.txt:44
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"

#. type: Plain text
#: manual/commands/dc.txt:70
#, no-wrap
msgid ""
"  dc 1\n"
"Do a single point DC signal simulation, with `1 volt' input.\n"
"  dc -10 15 1\n"
"Sweep the circuit input from -10 to +15 in steps of 1. (usually volts.) Do a DC transfer simulation at each step.\n"
"  dc\n"
"With no parameters, it uses the same ones as the last time. In this case, from -10 to 15 in 1 volt steps.\n"
"  dc V13 -10 15 1\n"
"Sweep the \"value\" of the component \"V13\" from -10 to +15 in steps of 1. Do a DC transfer simulation at each step.\n"
"  dc 20 0 -2\n"
"You can sweep downward, by asking for a negative increment. Sometimes, this will result in better convergence, or even different results! (For example, in the case of a bi-stable circuit.)\n"
"  dc -2 2 .1 loop\n"
"After the sweep, do it again in the opposite direction. In this case, the sweep is -2 to +2 in steps of .1. After it gets to +2, it will go back, and sweep from +2 to -2 in steps of -.1. The plot will be superimposed on the up sweep. This way, you can see hysteresis in the circuit.\n"
"  dc temperature=75\n"
"Simulate at 75 degrees, this time. Since we didn't specify new sweep parameters, do the same as last time. (Without the loop.)\n"
msgstr ""
"  dc 1\n"
"Выполнить моделирование статического режима по постоянному току в\n"
"одной точке с входным напряжением 1 вольт.\n"
"  dc -10 15 1\n"
"Изменять вход схемы от -10 до +15 с шагом 1 (обычно вольт).\n"
"Для каждого шага выполнять моделирование статической амплитудной\n"
"передаточной характеристики.\n"
"  dc\n"
"Если параметры не указаны, используются те же параметры, что и в\n"
"последний раз. В данном случае моделирование от -10 до 15 с шагом\n"
"1 В.\n"
"  dc V13 -10 15 1\n"
"Изменять «значение» компонента ''V13'' от -10 до +15 с шагом 1.\n"
"Для каждого шага выполнять моделирование статической амплитудной\n"
"передаточной характеристики.\n"
"  dc 20 0 -2\n"
"Запросив отрицательное приращение, можно менять значения в обратную\n"
"сторону. Иногда это приводит к лучшей сходимости, или даже к\n"
"отличающимся результатам! (Например, в случае бистабильной схемы.)\n"
"  dc -2 2 .1 loop\n"
"По завершению развёртки сделать её ещё раз в обратном направлении.\n"
"В данном случае значение изменяется от -2 до +2 с шагом 0,1. После\n"
"достижения значения +2 отсчёт пойдёт назад и развёртка пойдёт от\n"
"+2 до -2 с шагом -0,1. График будет наложен на развёртку вверх.\n"
"Таким образом в схеме можно наблюдать гистерезис.\n"
"  dc temperature=75\n"
"В этот раз моделировать при 75 градусах. Так как мы не указали\n"
"новые параметры развёртки, делать то же самое, что и в прошлый\n"
"раз (без ''loop'').\n"

#. type: Title ======
#: manual/commands/delete.txt:1
#, no-wrap
msgid "\"delete\" command"
msgstr "Команда «delete»"

#. type: Plain text
#: manual/commands/delete.txt:6
msgid "Remove a line, or a group of lines, from the circuit description."
msgstr "Удаление строки или группы строк из описания схемы."

#. type: Plain text
#: manual/commands/delete.txt:11
#, no-wrap
msgid ""
"  delete label ...\n"
"  delete all\n"
msgstr ""
"|''**delete** //обозначение_компонента// ...''|\n"
"|''**delete** all                           ''|\n"

#. type: Plain text
#: manual/commands/delete.txt:13
#, no-wrap
msgid "  clear\n"
msgstr "|''**clear**''|\n"

#. type: Plain text
#: manual/commands/delete.txt:17
msgid ""
"To delete a part, by label, enter the label. (Example `DEL R15'.) Wildcards "
"`*' and `?' are allowed, in which case, all that match are deleted."
msgstr ""
"Для удаления компонента по обозначению введите обозначение. (Пример: **''DEL "
"R15''**.) Разрешается использование метасимволов ''*'' и ''?'', в этом "
"случае удаляются любые совпадения."

#. type: Plain text
#: manual/commands/delete.txt:19
msgid ""
"To delete the entire circuit, the entire word ALL must be entered. (Example "
"`DEL ALL'.)"
msgstr ""
"Для удаления схемы целиком нужно ввести полностью слово ''ALL''. (Пример: "
"**''DEL ALL''**.)"

#. type: Plain text
#: manual/commands/delete.txt:21
msgid ""
"After deleting anything, there is usually no way to get it back, but if a "
"fault had been applied (see fault command) restore may have surprising "
"results."
msgstr ""
"Обычно после удаления всей схемы нет способа вернуть её обратно, но если до "
"того использовалась команда **''fault''** (см. [[fault.ru|описание команды "
"fault]]), попытка восстановления может привести с неожиданным результатам."

#. type: Plain text
#: manual/commands/delete.txt:23
msgid "\"clear\" is similar to, but a little more drastic than delete all."
msgstr ""
"Команда **''clear''** подобна команде **''delete all''**, но действует "
"несколько более радикально."

#. type: Plain text
#: manual/commands/delete.txt:36
#, no-wrap
msgid ""
"  delete all\n"
"Delete the entire circuit, but save the title.\n"
"  delete R12\n"
"Delete R12.\n"
"  delete R12 C3\n"
"Delete R12 and C3.\n"
"  delete R*\n"
"Delete all resistors. (Also, any models and subcircuits starting with R.)\n"
"  clear\n"
"Clear out everything to start over.\n"
msgstr ""
"  delete all\n"
"Удалить всю схему, но сохранить заголовок.\n"
"  delete R12\n"
"Удалить R12.\n"
"  delete R12 C3\n"
"Удалить R12 и C3.\n"
"  delete R*\n"
"Удалить все резисторы. (А также все модели и подсхемы, имена\n"
"которых начинаются на R.)\n"
"  clear\n"
"Очистить всё, чтобы начать всё с начала.\n"

#. type: Title ======
#: manual/commands/edit.txt:1
#, no-wrap
msgid "\"edit\" command"
msgstr "Команда «edit»"

#. type: Plain text
#: manual/commands/edit.txt:6
msgid "Use your editor to change the circuit."
msgstr "Редактирование схемы во внешнем редакторе."

#. type: Plain text
#: manual/commands/edit.txt:11
#, no-wrap
msgid ""
"  edit\n"
"  edit file\n"
msgstr ""
"|''**edit**              ''|\n"
"|''**edit** //имя_файла//''|\n"

#. type: Plain text
#: manual/commands/edit.txt:15
msgid ""
"The edit command runs your editor on a copy of the circuit in memory, then "
"reloads it."
msgstr ""
"По команде **edit** копия схемы, находящейся в памяти, открывается во "
"внешнем редакторе, а затем загружается обратно."

#. type: Plain text
#: manual/commands/edit.txt:17
msgid "Edit file runs your editor on the specified file."
msgstr "Если задано ''//имя_файла//'', в редакторе открывается указанный файл."

#. type: Plain text
#: manual/commands/edit.txt:19
msgid ""
"If you are only changing a component value, the modify command may be easier "
"to use."
msgstr ""
"Если необходимо изменить лишь значение какого-либо компонента, может быть "
"проще воспользоваться командой [[alter.ru|modify]]."

#. type: Plain text
#: manual/commands/edit.txt:21
msgid ""
"The program uses the EDITOR environment variable to find the editor to use. "
"The command fails if there is no EDITOR defined."
msgstr ""
"Для определения имени открываемого редактора программа использует значение "
"переменной окружения ''EDITOR''.  Если эта переменная не определена, команда "
"работать не будет."

#. type: Plain text
#: manual/commands/edit.txt:27
#, no-wrap
msgid ""
"  edit\n"
"Brings up your editor on the circuit.\n"
"  edit foo\n"
"Edits the file foo in your current directory.\n"
msgstr ""
"  edit\n"
"Открыть схему во внешнем редакторе.\n"
"  edit foo\n"
"Редактирование файла ''foo'' в текущем каталоге.\n"

#. type: Plain text
#: manual/commands/end.txt:2
msgid "\"end\" command"
msgstr "====== Команда «end» ======"

#. type: Plain text
#: manual/commands/end.txt:4
msgid ""
"When run in batch mode from the shell, the END command cleans up and exits "
"the program."
msgstr ""
"При запуске в пакетном режиме из shell команда **end** приводит к завершению "
"работы и выходу из программы."

#. type: Plain text
#: manual/commands/end.txt:6
msgid ""
"In script mode (< command) it ends the script and returns to the program "
"prompt."
msgstr ""
"В режиме скрипта (при выполнении файла, открытого командой [[in.ru|<]]) она "
"завершает скрипт и возвращается к приглашению программы."

#. type: Plain text
#: manual/commands/end.txt:7
msgid "In interactive mode it exits the program."
msgstr "В интерактивном режиме команда служит для выхода из программы."

#. type: Title ======
#: manual/commands/eval.txt:1
#, no-wrap
msgid "\"eval\" command"
msgstr "Команда «eval»"

#. type: Plain text
#: manual/commands/eval.txt:6
msgid "Check and evaluate an expression."
msgstr "Проверка и оценка выражения."

#. type: Plain text
#: manual/commands/eval.txt:10
#, no-wrap
msgid "  eval expression\n"
msgstr "|''**eval** //выражение//''|\n"

#. type: Plain text
#: manual/commands/eval.txt:14
msgid ""
"The eval command evaluates an expression and prints the result as a number."
msgstr ""
"Команда **eval** служит для вычисления значения выражения и вывода "
"результата в виде числа."

#. type: Plain text
#: manual/commands/eval.txt:28
#, no-wrap
msgid ""
"  gnucap> param a={b+c+7}\n"
"  gnucap> eval a\n"
"  parameter b+c+7 has no value\n"
"  parameter b+c+7 has no value\n"
"  a= NA\n"
"  gnucap> param b=c+3\n"
"  gnucap> param c=4\n"
"  gnucap> eval a\n"
"  a= 18.\n"
"  gnucap> eval b+c\n"
"  (b + c)= 11.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> param a={b+c+7}\n"
"  gnucap> eval a\n"
"  parameter b+c+7 has no value\n"
"  parameter b+c+7 has no value\n"
"  a= NA\n"
"  gnucap> param b=c+3\n"
"  gnucap> param c=4\n"
"  gnucap> eval a\n"
"  a= 18.\n"
"  gnucap> eval b+c\n"
"  (b + c)= 11.\n"
"  gnucap>\n"

#. type: Title ======
#: manual/commands/exit.txt:1
#, no-wrap
msgid "\"exit\", \"quit\" commands"
msgstr "Команды «exit» и «quit»"

#. type: Plain text
#: manual/commands/exit.txt:7
#, no-wrap
msgid " Terminates the program.\n"
msgstr " Завершение программы.\n"

#. type: Plain text
#: manual/commands/exit.txt:12
#, no-wrap
msgid ""
"  exit\n"
"  quit\n"
msgstr ""
"|''**exit**''|\n"
"|''**quit**''|\n"

#. type: Plain text
#: manual/commands/exit.txt:15
msgid "Be sure you have saved everything you want to!"
msgstr "Не забудьте [[save.ru|сохранить]] всё, что надо!"

#. type: Title ======
#: manual/commands/fault.txt:1
#, no-wrap
msgid "\"fault\" command"
msgstr "Команда «fault»"

#. type: Plain text
#: manual/commands/fault.txt:6
msgid "Temporarily change a component value."
msgstr "Временное изменение значения компонента."

#. type: Plain text
#: manual/commands/fault.txt:11
#, no-wrap
msgid ""
"  fault partlabel=value ...\n"
"  unfault\n"
msgstr ""
"|''**fault** //обозначение_компонента//=//значение ...//''|\n"
"|''**unfault**                                          ''|\n"

#. type: Plain text
#: manual/commands/fault.txt:15
msgid ""
"This command quickly changes the value of a component, usually with the "
"intention that you will not want to save it."
msgstr ""
"Эта команда служит для быстрого изменения значения компонента и обычно "
"используется в тех случаях, когда сохранять его не нужно."

#. type: Plain text
#: manual/commands/fault.txt:17
msgid ""
"If you apply this command to a nonlinear or otherwise strange part, it "
"becomes ordinary and linear until the fault is removed."
msgstr ""
"Если данная команда применяется к нелинейным или другим необычным "
"компонентам, они становятся обычными и линейными, до тех пор пока действие "
"**fault** не будет прекращено."

#. type: Plain text
#: manual/commands/fault.txt:19
msgid "It is an error to fault a model call."
msgstr "Ошибочно использовать **fault** для вызова модели."

#. type: Plain text
#: manual/commands/fault.txt:21
msgid ""
"If several components have the same label, the fault value applies to all of "
"them. (They will all have the same value.)"
msgstr ""
"Если несколько компонентов имеют одинаковое обозначение, значение **fault** "
"применяется к ним всем. (У них всех будет одинаковое значение.)"

#. type: Plain text
#: manual/commands/fault.txt:23
msgid "The unfault command restores the old values."
msgstr "Команда **unfault** восстанавливает старое значение."

#. type: Plain text
#: manual/commands/fault.txt:30
#, no-wrap
msgid ""
"  fault R66=1k\n"
"R66 now has a value of 1k, regardless of what it was before.\n"
"  unfault\n"
"Clears all faults. In this case, R66 has its old value again.\n"
msgstr ""
"  fault R66=1k\n"
"R66 теперь имеет значение 1 кОм, независимо от того, каким оно было раньше.\n"
"  unfault\n"
"Убрать все **fault**. В данном случае R66 снова получит своё старое значение.\n"

#. type: Plain text
#: manual/commands/fault.txt:35
#, no-wrap
msgid ""
"unfault can bring on surprises. Consider this sequence ...\n"
"  V1   1   0    ac  1\n"
"  C3   1   2    1u\n"
"  R4   2   0    10k\n"
msgstr ""
"Использование **unfault** может приводить к сюрпризам. Рассмотрим следующую последовательность...\n"
"  V1   1   0    ac  1\n"
"  C3   1   2    1u\n"
"  R4   2   0    10k\n"

#. type: Plain text
#: manual/commands/fault.txt:43
#, no-wrap
msgid ""
"  fault C3=100p\n"
"C3 is 100 picofarads, for now.\n"
"  modify C3=220p\n"
"C3 is 220 pf, for now. It will be restored.\n"
"  modify R4=1k\n"
"R4 is 1k. It will not be restored.\n"
"  unfault\n"
"C3 back to 1 uf, but R4 still 1k.\n"
msgstr ""
"  fault C3=100p\n"
"C3 теперь равно 100 пикофарадам.\n"
"  modify C3=220p\n"
"Значение C3 теперь равно 220 пФ. Старое значение будет восстановлено.\n"
"  modify R4=1k\n"
"Значение R4 равно 1 кОм. Старое значение восстановлено не будет.\n"
"  unfault\n"
"C3 снова равно 1 мкФ, но значение R4 так и останется равным 1 кОм.\n"

#. type: Title ======
#: manual/commands/fourier.txt:1
#, no-wrap
msgid "\"fourier\" command"
msgstr "Команда «fourier»"

#. type: Plain text
#: manual/commands/fourier.txt:6
msgid ""
"Performs a nonlinear time domain (transient) analysis, but displays the "
"results in the frequency domain."
msgstr ""
"Выполнение нелинейного анализа во временной области (временного анализа), но "
"отображение результатов в частотной области."

#. type: Plain text
#: manual/commands/fourier.txt:10
#, no-wrap
msgid "  fourier start stop stepsize {options ...}\n"
msgstr "|''**fourier** //начало конец размер_шага// {//опции ...//}''|\n"

#. type: Plain text
#: manual/commands/fourier.txt:12
msgid "Start, stop, and stepsize are frequencies."
msgstr "''//Начало//'', ''//конец//'' и ''//размер_шага//'' --- это частоты."

#. type: Plain text
#: manual/commands/fourier.txt:16
msgid ""
"This command is slightly different and more flexible than the SPICE "
"counterpart. SPICE always gives you the fundamental and 9 harmonics. Gnucap "
"will do the same if you only specify one frequency. SPICE has the probes on "
"the same line. Gnucap requires you to specify the probes with the print "
"command."
msgstr ""
"Данная команда гибче аналогичной команды SPICE, и несколько от неё "
"отличается. SPICE всегда выдаёт основную частоту и 9 гармоник. gnucap делает "
"то же самое только при задании одной частоты. В SPICE датчики задаются в той "
"же строке. gnucap требует явного указания датчиков командой [[print.ru|"
"print]]."

#. type: Plain text
#: manual/commands/fourier.txt:18
msgid ""
"SPICE uses the last piece of a transient that was already done. Gnucap does "
"its own transient analysis, continuing from where the most recent one left "
"off, and choosing the step size to match the Fourier Transform to be done. "
"Because of this the Gnucap Fourier analysis is much more accurate than SPICE."
msgstr ""
"В SPICE используется последняя часть ранее сделанного временного анализа. В "
"gnucap проводится свой собственный временной анализ. Он продолжается с точки "
"останова самого последнего анализа, а размер шага при этом выбирается таким, "
"чтобы он соответствовал производимому преобразованию Фурье. По этим причинам "
"анализ Фурье, выполняемый программой gnucap, гораздо точнее, чем в SPICE."

#. type: Plain text
#: manual/commands/fourier.txt:22
msgid ""
"Three parameters are normally needed for a Fourier analysis: start "
"frequency, stop frequency and step size, in this order."
msgstr ""
"Обычно для анализа Фурье нужны три параметра: начальная частота, конечная "
"частота и размер шага, в указанном порядке."

#. type: Plain text
#: manual/commands/fourier.txt:24
msgid ""
"If the start frequency is omitted it is assumed to be 0. The two remaining "
"parameters are stop and step, such that stop > step."
msgstr ""
"Если начальная частота не указана, она принимается равной нулю. Два "
"оставшихся параметра --- конечная частота и шаг, где конечная частота больше "
"шага."

#. type: Plain text
#: manual/commands/fourier.txt:26
msgid ""
"If only one frequency is specified, it is assumed to be step size, which is "
"equivalent to the fundamental frequency. The start frequency is zero and the "
"stop frequency is set according the harmonics option (from the options "
"command. The default is 9 harmonics."
msgstr ""
"Если указана только одна частота, она будет считаться размером шага, который "
"эквивалентен основной частоте. Начальная частота равна нулю, а конечная "
"устанавливается в соответствии с опцией ''harmonics'' (количество гармоник "
"из команды [[options.ru|options]]).  По умолчанию задаётся 9 гармоник."

#. type: Plain text
#: manual/commands/fourier.txt:28
msgid ""
"If two frequencies are specified, they are stop and step. The order doesn't "
"matter since stop is always larger than step."
msgstr ""
"Если указаны две частоты, они считаются конечной частотой и шагом. Порядок "
"указания не важен, так как конечная частота всегда больше шага."

#. type: Plain text
#: manual/commands/fourier.txt:30
msgid ""
"This command does a nonlinear time domain analysis, then performs a Fourier "
"transform on the data to get the frequency data. The transient analysis "
"parameters (start, stop, step) are determined by the program as necessary to "
"produce the desired spectral results. The internal time steps are selected "
"to match the Fourier points, so there is no interpolation done."
msgstr ""
"Данная команда выполняет нелинейный анализ во временной области, а затем для "
"нахождения частотных данных выполняет преобразование Фурье над его "
"результатами. Решение о параметрах временного анализа (начало, конец, шаг) "
"принимается программой на основе тех спектральных результатов, которые "
"хотелось бы получить. Внутренний шаг времени выбирается так, чтобы точки "
"соответствовали точкам Фурье, поэтому никакой интерполяции не производится."

#. type: Plain text
#: manual/commands/fourier.txt:32
msgid ""
"The underlying transient analysis begins where the previous one left off. If "
"you specify the \"cold\" option, it begins at time = 0. Often repeating a "
"run will improve the accuracy by giving more time for initial transients to "
"settle out."
msgstr ""
"Временной анализ, лежащий в основе преобразования Фурье, начинается с точки "
"останова предыдущего анализа. Если указать опцию ''cold'', он начнётся в "
"момент времени равный 0. Частое повторение запуска приведёт к увеличению "
"точности, давая больше времени для стабилизации начальных переходных "
"процессов."

#. type: Plain text
#: manual/commands/fourier.txt:34
msgid "See also: [[gnucap:manual:commands:transient|Transient command]]."
msgstr "См. также: [[gnucap:manual:commands:transient.ru|Команда transient]]."

#. type: Plain text
#: manual/commands/fourier.txt:43 manual/commands/transient.txt:30
#, no-wrap
msgid ""
"|dtmax time      |The maximum internal time step.  (Default = stepsize/skip)  |\n"
"|dtmin time      |The minimum internal time step. (Default = option dtmin) Time cannot be resolved closer than this.  |\n"
"|dtratio number  |The minimum internal time step, as a ratio. (Default = option dtratio) This is the maximum number of internal time steps for every requested step.  |\n"
"|skip count      |Force at least count internal transient time steps for each one displayed. If the output is a table or ASCII plot, the extra steps are hidden, unless the trace option specifies to print them.  |\n"
msgstr ""
"|''dtmax //время//      ''| Максимальный внутренний шаг времени. (Значение по умолчанию равно ''//размер_шага//''/''skip'')  |\n"
"|''dtmin //время//      ''| Минимальный внутренний шаг времени. (Значение по умолчанию равно [[options.ru|опции]] ''dtmin''.) Разрешение времени не может быть точнее указанного  |\n"
"|''dtratio //число//    ''| Минимальный внутренний шаг времени в виде отношения. (Значение по умолчанию равно [[options.ru|опции]] ''dtratio''.) Это максимальное количество внутренних шагов времени на каждый запрошенный шаг.  |\n"
"|''skip //количество//  ''| Использовать по меньшей мере указанное ''//количество//'' внутренних шагов времени на каждый отображаемый шаг. Дополнительные шаги не отображаются при выводе в виде таблицы или ASCII-графика, если только их вывод не будет задан опцией ''trace''  |\n"

#. type: Plain text
#: manual/commands/fourier.txt:57 manual/commands/transient.txt:44
#, no-wrap
msgid ""
"|trace off         |No extended trace information.  |\n"
"|trace warnings    |Show extended warnings.  |\n"
"|trace alltime     |Show all accepted internal time steps.  |\n"
"|trace rejected    |Show all internal time steps including rejected steps.  |\n"
"|trace iterations  |Show every iteration.  |\n"
"|trace verbose     |Show extended diagnostics.  |\n"
msgstr ""
"|''trace off         ''| Без вывода расширенной трассировочной информации                |\n"
"|''trace warnings    ''| Отображение расширенных предупреждений                          |\n"
"|''trace alltime     ''| Отображение всех разрешённых внутренних шагов времени           |\n"
"|''trace rejected    ''| Отображение всех внутренних шагов времени, включая отброшенные  |\n"
"|''trace iterations  ''| Отображение каждой итерации                                     |\n"
"|''trace verbose     ''| Расширенные диагностические сообщения                           |\n"

#. type: Plain text
#: manual/commands/fourier.txt:63
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC analysis. Instead, use the values specified with the IC = options on the various elements, and set everything else to zero.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"
"|''cold                     ''| Нулевые начальные условия. Холодный запуск с момента подачи питания  |\n"
"|''uic                      ''| Использовать начальные условия. Не проводить начальный статический анализ по постоянному току [[dc.ru|dc]]. Вместо этого использовать данные, указанные в опциях ''IC'' разных элементов, а всё остальное устанавливать в ноль  |\n"

#. type: Plain text
#: manual/commands/fourier.txt:75
#, no-wrap
msgid ""
"  fourier 1Meg\n"
"Analyze the spectrum assuming a fundamental frequency of 1 mHz. Use the harmonics option to determine how many harmonics (usually 9) to display.\n"
"  fourier 40 20K 20\n"
"Analyze the spectrum from 40 Hz to 20 kHz in 20 Hz steps. This will result in a transient analysis with 25 micro-second steps. (1 / 40k). It will run for .05 second. (1 / 20).\n"
"  fourier 0 20K 20\n"
"Similar to the previous example, but show the DC and 20 Hz terms, also.\n"
"  fourier\n"
"No parameters mean use the same ones as the last time. In this case: from 0 to 20 kHz, in 20 Hz steps.\n"
"  fourier skip 10\n"
"Do 10 transient steps internally for every step that is used. In this case it means to internally step at 2.5 micro-second, or 10 steps for every one actually used.\n"
msgstr ""
"  fourier 1Meg\n"
"Анализ спектра с установкой основной частоты равной 1 МГц. Используйте опцию ''harmonics'' для определения количества выводимых гармоник (обычно 9).\n"
"  fourier 40 20K 20\n"
"Анализ спектра от 40 Гц до 20 кГц с шагом в 20 Гц. Результатом будет временной анализ с шагами в 25 микросекунд (1/40k). Он будет длиться 0,05 секунды (1/20).\n"
"  fourier 0 20K 20\n"
"Подобно предыдущему примеру, но показать также результаты для статического режима по постоянному тока и для частоты 20 Hz.\n"
"  fourier\n"
"Отсутствие параметров означает использование тех же самых параметров, что и в прошлый раз. В данном случае: от 0 до 20 кГц с шагом в 20 Гц.\n"
"  fourier skip 10\n"
"Делать по 10 внутренних временных шагов на каждый используемый шаг. В данном случае это означает внутренние шаги по 2,5 микросекунды или 10 внутренних шагов на каждый шаг, который будет использоваться фактически.\n"

#. type: Title ======
#: manual/commands/freeze.txt:1
#, no-wrap
msgid "\"freeze, unfreeze\" commands"
msgstr "Команды «freeze», «unfreeze»"

#. type: Plain text
#: manual/commands/freeze.txt:6
msgid "\"Freeze\" to a point in time.  Remember circuit voltages and currents."
msgstr "«Заморозка» в точке времени. Запоминание напряжений и токов схемы."

#. type: Plain text
#: manual/commands/freeze.txt:11
#, no-wrap
msgid ""
"  freeze\n"
"  unfreeze\n"
msgstr ""
"|''**freeze  **''|\n"
"|''**unfreeze**''|\n"

#. type: Plain text
#: manual/commands/freeze.txt:15
msgid ""
"After the freeze command, the transient and fourier analysis will continue "
"from the values that were kept by the freeze command, instead of progressing "
"every time."
msgstr ""
"После команды **freeze** [[transient.ru|временной анализ]] и [[fourier.ru|"
"анализ Фурье]] продолжатся с тех значений, которые были запомнены этой "
"командой, вместо продолжения каждый раз дальше."

#. type: Plain text
#: manual/commands/freeze.txt:17
msgid ""
"This allows reruns from the same starting point, which may be at any time, "
"not necessarily 0."
msgstr ""
"Это даёт возможность перезапуска анализа с одной и той же стартовой точки "
"времени, которая может быть в любой момент, не обязательно в 0 секунд."

#. type: Plain text
#: manual/commands/freeze.txt:35
#, no-wrap
msgid ""
"  transient 0 1 .01\n"
"A transient analysis starting at zero, running until 1 second, with step size .01 seconds. After this run, the clock is at 1 second.\n"
"  freeze\n"
"Remember the time, voltages, currents, etc.\n"
"  transient\n"
"Another transient analysis. It continues from 1 second, to 2 seconds. (It spans 1 second, as before.) This command was not affected by the freeze command.\n"
"  transient\n"
"This will do exactly the same as the last one. From 1 second to 2 seconds. If it were not for freeze, it would have started from 2 seconds.\n"
"  transient 1.5 .001\n"
"Try again with smaller steps. Again, it starts at 1 second.\n"
"  unfreeze\n"
"Release the effect of freeze.\n"
"  transient\n"
"Exactly the same as the last time, as if we didn't unfreeze. (1 to 1.5 seconds.)\n"
"  transient\n"
"This one continues from where the last one left off: at 1.5 seconds. From now on, time will move forward.\n"
msgstr ""
"  transient 0 1 .01\n"
"Временной анализ, начинающийся в нулевое время, работающий 1 секунду с шагом .01 секунды. После его выполнения, часы установлены в точку 1 секунда.\n"
"  freeze\n"
"Запоминание времени, напряжений, токов и т. д.\n"
"  transient\n"
"Другой временной анализ. Он продолжается от 1 секунды до 2 секунд. (Его длительность, как и прежде, составляет 1 секунду.) На эту команду команда **freeze** не повлияла..\n"
"  transient\n"
"Эта команда делает ровно то же самое, что и предыдущая команда. Работа от 1 секунды до 2 секунд. Если бы она не была после **freeze**, она бы стартовала с 2 секунд.\n"
"  transient 1.5 .001\n"
"Попробовать ещё раз с меньшим шагом. Снова анализ начинается в момент времени 1 секунда.\n"
"  unfreeze\n"
"Отключить эффект заморозки от команды **freeze**.\n"
"  transient\n"
"Ровно то же самое, что и в последний раз, как будто заморозка не отключена (от 1 до 1.5 секунд.)\n"
"  transient\n"
"Эта команда продолжает работу с того места, где была остановлена последняя: в 1.5 секунды. С этой поры время будет идти вперёд.\n"

#. type: Title ======
#: manual/commands/generator.txt:1
#, no-wrap
msgid "\"generator\" command"
msgstr "Команда «generator»"

#. type: Plain text
#: manual/commands/generator.txt:6
msgid ""
"Sets up an input waveform for transient and Fourier analysis. Emulates a "
"laboratory type function generator."
msgstr ""
"Настройка формы входного сигнала для [[transient.ru|временного анализа]] и "
"[[fourier.ru|анализа Фурье]]. Эмуляция функционального генератора "
"лабораторного типа."

#. type: Plain text
#: manual/commands/generator.txt:10
#, no-wrap
msgid "  generator {option-name=value ...}\n"
msgstr "|''**generator** {//имя_опции=значение ...//}''|\n"

#. type: Plain text
#: manual/commands/generator.txt:14
msgid ""
"This command sets up a singal source that is conceptually separate from the "
"circuit. To use it, make the value of a component \"generator(1)\", or "
"substitute a scale factor for the parameter."
msgstr ""
"Данной командой настраивается источник сигнала, концептуально отделённый от "
"схемы. Для его использования необходимо задать для какого-либо компонента "
"значение в виде ''generator(1)'', или заменить указанный параметр "
"коэффициентом масштабирования."

#. type: Plain text
#: manual/commands/generator.txt:16
msgid ""
"The SPICE style input functions also work, but are considered to be part of "
"the circuit, instead of part of the test equipment."
msgstr ""
"Входные функции в стиле SPICE тоже будут работать, но они считаются частью "
"схемы, а не тестового оборудования."

#. type: Plain text
#: manual/commands/generator.txt:18
msgid ""
"The parameters available are designed to emulate the controls on a function "
"generator. There are actually two generators here: sine wave and pulse. If "
"both are on (by setting non-zero parameters) the sine wave is modulated by "
"the pulse, but either can be used alone."
msgstr ""
"Имеющиеся в распоряжении параметры спроектированы для эмуляции элементов "
"управления функционального генератора. Фактически здесь имеется два "
"генератора: синусоиды и прямоугольных импульсов (меандра). Если включены оба "
"(установкой ненулевых параметров), синусоидальная волна модулируется "
"импульсами, но любой из указанных сигналов может использоваться и сам по "
"себе."

#. type: Plain text
#: manual/commands/generator.txt:20
msgid ""
"Unless you change it, it is a unit-step function at time 0. The purpose of "
"the command is to change it."
msgstr ""
"Если команда не менялась пользователем, она определяет единичную ступенчатую "
"функцию в момент времени равный 0. Цель данной команды состоит в изменении "
"этой функции."

#. type: Plain text
#: manual/commands/generator.txt:22
msgid ""
"This command does not affect AC or DC analysis in any way. It is only for "
"transient and Fourier analysis. In AC analysis, the input signal is always a "
"sine wave at the analysis frequency."
msgstr ""
"Данная команда никоим образом не влияет на анализы [[ac.ru|ac]] или [[dc.ru|"
"dc]]. Она предназначена только для [[transient.ru|временного анализа]] и "
"[[fourier.ru|анализа Фурье]]. Для анализа [[ac.ru|ac]] входной сигнал всегда "
"представляет собой синусоиду заданной для этого анализа частоты."

#. type: Plain text
#: manual/commands/generator.txt:24
msgid ""
"Typical usage is the name of the control followed by its value, or just "
"plain Generator to display the present values."
msgstr ""
"При обычном использовании указываются имена управляющих параметров и их "
"значения, либо просто **''Generator''** без параметров для отображения их "
"текущих значений."

#. type: Plain text
#: manual/commands/generator.txt:26
msgid ""
"The actual time when switching takes place is ambiguous by one time step. If "
"precise time switching is necessary, use the Skip option on the transient "
"analysis command, to force more resolution. This ambiguity can usually be "
"avoided by specifying finite rise and fall times."
msgstr ""
"В пределах одного шага времени фактическое время переключения не определено. "
"Если необходимо прецизионное переключение во времени, воспользуйтесь опцией "
"''Skip'' команды временного анализа [[transient.ru|transient]] для "
"принудительного задания большего разрешения. Этой неопределённости обычно "
"можно избежать, указав конечное время для переднего и заднего фронтов."

#. type: Title =====
#: manual/commands/generator.txt:27 manual/commands/options.txt:25
#: manual/devices/basic/exp.txt:33 manual/devices/basic/fit.txt:50
#: manual/devices/basic/poly.txt:27 manual/devices/basic/posy.txt:40
#: manual/devices/basic/pulse.txt:43 manual/devices/basic/sffm.txt:26
#: manual/devices/basic/sin.txt:44 manual/devices/basic/tanh.txt:27
#: manual/measure/at.txt:10 manual/measure/cross.txt:10
#: manual/measure/mean.txt:15 manual/measure/minmax.txt:11
#: manual/measure/slope.txt:11 manual/tech/plugins/devices/parameters.txt:3
#: manual/measure/integrate.txt:11
#, no-wrap
msgid "Parameters"
msgstr "Параметры"

#. type: Plain text
#: manual/commands/generator.txt:41
#, no-wrap
msgid ""
"|frequency  |The frequency of the sine wave generator for a transient analysis. The sine wave is modulated by the pulse generator. A frequency of zero puts the pulse generator on line directly.  |\n"
"|amplitude  |The overall amplitude of the pulse and sine wave. A scale factor. It applies to everything except the offset and initial values.  |\n"
"|phase      |The phase of the sine wave, at the instant it is first turned on.  |\n"
"|max        |The amplitude of the pulse, when it is `on'. (During the width time) If the sine wave is on (frequency not zero) this is the amplitude of the sine wave during the first part of the period. The max is scaled by amplitude.  |\n"
"|min        |The amplitude of the pulse, when it is `off'. (After it falls, but before the next period begins.) Although we have called these min and max, there is no requirement that max be larger than min. If the sine wave is on, this is its amplitude during the second part of the period. The min is scaled by amplitude.  |\n"
"|offset     |The DC offset applied to the entire signal, at all times after the initial delay. The offset is not scaled by amplitude.  |\n"
"|initial    |The initial value of the pulse generator output. It will have this value starting at time 0, until delay time has elapsed. It will never return to this value, unless you restart at time 0.  |\n"
"|rise       |The rise time, or the time it takes to go from min to max, or for the first rise, initial to max. The rise is linear.  |\n"
"|fall       |The fall time. (The time required to go from max back to min.)  |\n"
"|delay      |The waiting time before the first rise.  |\n"
"|width      |The length of time the output of the generator has the value max. A width of zero means that the output remains high for the remainder of the period. If you really want a width of zero, use a very small number, less than the step size.  |\n"
"|period     |The time for repetition of the pulse. It must be greater than the sum of rise + fall + width. A period of zero means that the signal is not periodic and so will not repeat.  |\n"
msgstr ""
"|''frequency''  | Частота генератора синусоиды для [[transient.ru|временного анализа]]. Синусоида модулируется генератором импульсов. При частоте равной нулю импульсы накладываются непосредственно на прямую линию.  |\n"
"|''amplitude''  | Общая амплитуда импульсов и синусоиды. Коэффициент масштабирования. Он применяется ко всем параметрам, за исключением значений ''offset'' и ''initial''.  |\n"
"|''phase''      | Фаза синусоиды в момент её включения.  |\n"
"|''max''        | Амплитуда импульса, когда он «включен». (В течение времени ширины импульса ''width''.) Если синусоида включена (частота не равна нулю) это амплитуда синусоиды в течение первой части периода. Значение ''max'' масштабируется параметром ''amplitude''.  |\n"
"|''min''        | Амплитуда импульса, когда он «отключен». (После ниспадающего фронта и до начала следующего периода.) Хотя эти параметры и называются ''min'' и ''max'', не обязательно задавать ''max'' больше, чем ''min''. Если синусоида включена, это её амплитуда в течение второй части периода. Значение ''min'' масштабируется параметром ''amplitude''.  |\n"
"|''offset''     | Постоянное смещение, прикладываемое к сигналу как целому на всё время после начальной задержки ''delay''. Это смещение не масштабируется параметром ''amplitude''.  |\n"
"|''initial''    | Исходное значение выхода генератора импульсов. Генератор будет выдавать это значение с нулевого момента времени до тех пор, пока не пройдёт время ''delay''. Он никогда не вернётся к этому значению, если только не перезапустить моделирование с момента времени равного 0.  |\n"
"|''rise''       | Длительность нарастающего фронта: или время перехода от ''min'' до ''max'', или, для первого фронта, от ''initial'' до ''max''. Нарастающий фронт изменяется линейно.  |\n"
"|''fall''       | Длительность ниспадающего фронта. (Время, нужное для перехода от ''max'' обратно к ''min''.)  |\n"
"|''delay''      | Выдержка времени перед первым нарастающим фронтом.  |\n"
"|''width''      | Ширина импульса, то есть длительность времени, когда выход генератора имеет значение ''max''. Значение ''width'' равное 0 означает, что выход генератора останется высоким всю оставшуюся часть периода. Если вам на самом деле нужна нулевая ширина импульса, используйте очень маленькое число, меньше размера шага.  |\n"
"|''period''     | Время повторения импульсов. Оно должно быть больше суммы ''rise + fall + width''. Период равный нулю означает, что сигнал не периодический и поэтому повторяться не будет.  |\n"

#. type: Plain text
#: manual/commands/generator.txt:57
#, no-wrap
msgid ""
"The generator command ...\n"
"  gen\n"
"Display the present settings.\n"
"  gen freq=1k\n"
"Sets the sine wave to 1 kHz. All other parameters are as they were before.\n"
"  gen freq=0\n"
"Turns off the sine wave, leaving only the pulse.\n"
"  gen ampl=0\n"
"Sets the amplitude to zero, which means the circuit has no input, except for possibly a DC offset.\n"
"  gen period=.001 freq=1Meg\n"
"Sets the period back to 1 millisecond. Applies 1 mHz modulation to the pulse, resulting in a pulsed sine wave. In this case, a 100 microsecond 10 volt burst, repeating every millisecond. Between bursts, you will get 2.5 volts, with reversed phase. The old values, in this case from 2 lines back (above) are kept. (Ampl 5 Rise 10u Fall 10u ...)\n"
"  gen freq=60 phase=90 delay=.1\n"
"The sine wave frequency is 60 Hertz. Its phase is 90 degrees when it turns on, at time .1 seconds. It turns on sharply at the peak.\n"
msgstr ""
"Команда запуска генератора ...\n"
"  gen\n"
"Показать существующие настройки.\n"
"  gen freq=1k\n"
"Задать синусоиду частотой 1 кГц. Все прочие параметры остаются теми же, что и прежде.\n"
"  gen freq=0\n"
"Отключить синусоиду, оставив только импульсы.\n"
"  gen ampl=0\n"
"Установить амплитуду равной нулю, то есть для схемы не будет входного сигнала, за исключением, может быть, смещения по постоянному току.\n"
"  gen period=.001 freq=1Meg\n"
"Снова установить период равным 1 миллисекунде. Применить к импульсам модуляцию с частотой 1 МГц, что в итоге даст пульсирующую синусоиду. В данном случае возникают 100-микросекундные броски в 10 вольт, повторяющиеся каждую миллисекунду. Между бросками будет 2,5 вольта с противоположной фазой.  Старые значения, в данном случае на 2 строки назад (см. выше) сохраняются. (Амплитуда 5, нарастание 10 мкс, спад 10 мкс ...)\n"
"  gen freq=60 phase=90 delay=.1\n"
"Частота синусоиды составляет 60 Гц. Её фаза при включении в момент времени равный 0,1 секунды равна 90 градусам. Она включается резко на пике.\n"

#. type: Plain text
#: manual/commands/generator.txt:64
#, no-wrap
msgid ""
"A component using it ...\n"
"  V12 1 0 generator(1)\n"
"Use the generator as the circuit input through this voltage source. The DC and AC values are 0.\n"
"  V12 1 0 tran generator(1) ac 10 dc 5\n"
"Same as before, except that the AC value is 10 and DC value is 5.\n"
"  Rinput 1 0 tran generator(1)\n"
"Unlike SPICE, the functions can be used on other components. The resistance varies in time according to the \"generator\".\n"
msgstr ""
"Компонент, использующий эту команду ...\n"
"  V12 1 0 generator(1)\n"
"Использовать генератор как входной сигнал схемы, подаваемый через этот источник напряжения. Значения для анализов [[ac.ru|ac]] и [[dc.ru|dc]] равны нулю.\n"
"  V12 1 0 tran generator(1) ac 10 dc 5\n"
"То же, что и прежде, но значение для [[ac.ru|ac]] равно 10, а для [[dc.ru|dc]] 5.\n"
"  Rinput 1 0 tran generator(1)\n"
"В отличие от SPICE эти функции могут использоваться для других компонентов. Сопротивление меняется во времени в соответствии с функцией ''generator''.\n"

#. type: Title ======
#: manual/commands/get.txt:1
#, no-wrap
msgid "\"get\" command"
msgstr "Команда «get»"

#. type: Plain text
#: manual/commands/get.txt:7
msgid ""
"Gets an existing circuit file, but does not run it, after clearing memory. "
"Start over.  Set up for interactive operation."
msgstr ""
"Чтение существующего файла схемы после очистки памяти без запуска "
"моделирования. Начало работы заново. Настройка программы для интерактивной "
"работы."

#. type: Plain text
#: manual/commands/get.txt:11
#, no-wrap
msgid "  get filename\n"
msgstr "|''**get** //имя_файла//''|\n"

#. type: Plain text
#: manual/commands/get.txt:15
msgid ""
"The first comment line of the file being read is taken as the `title'. See "
"the title command."
msgstr ""
"Первая строка-комментарий считываемого файла считается строкой заголовка. "
"См. [[title.ru|описание команды title]]."

#. type: Plain text
#: manual/commands/get.txt:17
msgid ""
"Comments in the circuit file are stored, unless they start with *+ in which "
"case they are thrown away."
msgstr ""
"Все комментарии в файле схемы сохраняются, кроме тех, что начинаются с ''*"
"+'', такие комментарии отбрасываются."

#. type: Plain text
#: manual/commands/get.txt:19
msgid ""
"`Dot cards' are set up, but not executed. This means that variables and "
"options are changed, but simulation commands are not actually done. As an "
"example, the options command is actually performed, since it only sets up "
"variables. The ac card is not performed, but its parameters are stored, so "
"that a plain ac command will perform the analysis specified in the file."
msgstr ""
"«Командные карточки» настраиваются, но не выполняются. Это значит, что "
"переменные и опции меняются, но команды моделирования на самом деле не "
"выполняются. Для примера, команда [[options.ru|options]] на самом деле "
"выполняется, так как она лишь настраивает переменные. «Карточка» **ac** не "
"выполняется, но её параметры сохраняются, с тем чтобы определённый в этом "
"файле анализ можно было выполнить явной командой [[ac.ru|ac]]."

#. type: Plain text
#: manual/commands/get.txt:21
msgid ""
"Any circuit already in memory will be erased before loading the new circuit."
msgstr ""
"Любая схема, уже имеющаяся в памяти, будет удалена перед загрузкой новой "
"схемы."

#. type: Plain text
#: manual/commands/get.txt:29
#, no-wrap
msgid ""
"  get amp.ckt\n"
"Get the circuit file amp.ckt from the current directory.\n"
"  get /usr/foo/ckt/amp.ckt\n"
"Get the file amp.ckt from the /usr/foo/ckt directory.\n"
"  get npn.mod\n"
"Get the file npn.mod.\n"
msgstr ""
"  get amp.ckt\n"
"Считать файл схемы ''amp.ckt'' из текущего каталога.\n"
"  get /usr/foo/ckt/amp.ckt\n"
"Считать файл ''amp.ckt'' из каталога ''/usr/foo/ckt''.\n"
"  get npn.mod\n"
"Считать файл ''npn.mod''.\n"

#. type: Title ======
#: manual/commands/include.txt:1
#, no-wrap
msgid "\"include\" command"
msgstr "Команда «include»"

#. type: Plain text
#: manual/commands/include.txt:6
msgid "Include a file, directly, as is."
msgstr "Включение данных файла непосредственно, как есть."

#. type: Plain text
#: manual/commands/include.txt:10
#, no-wrap
msgid "  include filename\n"
msgstr "|''**include** //имя_файла//''|\n"

#. type: Plain text
#: manual/commands/include.txt:14
msgid "The file is included as is."
msgstr "Файл включается как есть."

#. type: Plain text
#: manual/commands/include.txt:16
msgid ""
"If you are running interactive, it is as if you typed in what is in the file."
msgstr ""
"В интерактивном режиме работы это тождественно тому, как если бы то, что "
"находится в файле, было введено с клавиатуры."

#. type: Plain text
#: manual/commands/include.txt:18
msgid ""
"If you are running in a batch mode, or including a file from another file, "
"it is as if you did a copy and paste into that file."
msgstr ""
"При запуске в пакетном режиме или при включении файла из другого файла это "
"равносильно тому, как будто бы содержимое включаемого файла было скопировано "
"и вставлено в тот файл."

#. type: Plain text
#: manual/commands/include.txt:22
#, no-wrap
msgid ""
"  include npn.mod\n"
"Include the file npn.mod.\n"
msgstr ""
"  include npn.mod\n"
"Вставка содержимого файла ''npn.mod''.\n"

#. type: Title ======
#: manual/commands/lib.txt:1
#, no-wrap
msgid "\"lib\" command"
msgstr "Команда «lib»"

#. type: Plain text
#: manual/commands/lib.txt:6
msgid "Selective \"library\" include, and mark sections of a library."
msgstr "Избирательное включение «библиотек» и именование разделов библиотеки."

#. type: Plain text
#: manual/commands/lib.txt:11
#, no-wrap
msgid ""
"  lib section-name\n"
"  lib file-name section-name\n"
msgstr ""
"|''**lib** //название_раздела//          ''|\n"
"|''**lib** //имя_файла название_раздела//''|\n"

#. type: Plain text
#: manual/commands/lib.txt:15
msgid "This command takes two forms:"
msgstr "Эта команда имеет две формы."

#. type: Plain text
#: manual/commands/lib.txt:17
msgid ""
"The first form is to mark a section of a file, with a name, so it can be "
"selectively included.  The section ends with a line \".endl\"."
msgstr ""
"Первая форма служит для обозначения раздела файла, чтобы его содержимое "
"можно было включить отдельно. Конец раздела обозначается строкой ''.endl''."

#. type: Plain text
#: manual/commands/lib.txt:26
#, no-wrap
msgid ""
"  .lib high\n"
"  R1 (1 2) 10k\n"
"  R2 (2 0) 10k\n"
"  .endl\n"
"  .lib low\n"
"  R1 (1 2) 1k\n"
"  R2 (2 0) 1k\n"
"  .endl\n"
msgstr ""
"  .lib high\n"
"  R1 (1 2) 10k\n"
"  R2 (2 0) 10k\n"
"  .endl\n"
"  .lib low\n"
"  R1 (1 2) 1k\n"
"  R2 (2 0) 1k\n"
"  .endl\n"

#. type: Plain text
#: manual/commands/lib.txt:28
msgid ""
"The second form has two arguments.  It is a special case of \"include\", "
"that only includes matching sections of the file."
msgstr ""
"Вторая форма --- вызов с двумя аргументами. Это особый вид команды [[include."
"ru|include]], позволяющий включение только соответствующих разделов "
"указанного файла."

#. type: Plain text
#: manual/commands/lib.txt:30
#, no-wrap
msgid "  .lib libfile high\n"
msgstr "  .lib libfile high\n"

#. type: Title ======
#: manual/commands/list.txt:1
#, no-wrap
msgid "\"list\" command"
msgstr "Команда «list»"

#. type: Plain text
#: manual/commands/list.txt:6
msgid "Lists the circuit in memory."
msgstr "Вывод описания схемы, сохранённой в памяти программы."

#. type: Plain text
#: manual/commands/list.txt:11
#, no-wrap
msgid ""
"  list {label ...}\n"
"  list {label - label}\n"
msgstr ""
"|''**list** {//обозначение ...//}              ''|\n"
"|''**list** {//обозначение// - //обозначение//}''|\n"

#. type: Plain text
#: manual/commands/list.txt:15
msgid "Plain list will list the whole circuit on the console."
msgstr ""
"Команда **''list''** без параметров служит для вывода на консоль всей схемы."

#. type: Plain text
#: manual/commands/list.txt:17
msgid ""
"List with a component label asks for that one only. Wildcards are "
"supported: ? matches any character, once. * matches zero or more of any "
"character."
msgstr ""
"При задании одного обозначения компонента запрашивается вывод только "
"указанного компонента. Поддерживаются метасимволы: «''?''» соответствует "
"одному любому символу. «''*''» соответствует любому количеству любых "
"символов, в том числе ни одному."

#. type: Plain text
#: manual/commands/list.txt:19
msgid "For several components, list them."
msgstr "При задании нескольких компонентов выводятся они все."

#. type: Plain text
#: manual/commands/list.txt:21
msgid "For a range, specify two labels separated by a dash."
msgstr ""
"Для задания диапазона следует указать два обозначения, разделённые дефисом."

#. type: Plain text
#: manual/commands/list.txt:31
#, no-wrap
msgid ""
"  list\n"
"List the entire circuit to the console.\n"
"  list R11\n"
"Show the component R11.\n"
"  list D12 - C5\n"
"List the part of the netlist from M12 to C5, inclusive. D12 must be before C5 in the list.\n"
"  list D* C*\n"
"List all diodes and capacitors.\n"
msgstr ""
"  list\n"
"Вывести на консоль всю схему.\n"
"  list R11\n"
"Показать компонент R11.\n"
"  list D12 - C5\n"
"Вывести часть списка соединений от D12 до C5 включительно. В выводимом перечне D12 должно быть до C5.\n"
"  list D* C*\n"
"Вывести все диоды и конденсаторы.\n"

#. type: Title ======
#: manual/commands/load.txt:1
#, no-wrap
msgid "\"load\" and \"unload\" commands"
msgstr "Команды «load» и «unload»"

#. type: Plain text
#: manual/commands/load.txt:6
msgid "Load and unload plugins."
msgstr "Загрузка и выгрузка плагинов."

#. type: Plain text
#: manual/commands/load.txt:12
#, no-wrap
msgid ""
"  load public-model.so\n"
"  load ./my-model.so\n"
"  unload ./my-model.so\n"
msgstr ""
"|''**load**   //общая_модель.so//''|\n"
"|''**load**   //./моя_модель.so//''|\n"
"|''**unload** //./моя_модель.so//''|\n"

#. type: Plain text
#: manual/commands/load.txt:16
msgid ""
"The load command loads a compiled plugin module.  Plugins can be used to "
"arbitrarily extend gnucap.  You can add models, commands, functions, "
"measurements, and anything else."
msgstr ""
"Командой **load** загружается скомпилированный модуль плагина. Плагины могут "
"использоваться для любых расширений gnucap. С их помощью можно добавлять "
"модели, команды, функции, виды измерений и тому подобное."

#. type: Plain text
#: manual/commands/load.txt:21
#, no-wrap
msgid ""
"Warning messages such as:\n"
"  M: already installed, replacing\n"
"  stashing as M:0\n"
"are harmless, and only indicate that something that was already installed is hidden by loading the plugin.\n"
msgstr ""
"Предупреждения вида:\n"
"  M: already installed, replacing\n"
"  stashing as M:0\n"
"безвредны, и только показывают, что что-то другое, установленное ранее, становится скрытым при загрузке этого плагина.\n"

#. type: Plain text
#: manual/commands/load.txt:24
msgid ""
"Plugins are shared-object files in a format that is determined by the "
"system.  Plugins must be compiled with the same compiler and same headers "
"that compiled the main executable."
msgstr ""
"Плагины --- разделяемые объектные файлы, формат которых определяется "
"системой. Плагины должны компилироваться тем же самым компилятором и с теми "
"же самыми заголовочными файлами, что использовались для компиляции основной "
"исполняемой программы."

#. type: Plain text
#: manual/commands/load.txt:26
msgid ""
"It is intended to maintain source compatibility between stable releases of "
"gnucap, but no guarantee is made about binary compatibility."
msgstr ""
"Подразумевается, что совместимость исходного кода между стабильными "
"выпусками gnucap будет сохраняться, но в отношении двоичной совместимости "
"такой гарантии нет."

#. type: Plain text
#: manual/commands/load.txt:28
msgid ""
"The load command must be available as a built-in command, because without "
"it, you cannot load any plugins.  It is possible to override it with a "
"plugin."
msgstr ""
"Команда **load** должна быть обязательно доступна в виде встроенной команды, "
"так как без неё невозможно загрузить ни один плагин. Есть возможность "
"переопределить её с помощью плагина."

#. type: Plain text
#: manual/commands/load.txt:35
#, no-wrap
msgid ""
"  load ./bsim463.so\n"
"Load the plugin from the current directory.\n"
"  load bsim463.so\n"
"Load it from the public area, as defined by LD_LIBRARY_PATH.\n"
msgstr ""
"  load ./bsim463.so\n"
"Загрузить плагин из текущего каталога.\n"
"  load bsim463.so\n"
"Загрузить его из общедоступной области, что определена переменной ''LD_LIBRARY_PATH''.\n"

#. type: Title ======
#: manual/commands/log.txt:1
#, no-wrap
msgid "\"log\" command"
msgstr "Команда «log»"

#. type: Plain text
#: manual/commands/log.txt:6
msgid "Saves a copy of your keyboard entries in a file."
msgstr "Сохранение копии ввода с клавиатуры в файл."

#. type: Plain text
#: manual/commands/log.txt:12
#, no-wrap
msgid ""
"  log file\n"
"  log >> file\n"
"  log\n"
msgstr ""
"|''**log**        //файл//''|\n"
"|''**log** %%>>%% //файл//''|\n"
"|''**log**                ''|\n"

#. type: Plain text
#: manual/commands/log.txt:16
msgid ""
"The `>>' option appends to an existing file, if it exists, otherwise it "
"creates one."
msgstr ""
"При использовании с опцией ''%%>>%%'', если указанный файл уже существует, "
"данные будут добавляться в него, иначе будет создан новый файл."

#. type: Plain text
#: manual/commands/log.txt:18
msgid ""
"Files can be nested. If you open one while another is already open, both "
"will contain all the information."
msgstr ""
"Файлы могут использоваться рекурсивно. Если в то время, как уже открыт один "
"файл, открыть ещё один, вся вновь вводимая информация будет содержаться в "
"обоих."

#. type: Plain text
#: manual/commands/log.txt:20
msgid ""
"A bare log closes the file. Because of this, the last line of this file is "
"always log. Ordinarily, this will not be of any consequence, but if a log "
"file is open when you use this file as command input, this will close it. If "
"more than one log file is open, they will be closed in the reverse of the "
"order in which they were opened, maintaining nesting."
msgstr ""
"Командой **''log''** без параметров файл закрывается. Из-за этого последней "
"строкой закрытого файла всегда будет ''log''. Обычно это не имеет никакого "
"значения, но если такой файл используется как входной для ввода команд, "
"когда файл журнала открыт, эта команда его закроет.  Если открыто более "
"одного файла журнала, они будут закрываться в порядке, обратном тому, в "
"котором открывались, сохраняя порядок рекурсивной вложенности."

#. type: Plain text
#: manual/commands/log.txt:22
msgid "See also: `>' and `<' commands."
msgstr "См. также команды [[outfile.ru|>]] и [[infile.ru|<]]."

#. type: Plain text
#: manual/commands/log.txt:24
msgid ""
"The file is an exact copy of what you type, so it is suitable for gnucap "
"<file from the shell. It is NOT suitable for the < command in gnucap or the "
"Spice-like mode gnucap file without <."
msgstr ""
"Файл журнала представляет собой точную копию ввода с клавиатуры, поэтому он "
"подходит для запуска командой **''gnucap <файл''** из shell. Он НЕ подходит "
"для команды [[infile.ru|<]] в интерактивном режиме gnucap или для команды "
"**''gnucap файл''** в SPICE-образной форме без ''<''."

#. type: Plain text
#: manual/commands/log.txt:34
#, no-wrap
msgid ""
"  log today\n"
"Save the commands in a file today in the current directory. If today already exists, the old one is gone.\n"
"  log >> doit\n"
"Save the commands in a file doit. If doit already exists, it is kept, and the new data is added to the end.\n"
"  log runit.bat\n"
"Use the file runit.bat.\n"
"  log\n"
"Close the file. Stop saving.\n"
msgstr ""
"  log today\n"
"Сохранять команды в файл ''today'' в текущем каталоге. Если ''today'' уже существует, старый файл с таким же именем будет утрачен.\n"
"  log >> doit\n"
"Сохранять команды в файл ''doit''. Если ''doit'' уже существует, он сохраняется, и новые данные добавляются к концу.\n"
"  log runit.bat\n"
"Использовать файл ''runit.bat''.\n"
"  log\n"
"Закрыть файл. Прекратить сохранение.\n"

#. type: Title ====
#: manual/commands/measure.txt:1
#: manual/tech/plugins/parameter_functions_and_measurements.txt:9
#, no-wrap
msgid "\"measure\" command"
msgstr "Команда «measure»"

#. type: Plain text
#: manual/commands/measure.txt:6
msgid "Make measurements on a circuit, based on stored data."
msgstr "Выполнение измерений в схеме на основе сохранённых данных."

#. type: Plain text
#: manual/commands/measure.txt:10
#, no-wrap
msgid "  measure param-name = measurefunction(args)\n"
msgstr "|''**measure** //имя_параметра// = //функция_измерения//(//аргументы//)''|\n"

#. type: Plain text
#: manual/commands/measure.txt:13
msgid ""
"The \"measure\" command sets parameters, like the \"parameter\" command, but "
"the value after a measure is a number."
msgstr ""
"В команде **measure**, как и в команде [[parameter.ru|parameter]], задаются "
"параметры, но результатом измерений является число."

#. type: Plain text
#: manual/commands/measure.txt:15
msgid ""
"It is used to make measurements on a circuit, such as slew rate, crossings, "
"or average value."
msgstr ""
"Команда используется для проведения измерений в схеме, таких как определение "
"[[..:measure:slope.ru|скорости нарастания сигнала]], [[..:measure:cross.ru|"
"пересечений]] или [[..:measure:mean.ru|средних значений]]."

#. type: Plain text
#: manual/commands/measure.txt:17
msgid ""
"Before using a \"measure\" command, you need to store the data for the probe "
"points you might want to measure.  This is done with the [[gnucap:manual:"
"commands:store]] command.  If you don't specify, no data is stored."
msgstr ""
"Перед использованием команды **measure** необходимо сохранить данные для "
"[[..:howto:probes.ru|датчиков]], которые хотелось бы измерить. Для этого "
"используется команда [[gnucap:manual:commands:store.ru|store]]. Если её не "
"задать, никакие данные сохранены не будут."

#. type: Plain text
#: manual/commands/measure.txt:19
msgid ""
"Then you need to do some kind of analysis, such as [[gnucap:manual:commands:"
"transient]] or [[gnucap:manual:commands:ac]]."
msgstr ""
"Затем нужно выполнить какой-нибудь анализ, например [[gnucap:manual:commands:"
"transient.ru|transient]] или [[gnucap:manual:commands:ac.ru|ac]]."

#. type: Plain text
#: manual/commands/measure.txt:21
msgid ""
"For better accuracy of measurements, it is best to specify the option "
"\"trace all\" on a transient command."
msgstr ""
"Для увеличения точности измерений команду [[transient.ru|transient]] лучше "
"всего задавать с опцией ''trace all''."

#. type: Title =====
#: manual/commands/measure.txt:22 manual/measure/at.txt:16
#: manual/measure/cross.txt:28
#, no-wrap
msgid "Diagnostics"
msgstr "Диагностика"

#. type: Plain text
#: manual/commands/measure.txt:25
msgid ""
"The message \"no match\" means that the probe you selected was not stored."
msgstr ""
"Сообщение «''no match''» означает, что данные выбранного датчика не "
"сохранялись."

#. type: Title =====
#: manual/commands/measure.txt:28 manual/howto/measure.txt:1
#: about/plugins/measurements.txt:3
#, no-wrap
msgid "Measurements"
msgstr "Измерения"

#. type: Plain text
#: manual/commands/measure.txt:31 manual/howto/measure.txt:4
#: manual/howto/measurements.txt:4
msgid ""
"\"Point\" here refers to time, frequency, or whatever is the independent \"x"
"\" value."
msgstr ""
"«Точкой» здесь называется время, частота или какая-то другая величина, "
"являющаяся независимым значением по оси «X»."

#. type: Plain text
#: manual/commands/measure.txt:40 manual/howto/measure.txt:13
#, no-wrap
msgid ""
"|[[gnucap:manual:measure:at]]     |The value of a wave at a point, or its derivative.  |\n"
"|[[gnucap:manual:measure:mean|average]]\\\\ [[gnucap:manual:measure:mean]]              |Average or mean value.  |\n"
"|[[gnucap:manual:measure:cross]]  |Find crossings.  |\n"
"|[[gnucap:manual:measure:mean|integrate]]\\\\ [[gnucap:manual:measure:mean|area]]  |The area under the curve.  |\n"
"|[[gnucap:manual:measure:minmax|max]]    |Maximum value, or its point.  |\n"
"|[[gnucap:manual:measure:minmax|min]]    |Minimum value, or its point.  |\n"
"|[[gnucap:manual:measure:mean|rms]]    |The RMS value.  |\n"
"|[[gnucap:manual:measure:slope|slewrate]]\\\\ [[gnucap:manual:measure:slope]]\\\\ [[gnucap:manual:measure:slope|ddt]]  |Slew rate or slope.  |\n"
msgstr ""
"|[[gnucap:manual:measure:at.ru|at]]     | Значение сигнала в какой-нибудь точке или его производная  |\n"
"|[[gnucap:manual:measure:mean.ru|average]]\\\\ [[gnucap:manual:measure:mean.ru|mean]]              |Среднее значение  |\n"
"|[[gnucap:manual:measure:cross.ru|cross]]  |Поиск пересечений  |\n"
"|[[gnucap:manual:measure:mean.ru|integrate]]\\\\ [[gnucap:manual:measure:mean.ru|area]]  | Размер области под кривой  |\n"
"|[[gnucap:manual:measure:minmax.ru|max]]  |Значение максимума или точка, в которой он находится  |\n"
"|[[gnucap:manual:measure:minmax.ru|min]]  |Значение минимума  или точка, в которой он находится  |\n"
"|[[gnucap:manual:measure:mean.ru|rms]]    |Среднеквадратичное значение  |\n"
"|[[gnucap:manual:measure:slope.ru|slewrate]]\\\\ [[gnucap:manual:measure:slope.ru|slope]]\\\\ [[gnucap:manual:measure:slope.ru|ddt]]  | Скорость нарастания или наклон кривой сигнала |\n"

#. type: Plain text
#: manual/commands/measure.txt:46
#, no-wrap
msgid ""
"Before making measurements, you need to store the data to measure:\n"
"  gnucap> store tran v(*) id(m*) gm(m*)\n"
"Then do the analysis\n"
"  gnucap> transient 0 100u 1u trace all\n"
msgstr ""
"До проведения измерений необходимо сохранить данные для них:\n"
"  gnucap> store tran v(*) id(m*) gm(m*)\n"
"Затем выполнить анализ:\n"
"  gnucap> transient 0 100u 1u trace all\n"

#. type: Plain text
#: manual/commands/measure.txt:48
msgid "Now you are ready to measure:"
msgstr "Теперь всё готово для измерений:"

#. type: Plain text
#: manual/commands/measure.txt:56
#, no-wrap
msgid ""
"  gnucap> measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  gnucap> measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  gnucap> param period = {t2-t1}\n"
"  gnucap> param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
msgstr ""
"  gnucap> measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Найти последнее время, когда напряжение v(out) пересекло 0 снизу вверх.\n"
"  gnucap> measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Найти последнее пересечение нуля при возрастании напряжения до момента времени t2.\n"
"  gnucap> param period = {t2-t1}\n"
"  gnucap> param frequency = {1/period}\n"
"Параметры интерпретируются как в функциональных языках программирования, поэтому их обновление будет производиться при любом изменении t1 или t2.\n"

#. type: Plain text
#: manual/commands/measure.txt:61
#, no-wrap
msgid ""
"  gnucap> measure meanvalue = mean(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the mean value of v(out) over one cycle.\n"
"  gnucap> measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
msgstr ""
"  gnucap> measure meanvalue = mean(probe=\"v(out)\" begin=t1 end=t2)\n"
"Найти среднее значение v(out) за один период.\n"
"  gnucap> measure sample = mean(probe=\"v(out)\")\n"
"Найти среднее значение v(out) за всё время работы.\n"

#. type: Plain text
#: manual/commands/measure.txt:64
#, no-wrap
msgid ""
"  gnucap> measure area = integrate(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the area under the curve of v(out) over one cycle.  The area might be zero.\n"
msgstr ""
"  gnucap> measure area = integrate(probe=\"v(out)\" begin=t1 end=t2)\n"
"Найти размер области под кривой v(out) за один период. Эта область может быть нулевой.\n"

#. type: Plain text
#: manual/commands/measure.txt:67
#, no-wrap
msgid ""
"  gnucap> measure rms = rms(probe=\"v(out)\" begin=t1 end=t2)\n"
"Find the RMS value of v(out) over one cycle.\n"
msgstr ""
"  gnucap> measure rms = rms(probe=\"v(out)\" begin=t1 end=t2)\n"
"Найти среднеквадратичное значение для v(out) за один период.\n"

#. type: Plain text
#: manual/commands/measure.txt:70
#, no-wrap
msgid ""
"  gnucap> measure rmsin = rms(probe=\"bar(in)\")\n"
"  no match: bar(in)\n"
"You didn't store the probe \"bar(in)\".\n"
msgstr ""
"  gnucap> measure rmsin = rms(probe=\"bar(in)\")\n"
"  no match: bar(in)\n"
"Данные для датчика «bar(in)» не были сохранены.\n"

#. type: Title ======
#: manual/commands/op.txt:1
#, no-wrap
msgid "\"op\" command"
msgstr "Команда «op»"

#. type: Plain text
#: manual/commands/op.txt:6
msgid ""
"Performs a nonlinear DC steady state analysis, with no input. If a "
"temperature range is given, it sweeps the temperature."
msgstr ""
"Выполнение нелинейного расчёта статического режима по постоянному току при "
"отсутствии входного сигнала. При задании температуры расчёт производится с "
"изменением температуры."

#. type: Plain text
#: manual/commands/op.txt:10
#, no-wrap
msgid "  op start stop stepsize {options ...}\n"
msgstr "|''**op** //начало конец размер_шага// {//опции ...//}''|\n"

#. type: Plain text
#: manual/commands/op.txt:14
msgid ""
"There are substantial extensions beyond the capabilities of the SPICE op "
"command."
msgstr ""
"Возможности команды **op** существенно расширены по сравнению с аналогичной "
"командой в SPICE."

#. type: Plain text
#: manual/commands/op.txt:16
msgid ""
"If there are numeric arguments, they represent a temperature sweep. They are "
"the start and stop temperatures in degrees Celsius, and the step size, in "
"order. They are saved between commands, so no arguments will repeat the "
"previous sweep."
msgstr ""
"Если заданы числовые аргументы, они представляют собой диапазон развёртки "
"температуры. Это начальная и конечная температура в градусах Цельсия, и "
"размер шага, в указанном порядке. Они сохраняются между командами, поэтому "
"ни при каких аргументах предыдущая развёртка повторяться не будет."

#. type: Plain text
#: manual/commands/op.txt:18
msgid ""
"This command will use the op probe set, instead of automatically printing "
"all nodes and source currents, so you must do \"print op ....\" before "
"running op. We did it this way because we believe that printing everything "
"all the time is usually unnecessary clutter. All of the information "
"available from SPICE and more is available here. See the print command and "
"the device descriptions for more details."
msgstr ""
"Вместо автоматического вывода всех узлов и токов источников для этой команды "
"будет использоваться набор датчиков **op**, поэтому до запуска команды "
"**op** вам необходимо задать **''print op ...''**. В таком виде это сделано "
"из-за того, что нам кажется, что постоянный вывод всех данных приводит "
"обычно лишь к ненужному беспорядку. Вся информация, доступная в SPICE, и "
"даже сверх того, доступна и здесь. Подробности см. в описании команды "
"[[print.ru|print]] и в [[..:devices.ru|описаниях устройств]]."

#. type: Plain text
#: manual/commands/op.txt:20
msgid ""
"A single parameter represents a single temperature. Two parameters instruct "
"the computer to analyze for those two points only."
msgstr ""
"Одним параметром задаётся одна температура. Двумя параметрами компьютеру "
"даётся приказ произвести расчёт только для двух указанных точек."

#. type: Plain text
#: manual/commands/op.txt:22
msgid ""
"This command also sets up the quiescent point for subsequent AC analysis. It "
"is necessary to do this for nonlinear circuits. The last step in the sweep "
"determines the quiescent point for the AC analysis."
msgstr ""
"Этой командой также настраивается статическая точка для последующего анализа "
"[[ac.ru|ac]]. Это необходимо для анализа нелинейных схем. Статическая точка "
"для анализа [[ac.ru|ac]] определяется последним шагом в диапазоне."

#. type: Plain text
#: manual/commands/op.txt:63
#, no-wrap
msgid ""
"  op 27\n"
"Do a DC operating point simulation at temperature 27 degrees Celsius.\n"
"  op -50 200 25\n"
"Sweep the temperature from -50 to 200 in 25 degree steps. Do a DC operating point simulation at each step.\n"
"  op\n"
"With no parameters, it uses the same ones as the last time. In this case, from -50 to 200 in 25 degree steps.\n"
"  op 200 -50 -25\n"
"You can sweep downward, by asking for a negative increment.\n"
"  op temperature=75\n"
" Simulate at 75 degrees, this time. This isn't remembered for next time.\n"
"  op\n"
"Since the last time used the temperature option, go back one more to find what the sweep parameters were. In this case, downward from 200 to -50 in 25 degree steps.\n"
msgstr ""
"  op 27\n"
"Произвести статический расчёт рабочей точки по постоянному току при температуре 27 градусов Цельсия.\n"
"  op -50 200 25\n"
"Изменять температуру от -50 до 200 с шагом в 25 градусов. Для каждого шага производить статический расчёт рабочей точки по постоянному току.\n"
"  op\n"
"Если параметры не указаны, будут использоваться те же самые параметры, что были заданы последний раз. В данном случае моделирование от -50 до 200 с шагом 25 градусов.\n"
"  op 200 -50 -25\n"
"Можно произвести развёртку в обратную сторону, запросив отрицательное приращение.\n"
"  op temperature=75\n"
"В этот раз произвести моделирование для 75 градусов. Параметр запоминаться не будет, и не будет использоваться для следующего моделирования.\n"
"  op\n"
"Так как последний раз использовалась опция ''temperature'', вернуться ещё на одну команду назад, чтобы узнать параметры развёртки. В данном случае это развёртка от 200 вниз до -50 с шагом 25 градусов.\n"

#. type: Title ======
#: manual/commands/options.txt:1
#, no-wrap
msgid "\"options\" command"
msgstr "Команда «options»"

#. type: Plain text
#: manual/commands/options.txt:6 manual/commands/options.txt:14
msgid "Sets options, iteration parameters, global data."
msgstr "Задание опций, параметров цикла, глобальных данных."

#. type: Plain text
#: manual/commands/options.txt:10
#, no-wrap
msgid ""
"  options\n"
"  options option-name value ...\n"
msgstr ""
"|''**options**                           ''|\n"
"|''**options** //имя_опции значение ...//''|\n"

#. type: Plain text
#: manual/commands/options.txt:18
msgid "Typical usage is the name of the item to set followed by the value."
msgstr ""
"При обычном использовании указывается имя опции и значение, в которое она "
"должна быть установлена."

#. type: Plain text
#: manual/commands/options.txt:20
msgid "The bare command `options' displays the values."
msgstr ""
"Команда **''options''** без параметров служит для вывода значений опций."

#. type: Plain text
#: manual/commands/options.txt:22
msgid ""
"These options control the simulation by specifying how to handle marginal "
"circumstances, how long to wait for convergence, etc."
msgstr ""
"Эти опции управляют моделированием, определяя, как обрабатывать граничные "
"условия, как долго ждать сходимости и т. д."

#. type: Plain text
#: manual/commands/options.txt:24
msgid "Most of the SPICE options are supported, more have been added."
msgstr "Поддерживается большая часть опций SPICE, добавлено ещё несколько."

#. type: Title ====
#: manual/commands/options.txt:26
#, no-wrap
msgid "i/o"
msgstr "Ввод/вывод"

#. type: Plain text
#: manual/commands/options.txt:40
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|acct         |false    |Turns on accounting. When enabled, print the CPU time used after each command, and a summary on exit in batch more.  |\n"
"|list         |false    |Turns on echo input.  |\n"
"|clobber      |true     |Allow clobber of files.  |\n"
"|out          |9999     |Output width.  Sets the output print width for tables and character graphics.  |\n"
"|ydivisions   |4.       |Y axis divisions. Sets the number of divisions on the Y axis for ASCII plotting.  |\n"
"|phase        |degrees  |In AC analysis, print phase in \"degrees\", \"+degrees\", \"-degrees\" or \"radians\".\\\\  \"degrees\" wraps phase to the range of -180 to +180.\\\\  \"+degrees\" wraps phase to the range of 0 to +360.\\\\  \"-degrees\" wraps phase to the range of -360 to 0.  |\n"
"|harmonics    |9        |Harmonics in Fourier analysis. The number of harmonics to display in a Fourier analysis, unless specified otherwise.  |\n"
"|edit         |true     |Enable command line editing.  |\n"
"|language     |acs      |Simulation language selection.  As supplied, the supported values are \"acs\", \"spice\", \"spectre\", and \"verilog\".  |\n"
"|insensitive  |         |Case sensitivity.  Whether it is true or false by default depends on the language.  |\n"
"|units        |spice    |Floating point units.  Supported values are \"spice\" and \"si\".  |\n"
"|recursion    |20       |Limit recursion in expresion evaluation to x levels.  The purpose is to trap infinite recursion in user expressions.  |\n"
msgstr ""
"^ Ключ             ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''acct''         |  **''false''**    | Включает учёт использования ресурсов системы («accounting»). При включенной опции после каждой команды выводится использованное время CPU, а в пакетном режиме краткая сводка по выходу из программы  |\n"
"| ''list''         |  **''false''**    | Включает эхо ввода  |\n"
"| ''clobber''      |  **''true''**     | Позволяет затирание файлов  |\n"
"| ''out''          |  **''9999''**     | Ширина вывода. Задаёт ширину печати вывода для таблиц и символьной графики |\n"
"| ''ydivisions''   |  **''4.''**       | Деления оси «Y». Устанавливает количество делений оси «Y» для вывода ASCII-графика  |\n"
"| ''phase''        |  **''degrees''**  | В анализе [[ac.ru|ac]] значение фазы выводится в виде, определяемом значением этой опции, которое может быть равно «''degrees''», «''+degrees''», «''-degrees''» или «''radians''».\\\\  При задании «''degrees''» фаза выводится в градусах в диапазоне от -180 до +180.\\\\  При задании «''+degrees''» фаза выводится в диапазоне от 0 до +360 градусов.\\\\ При задании «''-degrees''» фаза выводится в диапазоне от -360 до 0 градусов.\\\\ При задании «''radians''» фаза выводится в радианах.  |\n"
"| ''harmonics''    |  **''9''**        | Гармоники в [[fourier.ru|анализе Фурье]]. Количество гармоник, которое должно отображаться в анализе Фурье, если не определено иначе  |\n"
"| ''edit''         |  **''true''**     | Разрешить редактирование строк команд  |\n"
"| ''language''     |  **''acs''**      | Выбор языка моделирования. В текущей поставке поддерживаются значения «[[gnucap:manual:languages:acs.ru|acs]]», «[[gnucap:manual:languages:spice.ru|spice]]», «[[gnucap:manual:languages:spectre.ru|spectre]]» и «[[gnucap:manual:languages:verilog.ru|verilog]]».  |\n"
"| ''insensitive''  |                   | Зависимость языка от регистра символов. Значение по умолчанию **''true''** или **''false''** зависит от используемого языка  |\n"
"| ''units''        |  **''spice''**    | Формат представления чисел с плавающей запятой. Поддерживаются значения «''spice''» и «''si''»  |\n"
"| ''recursion''    |  **''20''**       | Ограничивает рекурсию при вычислении значений выражений до указанного количества уровней.  Целью является отслеживание бесконечной рекурсии в пользовательских выражениях  |\n"

#. type: Title ====
#: manual/commands/options.txt:42
#, no-wrap
msgid "accuracy, i/o"
msgstr "Точность, ввод/вывод"

#. type: Plain text
#: manual/commands/options.txt:48
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|numdgt       |5        |Number of significant digits to print for analysis results.  It is silently limited to 3 to 20.  |\n"
"|floor        |1.E-21   |Effective zero value.  Results values less than floor are shown as zero. Other small numbers are rounded to the nearest floor.  |\n"
"|vfloor       |1.f      |Effective zero value for voltage probes.  Results values less than vfloor are shown as zero. Other small numbers are rounded to the nearest vfloor.  |\n"
"|roundofftol  |100.f    |Numeric rounding tolerance.  Some internal calculations can result in cancellations, with a result near zero even though the operands are large. The number is converted to zero if it is less than roundofftol*theoperand.  |\n"
msgstr ""
"^ Ключ             ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''numdgt''       |  **''5''**        |Количество значащих цифр для вывода результатов анализа. Оно молча ограничивается диапазоном от 3 до 20.  |\n"
"| ''floor''        |  **''1.E-21''**   |Эффективное значение нуля. Значения результата меньше ''floor'' отображаются как ноль. Другие маленькие числа округляются до ближайшего ''floor''.  |\n"
"| ''vfloor''       |  **''1.f''**      |Эффективное значение нуля для датчиков напряжения. Значения результатов меньше чем ''vfloor'' отображаются как ноль. Другие маленькие числа округляются до ближайшего ''vfloor''.  |\n"
"| ''roundofftol''  |  **''100.f''**    |Числовой допуск округления. Некоторые внутренние расчёты могут завершиться потерей точности из-за уменьшения количества значащих разрядов с близким к нулю результатом даже при больших операндах. Результирующее число преобразуется в ноль, если оно меньше ''roundofftol*операнд''.  |\n"

#. type: Title ====
#: manual/commands/options.txt:49
#, no-wrap
msgid "accuracy, tolerances"
msgstr "Точность, допуски"

#. type: Plain text
#: manual/commands/options.txt:61
#, no-wrap
msgid ""
"^key         ^default  ^description  ^\n"
"|gmin        |1.p      |Minimum conductance allowed by the program.  Every node must have a net minimum conductance of GMIN to ground. If effective open circuits are found during the solution process (leading to a singular matrix) a conductance of GMIN is forced to ground, after printing an \"open circuit\" error message.  |\n"
"|short       |10.uΩ    |Resistance of voltage source or short. Sets the default resistance of voltage sources. In some cases, inductors are replaced by resistors, if so, this is the value. It is also the resistance used to replace short circuits anywhere they are not allowed and the program finds one.  |\n"
"|reltol      |0.001    |Relative error tolerance allowed.  If the ratio of successive values in iteration are within RELTOL of one, this value is considered to have converged.  |\n"
"|abstol      |1.p      |Absolute error tolerance allowed.  If successive values in iteration are within ABSTOL of each other, this value is considered to have converged.  |\n"
"|vntol       |1.u      |Absolute voltage error required to force model re-evaluation.  If the voltage at the terminals of a model is within VNTOL of the previous iteration, the model is not re-evaluated. The old values are used directly.  |\n"
"|trtol       |7.       |Transient error “tolerance”.  This parameter is an estimate of the factor by which the program overestimates the actual truncation error.  For critical applications, it should be set to 1.  |\n"
"|chgtol      |10.f     |Charge tolerance.  It is used in step size control in transient analysis.  |\n"
"|pivtol      |100.f    |Pivot tolerance.  Sets a threshold for printing an \"open circuit\" warning.  |\n"
"|bypasstol   |0.1      |Tolerance multiplier for evaluation bypass checking.  |\n"
"|loadtol     |0.1      |Tolerance multiplier for matrix load bypass checking.  |\n"
msgstr ""
"^ Ключ           ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''gmin''       |  **''1.p''**    | Минимальная проводимость, разрешённая в программе.  Каждый узел должен иметь минимальную проводимость соединения на землю равную ''gmin''. Если в процессе решения найдены фактические разомкнутые контуры (приводящие к вырожденной сингулярной матрице), для них, после вывода сообщения об ошибке «open circuit», принудительно задаётся проводимость на землю равная ''gmin''.  |\n"
"| ''short''      |  **''10.uΩ''**  | Сопротивление источника напряжения или короткого замыкания. Задаёт значение по умолчанию для сопротивлений источников напряжения. В некоторых случаях катушки индуктивности заменяются резисторами, там это значение будет представлять их сопротивление. Это также то сопротивление, которое используется для замены короткозамкнутых цепей во всех тех местах, где они не разрешены, но найдены программой.  |\n"
"| ''reltol''     |  **''0.001''**  | Допустимое отклонение относительной погрешности. Если отношение последовательных значений в цикле находится в пределах ''reltol'' от единицы, считается, что сходимость этого значения достигнута  |\n"
"| ''abstol''     |  **''1.p''**    | Допустимое отклонение абсолютной погрешности. Если последовательные значения в цикле находятся в пределах ''abstol'' друг от друга, считается, что сходимость этого значения достигнута  |\n"
"| ''vntol''      |  **''1.u''**    | Абсолютная погрешность по напряжению, необходимая для принудительного пересчёта модели. Если напряжение на выводах модели находится в пределах ''vntol'' от предыдущей итерации, модель не пересчитывается. Непосредственно используются старые значения  |\n"
"| ''trtol''      |  **''7.''**     | «Допуск» погрешности временного анализа.  Этот параметр представляет собой приблизительное значение коэффициента, на который программа умножает текущую погрешность численного метода («truncation error»).  Для критических приложений он должен быть установлен в 1  |\n"
"| ''chgtol''     |  **''10.f''**   | Допуск заряда. Параметр используется в управлении размером шага во временном анализе  |\n"
"| ''pivtol''     |  **''100.f''**  | Допуск ведущего элемента матрицы. Задаёт порог для вывода предупреждения «open circuit»  |\n"
"| ''bypasstol''  |  **''0.1''**    | Множитель допуска для проверки на пропуск расчёта модели  |\n"
"| ''loadtol''    |  **''0.1''**    | Множитель допуска для проверки на пропуск загрузки матрицы  |\n"

#. type: Title ====
#: manual/commands/options.txt:62
#, no-wrap
msgid "accuracy, algorithms"
msgstr "Точность, алгоритмы"

#. type: Plain text
#: manual/commands/options.txt:75
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|method        |trap     |Differentiation method.  Incorrectly called “integration” method in SPICE. Possible values are euler, gear, and trap.  |\n"
"|bypass        |true     |Bypass model evaluation if appropriate. If the last two iterations indicate that an element is converged or dormant, do not evaluate it but use its old values directly.  |\n"
"|incmode       |true     |Incrementally update the matrix. Instead of rebuilding the matrix on every iteration, keep as much of the old matrix as possible and make incremental changes.  |\n"
"|lcbypass      |true     |Bypass evaluation of linear inductors and capacitors when possible. When set, they are evaluated only on the first iteration of a time step.  |\n"
"|lubypass      |true     |Bypass parts of LU decomposition if appropriate. If only a few elements of the matrix were changed solve only those parts of the LU matrix that depend on them.  |\n"
"|fbbypass      |true     |Skip matrix solution the last iteration. In theory, it reduces accuracy slightly, but specified tolerances will still be met. Time saving can be significant.  |\n"
"|traceload     |true     |Use a queue to only load changed elements to the matrix. This results in faster loading and has no known drawbacks.  |\n"
"|order         |auto     |Equation ordering.  Determines how external node numbers are mapped to internal numbers. The values are forward, reverse, and auto.  |\n"
"|mode          |mixed    |Simulation mode selection.  Values are analog, digital, and mixed. In analog mode, logic elements (type U) are replaced by their subcircuits as if they were type X. In digital mode, logic elements are simulated as digital regardless of whether the signals are proper or not, as in traditional mixed-mode simulation. In mixed mode, logic elements may be simulated as analog or digital depending on the signals present.  |\n"
"|transits      |2        |Mixed mode transition count.  Sets the number of “good” transitions for a supposedly digital signal to be accepted as digital.  |\n"
"|quitconvfail  |false    |Quit on convergence failure in transient analysis. Do not adjust time step, just stop.  |\n"
msgstr ""
"^ Ключ           ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''method''        |  **''trap''**     |Метод дифференцирования. Некорректно назван в SPICE методом «интегрирования». Возможные значения «''euler''» (метод Эйлера), «''gear''» (метод Гира) и «''trap''» (метод трапеций)  |\n"
"| ''bypass''        |  **''true''**     |Пропускать расчёт модели в подходящих случаях. Если две последние итерации показывают, что элемент сходящийся или неактивный, не производить для него расчёт, а использовать непосредственно его старые значения  |\n"
"| ''incmode''       |  **''true''**     |Инкрементальное обновление матрицы. Вместо перестроения матрицы во время каждой итерации сохранять как можно больше информации из старой матрицы и производить инкрементальные изменения  |\n"
"| ''lcbypass''      |  **''true''**     |Пропуск вычисления линейных индуктивностей и емкостей, когда это возможно. Когда параметр установлен, они вычисляются только на первой итерации шага времени  |\n"
"| ''lubypass''      |  **''true''**     |Пропускать части LU-разложения в подходящих случаях. Если было изменено только несколько элементов матрицы, разрешить только те части LU-матрицы, которые от них зависят  |\n"
"| ''fbbypass''      |  **''true''**     |Пропустить решение матрицы в последней итерации. В теории, это немного уменьшает точность, но указанные допуски всё же будут соблюдены. Экономия времени может быть значительной  |\n"
"| ''traceload''     |  **''true''**     |Использовать очередь, чтобы загружать в матрицу только изменённые элементы. В результате этого загрузка будет более быстрой, а известных недостатков нет  |\n"
"| ''order''         |  **''auto''**     |Порядок равенств. Определяет, как номера внешних узлов конвертируются во внутренние номера. Возможные значения параметра: «''forward''» (прямой порядок), «''reverse''» (обратный порядок) и «''auto''» (автоматический выбор)  |\n"
"| ''mode''          |  **''mixed''**    |Выбор режима моделирования. Значения: «''analog''» (аналоговое), «''digital''» (цифровое) и «''mixed''» (смешанное). В аналоговом режиме логические элементы (тип U) замещаются их подсхемами, как будто бы они были типа X. В цифровом режиме логические элементы моделируются как цифровые, независимо от того, подходящие ли сигналы или нет, как в традиционном моделировании в смешанном режиме. В смешанном режиме логические элементы могут моделироваться как аналоговые или цифровые, в зависимости от имеющихся сигналов  |\n"
"| ''transits''      |  **''2''**        |Количество переходов для смешанного режима. Задаёт число «хороших» переходов для предположительно цифрового сигнала, чтобы он был признан цифровым  |\n"
"| ''quitconvfail''  |  **''false''**    |Выход при отсутствии сходимости во [[transient.ru|временном анализе]]. Не корректировать шаг времени, просто остановиться  |\n"

#. type: Title ====
#: manual/commands/options.txt:75
#, no-wrap
msgid "iteration limiting and heuristics"
msgstr "Ограничение количества итераций и эвристика"

#. type: Plain text
#: manual/commands/options.txt:91
#, no-wrap
msgid ""
"^key           ^default  ^description  ^\n"
"|itl1          |100      |DC iteration limit.  Sets the maximum number of iterations in a DC, OP, or initial transient analysis allowed before stopping and reporting that it did not converge.  |\n"
"|itl2          |50       |DC transfer curve iteration limit.  SPICE option accepted but not implemented. Use itl1 instead.  |\n"
"|itl3          |6        |Lower transient iteration limit.  If the number of iterations is more than itl3 the step size is limited by trstephold. Otherwise, it can grow by trstepgrow.  |\n"
"|itl4          |20       |Upper transient iteration limit.  Sets the maximum number of iterations on a step in transient analysis. If the circuit fails to converge in this many iterations the step size is reduced (by option trstepshrink), time is backed up, and the calculation is repeated.  |\n"
"|itl5          |0        |Transient analysis total iteration limit.  SPICE option accepted but not implemented. Actual behavior is the same as itl5 = 0, in SPICE, which omits this test.  |\n"
"|itl6          |5000     |Homotopy iteration limit.  Sets the maximum number of iterations to allow for homotopy methods of recovering from a convergence failure.  Setting itl6 to 0 disables homotopy.  |\n"
"|itl7          |1        |Worst case analysis iteration limit.  Sets the maximum number of iterations for the individual element trials in a DC or bias worst case analysis. If more iterations than this are necessary, the program silently goes on to the next step, as if nothing was wrong, which is usually the case.  |\n"
"|itl8          |99       |Convergence diagnostic iteration threshold.  If the iteration count on a step exceeds itl8 diagnostic messages are printed in an attempt to aid the user in solving the convergence problem.  |\n"
"|itermin       |1        |Number of extra iterations after convergence.  After convergence tolerances are met, do itermin extra iterations to be sure. This provides protection against false indication of convergence. Setting itermin = 0 is equivalent to SPICE, with improved simulation speed.  |\n"
"|vmin          |-5.      |Initial negative node voltage limit.  All node voltages may be limited to −x to aid in convergence and prevent numeric overflow. This is intended as a convergence aid only. It may or may not help. This number is used as a starting point. It is adjusted as the simulation progresses.  |\n"
"|vmax          |5.       |Initial positive node voltage limit.  All node voltages may be limited to +x to aid in convergence and prevent numeric overflow. This is intended as a convergence aid only. It may or may not help. This number is used as a starting point. It is adjusted as the simulation progresses.  |\n"
"|dampmax       |1.       |Normal Newton damping factor.  Sets the damping factor for iteration by damped Newton's method, used when all is well. It must be between 0 and 1, as close to 1 as possible and still achieve convergence. The useful range is from .9 to 1. Setting dampmax too low will probably cause convergence to a nonsense result.  |\n"
"|dampmin       |0.5      |Newton damping factor in problem cases.  Sets the damping factor for iteration by damped Newton's method, used when there are problems. It must be between 0 and 1, and is usually set somewhat less than dampmax. The useful range is from .5 to .9. Setting it lower than .5 may cause convergence to a nonsense result. Aside from that, a lower value (but less than dampmax) tends to improve robustness at the expense of convergence speed.  |\n"
"|dampstrategy  |0        |Damping strategy.  The actual damping factor to use is determined by heuristics. Normally the damping factor is dampmax. It is reduced to dampmin when certain conditions occur, then it drifts back up on subsequent iterations.  The strategy used is determined by the sum of the following factors:\\\\  1: initial step: Use dampmin on the second iteration.\\\\  2: range:  Use dampmin if an iteration voltage would be out of range (vmin, vmax).\\\\  4: device limiting:  Use dampmin when device based voltage or current limiting limits.  (If supported by the device.)\\\\  10: device region:  Use dampmin when a device passes a region boundary (If supported by the device.)\\\\  20:  device reverse:  Use dampmin when a device is reversed.  (If supported by the device.)  |\n"
msgstr ""
"^ Ключ           ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''itl1''          |  **''100''**      |Количество итераций для расчёта статического режима.  Задаёт максимально допустимое число итераций в [[dc.ru|dc]], [[op.ru|op]] или первоначальном [[transient.ru|временном анализе]] до остановки и вывода сообщения об отсутствии сходимости  |\n"
"| ''itl2''          |  **''50''**       |Ограничение на количество итераций при расчёте статической амплитудной передаточной характеристики («DC transfer curve»).  Опция SPICE, принимаемая, но не реализованная. Используйте вместо неё ''itl1''.  |\n"
"| ''itl3''          |  **''6''**        |Нижний предел итераций [[transient.ru|временного анализа]].  Если число итераций больше, чем ''itl3'', размер шага ограничивается параметром ''trstephold''. В противном случае он может расти в соответствии с параметром ''trstepgrow''.  |\n"
"| ''itl4''          |  **''20''**       |Верхний предел итераций [[transient.ru|временного анализа]].  Задаёт максимальное число итераций на шаг во временном анализе. Если за это количество итераций сходимость для схемы не достигается, размер шага уменьшается (в количество раз, равное опции ''trstepshrink''), точка времени возвращается и расчёт повторяется заново.  |\n"
"| ''itl5''          |  **''0''**        |Общий предел итераций временного анализа. Опция SPICE, принимаемая, но не реализованная. Фактическое поведение такое же, как при задании ''itl5'' = 0 в SPICE, что означает пропуск этого теста.  |\n"
"| ''itl6''          |  **''5000''**     |Предел итераций гомотопии. Задаёт максимальное число итераций, чтобы дать возможность исправить отсутствие сходимости с помощью методов гомотопии. Установка ''itl6'' равным 0 отключает гомотопию.  |\n"
"| ''itl7''          |  **''1''**        |Предел итераций для анализа наихудшего варианта. Задаёт максимальное число итераций для испытаний отдельного элемента в анализе наихудшего варианта для статического режима или для смещения. Если необходимо больше итераций, чем это число, программа молча переходит к следующему шагу, как будто никакой ошибки нет, что обычно так и есть.  |\n"
"| ''itl8''          |  **''99''**       |Порог итераций диагностики сходимости.  Если количество итераций для одного шага превышает ''itl8'', выводятся диагностические сообщения, чтобы помочь пользователю решить проблемы со сходимостью.  |\n"
"| ''itermin''       |  **''1''**        |Количество дополнительных итераций после достижения сходимости. После того как допуски сходимости удовлетворены, сделать для надёжности ''itermin'' дополнительных итераций. Это даёт защиту от ложного определения сходимости. При задании ''itermin'' = 0 программа работает эквивалентно SPICE, но скорость моделирования выше.  |\n"
"| ''vmin''          |  **''-5.''**      |Начальное ограничение напряжения отрицательного узла. Напряжения всех узлов могут быть ограничены в −x для улучшения сходимости и предотвращения числового переполнения. Данный параметр предусмотрен только для улучшения сходимости. Это может помочь, а может и нет. Это число используется как начальная точка. В процессе моделирования оно корректируется.  |\n"
"| ''vmax''          |  **''5.''**       |Начальное ограничение напряжения положительного узла. Напряжения всех узлов могут быть ограничены значением +x для улучшения сходимости и предотвращения числового переполнения. Данный параметр предусмотрен только для улучшения сходимости. Это может помочь, а может и нет. Это число используется как начальная точка. В процессе моделирования оно корректируется. |\n"
"| ''dampmax''       |  **''1.''**       |Коэффициент затухания Ньютона для обычной работы. Задаёт коэффициент затухания для итераций по методу Ньютона с ограничением на длину шага («damped Newton»), используемый, когда всё идёт хорошо. Он должен быть между 0 и 1, как можно ближе к 1, и при этом всё же должна достигаться сходимость. Полезный диапазон составляет от .9 до 1. Установка ''dampmax'' в слишком низкое значение может привести к сходимости с неадекватным результатом.  |\n"
"| ''dampmin''       |  **''0.5''**      |Коэффициент затухания Ньютона для проблемных случаев. Устанавливает коэффициент затухания для итераций по методу Ньютона с ограничением на длину шага («damped Newton»), используемый при наличии проблем. Он должен быть в диапазоне от 0 до 1, и обычно устанавливается несколько меньше, чем ''dampmax''. Подходящий диапазон от .5 до .9. Установка его в значение меньше 0.5 может привести к сходимости с неадекватным результатом. Помимо этого, использование более низкого значения (но меньшего ''dampmax'') обычно ведёт к улучшению ошибкоустойчивости за счёт скорости сходимости.  |\n"
"| ''dampstrategy''  |  **''0''**        |Стратегия затухания.  Фактический коэффициент затухания, который должен использоваться, определяется эвристически. Обычно в качестве значения коэффициента затухания используется ''dampmax''. При наступлении определённых условий это значение уменьшается до ''dampmin'', затем оно медленно меняется в обратную сторону на последующих операциях.  Используемая стратегия определяется суммой следующих факторов:\\\\  1: начальный шаг: использовать ''dampmin'' на второй итерации.\\\\  2: диапазон:  использовать ''dampmin'', если какое-нибудь напряжение в итерации будет вне диапазона (''vmin'', ''vmax'').\\\\  4: ограничение устройством:  использовать ''dampmin'', когда срабатывает ограничение на напряжение или ток модели устройства (если поддерживается этим устройством).\\\\  10: диапазон устройства:  использовать ''dampmin'', когда устройство пересекает границы диапазона (если поддерживается этим устройством).\\\\  20:  реверс устройства:  использовать ''dampmin'' при реверсе устройства (если поддерживается этим устройством).  |\n"

#. type: Title ====
#: manual/commands/options.txt:93
#, no-wrap
msgid "time step control"
msgstr "Управление шагом времени"

#. type: Plain text
#: manual/commands/options.txt:105
#, no-wrap
msgid ""
"^key           ^default     ^description  ^\n"
"|dtmin         |1.p         |Minimum time step.  The smallest internal time step in transient analysis. The transient command dtmin option and the dtratio option override it if it is bigger.  |\n"
"|dtratio       |1.G         |The ratio between minimum and maximum time step.  |\n"
"|trstepgrow    |1.E+99      |The maximum internal step size growth in transient analysis. Default = 1e99, which allows arbitrary changes in step size.  |\n"
"|trstephold    |1.E+99      |The maximum internal step size growth in transient analysis, when the iteration count exceeds itl3 but still converges.   |\n"
"|trstepshrink  |2.          |The amount to decrease the transient step size by when convergence fails.  |\n"
"|trreject      |0.5         |Transient error rejection threshold.  Controls how bad the truncation error must be to reject a time step. A value of .5 means that if the step reqested is smaller than .5 times the step size used, the current step will be rejected. If the new step is .8 times the old step size it will be adjusted but the step just calculated will not be rejected.  |\n"
"|trsteporder   |3           |Control time steps according to \"trsteporder\" order interpolation.  Supported values are 1, 2, 3.  |\n"
"|trstepcoef1   |0.25        |Coefficient used in order 1 step control  |\n"
"|trstepcoef2   |0.04166667  |Coefficient used in order 2 step control  |\n"
"|trstepcoef3   |0.00520833  |Coefficient used in order 3 step control  |\n"
msgstr ""
"^ Ключ           ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''dtmin''         |  **''1.p''**         |Минимальный шаг времени. Наименьший внутренний шаг времени во временном анализе. Опция ''dtmin'' команды [[transient.ru|transient]] и опция ''dtratio'' имеют преимущество над ней, если её значение больше.  |\n"
"| ''dtratio''       |  **''1.G''**         |Отношение между минимальным и максимальным шагами времени.  |\n"
"| ''trstepgrow''    |  **''1.E+99''**      |Максимальное увеличение размера внутреннего шага во временном анализе. По умолчанию принимает значение 1e99, позволяющее менять размер шага произвольным образом.  |\n"
"| ''trstephold''    |  **''1.E+99''**      |Максимальное увеличение размера внутреннего шага во временном анализе, когда количество итераций превышает ''itl3'', но сходимость ещё достигается.   |\n"
"| ''trstepshrink''  |  **''2.''**          |Количество раз, в которое уменьшается размер шага временного анализа при отсутствии сходимости.  |\n"
"| ''trreject''      |  **''0.5''**         |Порог отклонения ошибки временного анализа. Управляет тем, насколько велика должна быть погрешность численного метода («truncation error»), чтобы отклонить какой-либо шаг времени. Значение .5 означает, что если запрошенный шаг меньше, чем .5 от используемого размера шага, текущий шаг будет отклонён. Если новый шаг составляет .8 от старого размера шага, он будет подкорректирован, но шаг, рассчитанный только что, отклонён не будет.  |\n"
"| ''trsteporder''   |  **''3''**           |Управление шагом времени в соответствии с указанной степенью интерполяции.  Поддерживаются значения 1, 2, 3.  |\n"
"| ''trstepcoef1''   |  **''0.25''**        |Коэффициент, используемый при управлении шагом в степени 1  |\n"
"| ''trstepcoef2''   |  **''0.04166667''**  |Коэффициент, используемый при управлении шагом в степени 2  |\n"
"| ''trstepcoef3''   |  **''0.00520833''**  |Коэффициент, используемый при управлении шагом в степени 3  |\n"

#. type: Title ====
#: manual/commands/options.txt:106
#, no-wrap
msgid "circuit environment"
msgstr "Окружение схемы"

#. type: Plain text
#: manual/commands/options.txt:115
#, no-wrap
msgid ""
"^key          ^default  ^description  ^\n"
"|tnom         |27.      |Nominal temperature, Celsius.  All components have their nominal value at this temperature.  |\n"
"|temperature  |27.      |Simulation temperature.  Sets the ambient temperature, in degrees Celsius. This is the temperature at which the simulation takes place, unless changed by some other command.  |\n"
"|rstray       |true     |Include series resistance in device models. This creates internal nodes and results in a significant speed and memory penalty. It also makes convergence characteristics worse.  |\n"
"|cstray       |true     |Include capacitance in device models. This may create internal nodes and result in a significant speed and memory penalty. It also may make convergence characteristics worse.  |\n"
"|defl         |100.u    |MOSFET default channel length in meters.  |\n"
"|defw         |100.u    |MOSFET default channel width in meters.  |\n"
"|defad        |0.       |MOSFET default drain diffusion area in square meters.  |\n"
"|defas        |0.       |MOSFET default source diffusion area in square meters.  |\n"
msgstr ""
"^ Ключ             ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"| ''tnom''         |  **''27.''**      |Номинальная температура, в градусах Цельсия.  При этой температуре все компоненты имеют свои номинальные значения.  |\n"
"| ''temperature''  |  **''27.''**      |Температура моделирования. Задаёт температуру окружающей среды в градусах Цельсия. Это та температура, при которой производится моделирование, если только это значение не было изменено какой-нибудь другой командой.  |\n"
"| ''rstray''       |  **''true''**     |Подключать последовательные сопротивления в моделях устройств. Это приводит к созданию внутренних узлов и влечёт за собой существенные потери в скорости и памяти. Кроме того, характеристики сходимости становятся хуже.  |\n"
"| ''cstray''       |  **''true''**     |Подключать ёмкости в моделях устройств. Это может привести к созданию внутренних узлов и влечёт за собой существенные потери в скорости и памяти. Кроме того, характеристики сходимости становятся хуже.  |\n"
"| ''defl''         |  **''100.u''**    |Значение по умолчанию длины канала MOSFET в метрах.  |\n"
"| ''defw''         |  **''100.u''**    |Значение по умолчанию ширины канала MOSFET в метрах.  |\n"
"| ''defad''        |  **''0.''**       |Значение по умолчанию области диффузии стока MOSFET в квадратных метрах.  |\n"
"| ''defas''        |  **''0.''**       |Значение по умолчанию области диффузии истока MOSFET в квадратных метрах.  |\n"

#. type: Title ======
#: manual/commands/outfile.txt:1
#, no-wrap
msgid "\">\" command"
msgstr "Команда «>»"

#. type: Plain text
#: manual/commands/outfile.txt:6
msgid "Saves a copy of all program output (except help) in a file."
msgstr ""
"Сохранение копии всего вывода программы (за исключением справки) в файл."

#. type: Plain text
#: manual/commands/outfile.txt:12
#, no-wrap
msgid ""
"  > file\n"
"  >> file\n"
"  >\n"
msgstr ""
"|''**>**      //файл//''|\n"
"|''**%%>>%%** //файл//''|\n"
"|''**>**              ''|\n"

#. type: Plain text
#: manual/commands/outfile.txt:16
msgid ""
"''>'' creates a new file for this output. If the file already exists, the "
"old one is lost, and replaced by the new one."
msgstr ""
"Командой **>** создаётся новый файл для вывода данных. Если такой файл уже "
"существует, старый файл с тем же именем будет утрачен и заменён новым."

#. type: Plain text
#: manual/commands/outfile.txt:18
msgid ""
"''>''''>'' appends to an existing file, if it exists, otherwise it creates "
"one."
msgstr ""
"По команде **%%>>%%**, если указанный файл уже существует, данные будут "
"добавляться в него, иначе будет создан новый файл."

#. type: Plain text
#: manual/commands/outfile.txt:20
msgid "A bare ''>'' closes the file."
msgstr ""
"Команда **>** без параметров приводит к закрытию ранее открытого файла."

#. type: Plain text
#: manual/commands/outfile.txt:28
#, no-wrap
msgid ""
"  > run1\n"
"Save everything in a file run1 in the current directory. If run1 already exists, the old one is gone.\n"
"  >> allof\n"
"Save everything in a file allof. If allof already exists, it is kept, and the new data is added to the end.\n"
"  >\n"
"Close the file. Stop saving.\n"
msgstr ""
"  > run1\n"
"Сохранять весь вывод в файл ''run1'' в текущем каталоге. Если ''run1'' уже существует, старый файл уничтожается.\n"
"  >> allof\n"
"Сохранять весь вывод в файл ''allof''. Если ''allof'' уже существует, он сохраняется, а новые данные добавляются в его конец.\n"
"  >\n"
"Закрыть файл. Прекратить сохранение.\n"

#. type: Title ====
#: manual/commands/parameter.txt:1
#: manual/tech/plugins/parameter_functions_and_measurements.txt:17
#, no-wrap
msgid "\"parameter\" command"
msgstr "Команда «parameter»"

#. type: Plain text
#: manual/commands/parameter.txt:6
msgid "Set and view parameters."
msgstr "Установка и просмотр параметров."

#. type: Plain text
#: manual/commands/parameter.txt:13
#, no-wrap
msgid ""
"  param\n"
"  parameter\n"
"  param param-name value ...\n"
"  parameter param-name value ...\n"
msgstr ""
"|''**param**                                   ''|\n"
"|''**parameter**                               ''|\n"
"|''**param** //имя_параметра значение ...//    ''|\n"
"|''**parameter** //имя_параметра значение ...//''|\n"

#. type: Plain text
#: manual/commands/parameter.txt:17
msgid "The bare command param lists all defined parameters and their values."
msgstr ""
"Команда **''param''** без указания параметров выводит все определённые "
"параметры и их значения."

#. type: Plain text
#: manual/commands/parameter.txt:19
msgid ""
"The value may be a number, the name of another parameter, or an expression. "
"If it is another parameter, eventually it must resolve to a number. This "
"depth can be set by the option recursion which has a default value of 20. "
"The depth is limited to prevent infinite recursion."
msgstr ""
"Значение может быть числом, именем другого параметра или [[gnucap:manual:"
"howto:expressions.ru|выражением]]. Если это другой параметр, то в конце "
"концов он должен разрешиться как число.  Глубина разрешения может быть "
"установлена [[options.ru|опцией]] ''recursion'', значение которой по "
"умолчанию равно 20. Эта глубина ограничена для предотвращения бесконечной "
"рекурсии."

#. type: Plain text
#: manual/commands/parameter.txt:21
msgid ""
"All component values, numeric lists such as in PWL, component and model "
"parameters can be numbers or expressions.  Numeric arguments to most "
"commands can also be parameters or expressions."
msgstr ""
"Все значения компонентов, списки чисел, такие как [[gnucap:manual:devices:"
"basic:fit.ru|PWL]], параметры компонентов и моделей могут быть числами либо "
"выражениями. Числовые аргументы большинства команд также могут быть "
"параметрами или выражениями."

#. type: Plain text
#: manual/commands/parameter.txt:23
msgid ""
"If the same parameter is set more than once, the most recent one prevails. "
"All instances of the parameter will take the new value."
msgstr ""
"Если один и тот же параметр устанавливается более чем однажды, приоритет "
"будет иметь самое последнее действие. Все экземпляры этого параметра примут "
"новое значение."

#. type: Plain text
#: manual/commands/parameter.txt:25
msgid ""
"When a parameter name is used as a value, it may be enclosed by quotes or "
"curly braces."
msgstr ""
"Когда имя параметра используется как значение, оно может заключаться в "
"кавычки или фигурные скобки."

#. type: Plain text
#: manual/commands/parameter.txt:27
msgid ""
"Parameter expressions use late evaluation and dynamic scoping, like a "
"functional language."
msgstr ""
"В выражениях с параметрами используются отложенные вычисления и динамический "
"контекст, как и в функциональных языках программирования."

#. type: Plain text
#: manual/commands/parameter.txt:29
msgid ""
"For more information on parameter expressions, look [[gnucap:manual:howto:"
"expressions|here]]."
msgstr ""
"Более подробную информацию о выражениях параметров см. [[gnucap:manual:howto:"
"expressions.ru|здесь]]."

#. type: Plain text
#: manual/commands/parameter.txt:68
#, no-wrap
msgid ""
"Suppose we have this circuit:\n"
"  .model small npn (bf=beta)\n"
"  Vpower (vcc 0) dc vcc\n"
"  Vin    (in  0) generator\n"
"  Q1 (c b e) small\n"
"  Rc (vcc c) rc\n"
"  Re (e 0) re\n"
"  Rb1 (vcc b) rb1\n"
"  Rb2 (b 0)   rb2\n"
"If I try to simulate it now, it will not be very useful. We need to give our circuit some values:\n"
"  gnucap> param vcc=10 beta=100 rc=10k re=1k rb1=100k rb2=rc\n"
"Let's see what it does:\n"
"  gnucap> print op v(nodes)\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.8941   8.3513   0.16652  0.       10.\n"
"What happens if I change beta?\n"
"  gnucap> param beta=200\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.90128  8.2822   0.17264  0.       10.\n"
"Not much changes. Let's try to lower v(''''c). About 6 should be better.\n"
"  gnucap> param rb1=68k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.2602   4.9866   0.50385  0.       10.\n"
"Too low, try again:\n"
"  gnucap> param rb1=82k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.0724   6.7437   0.32726  0.       10.\n"
"Too high...\n"
"  gnucap> param rb1=75k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.1586   5.9433   0.4077   0.       10.\n"
"Close enough.\n"
msgstr ""
"Предположим у нас есть такая схема:\n"
"  .model small npn (bf=beta)\n"
"  Vpower (vcc 0) dc vcc\n"
"  Vin    (in  0) generator\n"
"  Q1 (c b e) small\n"
"  Rc (vcc c) rc\n"
"  Re (e 0) re\n"
"  Rb1 (vcc b) rb1\n"
"  Rb2 (b 0)   rb2\n"
"Если попробовать её сейчас промоделировать, много пользы от этого не будет.\n"
"Нужно задать для неё несколько значений:\n"
"  gnucap> param vcc=10 beta=100 rc=10k re=1k rb1=100k rb2=rc\n"
"Посмотрим, что она делает:\n"
"  gnucap> print op v(nodes)\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.8941   8.3513   0.16652  0.       10.\n"
"Что будет, если поменять ''beta''?\n"
"  gnucap> param beta=200\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      0.90128  8.2822   0.17264  0.       10.\n"
"Ничего особо не изменилось. Давайте попробуем уменьшить v(''''c).\n"
"Значение около 6 должно быть получше.\n"
"  gnucap> param rb1=68k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.2602   4.9866   0.50385  0.       10.\n"
"Слишком мало, пробуем ещё раз:\n"
"  gnucap> param rb1=82k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.0724   6.7437   0.32726  0.       10.\n"
"Слишком много...\n"
"  gnucap> param rb1=75k\n"
"  gnucap> op\n"
"  #         v(b)     v(c)     v(e)     v(in)    v(vcc)\n"
"   27.      1.1586   5.9433   0.4077   0.       10.\n"
"Довольно близко.\n"

#. type: Title ======
#: manual/commands/pause.txt:1
#, no-wrap
msgid "\"pause\" command"
msgstr "Команда «pause»"

#. type: Plain text
#: manual/commands/pause.txt:6
msgid "Suspend batch mode. Wait for the user to hit a key."
msgstr ""
"Приостановка работы в пакетном режиме. Ожидание нажатия клавиши "
"пользователем."

#. type: Plain text
#: manual/commands/pause.txt:10
#, no-wrap
msgid "  pause comment\n"
msgstr "|''**pause** //комментарий//''|\n"

#. type: Title ======
#: manual/commands/pause.txt:11 manual/commands/plot.txt:14
#: manual/languages/spectre.txt:120 manual/languages/verilog.txt:132
#: spectre.txt:92
#, no-wrap
msgid "Status"
msgstr "Состояние"

#. type: Plain text
#: manual/commands/pause.txt:14
msgid ""
"This command does not work on all systems, due to buffering of console i/o."
msgstr ""
"Данная команда работает не на всех системах из-за буферизации консольного "
"ввода/вывода."

#. type: Plain text
#: manual/commands/pause.txt:18
msgid ""
"Prints Continue? and waits for a key hit. Type `n', `N', escape or control-c "
"to terminate the batch mode. Type anything else to continue."
msgstr ""
"Выводит ''Continue?'' и ожидает следующего нажатия клавиши. Для выхода из "
"пакетного режима следует нажать <key>n</key>, <key>S-N</key>, <key>escape</"
"key> или <key>control-c</key>. Нажатие других клавиш ведёт к продолжению "
"работы."

#. type: Plain text
#: manual/commands/pause.txt:20
msgid "Any comment is ignored."
msgstr "Любые комментарии игнорируются."

#. type: Plain text
#: manual/commands/pause.txt:25
#, no-wrap
msgid ""
"  pause Try more gain\n"
"  pause\n"
"These both work the same. Ask to continue, wait for a key hit, then go on.\n"
msgstr ""
"  pause Пробуем больший коэффициент усиления\n"
"  pause\n"
"Обе эти команды работают одинаково. Запрашивается продолжение,\n"
"ожидается нажатие клавиши, затем работа продолжается.\n"

#. type: Title ======
#: manual/commands/plot.txt:1
#, no-wrap
msgid "\"plot\" command"
msgstr "Команда «plot»"

#. type: Plain text
#: manual/commands/plot.txt:6
msgid "Select points in the circuit for graphic output. Select graphic output."
msgstr "Выбор точек схемы для графического вывода. Выбор графического вывода."

#. type: Plain text
#: manual/commands/plot.txt:13
#, no-wrap
msgid ""
"  plot\n"
"  plot mode points ... ...\n"
"  plot mode + points ... ...\n"
"  plot mode - points ... ...\n"
"  plot mode CLEAR\n"
msgstr ""
"|''**plot**                              ''|\n"
"|''**plot** //режим точки       ... ...//''|\n"
"|''**plot** //режим// + //точки ... ...//''|\n"
"|''**plot** //режим// - //точки ... ...//''|\n"
"|''**plot** //режим// clear              ''|\n"

#. type: Plain text
#: manual/commands/plot.txt:17
msgid ""
"The plotting leaves something to be desired. Only two signals can be plotted "
"at a time. The output file is corrupt when plotting is on."
msgstr ""
"Вывод графиков оставляет желать лучшего. За раз можно вывести только два "
"сигнала. При включенном построении графиков искажается [[outfile.ru|выходной "
"файл]]."

#. type: Plain text
#: manual/commands/plot.txt:21
msgid ""
"The `plot' command selects where to look at the circuit, or where to hook "
"the oscilloscope probe."
msgstr ""
"Командой **plot** выбирается, что смотреть в схеме, или куда подцепить щуп "
"осциллографа."

#. type: Plain text
#: manual/commands/plot.txt:25
msgid "To list the probe points, use the bare command `plot'."
msgstr ""
"Для вывода перечня датчиков используйте команду **''plot''** без параметров."

#. type: Plain text
#: manual/commands/plot.txt:36
msgid ""
"You must set the scaling. If you do not, the default range is fixed at -5 to "
"5. Gnucap cannot auto-scale because it generates the plot during simulation, "
"so the necessary information is not available yet. Spice can auto-scale only "
"because it waits for the simulation to complete before producing any output."
msgstr ""
"Вы должны настроить масштабирование. Если этого не сделать, по умолчанию "
"будет использоваться фиксированный диапазон от -5 до 5. gnucap не может "
"подобрать масштаб автоматически, потому что график генерируется после "
"моделирования, и необходимая информация ещё не доступна. SPICE может "
"производить автоматическое масштабирование, потому что эта программа ждёт "
"завершения моделирование, прежде чем выводить любые выходные данные."

#. type: Plain text
#: manual/commands/plot.txt:38
msgid ""
"Plot uses the same variables as print. See the print command for a list of "
"what is available."
msgstr ""
"Для **plot** используются те же самые переменные, что и для **print**. "
"Список того, что можно использовать, см. в [[print.ru|описании команды "
"print]]."

#. type: Plain text
#: manual/commands/plot.txt:40 manual/commands/print.txt:30
msgid ""
"The options plot and noplot on any analysis command turn plotting on and off "
"a single run. The plot command turns plotting on and tabular output off. The "
"print command turns plotting off and tabular output on."
msgstr ""
"Указание в строке команды любого анализа опции ''plot'' или ''noplot'' "
"позволяет включить или отключить вывод графиков на один запуск. Команда "
"[[plot.ru|plot]] включает вывод графиков и отключает табличный вывод данных. "
"Команда [[print.ru|print]] отключает вывод графиков и включает табличный "
"вывод данных."

#. type: Plain text
#: manual/commands/plot.txt:42
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"plot ac + v(3) adds v(3) to the existing set of AC probes. plot ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами «''+''» или «''-''», их можно добавлять в "
"существующий список или удалять из него. **''plot ac + v(3)''** добавит ''v"
"(3)'' в существующий набор датчиков анализа [[ac.ru|ac]]. **''plot ac - q"
"(c5)''** удалит ''q(c5)'' из списка. При удалении можно использовать "
"метасимволы «''*''» и «''?''»."

#. type: Plain text
#: manual/commands/plot.txt:44
msgid "Plotting is limited to 2 items."
msgstr "Вывод графиков ограничен двумя элементами данных."

#. type: Plain text
#: manual/commands/plot.txt:58
#, no-wrap
msgid ""
"  plot ac vm(12)(0,5) vm(13)(-5,5)\n"
"The magnitude of the voltage at node 12 with a range of 0 to 5, and node 13 with a range of -5 to 5 for AC analysis.\n"
"  plot dc v(r26)\n"
"The voltage across R26 for DC analysis. Since there is no range, default values will be used.\n"
"  plot tran v(r83)(0,5) p(r83)(0,1u)\n"
"Plot the voltage and power of R83 in the next transient analysis. The voltage scale is 0 to 5. The power scale is 0 to 1 microwatt.\n"
"  plot\n"
"List all the probes for all modes.\n"
"  plot dc\n"
"Display the DC plot list.\n"
"  plot ac clear\n"
"Clear the AC list.\n"
msgstr ""
"  plot ac vm(12)(0,5) vm(13)(-5,5)\n"
"Величина напряжения на узле 12 в диапазоне от 0 до 5, и на узле 13 в диапазоне от -5 до 5 для [[ac.ru|частотного анализа]].\n"
"  plot dc v(r26)\n"
"Напряжение на R26 для [[DC.ru|расчёта статического режима по постоянному току]]. Так как диапазон не указан, будут использоваться значения по умолчанию.\n"
"  plot tran v(r83)(0,5) p(r83)(0,1u)\n"
"Вывести график напряжения и мощности для R83 в следующем [[transient.ru|временном анализе]]. Масштаб напряжения от 0 до 5. Масштаб мощности от 0 до 1 микроватта.\n"
"  plot\n"
"Вывести перечень всех датчиков для всех режимов.\n"
"  plot dc\n"
"Показать список графиков для анализа [[dc.ru|статического режима]].\n"
"  plot ac clear\n"
"Очистить список для [[ac.ru|частотного анализа]].\n"

#. type: Title ======
#: manual/commands/print.txt:1
#, no-wrap
msgid "\"print\" command"
msgstr "Команда «print»"

#. type: Plain text
#: manual/commands/print.txt:6
msgid "Select points in the circuit for tabular output. Select tabular output."
msgstr ""
"Выбор точек в схеме для табличного вывода данных. Выбор табличного вывода "
"данных."

#. type: Plain text
#: manual/commands/print.txt:14
#, no-wrap
msgid ""
"  print\n"
"  print mode points ... ...\n"
"  print mode + points ... ...\n"
"  print mode - points ... ...\n"
"  print mode CLEAR\n"
msgstr ""
"|''**print**                              ''|\n"
"|''**print** //режим точки       ... ...//''|\n"
"|''**print** //режим// + //точки ... ...//''|\n"
"|''**print** //режим// - //точки ... ...//''|\n"
"|''**print** //режим// clear              ''|\n"

#. type: Plain text
#: manual/commands/print.txt:18
msgid ""
"The `print' command selects where to look at the circuit, or where to hook "
"the voltmeter (ammeter, watt meter, ohm meter, etc.) probe."
msgstr ""
"Командой **print** выбирается, что смотреть в схеме или куда подцепить щуп "
"вольтметра (амперметра, ваттметра, омметра и т. д.)."

#. type: Plain text
#: manual/commands/print.txt:22
msgid "To list the probe points, use the bare command `print'."
msgstr ""
"Для вывода перечня датчиков используйте команду **''print''** без параметров."

#. type: Plain text
#: manual/commands/print.txt:24
msgid ""
"On start-up, probes are not set. You must do the command `print op v(nodes)' "
"or put `.print op v(nodes)' in the circuit file to get any output from the "
"op command."
msgstr ""
"При запуске программы датчики не заданы. Для получения какого-нибудь вывода "
"команды [[op.ru|op]] необходимо задать команду **''print op v(nodes)''** или "
"добавить ''.print op v(nodes)'' в файл схемы."

#. type: Plain text
#: manual/commands/print.txt:26
msgid ""
"Syntax for each point is parameter(node), parameter(componentlabel), or "
"parameter(index). Some require a dummy index."
msgstr ""
"Синтаксис для каждой точки это ''параметр(узел)'', ''параметр"
"(обозначение_компонента)'', или ''параметр(индекс)''. Для некоторых "
"параметров требуется фиктивный индекс."

#. type: Plain text
#: manual/commands/print.txt:28
msgid ""
"If the component does not exist, you will get an error message. If the "
"component exists but the parameter is not valid for that type, there will be "
"no error message but the value printed will be obviously bogus."
msgstr ""
"Если указанный компонент не существует, вы получите сообщение об ошибке. "
"Если компонент существует, но параметр недопустим для данного типа, "
"сообщения об ошибке не будет, но выведенное значение будет, очевидно, "
"фиктивным."

#. type: Plain text
#: manual/commands/print.txt:32
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"print ac + v(3) adds v(3) to the existing set of AC probes. print ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами «''+''» или «''-''», их можно добавлять в "
"существующий список или удалять из него. **''print ac + v(3)''** добавит ''v"
"(3)'' в существующий набор датчиков анализа [[ac.ru|ac]]. **''print ac - q"
"(c5)''** удалит ''q(c5)'' из списка. При удалении можно использовать "
"метасимволы «''*''» и «''?''»."

#. type: Plain text
#: manual/commands/print.txt:50
#, no-wrap
msgid ""
"  print ac v(12) v(13) v(14)\n"
"The voltage at nodes 12, 13, and 14 for AC analysis.\n"
"  print dc v(r26)\n"
"The voltage across R26, for DC analysis.\n"
"  print tran v(r83) p(r83)\n"
"Voltage and power of R83, for transient analysis.\n"
"  print dc i(c8) p(r5) z(r5)\n"
"The current through C8, power dissipated in R5, and the impedance seen looking into the circuit across R5.\n"
"  print op v(nodes)\n"
"The voltage at all nodes for the op command.\n"
"  print\n"
"List all the probes, for all modes.\n"
"  print op\n"
"Display the OP probe list.\n"
"  print ac clear\n"
"Clear the AC list.\n"
msgstr ""
"  print ac v(12) v(13) v(14)\n"
"Напряжения узлов 12, 13 и 14 для [[ac.ru|частотного анализа]].\n"
"  print dc v(r26)\n"
"Напряжение на R26 для [[dc.ru|анализа статического режима по постоянному току]].\n"
"  print tran v(r83) p(r83)\n"
"Напряжение и мощность для R83 для [[transient.ru|временного анализа]].\n"
"  print dc i(c8) p(r5) z(r5)\n"
"Ток через C8, мощность, рассеиваемая на R5, и импеданс, наблюдаемый при исследовании схемы на выводах R5.\n"
"  print op v(nodes)\n"
"Напряжения всех узлов для команды [[op.ru|op]].\n"
"  print\n"
"Вывести список всех датчиков для всех режимов.\n"
"  print op\n"
"Показать список датчиков для [[op.ru|op]].\n"
"  print ac clear\n"
"Очистить список для [[ac.ru|ac]].\n"

#. type: Title ======
#: manual/commands/save.txt:1
#, no-wrap
msgid "\"save\" command"
msgstr "Команда «save»"

#. type: Plain text
#: manual/commands/save.txt:6
msgid "Saves the circuit to a file."
msgstr "Сохранение схемы в файл."

#. type: Plain text
#: manual/commands/save.txt:10
#, no-wrap
msgid "  save filename {options ...}\n"
msgstr "|''**save** //имя_файла// {//опции ...//}''|\n"

#. type: Plain text
#: manual/commands/save.txt:14
msgid ""
"The file is in an ASCII format, so the list may be used as part of a report."
msgstr ""
"Файл выводится в формате ASCII, поэтому этот список может использоваться как "
"часть отчёта."

#. type: Plain text
#: manual/commands/save.txt:16
msgid ""
"The format used depends on the \"language\" option, which could use a plugin "
"to provide any format.  \"Spice\", \"Spectre\" and \"Verilog\" formats are "
"supported in the standard installation."
msgstr ""
"Формат списка соединений зависит от [[options.ru|опции]] ''language'', "
"вместе с которой можно было бы использовать плагины для реализации вывода в "
"любом формате. Форматы «[[gnucap:manual:languages:spice.ru|spice]]», "
"«[[gnucap:manual:languages:spectre.ru|spectre]]» и «[[gnucap:manual:"
"languages:verilog.ru|verilog]]» поддерживаются в стандартной установке."

#. type: Plain text
#: manual/commands/save.txt:18
msgid ""
"You can save a part of a circuit. See the list command for more details."
msgstr ""
"Имеется возможность сохранения части схемы. Подробности см. в [[list.ru|"
"описании команды list]]."

#. type: Plain text
#: manual/commands/save.txt:28
#, no-wrap
msgid ""
"  save works.ckt\n"
"Save the circuit in the file works.ckt, in the current directory.\n"
"  save\n"
"Save the circuit. Since you did not specify a file name, it will ask for one.\n"
"  save partof.ckt R*\n"
"Save a partial circuit, just the resistors, to the file partof.ckt. (See the List command.)\n"
"  save /client/sim/ckt/no33\n"
"You can specify a path name.\n"
msgstr ""
"  save works.ckt\n"
"Сохранить схему в файл ''works.ckt'' в текущем каталоге.\n"
"  save\n"
"Сохранить схему. Так как имя файла не указано, оно будет запрошено программой.\n"
"  save partof.ckt R*\n"
"Сохранить схему частично, а именно резисторы, в файл ''partof.ckt''. (См. [[List.ru|описание команды List]].)\n"
"  save /client/sim/ckt/no33\n"
"Можно указывать путь к файлу.\n"

#. type: Title ======
#: manual/commands/status.txt:1
#, no-wrap
msgid "\"status\" command"
msgstr "Команда «status»"

#. type: Plain text
#: manual/commands/status.txt:6
msgid "Shows information on how the system resources are being utilized."
msgstr "Отображение информации об использовании системных ресурсов."

#. type: Plain text
#: manual/commands/status.txt:11
#, no-wrap
msgid ""
"  status\n"
"  status notime\n"
msgstr ""
"|''**status**       ''|\n"
"|''**status** notime''|\n"

#. type: Plain text
#: manual/commands/status.txt:14
msgid "The notime option omits times but prints everything else."
msgstr "При задании с опцией ''notime'' выводится всё, кроме времени."

#. type: Title ======
#: manual/commands/store.txt:1
#, no-wrap
msgid "\"store\" command"
msgstr "Команда «store»"

#. type: Plain text
#: manual/commands/store.txt:6
msgid "Select points in the circuit to store for postprocessing."
msgstr ""
"Выбор точек схемы, данные которых должны сохраняться для дальнейшей "
"обработки."

#. type: Plain text
#: manual/commands/store.txt:14
#, no-wrap
msgid ""
"  store\n"
"  store mode points ... ...\n"
"  store mode + points ... ...\n"
"  store mode - points ... ...\n"
"  store mode CLEAR\n"
msgstr ""
"|''**store**                              ''|\n"
"|''**store** //режим точки       ... ...//''|\n"
"|''**store** //режим// + //точки ... ...//''|\n"
"|''**store** //режим// - //точки ... ...//''|\n"
"|''**store** //режим// clear              ''|\n"

#. type: Plain text
#: manual/commands/store.txt:18
msgid ""
"The \"store\" command selects probes to store for postprocessing, such as "
"measures."
msgstr ""
"Команда **store** служит для выбора [[..:howto:probes.ru|датчиков]], которые "
"следует сохранять для последующей обработки, такой как, например, [[measure."
"ru|измерения]]."

#. type: Plain text
#: manual/commands/store.txt:20
msgid "There are separate lists of points for each type of analysis."
msgstr "Для каждого вида анализа имеется отдельный список точек."

#. type: Plain text
#: manual/commands/store.txt:22
msgid "To list the points, use the bare command \"store\"."
msgstr ""
"Для вывода перечня точек используется команда **''store''** без параметров."

#. type: Plain text
#: manual/commands/store.txt:24
msgid ""
"On start-up, probes are not set. You must do the command \"store op v"
"(nodes)\", \"store tran v(nodes)\" or whatever you want, to store any data "
"for post-processing."
msgstr ""
"При запуске датчики не заданы. Для сохранения каких-либо данных для "
"последующей обработки необходимо выполнить команду **''store op v"
"(nodes)''**, **''store tran v(nodes)''** или какую-нибудь ещё."

#. type: Plain text
#: manual/commands/store.txt:26
msgid ""
"You can add to or delete from an existing list by prefixing with + or -. "
"store ac + v(3) adds v(3) to the existing set of AC probes. store ac - q(c5) "
"removes q(c5) from the list. You can use the wildcard characters * and ? "
"when deleting."
msgstr ""
"Указывая перед параметрами «''+''» или «''-''», их можно добавлять в "
"существующий список или удалять из него. **''store ac + v(3)''** добавит ''v"
"(3)'' в существующий набор датчиков анализа [[ac.ru|ac]]. **''store ac - q"
"(c5)''** удалит ''q(c5)'' из списка. При удалении можно использовать "
"метасимволы «''*''» и «''?''»."

#. type: Plain text
#: manual/commands/store.txt:40
#, no-wrap
msgid ""
"  store ac v(nodes)\n"
"The voltage at all nodes for AC analysis.\n"
"  store dc v(nodes) id(M*)\n"
"The voltage at all nodes and the parameter \"id\" on all devices witl labels starting with \"M\", for DC analysis.\n"
"  store tran v(*) p(*)\n"
"All parameters named \"v\", which probably means all node voltages and the most common voltage for all devices.  All parameters named \"p\", which is usually power.\n"
"  store\n"
"List all probes stored, for all modes.\n"
"  store op\n"
"Display the OP store list.\n"
"  store ac clear\n"
"Clear the AC list.\n"
msgstr ""
"  store ac v(nodes)\n"
"Напряжения всех узлов для [[ac.ru|частотного анализа]].\n"
"  store dc v(nodes) id(M*)\n"
"Напряжения всех узлов и параметр ''id'' всех устройств, обозначения которых начинаются на «M», для анализа [[dc.ru|dc]].\n"
"  store tran v(*) p(*)\n"
"Все параметры с названием «v», что, вероятно, подразумевает выбор напряжений всех узлов и наиболее общих напряжений всех устройств. Все параметры «p», обычно обозначающие мощность.\n"
"  store\n"
"Вывести список всех датчиков, сохранённых для всех режимов.\n"
"  store op\n"
"Отобразить список сохранённых точек для [[op.ru|op]].\n"
"  store ac clear\n"
"Очистить список для [[ac.ru|ac]].\n"

#. type: Title ======
#: manual/commands/sweep.txt:1
#, no-wrap
msgid "\"sweep\" command"
msgstr "Команда «sweep»"

#. type: Plain text
#: manual/commands/sweep.txt:6
msgid ""
"Sweep a component (or group of components) over a range. Set up a loop for "
"iteration."
msgstr ""
"Изменение значения компонента (или значений группы компонентов) в некотором "
"диапазоне. Настройка цикла для итерации."

#. type: Plain text
#: manual/commands/sweep.txt:10
#, no-wrap
msgid "  sweep {stepcount} partlabel=range ...\n"
msgstr "|''**sweep** {//количество_шагов//} //обозначение_компонента//=//диапазон ...//''|\n"

#. type: Plain text
#: manual/commands/sweep.txt:14
msgid ""
"This command is considered obsolete, but the replacement is not working yet."
msgstr "Данная команда считается устаревшей, но её замена пока не работает."

#. type: Plain text
#: manual/commands/sweep.txt:16
msgid ""
"This command begins a loop which will sweep a component or group of "
"components."
msgstr ""
"Данной командой запускается цикл, в котором будут меняться значения одного "
"или нескольких компонентов."

#. type: Plain text
#: manual/commands/sweep.txt:18
msgid ""
"When this command is given, the only apparent actions will be a change in "
"the prompt from `gnucap>' to `>>>', and some disk action."
msgstr ""
"При задании этой команды её единственными очевидными проявлениями будут "
"изменение приглашения с ''gnucap>'' на ''%%>>>%%'' и некоторое действие "
"диска."

#. type: Plain text
#: manual/commands/sweep.txt:20
msgid ""
"The different prompt means that commands are not executed immediately, but "
"are stored in a temporary file."
msgstr ""
"Другой вид приглашения означает, что в этом режиме команды не исполняются "
"сразу, но сохраняются во временный файл."

#. type: Plain text
#: manual/commands/sweep.txt:22
msgid ""
"The bare command will repeat the same command sequence as the last time "
"sweep was run, and not prompt for anything else."
msgstr ""
"При указании команды без параметров будет повторяться та же самая "
"последовательность команд, что выполнялась при последнем запуске **sweep**, "
"и не будет выводиться никакого приглашения ни для чего больше."

#. type: Plain text
#: manual/commands/sweep.txt:24
msgid ""
"Additional components can be swept at the same time by entering a `FAult' "
"command at the `>>>' prompt. The `fault' behaves differently here: It "
"accepts a range, which is the sweep limits."
msgstr ""
"В то же самое время при вводе команды [[fault.ru|fault]] после приглашения "
"''%%>>>%%'' могут изменяться значения дополнительных компонентов. [[fault.ru|"
"fault]] ведёт себя здесь по-другому: в качестве параметров команда принимает "
"диапазон, который представляет собой пределы изменения значений."

#. type: Plain text
#: manual/commands/sweep.txt:26
msgid ""
"The `go' command will end the entry sequence, and make it all happen. After "
"this, the values are restored. (Also, all faults are restored, as if by the "
"`restore' command.)"
msgstr ""
"Команда **go** завершит ввод записей, и заставит всё это заработать. После "
"этого значения восстанавливаются. (Кроме того, все ошибочные значения, "
"организованные с помощью [[fault.ru|fault]], восстанавливаются, как после "
"команды [[fault.ru|restore]].)"

#. type: Plain text
#: manual/commands/sweep.txt:28
msgid ""
"All commands can be used in this mode. Of course, some of them are not "
"really useful (quit) because they work as usual."
msgstr ""
"В этом режиме можно пользоваться всеми командами. Разумеется, некоторые из "
"них (например, [[exit.ru|quit]]) на самом деле не очень здесь полезны, "
"потому что работают как обычно."

#. type: Plain text
#: manual/commands/sweep.txt:30
msgid ""
"Only linear, ordinary parts can be swept. (No semiconductor devices, or "
"elements using behavioral modeling.) The tolerance remains unchanged. If you "
"attempt to sweep a nonlinear or otherwise strange part, it becomes ordinary "
"and linear during the sweep."
msgstr ""
"Значения могут меняться только для линейных, обычных приборов (никаких "
"[[gnucap:manual:devices:semi.ru|полупроводниковых устройств]] или элементов, "
"использующих [[gnucap:manual:devices:basic:inline_behavioral_modeling.ru|"
"поведенческое моделирование]].) [[options.ru|Допуски]] останутся "
"неизменными. Если попытаться работать в диапазоне изменения значений "
"нелинейных или других необычных приборов, они при этом станут обычными и "
"линейными."

#. type: Plain text
#: manual/commands/sweep.txt:38
#, no-wrap
msgid ""
"  gnucap> sweep  5   R14=1,100k   R15=100k,1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
"This sequence of commands says to simultaneously sweep R14 and R15 in 5 steps, in opposite directions, list the circuit and do an AC analysis for each step.\n"
msgstr ""
"  gnucap> sweep  5   R14=1,100k   R15=100k,1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
"Эта последовательность команд говорит одновременно менять R14 и R15 за 5 шагов в противоположных направлениях, для каждого шага вывести схему и сделать анализ [[ac.ru|ac]].\n"

#. type: Plain text
#: manual/commands/sweep.txt:58
#, no-wrap
msgid ""
"Assuming the circuit was:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
"The result of this sequence would be:\n"
"  R14  1   0   1\n"
"  R15  2   0   100k\n"
"an AC analysis\n"
"  R14  1   0   25.75k\n"
"  R15  2   0   75.25k\n"
"an AC analysis\n"
"  R14  1   0   50.5k\n"
"  R15  2   0   50.5k\n"
"an AC analysis\n"
"  R14  1   0   75.25k\n"
"  R15  2   0   25.75k\n"
"an AC analysis\n"
"  R14  1   0   100k\n"
"  R15  2   0   1\n"
"an AC analysis\n"
msgstr ""
"Предположим, в схеме было:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
"Результатом ввода этого набора команд стало бы следующее:\n"
"  R14  1   0   1\n"
"  R15  2   0   100k\n"
"анализ [[ac.ru|ac]] ...\n"
"  R14  1   0   25.75k\n"
"  R15  2   0   75.25k\n"
"анализ [[ac.ru|ac]] ...\n"
"  R14  1   0   50.5k\n"
"  R15  2   0   50.5k\n"
"анализ [[ac.ru|ac]] ...\n"
"  R14  1   0   75.25k\n"
"  R15  2   0   25.75k\n"
"анализ [[ac.ru|ac]] ...\n"
"  R14  1   0   100k\n"
"  R15  2   0   1\n"
"анализ [[ac.ru|ac]] ...\n"

#. type: Plain text
#: manual/commands/sweep.txt:62
#, no-wrap
msgid ""
"After all this is done, the circuit is restored, so list would show:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"
msgstr ""
"После того, как всё это было сделано, схема восстанавливается, поэтому команда [[list.ru|list]] показала бы:\n"
"  R14  1   0   50k\n"
"  R15  2   0   50k\n"

#. type: Plain text
#: manual/commands/sweep.txt:69
#, no-wrap
msgid ""
"You could accomplish the same thing by entering fault commands at the `>>>' prompt.\n"
"  gnucap>sweep  5\n"
"  >>>fault  R14=1, 100k\n"
"  >>>fault  R15=100k, 1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"
msgstr ""
"Того же самого можно было бы добиться, введя после приглашения ''%%>>>%%'' две команды [[fault.ru|fault]]:\n"
"  gnucap>sweep  5\n"
"  >>>fault  R14=1, 100k\n"
"  >>>fault  R15=100k, 1\n"
"  >>>list\n"
"  >>>ac 500 2k oct\n"
"  >>>go\n"

#. type: Title ======
#: manual/commands/temp.txt:1
#, no-wrap
msgid "\"temperature\" command"
msgstr "Команда «temperature»"

#. type: Plain text
#: manual/commands/temp.txt:6
msgid "Views and sets the temperature, with SPICE compatible syntax."
msgstr ""
"Просмотр и установка температуры с использованием SPICE-совместимого "
"синтаксиса."

#. type: Plain text
#: manual/commands/temp.txt:11
#, no-wrap
msgid ""
"  temperature\n"
"  temperature value\n"
msgstr ""
"|''**temperature**             ''|\n"
"|''**temperature** //значение//''|\n"

#. type: Plain text
#: manual/commands/temp.txt:15
msgid "With no value, it prints the temperature."
msgstr "При задании без указания значения команда выводит температуру."

#. type: Plain text
#: manual/commands/temp.txt:17
msgid "With a value, it is equivalent to “.option temperature=value”."
msgstr ""
"Указание значения эквивалентно заданию «''.option temperature=//"
"значение//''»."

#. type: Plain text
#: manual/commands/temp.txt:19
msgid "The real purpose of this command is Spice compatibility."
msgstr "Подлинное назначение этой команды --- совместимость со SPICE."

#. type: Title ======
#: manual/commands/title.txt:1
#, no-wrap
msgid "\"title\" command"
msgstr "Команда «title»"

#. type: Plain text
#: manual/commands/title.txt:6
msgid "View and create the heading line for printouts and files."
msgstr "Просмотр и создание строки заголовка для вывода на печать и в файлы."

#. type: Plain text
#: manual/commands/title.txt:11
#, no-wrap
msgid ""
"  title\n"
"  title a line of text\n"
msgstr ""
"|''**title**                     ''|\n"
"|''**title** //текстовая строка//''|\n"

#. type: Plain text
#: manual/commands/title.txt:15
msgid ""
"There is a header line at the beginning of every file, to help you identify "
"it in the future. This command sets up what it says. It also sets up a "
"heading for printouts and graphs."
msgstr ""
"В начале каждого файла имеется строка заголовка для информации о файле на "
"будущее. Данной командой задаётся содержимое этой строки. Кроме того, с её "
"помощью настраивается заголовок для вывода данных и графиков."

#. type: Plain text
#: manual/commands/title.txt:17
msgid ""
"When you use the `get' command to bring in a new circuit, it replaces the "
"title with the one in the file. The `title' command lets you change it, for "
"the next time it is written out."
msgstr ""
"Когда для открытия файла новой схемы используется команда [[get.ru|get]], "
"заголовок заменяется строкой заголовка из этого файла. Команда **title** "
"позволяет изменить его для записи в следующий раз."

#. type: Plain text
#: manual/commands/title.txt:23
#, no-wrap
msgid ""
"  title This is a test.\n"
"Sets the file heading to `This is a test.' In the future, all files written will have `This is a test.' as their first line.\n"
"  title\n"
"Displays the file heading. In this case, it prints `This is a test.'\n"
msgstr ""
"  title This is a test.\n"
"Задаёт в качестве заголовка файла строку «''This is a test.''». В\n"
"будущем во всех записываемых файлах эта строка будет идти первой.\n"
"  title\n"
"Выводит заголовок файла. В данном случае печатает «''This is a test.''».\n"

#. type: Title ======
#: manual/commands/transient.txt:1
#, no-wrap
msgid "\"transient\" command"
msgstr "Команда «transient»"

#. type: Plain text
#: manual/commands/transient.txt:6
msgid "Performs a nonlinear time domain (transient) analysis."
msgstr ""
"Выполнение нелинейного анализа во временной области (временной анализ)."

#. type: Plain text
#: manual/commands/transient.txt:11
#, no-wrap
msgid ""
"  transient start stop stepsize {options ...}\n"
"  transient stepsize stop start {options ...}\n"
msgstr ""
"|''**transient** //начало конец размер_шага// {//опции ...//}''|\n"
"|''**transient** //размер_шага конец начало// {//опции ...//}''|\n"

#. type: Plain text
#: manual/commands/transient.txt:14
msgid ""
"The probes to look at must have been previously selected by the print or "
"plot command."
msgstr ""
"Датчики, значения которых нужно посмотреть, должны быть заранее выбраны "
"командами [[print.ru|print]] или [[plot.ru|plot]]."

#. type: Plain text
#: manual/commands/transient.txt:16
msgid ""
"Three parameters are normally needed for a Transient analysis: start time, "
"stop time and step size, in this order. The SPICE order (step size, stop, "
"start) is also acceptable. An optional fourth parameter is the maximum "
"internal time step."
msgstr ""
"Для временного анализа обычно нужно три параметра: начальное время, конечное "
"время и размер шага, в указанном порядке. Обратный порядок, как в SPICE "
"(размер шага, конец, начало), тоже приемлем. Дополнительным четвёртым "
"параметром задаётся максимальный внутренний шаг времени."

#. type: Plain text
#: manual/commands/transient.txt:18
msgid ""
"If all of these are omitted, the simulation will continue from where the "
"most recent one left off, with the same step size, unless the circuit "
"topology has been changed. It will run for the same length of time as the "
"previous run."
msgstr ""
"Если ни один из параметров не указан, будет продолжено самое последнее "
"моделирование с той точки, где оно было остановлено, с тем же размером шага, "
"если только топология схемы не изменилась. Длительность его выполнения будет "
"той же самой, что и при предыдущем запуске."

#. type: Plain text
#: manual/commands/transient.txt:20
msgid ""
"Do not use a step size too large as this will result in errors in the "
"results. If you suspect that the results are not accurate, try a larger "
"argument to skip. This will force a smaller internal step size. If the "
"results are close to the same, they can be trusted. If not, try a still "
"larger skip argument until they appear to match close enough."
msgstr ""
"Не используйте слишком большой размер шага, так как это приведёт к\n"
"ошибкам в результатах. Если вы подозреваете, что результаты\n"
"неточны, попробуйте задать больший аргумент для ''skip''. Это приведёт\n"
"к установке меньшего размера внутреннего шага. Если результаты\n"
"близки к тем же самым, им можно верить. Если нет, пробуйте ещё\n"
"больший аргумент для ''skip'' и продолжайте до тех пор, пока последние\n"
"результаты не будут выглядеть достаточно близко совпадающими друг\n"
"с другом.\n"

#. type: Plain text
#: manual/commands/transient.txt:22
msgid ""
"The most obvious error of this type is aliasing. You must select sample "
"frequency at least twice the highest signal frequency that exists anywhere "
"in the circuit. This frequency can be very high, when you use the default "
"step function as input. The signal generator does not have any filtering."
msgstr ""
"Наиболее очевидной ошибкой этого типа является алиасинг (наложение спектров "
"дискретизованного сигнала). Частоту дискретизации необходимо выбирать по "
"крайней мере вдвое выше наибольшей частоты сигнала, присутствующего в любом "
"месте схемы. При использовании в качестве входного сигнала стандартной "
"ступенчатой функции эта частота может быть очень высокой. [[generator.ru|"
"Генератор сигналов]] не производит никакой фильтрации."

#. type: Plain text
#: manual/commands/transient.txt:49
#, no-wrap
msgid ""
"|dtemp //degrees//        |Temperature offset, degrees C. Add this number to the temperature from the options command.  |\n"
"|temperature //degrees//  |Temperature, degrees C.  |\n"
"|cold                     |Zero initial conditions. Cold start from power-up.  |\n"
"|uic                      |Use initial conditions. Do not do an initial DC analysis. Instead, use the values specified with the IC = options on the various elements, and set everything else to zero.  In most cases, UIC is not recommended.  Improper use of UIC causes more problems than it solves.  It is the way it is for Spice compatibility.  |\n"
msgstr ""
"|''dtemp //градусы//        ''| Смещение температуры, °C. Это число добавляется к температуре из команды [[options.ru|options]].  |\n"
"|''temperature //градусы//  ''| Температура, °C  |\n"
"|''cold                     ''| Нулевые начальные условия. Холодный запуск с момента подачи питания  |\n"
"|''uic                      ''| Использовать начальные условия. Не проводить начальный статический анализ по постоянному току [[dc.ru|dc]]. Вместо этого использовать данные, указанные в опциях ''IC'' разных элементов, а всё остальное устанавливать в ноль. В большинстве случаев задавать ''uic'' не рекомендуется. Неправильное использование ''uic'' вносит больше проблем, чем решает. В таком виде, в каком этот параметр представлен сейчас, он присутствует для совместимости со SPICE  |\n"

#. type: Plain text
#: manual/commands/transient.txt:61
#, no-wrap
msgid ""
"  transient 0 100u 10n\n"
"Start at time 0, stop after 100 micro-seconds. Simulate using 10 nanosecond steps.\n"
"  transient\n"
"No parameters mean to continue from the last run. In this case it means to step from 100 us to 200 us in 10 ns steps. (The same step size and run length, but offset to start where the last one stopped.\n"
"  transient skip 10\n"
"Do 10 extra steps internally for every step that would be done otherwise. In this case it means to internally step at 1 nanosecond. If the output is in tabular form, the extra steps are hidden.\n"
"  transient 0\n"
"Start over at time = 0. Keep the same step size and run length.\n"
"  transient >arun\n"
"Save the results of this run in the file \"arun\".\n"
msgstr ""
"  transient 0 100u 10n\n"
"Запустить во время 0, остановить через 100 микросекунд.\n"
"Моделировать с шагом 10 наносекунд.\n"
"  transient\n"
"Отсутствие параметров означает продолжение работы с момента останова при последнем запуске. В\n"
"данном случае это значит идти от 100 мкс до 200 мкс с шагом 10 нс.\n"
"(Тот же размер шага и та же длительность выполнения, но начало\n"
"моделирования смещается в ту точку, где оно последний раз было\n"
"остановлено.)\n"
"  transient skip 10\n"
"Делать 10 дополнительных внутренних шагов на каждый шаг, который\n"
"был бы сделан в противном случае. В данном случае это значит\n"
"использовать внутренний шаг в 1 наносекунду. Если вывод\n"
"производится в табличной форме, дополнительные шаги не\n"
"отображаются.\n"
"  transient 0\n"
"Запустить снова во время равное 0. Сохранить тот же размер шага и\n"
"длительность выполнения.\n"
"  transient >arun\n"
"При этом запуске сохранить результаты в файл ''arun''.\n"

#. type: Title ======
#: manual/commands/width.txt:1
#, no-wrap
msgid "\"width\" command"
msgstr "Команда «width»"

#. type: Plain text
#: manual/commands/width.txt:6
msgid "Set input and output width."
msgstr "Установка ширины ввода и вывода."

#. type: Plain text
#: manual/commands/width.txt:10
#, no-wrap
msgid "  width {IN=value} {OUT=value}\n"
msgstr "|''**width** {IN=//значение//} {OUT=//значение//}''|\n"

#. type: Plain text
#: manual/commands/width.txt:13
msgid ""
"The `width' command is the same as the `options' command. It is provided for "
"SPICE compatibility. SPICE uses width to set two parameters: in and out, "
"which we set with the options command."
msgstr ""
"Команда **width** служит для того же, что и команда [[options.ru|options]]. "
"Она предоставляется для совместимости со SPICE. В SPICE команда **width** "
"используется для установки двух параметров: ''in'' и ''out'', которые здесь "
"устанавливаются командой [[options.ru|options]]."

#. type: Title ======
#: manual/compatibility.txt:1
#: manual/compatibility/subcircuit_with_parameters.txt:1
#, no-wrap
msgid "Compatibility"
msgstr "Совместимость"

#. type: Plain text
#: manual/compatibility.txt:4
msgid ""
"This section documents compatibility issues, including syntax and feature "
"differences compared to other simulators.  In some cases, a workaround is "
"suggested.  In almost all cases, there are plans to provide exact "
"compatibility in the future."
msgstr ""
"В настоящем разделе рассматриваются вопросы совместимости, в том числе "
"синтаксические отличия и отличия в возможностях по сравнению с другими "
"программами моделирования. В некоторых случаях предлагаются обходные "
"варианты решения проблем. В будущем планируется обеспечить полную "
"совместимость почти во всех случаях."

#. type: Bullet: '  * '
#: manual/compatibility.txt:5
#, no-wrap
msgid "[[.:compatibility:subcircuit with parameters|subcircuit with parameters, Pspice, LTspice]]\n"
msgstr "[[.:compatibility:subcircuit with parameters.ru|подсхема с параметрами, Pspice, LTspice]]\n"

#. type: Title =====
#: manual/compatibility/subcircuit_with_parameters.txt:2
#, no-wrap
msgid "Subcircuit with parameters"
msgstr "Подсхема с параметрами"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:5
msgid ""
"Some simulators (LTspice, Pspice) accept a syntax for subcircuits that is "
"incompatible with gnucap."
msgstr ""
"Синтаксис подсхем некоторых программы моделирования (LTspice, Pspice) не "
"совместим с gnucap."

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:7
msgid "The Gnucap syntax is compatible with other simulators such as Hspice."
msgstr ""
"Синтаксис gnucap совместим с другими программами моделирования, такими как "
"Hspice."

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:7
#, no-wrap
msgid "Subcircuit instantiation syntax"
msgstr "Синтаксис создания экземпляра подсхемы"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:10
#: manual/compatibility/subcircuit_with_parameters.txt:25
msgid "LTspice syntax:"
msgstr "Синтаксис LTspice:"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:13
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack params: ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance params: ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"
msgstr ""
"  Xv   v1r v1i      vri_slack params: ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance params: ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:16
msgid ""
"The key ''params:'' should be omitted.  Parentheses are optional.\\\\ Gnucap "
"syntax:"
msgstr ""
"Ключевое слово «''params:''» использоваться не должно. Круглые скобки "
"необязательны.\\\\ Синтаксис gnucap: "

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:19
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"
msgstr ""
"  Xv   v1r v1i      vri_slack ( vr=10  vi=1  on=1 vfactor=1.732 )\n"
"  Ximp v1r v1i 0 0  impedance ( r=1 xl=10 xc=2 length=1 zfactor=1 )\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid ""
"  Xv   v1r v1i      vri_slack vr=10  vi=1  on=1 vfactor=1.732\n"
"  Ximp v1r v1i 0 0  impedance r=1 xl=10 xc=2 length=1 zfactor=1\n"
msgstr ""
"  Xv   v1r v1i      vri_slack vr=10  vi=1  on=1 vfactor=1.732\n"
"  Ximp v1r v1i 0 0  impedance r=1 xl=10 xc=2 length=1 zfactor=1\n"

#. type: Title ====
#: manual/compatibility/subcircuit_with_parameters.txt:22
#, no-wrap
msgid "Subcircuit declaration syntax"
msgstr "Синтаксис объявления подсхемы"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:27
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i params: on = 1 r = 100 xl = 0\n"
msgstr "  .subckt impedance v1r v1i v2r v2i params: on = 1 r = 100 xl = 0\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:33
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + params:\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + params:\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:36
msgid ""
"The key params: should be omitted.  It is not necessary to declare "
"parameters, but you may do it for documentation or to specify default "
"values.  Parameters can be on the same line or in .param statements on "
"following lines.\\\\ Gnucap syntax:"
msgstr ""
"Ключевое слово «''params:''» использоваться не должно. Параметры объявлять "
"не обязательно, но делать это можно для документирования или для указания "
"значений по умолчанию. Параметры можно указывать в той же самой строке или в "
"операторах «''.param''» в следующих строках.\\\\ Синтаксис gnucap:"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:38
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i on = 1 r = 100 xl = 0\n"
msgstr "  .subckt impedance v1r v1i v2r v2i on = 1 r = 100 xl = 0\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:43
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:45
#, no-wrap
msgid "  .subckt impedance v1r v1i v2r v2i (on = 1 r = 100 xl = 0)\n"
msgstr "  .subckt impedance v1r v1i v2r v2i (on = 1 r = 100 xl = 0)\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:48
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param on = 1 r = 100 xl = 0\n"
msgstr ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param on = 1 r = 100 xl = 0\n"

#. type: Plain text
#: manual/compatibility/subcircuit_with_parameters.txt:54
#, no-wrap
msgid ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"
msgstr ""
"  .subckt impedance v1r v1i v2r v2i\n"
"  .param\n"
"  + on = 1\n"
"  + r = 100\n"
"  + xl = 0\n"

#. type: Title ======
#: manual/devices.txt:1
#, no-wrap
msgid "Devices"
msgstr "Устройства"

#. type: Plain text
#: manual/devices.txt:4
msgid ""
"Gnucap devices are defined by plugins. This section defines all commands "
"supplied in the main tarball, and also the optional \"models\" tarballs."
msgstr ""
"Устройства gnucap определяются посредством плагинов. В настоящем разделе "
"определяются все команды, поставляемые в основном tar-архиве, а также "
"дополнительные tar-архивы «моделей»."

#. type: Plain text
#: manual/devices.txt:6
msgid ""
"Your installation may not have all of these, and may have others in addition "
"to these. It depends on which plugins you have installed."
msgstr ""
"В вашей установке может не быть всех представленных ниже устройств, или "
"могут быть другие в дополнение к указанным. Это зависит от того, какие у вас "
"установлены плагины."

#. type: Plain text
#: manual/devices.txt:8
msgid ""
"The main tarball contains simple models, including most models that are "
"included with Spice-2g6, and some that are in Spice-3.  This should be "
"adequate for beginning academic work and most hobby work.  The other "
"tarballs contain specific models from a variety of sources.  Some are exact "
"industry standard models.  Some are from other simulators and are provided "
"for compatibility.  Some are new research oriented models.  Some are of "
"primarily historical interest."
msgstr ""
"В основном tar-архиве содержатся простые модели, включая большинство "
"моделей, входящих в SPICE-2g6, и некоторые из имеющихся в SPICE-3. Этого "
"должно быть достаточно для начала учебной работы и большей части "
"любительской практики. В других tar-архивах содержатся специфические модели "
"из множества источников. Некоторые из них представляют собой точные "
"стандартные промышленные модели.  Некоторые взяты из других программ "
"моделирования и приводятся для совместимости. Некоторые являются новыми "
"моделями, предназначенными для исследований. Некоторые представляют главным "
"образом исторический интерес."

#. type: Plain text
#: manual/devices.txt:10
msgid ""
"The Gnucap plugin system allows anyone to develop new models and add them, "
"without recompiling or reinstalling the main simulator.  There are several "
"options for doing this, including a model compiler and a wrapper that allows "
"the use of unmodified Spice C models."
msgstr ""
"Система плагинов gnucap позволяет любому пользователю разрабатывать новые "
"модели и добавлять их без перекомпиляции или переустановки основной "
"программы моделирования. Для этого существуют разные средства, в том числе "
"компилятор моделей и оболочка, позволяющая использовать модели SPICE, "
"написанные на C, без модификации."

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:basic|Basic passive devices]]\n"
msgstr "[[.:devices:basic.ru|Базовые пассивные устройства]]\n"

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:other|Other \"spice\" devices]]\n"
msgstr "[[.:devices:other.ru|Прочие устройства SPICE]]\n"

#. type: Bullet: '  * '
#: manual/devices.txt:13
#, no-wrap
msgid "[[.:devices:semi|Semiconductor devices]]\n"
msgstr "[[.:devices:semi.ru |Полупроводниковые устройства]]\n"

#. type: Title =====
#: manual/devices/basic.txt:1
#, no-wrap
msgid "Basic passive devices"
msgstr "Базовые пассивные устройства"

#. type: Plain text
#: manual/devices/basic.txt:4
msgid ""
"Gnucap includes the usual basic Spice devices, and some others that are "
"found in commercial versions of Spice."
msgstr ""
"В gnucap входят как обычные базовые устройства SPICE, так и несколько "
"других, найденных в коммерческих версиях SPICE."

#. type: Plain text
#: manual/devices/basic.txt:6
msgid ""
"All of them are designed as plugins, but are included in the base "
"distribution and loaded by default."
msgstr ""
"Все они реализованы в виде плагинов, но входят в основной дистрибутив и "
"загружаются по умолчанию."

#. type: Plain text
#: manual/devices/basic.txt:8
msgid ""
"All of them can be extended by simple behavioral expressions, in some cases "
"beyond what is available in any Spice."
msgstr ""
"Все они могут быть расширены с помощью простых поведенческих выражений, и в "
"некоторых случаях сверх того, что доступно в любой из версий SPICE."

#. type: Plain text
#: manual/devices/basic.txt:10
msgid "All of them have extended probes, more than any Spice."
msgstr ""
"Все они имеют усовершенствованные датчики, которых больше, чем в любой из "
"версий SPICE."

#. type: Title ====
#: manual/devices/basic.txt:11
#, no-wrap
msgid "The basic devices"
msgstr "Базовые устройства"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "capacitor (C)\n"
msgstr "конденсатор (C)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "inductor (L)\n"
msgstr "катушка индуктивности (L)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "resistor (R)\n"
msgstr "резистор (R)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed voltage source (V)\n"
msgstr "независимый источник напряжения (V)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "fixed current source (I)\n"
msgstr "независимый источник тока (I)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled voltage source (E)\n"
msgstr "источник напряжения, управляемый напряжением (E)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "voltage controlled current source (G)\n"
msgstr "источник тока, управляемый напряжением (G)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled voltage source (H)\n"
msgstr "источник напряжения, управляемый током (H)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:22
#, no-wrap
msgid "current controlled current source (F)\n"
msgstr "источник тока, управляемый током (F)\n"

#. type: Title ====
#: manual/devices/basic.txt:22
#, no-wrap
msgid "Less common basic devices"
msgstr "Менее распространённые базовые устройства"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "admittance (Y)\n"
msgstr "проводимость (Y)\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled resistor\n"
msgstr "сопротивление, управляемое напряжением\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled capacitor\n"
msgstr "ёмкость, управляемая напряжением\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "voltage controlled admittance\n"
msgstr "проводимость, управляемая напряжением\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:29
#, no-wrap
msgid "trans-capacitor\n"
msgstr "проходная ёмкость\n"

#. type: Title ====
#: manual/devices/basic.txt:30
#, no-wrap
msgid "More info"
msgstr "Дополнительная информация"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:basic syntax]]\n"
msgstr "[[gnucap:manual:devices:basic:basic syntax.ru|Синтаксис базовых устройств]]\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:inline behavioral modeling]]\n"
msgstr "[[gnucap:manual:devices:basic:inline behavioral modeling.ru|Встроенное поведенческое моделирование]]\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:spice-style models]]\n"
msgstr "[[gnucap:manual:devices:basic:spice-style models.ru|Модели в стиле SPICE]]\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:basic:probes]]\n"
msgstr "[[gnucap:manual:devices:basic:probes.ru|Датчики]]\n"

#. type: Bullet: '  * '
#: manual/devices/basic.txt:36
#, no-wrap
msgid "[[gnucap:manual:devices:capacitor|.]]\n"
msgstr "[[gnucap:manual:devices:capacitor.ru|Конденсаторы]]\n"

#. type: Title ======
#: manual/devices/basic/basic_syntax.txt:1
#, no-wrap
msgid "Basic device syntax"
msgstr "Синтаксис базовых устройств"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:4
msgid ""
"This page applies to the simple \"Spice\" basic devices, and some extended "
"forms of them."
msgstr ""
"На данной странице приводится описание простых базовых устройств SPICE и их "
"расширенных вариантов."

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:4 manual/devices/capacitor.txt:5
#, no-wrap
msgid "Spice format"
msgstr "Формат SPICE"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:7
#: manual/devices/basic/basic_syntax.txt:57
#: manual/devices/basic/basic_syntax.txt:71
msgid "The format for simple devices is:"
msgstr "Формат записи для простых устройств:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:9
#, no-wrap
msgid "  label  (connections)  value\n"
msgstr "  обозначение  (соединения)  значение\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:11
msgid "Parentheses around the connections are optional."
msgstr "Скобки вокруг соединений необязательны."

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:13
#: manual/devices/basic/basic_syntax.txt:61
#: manual/devices/basic/basic_syntax.txt:77
msgid "Examples:"
msgstr "Примеры:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:18
#, no-wrap
msgid ""
"  Vin     (in 0)   10\n"
"  Lseries (in out) .01\n"
"  Cshunt  (out 0)  100u\n"
"  Rload   (out 0)  100\n"
msgstr ""
"  Vin     (in 0)   10\n"
"  Lseries (in out) .01\n"
"  Cshunt  (out 0)  100u\n"
"  Rload   (out 0)  100\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:20
msgid "The first letter of the label determines the type:"
msgstr "Первая буква обозначения определяет тип устройства:"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:30
#, no-wrap
msgid ""
"^2 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|C      |capacitor                         |capacitance q/v   |Cxxxx (p n) capacitance       |\n"
"|L      |inductor                          |inductance flux/i |Lxxxx (p n) inductance        |\n"
"|R      |resistor                          |resistance v/i    |Rxxxx (p n) resistance        |\n"
"|Y      |admittance                        |admittance i/v    |Yxxxx (p n) admittance        |\n"
"|V      |fixed voltage source              |DC voltage        |Vxxxx (p n) voltage           |\n"
"|I      |fixed current source              |DC current        |Ixxxx (sink src) current      |\n"
msgstr ""
"^ Устройства с 2 выводами ^^^^\n"
"^ Буква ^  Тип                              ^ Значение              ^ Синтаксис                    ^\n"
"| C     | конденсатор                       | ёмкость       (Q/U)   |Cxxxx (p n) ёмкость           |\n"
"| L     | катушка индуктивности             | индуктивность (Ф/I)   |Lxxxx (p n) индуктивность     |\n"
"| R     | резистор                          | сопротивление (U/I)   |Rxxxx (p n) сопротивление     |\n"
"| Y     | проводимость                      | проводимость  (I/U)   |Yxxxx (p n) проводимость      |\n"
"| V     | независимый источник напряжения   | постоянное напряжение |Vxxxx (p n) напряжение        |\n"
"| I     | независимый источник тока         | постоянный ток        |Ixxxx (sink source) ток       |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:37
#, no-wrap
msgid ""
"^4 terminal devices ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|E      |voltage controlled voltage source |gain vout/vin     |Exxxx (p n ps ns) gain        |\n"
"|G      |voltage controlled current source |gm   iout/vin     |Gxxxx (sink src ps ns) gm     |\n"
"|H      |current controlled voltage source |rm   vout/iin     |Hxxxx (p n control) gain      |\n"
"|F      |current controlled current source |gain iout/iin     |Fxxxx (sink src control) gain |\n"
msgstr ""
"^ Устройства с 4 выводами ^^^^\n"
"^ Буква ^ Тип                                          ^ Значение                                        ^ Синтаксис                                 ^\n"
"| E     | источник напряжения, управляемый напряжением | K<sub>U</sub> (U<sub>вых</sub>/U<sub>вх</sub>)  | Exxxx (p n ps ns) K<sub>U</sub>           |\n"
"| G     | источник тока,       управляемый напряжением | gm            (I<sub>вых</sub>/U<sub>вх</sub>)  | Gxxxx (sink source ps ns) gm              |\n"
"| H     | источник напряжения, управляемый током       | rm            (U<sub>вых</sub>/I<sub>вх</sub>)  | Hxxxx (p n control) rm                    |\n"
"| F     | источник тока,       управляемый током       | K<sub>I</sub> (I<sub>вых</sub>/I<sub>вх</sub>)  | Fxxxx (sink source control) K<sub>I</sub> |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:44
#, no-wrap
msgid ""
"^devices with special syntax ^^^^\n"
"^letter ^type                              ^value             ^syntax                        ^\n"
"|G      |voltage controlled resistor       |R/vc              |Gxxxx (p n ps ns) vcr value   |\n"
"|G      |voltage controlled admittance     |Y/vc              |Gxxxx (p n ps ns) vcg value   |\n"
"|G      |voltage controlled capacitor      |C/vc              |Gxxxx (p n ps ns) vccap value |\n"
"|C      |trans-capacitor                   |Qout/vin          |Cxxxx (p n ps ns) tcap value  |\n"
msgstr ""
"^ Устройства с особым синтаксисом ^^^^\n"
"^ Буква ^ Тип                                    ^ Значение                        ^ Синтаксис                       ^\n"
"|G      |сопротивление, управляемое напряжением  | R/U<sub>у</sub>                 |Gxxxx (p n ps ns) vcr   значение |\n"
"|G      |проводимость,  управляемая напряжением  | Y/U<sub>у</sub>                 |Gxxxx (p n ps ns) vcg   значение |\n"
"|G      |ёмкость,       управляемая напряжением  | C/U<sub>у</sub>                 |Gxxxx (p n ps ns) vccap значение |\n"
"|C      |проходная ёмкость                       | Q<sub>вых</sub>/U<sub>вх</sub>  |Cxxxx (p n ps ns) tcap  значение |\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:53
#, no-wrap
msgid ""
"^Port names ^^\n"
"|p       |positive node or positive output        |\n"
"|n       |negative node or negative output        |\n"
"|sink    |current sink or current sink output     |\n"
"|source  |current source or current source output |\n"
"|ps      |positive input or control voltage node  |\n"
"|ns      |negative input or control voltage node  |\n"
"|control |current probe controlling element       |\n"
msgstr ""
"^ Имена портов ^^\n"
"|p       | положительный узел или выход                        |\n"
"|n       | отрицательный узел или выход                        |\n"
"|sink    | источник втекающего тока или его выход              |\n"
"|source  | источник вытекающего тока или его выход             |\n"
"|ps      | положительный вход или узел управляющего напряжения |\n"
"|ns      | отрицательный вход или узел управляющего напряжения |\n"
"|control | управляющий элемент датчика тока                    |\n"

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:54 manual/devices/capacitor.txt:11
#, no-wrap
msgid "Spectre format"
msgstr "Формат Spectre"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:59
#, no-wrap
msgid "  label  (connections)  type  parameter=value\n"
msgstr "  обозначение  (соединения)  тип  параметр=значение\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:66
#, no-wrap
msgid ""
"  Vin     (in 0)   vsource   dc=10\n"
"  Lseries (in out) inductor  l=.01\n"
"  Cshunt  (out 0)  capacitor c=100u\n"
"  Rload   (out 0)  resistor  r=100\n"
msgstr ""
"  Vin     (in 0)   vsource   dc=10\n"
"  Lseries (in out) inductor  l=.01\n"
"  Cshunt  (out 0)  capacitor c=100u\n"
"  Rload   (out 0)  resistor  r=100\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:68
msgid ""
"The device type is determined by the type field.  The first letter of the "
"label doesn't matter."
msgstr ""
"Тип устройства определяется полем «тип».  Первая буква обозначения не несёт "
"особого смысла."

#. type: Title ===
#: manual/devices/basic/basic_syntax.txt:68 manual/devices/capacitor.txt:17
#, no-wrap
msgid "Verilog format"
msgstr "Формат Verilog"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:75
#, no-wrap
msgid ""
"  type #(.parameter(value)) label (connections);\n"
"or\n"
"  type #(value) label (connections);\n"
msgstr ""
"  тип #(.параметр(значение)) обозначение (соединения);\n"
"или\n"
"  тип #(значение) обозначение (соединения);\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:82
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (.p(in), .n(0));\n"
"  inductor  #(.l(.01))  Lseries (.p(in), .n(out));\n"
"  capacitor #(.c(100u)) Cshunt  (.p(out), .n(0));\n"
"  resistor  #(.r(100))  Rload   (.p(out), .n(0));\n"
msgstr ""
"  vsource   #(.dc(10))  Vin     (.p(in), .n(0));\n"
"  inductor  #(.l(.01))  Lseries (.p(in), .n(out));\n"
"  capacitor #(.c(100u)) Cshunt  (.p(out), .n(0));\n"
"  resistor  #(.r(100))  Rload   (.p(out), .n(0));\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:87
#, no-wrap
msgid ""
"  vsource   #(.dc(10))  Vin     (in, 0);\n"
"  inductor  #(.l(.01))  Lseries (in, out);\n"
"  capacitor #(.c(100u)) Cshunt  (out, 0);\n"
"  resistor  #(.r(100))  Rload   (out, 0);\n"
msgstr ""
"  vsource   #(.dc(10))  Vin     (in, 0);\n"
"  inductor  #(.l(.01))  Lseries (in, out);\n"
"  capacitor #(.c(100u)) Cshunt  (out, 0);\n"
"  resistor  #(.r(100))  Rload   (out, 0);\n"

#. type: Plain text
#: manual/devices/basic/basic_syntax.txt:91
#, no-wrap
msgid ""
"  vsource   #(10)   Vin     (in, 0);\n"
"  inductor  #(.01)  Lseries (in, out);\n"
"  capacitor #(100u) Cshunt  (out, 0);\n"
"  resistor  #(100)  Rload   (out, 0);\n"
msgstr ""
"  vsource   #(10)   Vin     (in, 0);\n"
"  inductor  #(.01)  Lseries (in, out);\n"
"  capacitor #(100u) Cshunt  (out, 0);\n"
"  resistor  #(100)  Rload   (out, 0);\n"

#. type: Title ======
#: manual/devices/basic/complex.txt:1
#, no-wrap
msgid "\"complex\" Complex value"
msgstr "Функция «complex»: комплексное значение"

#. type: Plain text
#: manual/devices/basic/complex.txt:6
#, no-wrap
msgid "  complex ( realpart imaginarypart options )\n"
msgstr "|''**complex** ( //вещественная_часть мнимая_часть опции// )''|\n"

#. type: Plain text
#: manual/devices/basic/complex.txt:10
msgid "Complex component value, using a real and imaginary part.  AC only."
msgstr ""
"Определение комплексного значения компонента, его вещественной и мнимой "
"части. Только для анализа [[gnucap:manual:commands:ac.ru|ac]]."

#. type: Plain text
#: manual/devices/basic/complex.txt:15
msgid ""
"Strictly, this adds no functionality over the polar option on any function, "
"except notational convenience."
msgstr ""
"Строго говоря, по сравнению с использованием для любой функции опции "
"''polar'', эта функция, кроме удобства записи, никакой функциональности не "
"добавляет."

#. type: Plain text
#: manual/devices/basic/complex.txt:18
msgid ""
"It is only meaningful in AC analysis.  Others take the real part and ignore "
"the imaginary part.  No warning is issued."
msgstr ""
"Использовать её имеет смысл только в анализе [[gnucap:manual:commands:ac.ru|"
"ac]].  В других анализах вещественная часть учитывается, а мнимая "
"игнорируется. Никаких предупреждений не выдаётся."

#. type: Title =====
#: manual/devices/basic/complex.txt:18 manual/devices/basic/exp.txt:43
#: manual/devices/basic/fit.txt:67 manual/devices/basic/poly.txt:33
#: manual/devices/basic/pulse.txt:52 manual/devices/basic/sffm.txt:37
#: manual/devices/basic/sin.txt:55 manual/devices/basic/tanh.txt:32
#: manual/devices/lossless_transmission_line.txt:41
#, no-wrap
msgid "Step control"
msgstr "Управление временным шагом"

#. type: Plain text
#: manual/devices/basic/complex.txt:21
msgid ""
"This function does have any role in time step control.  The notion of "
"complex values does not work in transient analysis."
msgstr ""
"Эта функция не играет никакой роли в управлении временным шагом. Для "
"временного анализа категория комплексных значений не работает."

#. type: Plain text
#: manual/devices/basic/complex.txt:26
#, no-wrap
msgid ""
"  V12 (2 0) complex(1,2)\n"
"A voltage source with a value of 1 + j2 volts.\n"
msgstr ""
"  V12 (2 0) complex(1,2)\n"
"Источник напряжения со значением 1 + j2 Вольт.\n"

#. type: Plain text
#: manual/devices/basic/complex.txt:28
#, no-wrap
msgid ""
"  R12 (2 4) complex(50,-10)\n"
"A \"resistor\" with a value of 50 - j10 ohms.\n"
msgstr ""
"  R12 (2 4) complex(50,-10)\n"
"«Резистор» с номиналом 50 - j10 Ом.\n"

#. type: Title ======
#: manual/devices/basic/exp.txt:1
#, no-wrap
msgid "\"exp\" Exponential time dependent value"
msgstr "Функция «exp»: экспоненциальная временная зависимость"

#. type: Plain text
#: manual/devices/basic/exp.txt:7
#, no-wrap
msgid ""
"  exp (args)\n"
"  exp (iv pv td1 tau1 td2 tau2 period)\n"
msgstr ""
"|''**exp** (//аргументы//)                     ''|\n"
"|''**exp** (//iv pv td1 tau1 td2 tau2 period//)''|\n"

#. type: Plain text
#: manual/devices/basic/exp.txt:11
msgid "The component value is an exponential function of time."
msgstr "Задание значения компонента в виде экспоненциальной функции времени."

#. type: Plain text
#: manual/devices/basic/exp.txt:14
msgid ""
"For voltage and current sources, this is the same as the Spice \"exp\" "
"function, with some extensions."
msgstr ""
"Для источников напряжения и тока функция тождественна одноимённой функции "
"SPICE, но имеет некоторые расширения."

#. type: Plain text
#: manual/devices/basic/exp.txt:16 manual/devices/basic/sin.txt:24
msgid "The shape of the waveform is described by the following algorithm:"
msgstr "Форма сигнала описывается следующим алгоритмом:"

#. type: Plain text
#: manual/devices/basic/exp.txt:28
#, no-wrap
msgid ""
"<code>\n"
"ev = _iv;\n"
"for (reltime=time; reltime>=0; reltime-=_period){\n"
"  if (reltime > _td1){\n"
"    ev += (_pv - _iv) * (1. - Exp(-(reltime-_td1)/_tau1));\n"
"  }\n"
"  if (reltime > _td2){\n"
"    ev += (_iv - _pv) * (1. - Exp(-(reltime-_td2)/_tau2));\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""
"<code>\n"
"ev = _iv;\n"
"for (reltime=time; reltime>=0; reltime-=_period){\n"
"  if (reltime > _td1){\n"
"    ev += (_pv - _iv) * (1. - Exp(-(reltime-_td1)/_tau1));\n"
"  }\n"
"  if (reltime > _td2){\n"
"    ev += (_iv - _pv) * (1. - Exp(-(reltime-_td2)/_tau2));\n"
"  }\n"
"}\n"
"</code>\n"

#. type: Plain text
#: manual/devices/basic/exp.txt:30 manual/devices/basic/pulse.txt:40
#: manual/devices/basic/sffm.txt:22 manual/devices/basic/sin.txt:39
msgid "For other components, it gives a time dependent value."
msgstr ""
"Для прочих компонентов функция определяет временную зависимость значений их "
"величин."

#. type: Plain text
#: manual/devices/basic/exp.txt:33 manual/devices/basic/pulse.txt:43
#: manual/devices/basic/sffm.txt:24 manual/devices/basic/sin.txt:42
msgid ""
"As an extension beyond Spice, you may specify the parameters as name=value "
"pairs in any order."
msgstr ""
"Расширением по отношению к SPICE является возможность задавать параметры в "
"виде пар ''имя=значение'' в любом порядке следования."

#. type: Plain text
#: manual/devices/basic/exp.txt:42
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)             |\n"
"|pv      |Pulsed value.  (required)              |\n"
"|td1     |Rise time delay.  (Default = 0.)       |\n"
"|tau1    |Rise time constant.  (Default = 0.)    |\n"
"|td2     |Fall time delay.  (Default = 0.)       |\n"
"|tau2    |Fall time constant.  (Default = 0.)    |\n"
"|period  |Repeat period.  (Default = infinity.)  |\n"
msgstr ""
"^ Параметр   ^  Значение по\\\\ умолчанию   ^ Описание                                    ^\n"
"|''iv''      |  //обязательный//            | Исходное значение                           |\n"
"|''pv''      |  //обязательный//            | Величина импульса                           |\n"
"|''td1''     |  **''0''**                   | Выдержка времени перед нарастающим фронтом  |\n"
"|''tau1''    |  **''0''**                   | Постоянная времени нарастающего фронта      |\n"
"|''td2''     |  **''0''**                   | Выдержка времени перед ниспадающим фронтом  |\n"
"|''tau2''    |  **''0''**                   | Постоянная времени ниспадающего фронта      |\n"
"|''period''  |  **''∞''**                   | Период повторения                           |\n"

#. type: Plain text
#: manual/devices/basic/exp.txt:46
msgid ""
"This function influences time step control through both smoothness control "
"and analog events."
msgstr ""
"Данная функция влияет на управление временным шагом как через управление "
"гладкостью, так и через аналоговые события."

#. type: Plain text
#: manual/devices/basic/exp.txt:48
msgid ""
"The time step is limited by the active time constant, either tau1 or tau2, "
"depending on whether it is rising or falling."
msgstr ""
"Временной шаг ограничивается значением активной постоянной времени, либо "
"''tau1'', либо ''tau2'', в зависимости от того, является ли текущий фронт "
"нарастающим или ниспадающим."

#. type: Plain text
#: manual/devices/basic/exp.txt:50
msgid ""
"The corners in as exp waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""
"Начальные точки фронтов экспоненциального сигнала считаются аналоговыми "
"событиями. Во [[gnucap:manual:commands:transient.ru|временном анализе]] "
"программа будет пытаться отрегулировать точность выбора моментов времени для "
"этих аналоговых событий.  Если она будет достаточной, временные шаги должны "
"планироваться точно в моменты этих событий. В любом случае временной шаг "
"должен попадать в указанный момент времени с погрешностью не более значения "
"[[gnucap:manual:commands:options.ru|опции]] ''dtmin''."

#. type: Title ======
#: manual/devices/basic/fit.txt:1
#, no-wrap
msgid "\"fit\" Fit a curve   \"pwl\" Piece-wise linear"
msgstr "Функция «fit»: аппроксимация кривой. Функция «pwl»: кусочно-линейная функция"

#. type: Plain text
#: manual/devices/basic/fit.txt:6
#, no-wrap
msgid ""
"  fit x1,y1 x2,y2 ... args\n"
"  pwl x1,y1 x2,y2 ... args\n"
msgstr ""
"|''**fit** //x1,y1 x2,y2// ... //аргументы//''|\n"
"|''**pwl** //x1,y1 x2,y2// ... //аргументы//''|\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:9
msgid "FIT fits a set of data using piecewise polynomials, or splines."
msgstr ""
"**fit** аппроксимирует набор данных с помощью кусочно-полиномиальных функций "
"или сплайнов."

#. type: Plain text
#: manual/devices/basic/fit.txt:11
msgid ""
"PWL is a a special case of FIT, it defines a piecewise linear transfer "
"function or time dependent value."
msgstr ""
"**pwl** это особый вид **fit**, определяющий передаточную функцию или "
"временную зависимость устройства в виде кусочно-линейной функции."

#. type: Plain text
#: manual/devices/basic/fit.txt:14
msgid ""
"The \"fit\" function fits a set of piecewise polynomials to a set of data."
msgstr ""
"Функция **fit** аппроксимирует набор данных кусочно-полиномиальными "
"функциями."

#. type: Plain text
#: manual/devices/basic/fit.txt:16
msgid ""
"The \"pwl\" function is a special case of \"fit\", forcing \"order\" to 1.  "
"It is designed for Spice compatibility."
msgstr ""
"Функция **pwl** представляет собой особый вид **fit**, в которой степень "
"полинома (''order'') принудительно устанавливается в 1.  Она разработана для "
"совместимости со SPICE."

#. type: Plain text
#: manual/devices/basic/fit.txt:18 manual/devices/basic/posy.txt:23
msgid "For fixed sources, it defines voltage or current as a function of time."
msgstr ""
"Для независимых источников напряжения или тока данная функция определяет "
"временную зависимость напряжения или тока."

#. type: Plain text
#: manual/devices/basic/fit.txt:20
msgid ""
"The meaning of the //x// and //y// values depends on the component type:"
msgstr "Смысл значений //x// и //y// зависит от типа компонента:"

#. type: Plain text
#: manual/devices/basic/fit.txt:36
#, no-wrap
msgid ""
"^component          ^X        ^Y            ^\n"
"|C (capacitor)      |voltage  |charge       |\n"
"|E (VCVS)           |voltage  |voltage      |\n"
"|F (CCCS)           |current  |current      |\n"
"|G (VCCS)           |voltage  |current      |\n"
"|H (CCVS)           |current  |voltage      |\n"
"|I (current source) |time     |current      |\n"
"|L (inductor)       |current  |flux         |\n"
"|R (resistor)       |current  |voltage      |\n"
"|V (voltage source) |time     |voltage      |\n"
"|Y (admittance)     |voltage  |current      |\n"
"|VCCAP              |voltage  |capacitance  |\n"
"|VCG                |voltage  |conductance  |\n"
"|VCR                |voltage  |resistance   |\n"
"|trans-capacitor    |voltage  |charge       |\n"
msgstr ""
"^компонент                                           ^ X            ^ Y              ^\n"
"|**C**     (конденсатор)                             | напряжение   | заряд          |\n"
"|**E**     (ИНУН)                                    | напряжение   | напряжение     |\n"
"|**F**     (ИТУТ)                                    | ток          | ток            |\n"
"|**G**     (ИТУН)                                    | напряжение   | ток            |\n"
"|**H**     (ИНУТ)                                    | ток          | напряжение     |\n"
"|**I**     (источник тока)                           | время        | ток            |\n"
"|**L**     (катушка индуктивности)                   | ток          | магн. поток    |\n"
"|**R**     (резистор)                                | ток          | напряжение     |\n"
"|**V**     (источник напряжения)                     | время        | напряжение     |\n"
"|**Y**     (проводимость)                            | напряжение   | ток            |\n"
"|**VCCAP** (ёмкость,       управляемая напряжением)  | напряжение   | ёмкость        |\n"
"|**VCG**   (проводимость,  управляемая напряжением)  | напряжение   | проводимость   |\n"
"|**VCR**   (сопротивление, управляемое напряжением)  | напряжение   | сопротивление  |\n"
"|**С**     (проходная ёмкость)                       | напряжение   | заряд          |\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:39
msgid "The values of //x// must be in increasing order."
msgstr "Значения //x// должны указываться в порядке возрастания."

#. type: Plain text
#: manual/devices/basic/fit.txt:43
msgid ""
"For \"fit\" if //order// is 1, it is the same as \"pwl\".  If //order// is "
"3, it will use cubic splines.  The result and its first two derivatives are "
"continuous."
msgstr ""
"Если для функции **fit** параметр //order// равен 1, она будет тождественна "
"функции **pwl**.  Если //order// равен 3, будут использоваться кубические "
"сплайны. Результат и его первые две производные будут непрерывными."

#. type: Plain text
#: manual/devices/basic/fit.txt:49
msgid ""
"Outside the specified range, it uses linear extrapolation.  The behavior "
"depends on the parameters //below// and //above//.  The value of //below// "
"or //above// is the derivative to use, which is a resistance for resistors, "
"voltage gain for a VCVS, and so on.  If it is not specified, the value is "
"automatically determined."
msgstr ""
"Вне указанного диапазона используется линейная экстраполяция. Поведение "
"функции зависит от параметров //below// и //above//.  Значением //below// "
"или //above// определяется значение производной, которое должно там "
"использоваться, и для резисторов представляющее собой сопротивление, для "
"ИНУН --- коэффициент усиления по напряжению и т. д.  Если это значение не "
"указано, оно определяется автоматически."

#. type: Plain text
#: manual/devices/basic/fit.txt:53
msgid "These parameters apply to the \"fit\" function only, not \"pwl\"."
msgstr ""
"Следующие параметры относятся только к функции  **fit**, к **pwl** не "
"относятся."

#. type: Plain text
#: manual/devices/basic/fit.txt:57
#, no-wrap
msgid ""
"|order  |The order of the polynomial to fit, within the supplied data.  (Default = 3) Legal values are 0, 1, 2, and 3, only.  For \"pwl\" a value of 1 is assumed.  |\n"
"|below  |The value of the derivative to use below or before the specified range.  |\n"
"|above  |The value of the derivative to use above or after the specified range.  |\n"
msgstr ""
"^ Параметр ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''order'' |  **''3''**  | Порядок полигона для аппроксимации в пределах заданных данных. Допустимыми значениями являются только 0, 1, 2 и 3.  Для **pwl** принимается значение 1  |\n"
"|''below'' | | Значение производной, которую следует использовать ниже или до указанного диапазона  |\n"
"|''above'' | | Значение производной, которую следует использовать выше или после указанного диапазона  |\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:59
msgid ""
"For \"fit\" only, the properties are determined by the value of //order//.  "
"For \"pwl\", order is assumed to be 1."
msgstr ""
"Только для **fit** свойства определяются значением ''order''.  Для **pwl** "
"''order'' принимается равным 1."

#. type: Plain text
#: manual/devices/basic/fit.txt:61
msgid ""
"If \"above\" or \"below\" are not specified, out of range behavior is "
"determined as follows:"
msgstr ""
"Если ''above'' или ''below'' не указаны, поведение вне диапазона "
"определяется следующим образом:"

#. type: Plain text
#: manual/devices/basic/fit.txt:66
#, no-wrap
msgid ""
"|Order = 3\\\\ cubic_splines  |The default is to use \"natural\" splines, which sets the second derivative to zero at the boundary.  If a value of //below// or //above// is specified, \"clamped\" splines will be used.  In any case, there will be a smooth transition at the boundaries.  When using \"clamped\" splines, the second derivative may have a discontinuity at the boundaries.  |\n"
"|Order = 2\\\\ quadratic_splines  |By default, the derivative at the upper end is determined by the slope of the last segment.  This is also the derivative above the range.  Below the range, the derivative determined at the lower bound is used.  It is recommended that only one of //below// and //above// be specified.  If both are specified, the splines are determined using //above//, and there will be a discontinuity in the derivative at the lower bound.  |\n"
"|Order = 1\\\\ piecewise_linear  |For first order (linear) interpolation, the default slope outside the range is the extension of the slope in the end segments.  The parameters //below// and //above// have no effect inside the range.  |\n"
"|Order = 0\\\\ piecewise_constant  |The resulting value is constant over the interval, and hasdiscontinuities at the specified points.  The parameters //below// and //above// are ignored.  The slope is always 0.  |\n"
msgstr ""
"|''Order = 3\\\\ cubic_splines'' |По умолчанию используются «натуральные» сплайны, которые устанавливают вторую производную в ноль на границе. Если указано значение ''below'' или ''above'',  будут использоваться кубические эрмитовы сплайны («clamped spline»). В любом случае на границах будет плавный переход. При использовании таких сплайнов вторая производная может иметь разрывы на границах  |\n"
"|''Order = 2\\\\ quadratic_splines'' |По умолчанию производная в верхнем конце определяется наклоном последнего сегмента. Это будет также производной выше диапазона. Ниже диапазона используется производная, определённая в нижней грaнице. Рекомендуется указывать только один из параметров ''below'' или ''above''. Если указать оба, сплайны будут определяться посредством ''above'' и в нижней границе диапазона будет разрыв производной  |\n"
"|''Order = 1\\\\ piecewise_linear'' |Для интерполяции первого порядка (линейной) наклон кривой вне диапазона по умолчанию определяется как продолжение наклона в конечных сегментах. Внутри диапазона параметры ''below'' и ''above'' никакого действия не имеют  |\n"
"|''Order = 0\\\\ piecewise_constant'' |Результирующее значение является константой на всём интервале и имеет разрывы в указанных точках.  Параметры ''below'' и ''above'' игнорируются.  Наклон всегда равен 0  |\n"

#. type: Plain text
#: manual/devices/basic/fit.txt:70
msgid ""
"The \"pwl\" function participates in time step control only if the device is "
"a fixed source.  In this case, the corners in are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times."
msgstr ""
"Функция **pwl** участвует в управлении временным шагом, только если "
"устройство представляет собой независимый источник напряжения или тока. В "
"этом случае начальные и конечные точки считаются аналоговыми событиями. Во "
"[[gnucap:manual:commands:transient.ru|временном анализе]] программа будет "
"пытаться отрегулировать точность выбора моментов времени для этих аналоговых "
"событий.  Если она будет достаточной, временные шаги должны планироваться "
"точно в моменты этих событий. В любом случае временной шаг должен попадать в "
"указанный момент времени с погрешностью не более значения [[gnucap:manual:"
"commands:options.ru|опции]] ''dtmin''."

#. type: Plain text
#: manual/devices/basic/fit.txt:72
msgid ""
"For devices that are not fixed sources, the fit or pwl describes a nonlinear "
"transfer function.  Finding the corresponding times requires analysis of "
"\"cross\" events, which is more difficult and not done yet.  This is "
"considered to be a deficiency, and may be addressed in the future."
msgstr ""
"Для устройств, не являющихся независимыми источниками тока или напряжения, "
"**fit** или **pwl** описывают нелинейную передаточную функцию. Нахождение "
"соответствующих моментов времени требует анализа событий [[gnucap:manual:"
"measure:cross.ru|пересечений]], что более сложно и пока ещё не реализовано. "
"Это определённо рассматривается как недостаток программы, который может быть "
"устранён в будущем."

#. type: Plain text
#: manual/devices/basic/fit.txt:83
#, no-wrap
msgid ""
"  C1 (2 0) fit (-5,-5u 0,0 1,1u 4,2u 5,2u) order=1\n"
"This \"capacitor\" stores 5 microcoulombs at -5 volts (negative,\n"
"corresponding to the negative voltage, as expected).  The charge\n"
"varies linearly to 0 at 0 volts, acting like a 1 microfarad capacitor.\n"
"(C = dq/dv).  This continues to 1 volt.  The 0,0 point could have been\n"
"left out.  The charge increases only to 2 microcoulombs at 4 volts,\n"
"for an incremental capacitance of 1u/3 or .3333 microfarads.  The same\n"
"charge at 5 volts indicates that it saturates at 2 microcoulombs.  For\n"
"negative voltages, the slope continues.\n"
msgstr ""
"  C1 (2 0) fit (-5,-5u 0,0 1,1u 4,2u 5,2u) order=1\n"
"Данный «конденсатор» при напряжении -5 вольт имеет заряд 5 микрокулон\n"
"(отрицательный заряд соответствует отрицательному напряжению, как и\n"
"следовало ожидать).  Заряд меняется линейно до 0 при 0 вольт, действуя как\n"
"конденсатор ёмкостью в 1 микрофарад (C = dq/du). Это продолжается до\n"
"напряжения в 1 вольт.  Точку 0,0 можно было бы исключить. Далее заряд\n"
"растёт только до 2 микрокулон при напряжении в 4 вольта из-за приращения\n"
"ёмкости, составляющего 1u/3 или 0,3333 микрофарад.  Тот же самый заряд при\n"
"напряжении 5 вольт указывает, что при 2 микрокулонах происходит «насыщение».\n"
"Для отрицательных напряжений наклон характеристики (уменьшение ёмкости с той\n"
"же скоростью) будет продолжаться.\n"

#. type: Title ======
#: manual/devices/basic/generator.txt:1
#, no-wrap
msgid "\"generator\" Signal Generator time dependent value"
msgstr "Функция «generator»: временная зависимость, определяемая генератором сигналов"

#. type: Plain text
#: manual/devices/basic/generator.txt:6
#, no-wrap
msgid "  generator  scale\n"
msgstr "|''**generator** //коэффициент_масштабирования//''|\n"

#. type: Plain text
#: manual/devices/basic/generator.txt:11
msgid ""
"The component \"value\" is dependent on a \"signal generator\", manipulated "
"by the \"generator\" command."
msgstr ""
"Привязка значения величины компонента к значению выхода «генератора "
"сигналов», управляемого командой [[gnucap:manual:commands:generator.ru|"
"generator]]."

#. type: Plain text
#: manual/devices/basic/generator.txt:18
msgid ""
"For transient analysis, the \"value\" is determined by a signal generator, "
"which is considered to be external to the circuit and part of the test "
"bench.  See the \"generator\" command for more information."
msgstr ""
"Для [[gnucap:manual:commands:transient.ru|временного анализа]] указанное "
"значение определяется генератором сигналов, который считается внешним к "
"схеме и частью тестового оборудования.  Подробности см. в [[gnucap:manual:"
"commands:generator.ru|описании команды generator]]."

#. type: Plain text
#: manual/devices/basic/generator.txt:20
msgid "For AC analysis, the value here is the amplitude."
msgstr ""
"Для [[gnucap:manual:commands:ac.ru|частотного анализа]] данное значение "
"определяет амплитуду."

#. type: Plain text
#: manual/devices/basic/generator.txt:25
msgid ""
"Strictly, all of the functionality and more is available through the Spice-"
"like behavioral modeling functions, but this one provides a user interface "
"closer to the function generator that an analog designer would use on a real "
"bench.  It is mainly used for interactive operation."
msgstr ""
"Строго говоря, вся функциональность, и даже более того, доступна через SPICE-"
"подобные функции поведенческого моделирования, но эта функция предоставляет "
"пользовательский интерфейс, более близкий к функциональному генератору, "
"который проектировщик аналоговых схем может использовать на реальном "
"тестовом стенде. В основном она используется для интерактивной работы."

#. type: Plain text
#: manual/devices/basic/generator.txt:27
msgid ""
"It also provides backward compatibility with predecessors to Gnucap, which "
"used a different netlist format."
msgstr ""
"Она также обеспечивает обратную совместимость с предшественниками gnucap, в "
"которых использовался другой формат списков соединений."

#. type: Title ======
#: manual/devices/basic/inline_behavioral_modeling.txt:1
#, no-wrap
msgid "Device behavioral expressions"
msgstr "Поведенческие выражения устройств"

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:2
#: manual/tech/plugins/coding.txt:9
#, no-wrap
msgid "Basics"
msgstr "Основы"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:5
msgid ""
"All simple components can have a behavioral description, with syntax "
"designed as an extension of the Spice time dependent sources.  They are not "
"necessarily physically realizable, but provide useful modeling capability.  "
"Some only work on particular types of analysis, or over a small range of "
"values.  Some can be used together, some cannot."
msgstr ""
"Все простые компоненты могут иметь поведенческое описание, синтаксис "
"которого представляет собой расширение синтаксиса источников напряжения и "
"тока SPICE, имеющих временную зависимость. Такие компоненты не обязательно "
"физически реализуемы, но они предоставляют удобные возможности для "
"моделирования.  Некоторые из них могут работать только в специфических видах "
"анализов или в малых диапазонах значений. Какие-то могут использоваться "
"совместно друг с другом, какие-то нет."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:7
msgid ""
"As of July 2009, these functions only work with Spice or ACS syntax.  They "
"do not work with Verilog or Spectre syntax."
msgstr ""
"На июль 2009 года эти функции работают только при использовании синтаксиса "
"[[gnucap:manual:languages:spice.ru|SPICE]] или [[gnucap:manual:languages:acs."
"ru|ACS]]. Синтаксис [[gnucap:manual:languages:Verilog.ru|Verilog]] или "
"[[gnucap:manual:languages:Spectre.ru|Spectre]] для них не поддерживается."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:9
msgid ""
"All simple components are considered to have simple transformations.  A "
"function returns one parameter as a function of one other, as an extension "
"of their linear behavior.  For behavioral modeling or nonlinear values, "
"replace the constant times input by an arbitrary function."
msgstr ""
"Считается, что все простые компоненты осуществляют простые преобразования. "
"Любая функция в качестве расширения её линейного поведения возвращает один "
"параметр как функцию от какого-то другого. Для реализации поведенческого "
"моделирования или нелинейных значений входной постоянный коэффициент "
"заменяется произвольной функцией."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:19
#, no-wrap
msgid ""
"^Type        ^Linear                              ^Nonlinear                            ^\n"
"|Capacitor   |q = C v                             |q = f(v)                             |\n"
"|Inductor    |Φ = L i                             |Φ = f(i)                             |\n"
"|Resistor    |v = I r                             |v = f(i)                             |\n"
"|Admittance  |i = Y v                             |i = f(v)                             |\n"
"|VCVS        |v<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = f(v<sub>in</sub>)  |\n"
"|VCCS        |i<sub>out</sub> = k v<sub>in</sub>  |v<sub>out</sub> = f(v<sub>in</sub>)  |\n"
"|CCVS        |v<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = f(i<sub>in</sub>)  |\n"
"|CCCS        |i<sub>out</sub> = k i<sub>in</sub>  |v<sub>out</sub> = f(i<sub>in</sub>)  |\n"
msgstr ""
"^Тип                   ^  Линейная\\\\ зависимость            ^  Нелинейная\\\\ зависимость           ^\n"
"|конденсатор           |  q = C u                             |  q = f(u)                             |\n"
"|катушка индуктивности |  Φ = L i                             |  Φ = f(i)                             |\n"
"|резистор              |  u = R i                             |  u = f(i)                             |\n"
"|проводимость          |  i = Y u                             |  i = f(u)                             |\n"
"|ИНУН                  |  u<sub>вых</sub> = k u<sub>вх</sub>  |  u<sub>вых</sub> = f(u<sub>вх</sub>)  |\n"
"|ИТУН                  |  i<sub>вых</sub> = k u<sub>вх</sub>  |  u<sub>вых</sub> = f(u<sub>вх</sub>)  |\n"
"|ИНУТ                  |  u<sub>вых</sub> = k i<sub>вх</sub>  |  u<sub>вых</sub> = f(i<sub>вх</sub>)  |\n"
"|ИТУТ                  |  i<sub>вых</sub> = k i<sub>вх</sub>  |  u<sub>вых</sub> = f(i<sub>вх</sub>)  |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:21
msgid ""
"Gnucap also has some other simple components, which are compatible with some "
"versions of Spice that also have them:"
msgstr ""
"В gnucap имеется ещё несколько других простых компонентов, которые "
"совместимы с некоторыми версиями SPICE, в которых они также есть:"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:26
#, no-wrap
msgid ""
"|voltage controlled resistor    |R = k v<sub>c</sub>                 |R = f(v<sub>c</sub>)   |\n"
"|voltage controlled capacitor   |C = k v<sub>c</sub>                 |C = f(v<sub>c</sub>)   |\n"
"|voltage controlled admittance  |Y = k v<sub>c</sub>                 |Y = f(v<sub>c</sub>)   |\n"
"|trans-capacitor                |q<sub>out</sub> = k v<sub>in</sub>  |q = f(v<sub>in</sub>)  |\n"
msgstr ""
"^ Тип                                     ^  Линейная\\\\ зависимость            ^  Нелинейная\\\\ зависимость  ^\n"
"| сопротивление, управляемое напряжением  |  R = k U<sub>у</sub>                 |  R = f(U<sub>у</sub>)        |\n"
"| ёмкость, управляемая напряжением        |  C = k U<sub>у</sub>                 |  C = f(U<sub>у</sub>)        |\n"
"| проводимость, управляемая напряжением   |  Y = k U<sub>у</sub>                 |  Y = f(U<sub>у</sub>)        |\n"
"| проходная ёмкость                       |  Q<sub>вых</sub> = k U<sub>вх</sub>  |  Q = f(U<sub>вх</sub>)       |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:28
msgid "Sources are defined as functions of time:"
msgstr ""
"Источники напряжения и тока определяются как устройства, имеющие временную "
"зависимость:"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:31
#, no-wrap
msgid ""
"|Voltage source  |v = f(t)  |\n"
"|Current source  |i = f(t)  |\n"
msgstr ""
"^ Тип                ^  Функция   ^\n"
"|Источник напряжения |  u = f(t)  |\n"
"|Источник тока       |  i = f(t)  |\n"

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:32
#, no-wrap
msgid "Verilog and Spectre syntax workaround"
msgstr "Обходные варианты для работы с синтаксисом Verilog и Spectre"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:35
msgid ""
"These functions do not fit with the style of Verilog or Spectre, so they "
"don't work with that syntax.  As a workaround, you can build a subcircuit "
"with Spice syntax, then call it as a component in any syntax."
msgstr ""
"Указанные функции не соответствуют стилю [[gnucap:manual:languages:verilog."
"ru|Verilog]] или [[gnucap:manual:languages:spectre.ru|Spectre]], поэтому они "
"не работают, когда включен синтаксис одного из этих языков. Чтобы обойти это "
"ограничение, можно построить подсхему с использованием синтаксиса [[gnucap:"
"manual:languages:spice.ru|SPICE]], а затем вызывать её как компонент в "
"режиме работы с синтаксисом любого языка."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:42
#, no-wrap
msgid ""
"<code>\n"
"spice\n"
".subckt vsin (p n)\n"
"Vsrc (p n) sin {offset} {amplitude} {frequency} {delay} {damping}\n"
".ends\n"
"verilog\n"
msgstr ""
"<code>\n"
"spice\n"
".subckt vsin (p n)\n"
"Vsrc (p n) sin {offset} {amplitude} {frequency} {delay} {damping}\n"
".ends\n"
"verilog\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:45
msgid "vsin #(.frequency(1K)) vinput (in, 0); </code>"
msgstr "vsin #(.frequency(1K)) vinput (in, 0); </code>"

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:47
#, no-wrap
msgid "Conditionals"
msgstr "Условные выражения"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:50
msgid ""
"Gnucap behavioral modeling conditionals are an extension of the \"AC\" and "
"\"DC\" Spice source parameters."
msgstr ""
"Условные выражения поведенческого моделирования gnucap представляют собой "
"расширения параметров ''AC'' и ''DC'', используемых в SPICE для источников "
"напряжения и тока."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:55
#, no-wrap
msgid ""
"The extensions ...\n"
"  * There are more choices, including an \"else\".\n"
"  * They apply to all elements (primitive components).\n"
"  * Each section can contain functions and options.\n"
msgstr ""
"Расширения:\n"
"  * Имеется больше возможностей выбора, включая ''else''.\n"
"  * Они применяются ко всем элементам (компонентам-примитивам).\n"
"  * Каждый раздел может содержать функции и опции.\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:57
msgid "The following are available:"
msgstr "Доступны следующие параметры:"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:65
#, no-wrap
msgid ""
"|AC    |AC analysis only.         |\n"
"|DC    |DC (steady state) value.  |\n"
"|OP    |OP analysis.              |\n"
"|TRAN  |Transient analysis.       |\n"
"|FOUR  |Fourier analysis only.    |\n"
"|ELSE  |Anything not listed.      |\n"
"|ALL   |Anything not listed.      |\n"
msgstr ""
"|''AC''    | Значение только для [[gnucap:manual:commands:AC.ru|анализа AC]]                        |\n"
"|''DC''    | Значение для [[gnucap:manual:commands:DC.ru|анализа DC]] (расчёт статического режима)  |\n"
"|''OP''    | Значение для [[gnucap:manual:commands:OP.ru|анализа OP]]                               |\n"
"|''TRAN''  | Значение для [[gnucap:manual:commands:transient.ru|временного анализа]]                |\n"
"|''FOUR''  | Значение только для [[gnucap:manual:commands:fourier.ru|анализа Фурье]]                |\n"
"|''ELSE''  | Значение для всего остального, что не указано в строке команды                         |\n"
"|''ALL''   | Значение для всего остального, что не указано в строке команды                         |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:67
msgid ""
"A value or function with no conditional keyword is equivalent to \"ALL\".  "
"For SPICE compatibility, use only \"DC\", \"AC\", or nothing."
msgstr ""
"Указание значения или функции без условного ключевого слова эквивалентно "
"использованию ''ALL''.  Для обеспечения совместимости со SPICE следует "
"использовать только ''DC'', ''AC'' или не использовать ничего."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:69
msgid ""
"They are interpreted like a \"switch\" statement.  In case of a conflict, "
"the last one applies.  A set of precedence rules applies when some keys are "
"missing.  It is SPICE compatible to the extent the features overlap."
msgstr ""
"Указанные параметры интерпретируются как оператор переключения «switch».  В "
"случае конфликта используется последний из них. Когда некоторые ключи "
"отсутствуют, применяется набор правил приоритета. Это совместимо со SPICE в "
"той области, где возможности программ совпадают."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:71
msgid "The following table describes the precedence rules:"
msgstr "В следующей таблице описаны правила приоритета:"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:78
#, no-wrap
msgid ""
"|OP analysis                  |OP, DC, ALL, TRAN, 0        |\n"
"|DC analysis                  |DC, ALL, OP, TRAN, 0        |\n"
"|Transient analysis           |TRAN, ALL, DC, OP, 0        |\n"
"|Fourier analysis             |FOUR, TRAN, ALL, DC, OP, 0  |\n"
"|AC analysis, fixed sources   |AC, 0                       |\n"
"|AC analysis, other elements  |AC, ALL, 0                  |\n"
msgstr ""
"|[[gnucap:manual:commands:OP.ru|Анализ OP]]                                                |''OP'', ''DC'', ''ALL'', ''TRAN'', ''0''        |\n"
"|[[gnucap:manual:commands:DC.ru|Анализ DC]]                                                |''DC'', ''ALL'', ''OP'', ''TRAN'', ''0''        |\n"
"|[[gnucap:manual:commands:transient.ru|Временной анализ]]                                  |''TRAN'', ''ALL'', ''DC'', ''OP'', ''0''        |\n"
"|[[gnucap:manual:commands:Fourier.ru|Анализ Фурье]]                                        |''FOUR'', ''TRAN'', ''ALL'', ''DC'', ''OP'', ''0''  |\n"
"|[[gnucap:manual:commands:AC.ru|Анализ AC]], для независимых источников напряжения и тока  |''AC'', ''0''                       |\n"
"|[[gnucap:manual:commands:AC.ru|Анализ AC]], для других элементов                          |''AC'', ''ALL'', ''0''                  |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:83
#, no-wrap
msgid ""
"  V12 (1 0) AC 1 DC 3\n"
"This voltage source has a value of 1 for AC analysis, 3 for DC.  OP, Transient, and Fourier inherit the DC value.\n"
msgstr ""
"  V12 (1 0) AC 1 DC 3\n"
"Этот источник напряжения имеет значение 1 для анализа [[gnucap:manual:commands:AC.ru|AC]], 3 для [[gnucap:manual:commands:DC.ru|DC]].  [[gnucap:manual:commands:OP.ru|OP]], [[gnucap:manual:commands:Transient.ru|Transient]] и [[gnucap:manual:commands:Fourier.ru|Fourier]] наследуют значение анализа [[gnucap:manual:commands:DC.ru|DC]].\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:86
#, no-wrap
msgid ""
"  R44 (2 3) OP 1 ELSE 1g\n"
"This resistor has a value of 1 ohm for the \"OP\" analysis, 1 gig-ohm for anything else.  This might be useful as the feedback resistor on an op-amp.  Set it to 1 ohm to set the operating point, then 1 gig to measure its open loop characteristics, hiding the fact that the op-amp would probably saturate if it was really left open loop.\n"
msgstr ""
"  R44 (2 3) OP 1 ELSE 1g\n"
"Этот резистор имеет значение 1 Ом для анализа [[gnucap:manual:commands:OP.ru|OP]], 1 ГОм для всего прочего.  Это может быть полезным для использования в качестве резистора обратной связи операционного усилителя.  Для настройки рабочей точки он устанавливается в 1 ом, а затем, для измерения характеристик разомкнутого контура, в 1 гигаом, скрывая тот факт, что если бы этот операционный усилитель был на самом деле оставлен с разомкнутым контуром, он, вероятно, зашёл бы в насыщение.\n"

#. type: Title =====
#: manual/devices/basic/inline_behavioral_modeling.txt:87
#: manual/howto/expressions.txt:56
#, no-wrap
msgid "Functions"
msgstr "Функции"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:90
msgid ""
"Gnucap behavioral modeling functions are an extension of the Spice source "
"time dependent values."
msgstr ""
"Функции поведенческого моделирования gnucap представляют собой расширение "
"время-зависимых значений источников напряжения и тока SPICE."

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:90
#, no-wrap
msgid "The extensions"
msgstr "Расширения"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They apply to all elements (primitive components).\n"
msgstr "Функции могут применяться для всех элементов (компонентов-примитивов).\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "All accept either Spice compatible order dependent parameters, or easier keyword=value notation.\n"
msgstr "Все функции принимают указание параметров либо совместимым со SPICE образом, где их назначение зависит от порядка задания, либо с использованием более лёгкой нотации ''ключевое_слово=значение''.\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "The syntax is identical for all supported components.\n"
msgstr "Для всех поддерживаемых компонентов синтаксис одинаков.\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:96
#, no-wrap
msgid "They work a little different, depending on the type of device:\n"
msgstr "Функции работают немного по-разному в зависимости от типа устройства:\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:101
#, no-wrap
msgid ""
"|Fixed sources  |Time dependent functions are voltage or current as a function of time. They are mostly Spice compatible, with extensions.\\\\ Nonlinear transfer functions use time as the independent variable.  Some may not make sense, but they are there anyway.  |\n"
"|Capacitors and inductors  |Time dependent functions are capacitance or inductance as a function of time.  They are voltage/current conserving, not charge/flux conserving.\\\\ Nonlinear transfer functions are charge or flux as a function of input (voltage or current).  Charge and flux are conserved, and can be probed.  |\n"
"|Resistors and conductances  |Time dependent functions are resistance or conductance as a function of time.\\\\ Nonlinear transfer functions are current or voltage as a function of input (voltage or current).  Resistors define voltage as a function of current.  Conductances define current as a function of voltage.  |\n"
"|Controlled sources  |Time dependent functions are gain (v/v, transconductance, etc) function of time.\\\\ Nonlinear transfer functions are output (voltage or current) as a function of input (voltage or current).  |\n"
msgstr ""
"|Независимые источники напряжения и тока | К время-зависимым функциям относятся напряжение или ток в функции времени. Большей частью они совместимы со SPICE, но имеются расширения.\\\\ В нелинейных передаточных функциях в качестве независимой переменной используется время. Некоторые функции могут не иметь смысла, но так или иначе они есть в наличии.  |\n"
"|Конденсаторы и катушки индуктивности | К время-зависимым функциям относятся ёмкость или индуктивность в функции времени. В них поддерживается сохранение напряжения/тока, а не заряда/магнитного потока.\\\\ Нелинейными передаточными функциями являются зависимости заряда или магнитного потока от входного параметра (напряжения или тока). Заряд и магнитный поток сохраняются и могут быть измерены.  |\n"
"|Резисторы и проводимости   | К время-зависимым функциям относятся сопротивление или проводимость в функции времени.\\\\ Нелинейными передаточными функциями являются зависимости тока или напряжения от входного параметра (напряжения или тока).  Для резисторов напряжение является функцией тока. Для проводимостей ток является функцией напряжения.  |\n"
"|Управляемые источники напряжения и тока | К время-зависимым функциям относятся усиление (коэффициент усиления по напряжению, активная составляющая проходной проводимости и т. д.) в функции времени.\\\\ Нелинейными передаточными функциями являются зависимость выходного параметра (напряжения или тока) от входного (напряжения или тока).  |\n"

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:101
#, no-wrap
msgid "Available functions"
msgstr "Функции, имеющиеся в наличии"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:complex]]  Complex (re, im) value.\n"
msgstr "[[.:complex.ru|complex]]: комплексное значение (re, im);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:exp]] Spice Exp source.  (time dependent value).\n"
msgstr "[[.:exp.ru|exp]]: SPICE-совместимый источник экспоненциального сигнала (функция времени);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit]] Fit a curve with splines.\n"
msgstr "[[.:fit.ru|fit]]: аппроксимация кривой сплайнами;\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:generator]] Value from Generator command.\n"
msgstr "[[.:generator.ru|generator]]: сигнал, выдаваемый [[gnucap:manual:commands:generator.ru|командой generator]];\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:poly]] Polynomial (Spice style).\n"
msgstr "[[.:poly.ru|poly]]: SPICE-совместимая полиномиальная функция;\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:posy]] Posynomial (Like poly, non-integer powers).\n"
msgstr "[[.:posy.ru|posy]]: позиномиальная функция (подобная полиномиальной, но не с целочисленными степенями);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:pulse]] Spice Pulse source.  (time dependent value).\n"
msgstr "[[.:pulse.ru|pulse]]: SPICE-совместимый источник импульсного сигнала (функция времени);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:fit|pwl]] Piece-wise linear.\n"
msgstr "[[.:fit.ru|pwl]]: кусочно-линейная функция;\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sffm]] Spice Frequency Modulation (time dependent value).\n"
msgstr "[[.:sffm.ru|sffm]]: SPICE-совместимый источник частотно-модулированного сигнала (функция времени);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:sin]] Spice Sin source.  (time dependent value).\n"
msgstr "[[.:sin.ru|sin]]: SPICE-совместимый источник синусоидального сигнала (функция времени);\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:114
#, no-wrap
msgid "[[.:tanh]] Hyperbolic tangent transfer function.\n"
msgstr "[[.:tanh.ru|tanh]]: передаточная функция равная гиперболическому тангенсу.\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:117
msgid ""
"In addition, you may name a \"function\" defined by a \".model\" statement.  "
"The following \".model\" types may be used here:"
msgstr ""
"Кроме того, можно указать «функцию» определённую оператором ''.model''. "
"Здесь могут использоваться следующие типы моделей:"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:table]] Fit a curve with splines.\n"
msgstr "[[.:table.ru|table]]: аппроксимация кривой сплайнами;\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:cap]] Spice semiconductor \"capacitor\" model.\n"
msgstr "[[.:cap.ru|cap]]: SPICE-модель полупроводникового «конденсатора»;\n"

#. type: Bullet: '  * '
#: manual/devices/basic/inline_behavioral_modeling.txt:121
#, no-wrap
msgid "[[.:res]] Spice semiconductor \"resistor\" model.\n"
msgstr "[[.:res.ru|res]]: SPICE-модель полупроводникового «резистора».\n"

#. type: Title ====
#: manual/devices/basic/inline_behavioral_modeling.txt:122
#, no-wrap
msgid "Parameters that apply to all functions"
msgstr "Параметры, относящиеся ко всем функциям"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:125
msgid ""
"These parameters are available with all functions.  Some may not make sense "
"in some cases, but they are available anyway."
msgstr ""
"Данные параметры доступны для всех функций. Некоторые из них в некоторых "
"случаях могут не иметь смысла, но они всё равно имеются в наличии."

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:138
#, no-wrap
msgid ""
"|Bandwidth  |AC analysis bandwidth.  (Default = infinity.)  The transfer function is frequency dependent, with a 3 DB point at this frequency.  There is frequency dependent phase shift ranging from 0 degrees at low frequencies to 90 degrees at high frequencies.  The phase shift is 45 degrees at the specified frequency.  AC ANALYSIS ONLY.  |\n"
"|Delay  |AC analysis delay.  (Default = 0.) The signal is delayed by x seconds, effectively by a frequency dependent phase shift.  AC ANALYSIS ONLY.  |\n"
"|Phase  |AC analysis phase.  (Default = 0.)  A fixed phase shift is applied.  This is primarily intended for sources, but applies to all elements.  AC ANALYSIS ONLY.  |\n"
"|IOffset  |Input offset.  (Default = 0.)  A DC offset is added to the \"input\" of the element, before evaluating the function.  |\n"
"|OOffset  |Output offset.  (Default = 0.)  A DC offset is added to the \"output\" of the element, after evaluating the function.  |\n"
"|Scale  |Transfer function scale factor.  (Default = 1.)  The transfer function is multiplied by a constant.  |\n"
"|TNOM  |Nominal temperature.  (Default = .option TNOM) The nominal values apply at this temperature.  |\n"
"|TEMP  |Actual temperature.  (Default = current global simulation temperature.  This is the actual device temperature.  |\n"
"|DTEMP  |Temperature rise over ambient.  (Default = 0.)  The actual device temperature is the global simulation temperature plus \"dtemp\".  |\n"
"|TC1  |First order temperature coefficient.  (Default = 0.)  |\n"
"|TC2  |Second order temperature coefficient.  (Default = 0.)  |\n"
"|IC   |Initial condition.  An initial value, to force at time=0.  The actual parameter applied depends on the component.  (Capacitor voltage, inductor current.  All others ignore it.)  You must use the \"UIC\" option for it to be used.  |\n"
msgstr ""
"^ Параметр      ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''Bandwidth''  |  ''**∞**''  | Рабочая полоса частот для [[gnucap:manual:commands:AC.ru|частотного анализа]]. Передаточная функция является частотно-зависимой и имеющей ослабление в 3 дБ при частоте, равной указанному значению.  Сдвиг фазы зависит от частоты и меняется в диапазоне от 0 градусов на низких частотах до 90 градусов на высоких. Для частоты, равной указанному значению, сдвиг фазы составляет 45 градусов. ТОЛЬКО ДЛЯ [[gnucap:manual:commands:AC.ru|АНАЛИЗА AC]]  |\n"
"|''Delay''      |  ''**0**''  | Задержка для [[gnucap:manual:commands:AC.ru|частотного анализа]]. Сигнал задерживается на указанное количество секунд, фактически посредством сдвига фазы, зависящего от частоты. ТОЛЬКО ДЛЯ [[gnucap:manual:commands:AC.ru|АНАЛИЗА AC]]  |\n"
"|''Phase''      |  ''**0**''  | Фаза для [[gnucap:manual:commands:AC.ru|частотного анализа]]. Используется фиксированный сдвиг фазы. В первую очередь это предусмотрено для источников напряжения и тока, но используется для всех элементов. ТОЛЬКО ДЛЯ [[gnucap:manual:commands:AC.ru|АНАЛИЗА AC]]  |\n"
"|''IOffset''    |  ''**0**''  | Смещение входа. Смещение по постоянному току, добавляемое к «входному» значению элемента до вычисления его функции  |\n"
"|''OOffset''    |  ''**0**''  | Смещение выхода. Смещение по постоянному току, добавляемое к «выходному» значению элемента после вычисления его функции  |\n"
"|''Scale''      |  ''**1**''  | Коэффициент масштабирования передаточной функции. Константа, на которую умножается передаточная функция  |\n"
"|''TNOM''       |  ''**значение [[gnucap:manual:commands:options.ru|опции]] TNOM**''  | Номинальная температура. При этой температуре элементы имеют номинальные значения своих величин  |\n"
"|''TEMP''       |  ''**текущая глобальная температура моделирования**''  | Фактическая температура. Это текущая температура устройства  |\n"
"|''DTEMP''      |  ''**0**''  | Превышение температуры над окружающей. Текущая температура устройства равна сумме глобальной температуры моделирования и данного параметра  |\n"
"|''TC1''        |  ''**0**''  | Температурный коэффициент первого порядка  |\n"
"|''TC2''        |  ''**0**''  | Температурный коэффициент второго порядка  |\n"
"|''IC''         |             | Исходное условие. Исходное значение, которое принудительно должно быть выставлено в нулевой момент времени. Фактически применяемый параметр зависит от компонента.  (Для конденсатора --- напряжение, для катушки индуктивности --- ток. Для все остальных компонентов это значение игнорируется.) Для использования в анализе значения этого параметра необходимо задать опцию ''UIC''  |\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:141
msgid "Temperature adjustments and scaling use the following formula:"
msgstr ""
"Для масштабирования и температурной коррекции значений используется "
"следующая формула:"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:143
#, no-wrap
msgid "  value *= _scale * (1 + _tc1*tempdiff + _tc2*tempdiff*tempdiff)\n"
msgstr "  value *= _scale * (1 + _tc1*tempdiff + _tc2*tempdiff*tempdiff)\n"

#. type: Plain text
#: manual/devices/basic/inline_behavioral_modeling.txt:144
msgid "where ''tempdiff'' is ''t - _tnom''."
msgstr "где значение ''tempdiff'' равно ''t - _tnom''."

#. type: Title ======
#: manual/devices/basic/poly.txt:1
#, no-wrap
msgid "\"poly\" Polynomial nonlinear transfer function"
msgstr "Функция «poly»: полиномиальная нелинейная передаточная функция"

#. type: Plain text
#: manual/devices/basic/poly.txt:7
#, no-wrap
msgid ""
"  poly  c0 c1 c2 c3 ...\n"
"  poly  c0 c1 c2 c3 ... args\n"
msgstr ""
"|''**poly** //c0 c1 c2 c3 ...          //''|\n"
"|''**poly** //c0 c1 c2 c3 ... аргументы//''|\n"

#. type: Plain text
#: manual/devices/basic/poly.txt:11
msgid "Defines a transfer function by a one dimensional polynomial."
msgstr "Определение передаточной функции в виде одномерного полинома."

#. type: Plain text
#: manual/devices/basic/poly.txt:19
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current.  If you have "
"the coefficients defining capacitance or inductance, prepending a \"0\" to "
"the list will turn it into the correct form for Gnucap."
msgstr ""
"Для конденсаторов данная функция определяет зависимость //заряда// от "
"напряжения.  Для катушек индуктивности она определяет зависимость //"
"магнитного потока// от тока.  Для преобразования перечня коэффициентов, "
"определяющих ёмкость или индуктивность, в корректный формат для gnucap, к "
"началу списка следует добавить «0»."

#. type: Plain text
#: manual/devices/basic/poly.txt:22
msgid ""
"For fixed sources, it defines voltage or current as a polynomial function of "
"time."
msgstr ""
"Для независимых источников напряжения и тока данная функция определяет "
"полиномиальную временную зависимость напряжения или тока."

#. type: Plain text
#: manual/devices/basic/poly.txt:24 manual/devices/basic/posy.txt:31
msgid "The transfer function is defined by:"
msgstr "Передаточная функция определяется выражением:"

#. type: Plain text
#: manual/devices/basic/poly.txt:26
#, no-wrap
msgid "  out = c0 + (c1*in) + (c2*in^2) + ....\n"
msgstr "  выходная_величина = c0 + (c1*входная_величина) + (c2*входная_величина^2) + ...\n"

#. type: Plain text
#: manual/devices/basic/poly.txt:32
#, no-wrap
msgid ""
"|min  |Minimum output value (clipping).  (Default = -infinity)  |\n"
"|max  |Maximum output value (clipping).  (Default = infinity)  |\n"
"|abs  |Absolute value, truth value.  (Default = false).  If set to true, the result will be always positive.  |\n"
msgstr ""
"^ Параметр      ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''min''        |  **''-∞''**     | Минимальное  значение выходной величины (ограничение).  |\n"
"|''max''        |  **''+∞''**     | Максимальное значение выходной величины (ограничение).  |\n"
"|''abs''        |  **''false''**  | Модуль числа (параметр логического типа). Если установлено в ''true'', результат будет всегда положительным.  |\n"

#. type: Plain text
#: manual/devices/basic/poly.txt:36
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise."
msgstr ""
"Эта функция не участвует напрямую в управлении временным шагом, за "
"исключением варианта, когда устройство настаивает на обратном."

#. type: Title ======
#: manual/devices/basic/posy.txt:1
#, no-wrap
msgid "\"posy\" Polynomial with non-integer powers"
msgstr "Функция «posy»: полиномиальная передаточная функция с нецелыми степенями"

#. type: Plain text
#: manual/devices/basic/posy.txt:7
#, no-wrap
msgid ""
"  posy  c1,p1 c2,p2 ...\n"
"  posy  c1,p1 c2,p2 ... args\n"
msgstr ""
"|''**posy** //c1,p1 c2,p2 ...          //''|\n"
"|''**posy** //c1,p1 c2,p2 ... аргументы//''|\n"

#. type: Plain text
#: manual/devices/basic/posy.txt:12
msgid ""
"Defines a transfer function by a one dimensional ``posynomial'', like a "
"polynomial, except that the powers are arbitrary, and usually non-integer."
msgstr ""
"Определение передаточной функции в виде одномерного «позинома», подобного "
"полиному, за тем исключением, что степени членов могут быть произвольными, и "
"обычно нецелыми."

#. type: Plain text
#: manual/devices/basic/posy.txt:16
msgid "There is no corresponding capability in any SPICE that I know of."
msgstr ""
"Насколько мне известно, ни в одной из известных мне реализаций SPICE такой "
"возможности нет."

#. type: Plain text
#: manual/devices/basic/posy.txt:20 manual/devices/basic/tanh.txt:20
msgid ""
"For capacitors, this function defines //charge// as a function of voltage.  "
"For inductors, it defines //flux// as a function of current."
msgstr ""
"Для конденсаторов данная функция определяет зависимость //заряда// от "
"напряжения.  Для катушек индуктивности она определяет зависимость //"
"магнитного потока// от тока."

#. type: Plain text
#: manual/devices/basic/posy.txt:29
msgid ""
"Normal use of this function required positive input (voltage or current).  "
"The result is zero if the input is negative.  Raising a negative number to a "
"non-integer power would produce a complex result, which implies a non-causal "
"result, which cannot be represented in a traditional transient analysis."
msgstr ""
"Для нормального использования этой функции значение входной величины "
"(напряжение или ток) должно быть положительным. При отрицательном входном "
"значении результат равен нулю. Возведение отрицательного числа в нецелую "
"степень дало бы в результате комплексное число, что означает непричинный "
"результат, который не может быть представлен в традиционном временном "
"анализе."

#. type: Plain text
#: manual/devices/basic/posy.txt:39
#, no-wrap
msgid ""
"<code>\n"
"if (in >= 0){\n"
"  out = (c1*in^p1) + (c2*in^p2) + ....\n"
"}else{\n"
"  out = 0.\n"
"}\n"
"</code>\n"
msgstr ""
"<code>\n"
"if (входная_величина >= 0){\n"
"  выходная_величина = (c1*входная_величина^p1) + (c2*входная_величина^p2) + ....\n"
"}else{\n"
"  выходная_величина = 0.\n"
"}\n"
"</code>\n"

#. type: Plain text
#: manual/devices/basic/posy.txt:47
#, no-wrap
msgid ""
"|min   |Minimum output value (clipping).  (Default  = -infinity)  |\n"
"|max   |Maximum output value (clipping).  (Default  = infinity)  |\n"
"|abs   |Absolute value, truth value.  (Default = false).  If set to true, the result will be always positive.  |\n"
"|odd   |Make odd function, truth value.  (Default = false).  If set to true, negative values of x will be evaluated as out = -f(-x), giving odd symmetry.  |\n"
"|even  |Make even function, truth value.  (Default = false).  If set to true, negative values of x will be evaluated as out = f(-x), giving even symmetry.  |\n"
msgstr ""
"^ Параметр      ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''min''   |  **''-∞''**     | Минимальное  значение выходной величины (ограничение)  |\n"
"|''max''   |  **''+∞''**     | Максимальное значение выходной величины (ограничение)  |\n"
"|''abs''   |  **''false''**  | Модуль числа (параметр логического типа).                       При задании ''true'' результат всегда будет положительным  |\n"
"|''odd''   |  **''false''**  | Использовать как нечётную функцию (параметр логического типа).  При задании ''true'' для отрицательных значений ''x'' выходное значение будет равно ''-f(-x)'', давая в результате нечётную симметрию  |\n"
"|''even''  |  **''false''**  | Использовать как   чётную функцию (параметр логического типа).  При задании ''true'' для отрицательных значений ''x'' выходное значение будет равно  ''f(-x)'', давая в результате   чётную симметрию  |\n"

#. type: Plain text
#: manual/devices/basic/posy.txt:51
#, no-wrap
msgid ""
"  E1 (2 0 1 0) posy(1 .5)\n"
"The output of E1 is the square root of its input.\n"
msgstr ""
"  E1 (2 0 1 0) posy(1 .5)\n"
"Выходное значение компонента E1 равно квадратному корню от входного.\n"

#. type: Title ====
#: manual/devices/basic/probes.txt:1
#: manual/devices/lossless_transmission_line.txt:37 manual/howto/probes.txt:1
#: manual/tech/plugins/devices/probes.txt:3
#, no-wrap
msgid "Probes"
msgstr "Датчики"

#. type: Title =====
#: manual/devices/basic/probes.txt:2
#, no-wrap
msgid "All basic elements"
msgstr "Все базовые элементы"

#. type: Plain text
#: manual/devices/basic/probes.txt:5 manual/howto/probes.txt:50
msgid ""
"Most two node elements (capacitors, inductors, resistors, sources) and four "
"terminal elements (controlled sources) have at least the following "
"parameters available. Others are available for some elements."
msgstr ""
"Для большинства двухвыводных элементов (конденсаторов, катушек "
"индуктивности, резисторов, источников напряжения и тока) и четырёхвыводных "
"элементов (управляемых источников напряжения и тока) доступны по крайней "
"мере параметры, указанные ниже. Для некоторых элементов доступны "
"дополнительные параметры."

#. type: Plain text
#: manual/devices/basic/probes.txt:7 manual/howto/probes.txt:52
msgid ""
"Some of these probes do not work for all devices, or all analysis.  It will "
"print \"??\" as the value when it doesn't work."
msgstr ""
"Некоторые из этих датчиков работают не для всех устройств или не для всех "
"видов анализа. Когда датчик не работает, вместо значения выводится «??»."

#. type: Plain text
#: manual/devices/basic/probes.txt:34
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second port.  |\n"
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for four terminal devices. The first node in the net list is assumed positive.  |\n"
"|vin       |Input voltage.  The voltage across the “input” terminals. For two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power indicates that the part is supplying power. Its value is the same as (PD - PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is always positive and does not consider its own dissipation.  |\n"
"|input     |The “input” of the device. It is the current through a resistor or inductor, the voltage across a capacitor or admittance, etc. It is the value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is the voltage across a resistor, the charge stored in a capacitor, the flux in an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is also the effective value of the part, in its units. If the part is ordinary, it will just show its value, but if it is time variant or nonlinear, it shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|z         |Circuit impedance seen by this device, with this device not counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this device.  Prints a meaningless number in transient analysis.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|errortime |Suggestion of next time point based on truncation or interpolation error.  |\n"
"|eventtime |Suggestion of next time point based on movable events.  |\n"
"|timefuture |Suggestion of next time point, the sooner of errortime and eventtime.  |\n"
msgstr ""
"|''v//n//''      | Напряжение порта. ''v2(m2)'' означает напряжение на втором порту  |\n"
"|''v''\\\\ ''vout''  | Напряжение ветви для двухвыводных устройств, выходное напряжение для четырёхвыводных устройств. Первый узел в списке соединений считается положительным  |\n"
"|''vin''         | Входное напряжение. Напряжение на «входных» выводах. Для двухвыводных элементов входное и выходное напряжение одинаковы  |\n"
"|''i''           | Ток ветви. Ток втекает в первый узел списка соединений и вытекает из второго  |\n"
"|''p''           | Мощность. Положительное значение мощности означает её рассеяние. Отрицательное значение означает, что компонент подаёт питание в схему. Значение данного параметра равно ''(pd - ps)''. В анализе [[gnucap:manual:commands:ac.ru|ac]] он представляет только вещественную часть  |\n"
"|''pd''          | Рассеиваемая мощность. Мощность, рассеиваемая в компоненте. Её значение всегда положительно и не включает питание, выдаваемое в схему |\n"
"|''ps''          | Отдаваемая в схему мощность ветви. Мощность, отдаваемая компонентом. Её значение всегда положительно и не учитывает мощности, рассеиваемой в самом компоненте  |\n"
"|''input''       | «Вход» устройства. Это ток через резистор или катушку индуктивности, напряжение на конденсаторе или проводимости и т. д. Это значение, используемое для оценки нелинейностей  |\n"
"|''f''           | Результат оценки функции компонента. Для резистора это падение напряжения, для конденсатора --- сохранённый в нём заряд, для катушки индуктивности --- магнитный поток, и т. д.  |\n"
"|''df''\\\\ ''ev''   | Производная от ''f'' по отношению ко входу. Обычно это также эффективное значение компонента, в единицах его величины. Для обычных компонентов просто отображаются их значения, но для изменяемых во времени или нелинейных компонентов отображаются значения в настоящий момент времени  |\n"
"|''nv''          | Номинальное значение. В большинстве случаев это просто значение, которое является константой, но оно может изменяться для внутренних элементов комплексных устройств  |\n"
"|''eiv''         | Эквивалентное входное напряжение. Напряжение, на основе которого заполняется подматрица  |\n"
"|''y''           | Проводимость подматрицы  |\n"
"|''istamp''      | Ток подматрицы  |\n"
"|''ipassive''    | Пассивная часть тока подматрицы  |\n"
"|''ioffset''     | Часть смещения тока подматрицы  |\n"
"|''iloss''       | Часть потерь тока устройства  |\n"
"|''z''           | Импеданс схемы, видимый со стороны устройства без учёта его самого. Во [[gnucap:manual:commands:transient.ru|временном анализе]] выводится значение, не имеющее смысла  |\n"
"|''zraw''        | Импеданс схемы, видимый со стороны устройства с учётом его самого. Во [[gnucap:manual:commands:transient.ru|временном анализе]] выводится значение, не имеющее смысла  |\n"
"|''dt''          | Время «дельта». Временной шаг для данного устройства  |\n"
"|''dtr''\\\\ ''dtrequired''  |''dt'' требуемое. Значение ''dt'', рекомендуемое для следующего шага  |\n"
"|''time''        | Значение времени, для которого производилось самое последнее вычисление. Обычно это настоящее время  |\n"
"|''timeold''     | Значение времени, для которого производилось предпоследнее вычисление  |\n"
"|''errortime''   | Следующая точка времени, предлагаемая на основе погрешности численного метода («truncation error») или погрешности интерполяции  |\n"
"|''eventtime''   | Следующая точка времени, предлагаемая на основе подвижных событий  |\n"
"|''timefuture''  | Следующая точка времени, предлагаемая как ближайшая из ''errortime'' и ''eventtime''  |\n"

#. type: Plain text
#: manual/devices/basic/probes.txt:37 manual/howto/probes.txt:89
msgid ""
"AC power probes:\\\\ In addition to those listed here, you can add a suffix "
"(M, P, R, I and DB) for magnitude, phase, real part, imaginary part, and "
"decibels, to any valid probe. Negative phase is capacitive. Positive phase "
"is inductive."
msgstr ""
"**Датчики мощности [[gnucap:manual:commands:ac.ru|ac]]**\\\\ В дополнение к "
"перечисленным здесь датчикам, к имени любого допустимого датчика можно "
"добавлять суффиксы ''M'', ''P'', ''R'', ''I'' и ''DB'' для измерения, "
"соответственно, амплитуды, фазы, вещественной части, мнимой части и уровня "
"величины в децибелах. Отрицательная фаза является емкостной. Положительная "
"фаза является индуктивной."

#. type: Plain text
#: manual/devices/basic/probes.txt:42 manual/howto/probes.txt:93
#, no-wrap
msgid ""
"|p   |Real power.  Watts.  |\n"
"|pi  |Reactive (imaginary) power, VAR.  |\n"
"|pm  |Volt amps.  Complex power.  |\n"
"|pp  |Power phase.  Angle between voltage and current.  |\n"
msgstr ""
"|''p''   | Активная мощность, Ватт    |\n"
"|''pi''  | Реактивная мощность, вар   |\n"
"|''pm''  | Комплексная мощность, В·А  |\n"
"|''pp''  | Фаза мощности. Угол между напряжением и током  |\n"

#. type: Title =====
#: manual/devices/basic/probes.txt:42
#, no-wrap
msgid "Capacitors"
msgstr "Конденсаторы"

#. type: Plain text
#: manual/devices/basic/probes.txt:51
#, no-wrap
msgid ""
"|method |A number corresponding to what differentiation method is now being used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = Gear, 4 = trapeuler |\n"
"|q\\\\ qcap\\\\ charge |The charge stored in this capacitor, in Coulombs. |\n"
"|c\\\\ capacitance |The effective capacitance of this device. For a fixed capacitor, it be its value. For a nonlinear capacitor, it is the effective capacitance at this time, or ∂q/∂v. |\n"
"|dcdt |The time derivative of capacitance. For a linear capacitor it will be zero. |\n"
"|dc |The change in capacitance compared to the previous sample. Its primary use is in debugging models and numerical problems. For a linear capacitor it will be zero. |\n"
"|dqdt |The time derivative of charge. Hopefully this is the same as current, but it is calculated a different way and can be used as an accuracy check. |\n"
"|dq |The change in charge compared to the previous sample. Its primary use is in debugging models and numerical problems. |\n"
msgstr ""
"|''method''  | Число, соответствующее методу дифференцирования, используемому в данный момент для этого устройства:\\\\ 0: trapgear\\\\ 1: Euler\\\\ 2: trapezoidal\\\\ 3: Gear\\\\ 4: trapeuler  |\n"
"|''q''\\\\ ''qcap''\\\\ ''charge'' | Заряд сохранённый в данном конденсаторе, в кулонах  |\n"
"|''c''\\\\ ''capacitance'' | Эффективная ёмкость данного устройства. Для конденсатора постоянной ёмкости датчик представляет значение её величины. Для нелинейного конденсатора это его эффективная ёмкость в данный момент времени, или ∂q/∂v  |\n"
"|''dcdt''    | Производная от ёмкости по времени. Для линейного конденсатора она будет равна нулю  |\n"
"|''dc''      | Изменение ёмкости по сравнению с предыдущим отсчётом. Данный датчик используется в основном для отладки моделей и проблем с численными методами. Для линейного конденсатора его значение будет равно нулю  |\n"
"|''dqdt''    | Производная от заряда по времени. Надо надеяться, что это то же самое, что и ток, но это значение рассчитывается по-другому и может использоваться для проверки точности вычислений  |\n"
"|''dq''      | Изменение заряда по сравнению с предыдущим отсчётом. Данный датчик используется в основном для отладки моделей и проблем с численными методами  |\n"

#. type: Title =====
#: manual/devices/basic/probes.txt:52
#, no-wrap
msgid "Inductors"
msgstr "Катушки индуктивности"

#. type: Plain text
#: manual/devices/basic/probes.txt:60
#, no-wrap
msgid ""
"|method |A number corresponding to what differentiation method is now being used for this device.\\\\ 0 = trapgear, 1 = Euler, 2 = trapezoidal, 3 = Gear, 4 = trapeuler |\n"
"|flux |The flux linkages stored in this inductor, in Weber-turns. |\n"
"|L\\\\ inductance |The effective inductance of this device. For a fixed inductor, it be its value. For a nonlinear inductor, it is the effective inductance at this time, or ∂ϕ/∂v. |\n"
"|dldt |The time derivative of inductance. For a linear inductor it will be zero. |\n"
"|dl |The change in inductance compared to the previous sample. Its primary use is in debugging models and numerical problems. For a linear inductor it will be zero. |\n"
"|dfdt |The time derivative of flux. Hopefully this is the same as voltage, but it is calculated a different way and can be used as an accuracy check. |\n"
"|dflux |The change in flux linkages compared to the previous sample. Its primary use is in debugging models and numerical problems. |\n"
msgstr ""
"|''method''  | Число, соответствующее методу дифференцирования, используемому в данный момент для этого устройства:\\\\ 0: trapgear\\\\ 1: Euler\\\\ 2: trapezoidal\\\\ 3: Gear\\\\ 4: trapeuler  |\n"
"|''flux''    | Потокосцепление, запасённое в данной катушке индуктивности, в Веберах (Вебер-витках)  |\n"
"|''L''\\\\ ''inductance'' | Эффективная индуктивность данного устройства. Для катушки постоянной индуктивности датчик представляет значение её величины. Для нелинейной катушки индуктивности это её эффективная индуктивность в данный момент времени, или ∂ϕ/∂v  |\n"
"|''dldt''    | Производная от индуктивности по времени. Для линейной катушки индуктивности она будет равна нулю  |\n"
"|''dl''      | Изменение индуктивности по сравнению с предыдущим отсчётом. Данный датчик используется в основном для отладки моделей и проблем с численными методами. Для линейной катушки индуктивности его значение будет равно нулю  |\n"
"|''dfdt''    | Производная от магнитного потока по времени. Надо надеяться, что это то же самое, что и напряжение, но это значение рассчитывается по-другому и может использоваться для проверки точности вычислений  |\n"
"|''dflux''   | Изменение потокосцепления по сравнению с предыдущим отсчётом. Данный датчик используется в основном для отладки моделей и проблем с численными методами  |\n"

#. type: Title ======
#: manual/devices/basic/pulse.txt:1
#, no-wrap
msgid "\"pulse\" Pulsed time dependent value"
msgstr "Функция «pulse»: импульсная временная зависимость"

#. type: Plain text
#: manual/devices/basic/pulse.txt:7
#, no-wrap
msgid ""
"  pulse args\n"
"  pulse iv pv delay rise fall width period\n"
msgstr ""
"|''**pulse** //аргументы//                         ''|\n"
"|''**pulse** //iv pv delay rise fall width period//''|\n"

#. type: Plain text
#: manual/devices/basic/pulse.txt:11
msgid "The component value is a pulsed function of time."
msgstr ""
"Задание значения компонента в виде импульсной функции времени (меандра)."

#. type: Plain text
#: manual/devices/basic/pulse.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice \"pulse\" "
"function, with some extensions."
msgstr ""
"Для источников напряжения и тока функция тождественна одноимённой функции в "
"SPICE, но имеет некоторые расширения."

#. type: Plain text
#: manual/devices/basic/pulse.txt:17
msgid "The shape of a single pulse is described by the following algorithm:"
msgstr "Форма одиночного импульса описывается следующим алгоритмом:"

#. type: Plain text
#: manual/devices/basic/pulse.txt:38
#, no-wrap
msgid ""
"<code>\n"
"if (time > _delay+_rise+_width+_fall){\n"
"  // past pulse\n"
"  ev = _iv;\n"
"}else if (time > _delay+_rise+_width){\n"
"  // falling\n"
"  interp=(time-(_delay+_rise+_width))/_fall;\n"
"  ev = _pv + interp * (_iv - _pv);\n"
"}else if (time > _delay+_rise){\n"
"  // pulsed value\n"
"  ev = _pv;\n"
"}else if (time > _delay){\n"
"  // rising\n"
"  interp = (time - _delay) / _rise;\n"
"  ev = _iv + interp * (_pv - _iv);\n"
"}else{\n"
"  // initial value\n"
"  ev = _iv;\n"
"}\n"
"</code>\n"
msgstr ""
"<code>\n"
"if (time > _delay+_rise+_width+_fall){\n"
"  // после импульса\n"
"  ev = _iv;\n"
"}else if (time > _delay+_rise+_width){\n"
"  // ниспадающий фронт\n"
"  interp=(time-(_delay+_rise+_width))/_fall;\n"
"  ev = _pv + interp * (_iv - _pv);\n"
"}else if (time > _delay+_rise){\n"
"  // величина импульса\n"
"  ev = _pv;\n"
"}else if (time > _delay){\n"
"  // нарастающий фронт\n"
"  interp = (time - _delay) / _rise;\n"
"  ev = _iv + interp * (_pv - _iv);\n"
"}else{\n"
"  // исходное значение\n"
"  ev = _iv;\n"
"}\n"
"</code>\n"

#. type: Plain text
#: manual/devices/basic/pulse.txt:52
#, no-wrap
msgid ""
"|iv      |Initial value.  (required)  |\n"
"|pv      |Pulsed value.  (required)  |\n"
"|delay   |Rise time delay, seconds.  (Default = 0.)  |\n"
"|rise    |Rise time, seconds.  (Default = 0.)  |\n"
"|fall    |Fall time, seconds.  (Default = 0.)  |\n"
"|width   |Pulse width, seconds.  (Default = 0.)  |\n"
"|period  |Repeat period, seconds.  (Default = infinity.)  |\n"
msgstr ""
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''iv''      |  //обязательный//  | Исходное значение                                    |\n"
"|''pv''      |  //обязательный//  | Величина импульса                                    |\n"
"|''delay''   |  **''0''**         | Выдержка времени до нарастающего фронта, в секундах  |\n"
"|''rise''    |  **''0''**         | Время нарастающего фронта, в секундах                |\n"
"|''fall''    |  **''0''**         | Время ниспадающего фронта, в секундах                |\n"
"|''width''   |  **''0''**         | Ширина импульса, в секундах                          |\n"
"|''period''  |  **''∞''**         | Период повторения, в секундах                        |\n"

#. type: Plain text
#: manual/devices/basic/pulse.txt:55
msgid ""
"The corners in a pulse waveform are considered to be analog events.  The "
"transient analysis will attempt to control timing accuracy of these analog "
"events.  If it is reasonable, a time step should be scheduled at these times "
"exactly.  In any case, there should be a time step within option::dtmin of "
"these times."
msgstr ""
"Начальные и конечные точки импульсного сигнала считаются аналоговыми "
"событиями. Во [[gnucap:manual:commands:transient.ru|временном анализе]] "
"программа будет пытаться отрегулировать точность выбора моментов времени для "
"этих аналоговых событий.  Если она будет достаточной, временные шаги должны "
"планироваться точно в моменты этих событий. В любом случае временной шаг "
"должен попадать в указанный момент времени с погрешностью не более значения "
"[[gnucap:manual:commands:options.ru|опции]] ''dtmin''."

#. type: Title ======
#: manual/devices/basic/sffm.txt:1
#, no-wrap
msgid "\"sffm\" Frequency Modulation time dependent value"
msgstr "Функция «sffm»: временная зависимость в виде частотно-модулированного сигнала"

#. type: Plain text
#: manual/devices/basic/sffm.txt:7
#, no-wrap
msgid ""
"  sffm args\n"
"  sffm offset amplitude carrier modindex signal\n"
msgstr ""
"|''**sffm** //аргументы                               //''|\n"
"|''**sffm** //offset amplitude carrier modindex signal//''|\n"

#. type: Plain text
#: manual/devices/basic/sffm.txt:11
msgid ""
"The component value is a sinusoid, frequency modulated by another sinusoid."
msgstr ""
"Задание значения компонента в виде синусоиды, частотно-модулированной другой "
"синусоидой."

#. type: Plain text
#: manual/devices/basic/sffm.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SFFM "
"function, with some extensions."
msgstr ""
"Для источников напряжения и тока функция тождественна одноимённой функции в "
"SPICE, но имеет некоторые расширения."

#. type: Plain text
#: manual/devices/basic/sffm.txt:17
msgid "The shape of the waveform is described by the following equations:"
msgstr "Форма сигнала описывается следующими уравнениями:"

#. type: Plain text
#: manual/devices/basic/sffm.txt:20
#, no-wrap
msgid ""
"  mod = (_modindex * sin(2*PI*_signal*time));\n"
"  ev = _offset + _amplitude * sin(2*PI*_carrier*time + mod);\n"
msgstr ""
"  mod = (_modindex * sin(2*PI*_signal*time));\n"
"  ev = _offset + _amplitude * sin(2*PI*_carrier*time + mod);\n"

#. type: Plain text
#: manual/devices/basic/sffm.txt:26 manual/devices/basic/sin.txt:44
msgid ""
"The non-Spice parameters (samples, zero, peak) assist in time step control.  "
"The defaults are usually appropriate."
msgstr ""
"Не-SPICE параметры (''samples'', ''zero'', ''peak'') используются для "
"управления временным шагом.  Обычно достаточно использовать значения по "
"умолчанию."

#. type: Plain text
#: manual/devices/basic/sffm.txt:36
#, no-wrap
msgid ""
"|offset     |Output offset.  (Default = 0.)  |\n"
"|amplitude  |Amplitude.  (Default = 1.)  |\n"
"|carrier    |Carrier frequency, Hz.  (required)  |\n"
"|modindex   |Modulation index.  (required)  |\n"
"|signal     |Signal frequency.  (required)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  (Default = true)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = true)  |\n"
msgstr ""
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''offset''     |  **''0''**         | Смещение выходного сигнала                                             |\n"
"|''amplitude''  |  **''1''**         | Амплитуда                                                              |\n"
"|''carrier''    |  //обязательный//  | Частота несущей, Гц                                                    |\n"
"|''modindex''   |  //обязательный//  | Индекс модуляции                                                       |\n"
"|''signal''     |  //обязательный//  | Частота сигнала                                                        |\n"
"|''samples''    |  **''4''**         | Минимальное число отсчётов на период                                   |\n"
"|''zero''       |  **''true''**      | Флажок: синхронизация внутренних временных шагов с пересечениями нуля  |\n"
"|''peak''       |  **''true''**      | Флажок: синхронизация внутренних временных шагов с экстремумами        |\n"

#. type: Plain text
#: manual/devices/basic/sffm.txt:40
msgid ""
"The ability to accurately determine instantaneous frequency is important, so "
"SFFM plays a significant role in time step control.  When using SFFM, "
"frequency is always changing, which can make step control difficult."
msgstr ""
"Возможность точного определения мгновенной частоты важна, поэтому **sffm** "
"играет существенную роль в управлении временным шагом. При использовании "
"**sffm** частота постоянно меняется, что может затруднить управление шагом."

#. type: Plain text
#: manual/devices/basic/sffm.txt:42
msgid ""
"By default, both zero crossings and peaks are considered to be analog "
"events.  The transient analysis will attempt to control timing accuracy of "
"these analog events.  If it is reasonable, a time step should be scheduled "
"at these times exactly.  In any case, there should be a time step within "
"option::dtmin of these times.  This means, by default, there will be at "
"least 4 time steps per cycle, synchronized with zero crossings and peaks."
msgstr ""
"По умолчанию и пересечения нуля, и экстремумы считаются аналоговыми "
"событиями. Во [[gnucap:manual:commands:transient.ru|временном анализе]] "
"программа будет пытаться отрегулировать точность выбора моментов времени для "
"этих аналоговых событий. Если она будет достаточной, временные шаги должны "
"планироваться точно в моменты этих событий. В любом случае временной шаг "
"должен попадать в указанный момент времени с погрешностью не более значения "
"[[gnucap:manual:commands:options.ru|опции]] ''dtmin''. Это значит, что по "
"умолчанию будет не меньше 4 временных шагов на период, синхронизированных с "
"пересечениями нуля и экстремумами."

#. type: Plain text
#: manual/devices/basic/sffm.txt:44
msgid ""
"There is also, a smoothness requirement, controlled by the parameter "
"\"samples\".  By default, there will be at least 4 samples per cycle.  This "
"is independent of the placement of samples at zeros and peaks, but usually "
"does not add samples."
msgstr ""
"Существует также требование гладкости, настраиваемое параметром "
"''samples''.  По умолчанию используется по меньшей мере 4 отсчёта на период. "
"Это не зависит от помещения отсчётов в точки нулевых значений и экстремумов, "
"но обычно больше отсчётов не добавляется."

#. type: Plain text
#: manual/devices/basic/sffm.txt:46
msgid ""
"If exact timing is not critical, you can often improve run speed by setting "
"\"zero\" or \"peak\" or both to false.  Doing this allows the time stepping "
"to be more consistent, which is usually faster even if the number of steps "
"is not reduced."
msgstr ""
"Если точная синхронизация по времени не критична, скорость работы часто "
"можно увеличить, установив ''zero'', ''peak'' или оба этих параметра в "
"''false''. Это позволяет производить более согласованный выбор временного "
"шага, что обычно приводит к увеличению скорости работы, даже если количество "
"шагов не уменьшается."

#. type: Plain text
#: manual/devices/basic/sffm.txt:47 manual/devices/basic/sin.txt:66
msgid ""
"If you need improved waveform smoothness, you can do this by increasing "
"\"samples\"."
msgstr ""
"Если нужно добиться большей гладкости сигнала, то это можно сделать, "
"увеличив значение ''samples''."

#. type: Title ======
#: manual/devices/basic/sin.txt:1
#, no-wrap
msgid "\"sin\" Sinusoidal time dependent value"
msgstr "Функция «sin»: синусоидальная временная зависимость"

#. type: Plain text
#: manual/devices/basic/sin.txt:7
#, no-wrap
msgid ""
"  sin args\n"
"  sin offset amplitude frequency delay damping\n"
msgstr ""
"|''**sin** //аргументы//''                               |\n"
"|''**sin** //offset amplitude frequency delay damping//''|\n"

#. type: Plain text
#: manual/devices/basic/sin.txt:11
msgid ""
"The component value is a sinusoidal function of time, with optional "
"exponential decay."
msgstr ""
"Задание значения компонента в виде синусоидальной функции времени с "
"необязательным экспоненциальным затуханием."

#. type: Plain text
#: manual/devices/basic/sin.txt:15
msgid ""
"For voltage and current sources, this is the same as the Spice SIN function, "
"with some extensions."
msgstr ""
"Для источников напряжения и тока функция тождественна одноимённой функции в "
"SPICE, но имеет некоторые расширения."

#. type: Plain text
#: manual/devices/basic/sin.txt:17
msgid "It generates either a steady sinusoid, or a damped sinusoid."
msgstr "Она генерирует или постоянную синусоиду, или затухающую синусоиду."

#. type: Plain text
#: manual/devices/basic/sin.txt:22
msgid ""
"If //delay// and //damping// are both zero, you get a steady sine wave at "
"the specified //frequency//.  Otherwise, you get a damped pulsed sine wave, "
"starting after //delay// and damping out with a time constant of 1/damping."
msgstr ""
"Если параметры ''delay'' и ''damping'' оба равны нулю, функция выдаст "
"неизменный синусоидальный сигнал заданной частоты ''frequency''. В противном "
"случае будет затухающий пульсирующий синусоидальный сигнал, начинающийся "
"после задержки ''delay'' и затухающий с постоянной времени ''1/damping''."

#. type: Plain text
#: manual/devices/basic/sin.txt:37
#, no-wrap
msgid ""
"<code>\n"
"reltime = time - _delay\n"
"if (reltime > 0.) {\n"
"  ev = _amplitude * sin(2*PI*_freq*reltime);\n"
"  if (_damping != 0.){\n"
"    ev *= exp(-reltime*_damping);\n"
"  }\n"
"  ev += _offset;\n"
"}else{\n"
"  ev = _offset;\n"
"}\n"
"</code>\n"
msgstr ""
"<code>\n"
"reltime = time - _delay\n"
"if (reltime > 0.) {\n"
"  ev = _amplitude * sin(2*PI*_freq*reltime);\n"
"  if (_damping != 0.){\n"
"    ev *= exp(-reltime*_damping);\n"
"  }\n"
"  ev += _offset;\n"
"}else{\n"
"  ev = _offset;\n"
"}\n"
"</code>\n"

#. type: Plain text
#: manual/devices/basic/sin.txt:54
#, no-wrap
msgid ""
"|offset     |DC offset.  (Default = 0.)  |\n"
"|amplitude  |Peak amplitude.  (Default = 1.)  |\n"
"|frequency  |Frequency, Hz.  (required)  |\n"
"|delay      |Turn on delay, seconds.  (Default = 0.)  |\n"
"|damping    |Damping factor, 1/seconds.  (Default = 0.)  |\n"
"|samples    |Minimum number of samples per cycle.  (Default = 4)  |\n"
"|zero       |Flag: Synchronize internal time steps to zero crossings.  (Default = false)  |\n"
"|peak       |Flag: Synchronize internal time steps to peaks.  (Default = false)  |\n"
msgstr ""
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''offset''     |  **''0''**         | Постоянное смещение                                                    |\n"
"|''amplitude''  |  **''1''**         | Максимальная амплитуда                                                 |\n"
"|''frequency''  |  //обязательный//  | Частота, Гц                                                            |\n"
"|''delay''      |  **''0''**         | Задержка по включению, с                                               |\n"
"|''damping''    |  **''0''**         | Коэффициент затухания, 1/с                                             |\n"
"|''samples''    |  **''4''**         | Минимальное число отсчётов на период                                   |\n"
"|''zero''       |  **''false''**     | Флажок: синхронизация внутренних временных шагов с пересечениями нуля  |\n"
"|''peak''       |  **''false''**     | Флажок: синхронизация внутренних временных шагов с экстремумами        |\n"

#. type: Plain text
#: manual/devices/basic/sin.txt:58
msgid ""
"For SIN, frequency is constant, so the default settings give preference to "
"waveform smoothness over timing."
msgstr ""
"Для функции **sin** частота постоянна, поэтому в настройках по умолчанию "
"предпочтение отдаётся гладкости формы сигнала, которая имеет приоритет над "
"синхронизацией его по времени."

#. type: Plain text
#: manual/devices/basic/sin.txt:60
msgid ""
"There is a smoothness requirement, controlled by the parameter \"samples\".  "
"By default, there will be at least 4 samples per cycle.  This is independent "
"of the placement of samples at zeros and peaks, but usually does not add "
"samples."
msgstr ""
"Существует также требование гладкости, настраиваемое параметром "
"''samples''.  По умолчанию будет не меньше 4 отсчётов на период. Это не "
"зависит от помещения отсчётов в точки нулевых значений и экстремумов, но "
"обычно больше отсчётов не добавляется."

#. type: Plain text
#: manual/devices/basic/sin.txt:62
msgid ""
"If you set the parameters \"zero\" and \"peak\" to true, both zero crossings "
"and peaks are considered to be analog events.  The transient analysis will "
"attempt to control timing accuracy of these analog events.  If it is "
"reasonable, a time step should be scheduled at these times exactly.  In any "
"case, there should be a time step within option::dtmin of these times. These "
"steps are forced regardless of steps required for smoothness."
msgstr ""
"Если установить параметры ''zero'' и ''peak'' равными ''true'', и "
"пересечения нуля, и достижения экстремумов будут считаться аналоговыми "
"событиями. Во [[gnucap:manual:commands:transient.ru|временном анализе]] "
"программа будет пытаться отрегулировать точность выбора моментов времени для "
"этих аналоговых событий. Если она будет достаточной, временные шаги должны "
"планироваться точно в моменты этих событий. В любом случае временной шаг "
"должен попадать в указанный момент времени с погрешностью не более значения "
"[[gnucap:manual:commands:options.ru|опции]] ''dtmin''. Эти шаги задаются "
"принудительно вне зависимости от шагов, необходимых для обеспечения "
"гладкости."

#. type: Plain text
#: manual/devices/basic/sin.txt:64
msgid ""
"\"Zero\" and \"peak\" are false by default, which allows time stepping to be "
"more consistent, improving run speed."
msgstr ""
"''Zero'' и ''peak'' по умолчанию равны ''false'', что позволяет производить "
"более согласованный выбор временного шага, что, в свою очередь, приводит к "
"увеличению скорости работы."

#. type: Plain text
#: manual/devices/basic/sin.txt:68
msgid "If you need timing accuracy, set \"zero\" and/or \"peak\" to true."
msgstr ""
"Если необходима точность синхронизации по времени, ''zero'' и/или ''peak'' "
"следует установить равными ''true''."

#. type: Title ======
#: manual/devices/basic/tanh.txt:1
#, no-wrap
msgid "\"tanh\" Hyperbolic tangent transfer function"
msgstr "Функция «tanh»: передаточная функция равная гиперболическому тангенсу"

#. type: Plain text
#: manual/devices/basic/tanh.txt:7
#, no-wrap
msgid ""
"  tanh gain limit\n"
"  tanh args\n"
msgstr ""
"|''**tanh** //gain limit//''|\n"
"|''**tanh** //аргументы// ''|\n"

#. type: Plain text
#: manual/devices/basic/tanh.txt:11
msgid "Defines a hyperbolic tangent, or soft limiting, transfer function."
msgstr ""
"Определение передаточной функции в виде функции гиперболического тангенса "
"или мягкого ограничения."

#. type: Plain text
#: manual/devices/basic/tanh.txt:16
msgid ""
"There is no corresponding capability in any SPICE that I know of, but you "
"can get close with POLY."
msgstr ""
"Насколько мне известно, ни в одной из известных мне реализаций SPICE такой "
"возможности нет, но с помощью [[gnucap:manual:devices:basic:poly.ru|poly]] "
"можно добиться довольно близких результатов."

#. type: Plain text
#: manual/devices/basic/tanh.txt:23
msgid ""
"For fixed sources, it defines voltage or current as a function of time, "
"which is probably not useful."
msgstr ""
"Для независимых источников напряжения и тока функция определяет временную "
"зависимость напряжения или тока, которая, вероятно, никому не нужна."

#. type: Plain text
#: manual/devices/basic/tanh.txt:27
msgid ""
"This function describes a hyperbolic tangent transfer function similar to "
"what you get with a single stage push-pull amplifier, or a simple CMOS "
"inverter acting as an amplifier."
msgstr ""
"Передаточная функция, равная гиперболическому тангенсу, подобна тому, что "
"получается на выходе однокаскадного двухтактного усилителя, или простого "
"КМОП-инвертора, работающего как усилитель."

#. type: Plain text
#: manual/devices/basic/tanh.txt:31
#, no-wrap
msgid ""
"|gain   |The small signal gain at 0 bias.  (Required)  |\n"
"|limit  |Maximum output value (soft clipping).  (Required)  |\n"
msgstr ""
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''gain ''  |  //обязательный//  |Коэффициент усиления в режиме малого сигнала при нулевом смещении  |\n"
"|''limit''  |  //обязательный//  |Величина максимального выходного значения (мягкое ограничение)     |\n"

#. type: Plain text
#: manual/devices/basic/tanh.txt:35
msgid ""
"This function does not directly participate in time step control, except as "
"the device would otherwise.  This is considered to be a deficiency, and may "
"be addressed in the future."
msgstr ""
"Эта функция не участвует напрямую в управлении временным шагом, за "
"исключением варианта, когда устройство настаивает на обратном. Это "
"определённо рассматривается как недостаток программы, который может быть "
"устранён в будущем."

#. type: Plain text
#: manual/devices/basic/tanh.txt:42
#, no-wrap
msgid ""
"  E1 (2 0 1 0) tanh gain=-10 limit=2 ioffset=2.5 ooffset=2.5\n"
"This gain block has a small signal gain of -10.  The input is\n"
"centered around 2.5 volts.  The output is also centered at 2.5 volts.\n"
"It \"clips\" softly at 2 volts above and below the output center, or\n"
"at .5 volts (2.5 - 2) and 4.5 volts (2.5 + 2).\n"
msgstr ""
"  E1 (2 0 1 0) tanh gain=-10 limit=2 ioffset=2.5 ooffset=2.5\n"
"Этот усилитель имеет коэффициент усиления в режиме малого сигнала равный -10. Входной сигнал\n"
"смещён на 2,5 вольт.  Выходной сигнал также отцентрирован относительно 2,5 вольт.\n"
"В усилителе производится «мягкая обрезка» при напряжениях на 2 вольта выше и ниже центра выходного сигнала, то есть при\n"
"0,5 вольт (2,5 - 2) и 4,5 вольт (2,5 + 2).\n"

#. type: Title ======
#: manual/devices/capacitor.txt:1
#, no-wrap
msgid "Capacitor, advanced"
msgstr "Конденсатор, расширенный формат"

#. type: Title =====
#: manual/devices/capacitor.txt:3
#, no-wrap
msgid "Syntax: instance"
msgstr "Синтаксис экземпляра"

#. type: Plain text
#: manual/devices/capacitor.txt:10
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n– value\n"
"  Cxxxxxxx n+ n– expression\n"
"  Cxxxxxxx n+ n– value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""
"|''**C**//xxxxxxx// //n+ n– значение//                              ''|\n"
"|''**C**//xxxxxxx// //n+ n– выражение//                             ''|\n"
"|''**C**//xxxxxxx// //n+ n– значение// {IC=//начальное_напряжение//}''|\n"
"|''**C**//xxxxxxx// //n+ n– модель// {L=//длина//} {W=//ширина//} {TEMP=//температура//} {IC=//начальное_напряжение//}''|\n"

#. type: Plain text
#: manual/devices/capacitor.txt:16
#, no-wrap
msgid ""
"  Cxxxxxxx n+ n– capacitor C=value\n"
"  Cxxxxxxx n+ n– capacitor expression\n"
"  Cxxxxxxx n+ n– capacitor C=value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""
"|''**C**//xxxxxxx// //n+ n–// capacitor C=//значение//                              ''|\n"
"|''**C**//xxxxxxx// //n+ n–// capacitor //выражение//                               ''|\n"
"|''**C**//xxxxxxx// //n+ n–// capacitor C=//значение// {IC=//начальное_напряжение//}''|\n"
"|''**C**//xxxxxxx// //n+ n–// //модель// {L=//длина//} {W=//ширина//} {TEMP=//температура//} {IC=//начальное_напряжение//}''|\n"

#. type: Plain text
#: manual/devices/capacitor.txt:23
#, no-wrap
msgid ""
"  capacitor #(.c(value))\n"
"  Cxxxxxxx n+ n– value\n"
"  Cxxxxxxx n+ n– expression\n"
"  Cxxxxxxx n+ n– value {IC=initial-voltage}\n"
"  Cxxxxxxx n+ n– model {L=length} {W=width} {TEMP=temperature} {IC=initial-voltage}\n"
msgstr ""
"|''**capacitor** #(.c(//значение//))                                    ''|\n"
"|''**C**//xxxxxxx// //n+ n–// //значение//                              ''|\n"
"|''**C**//xxxxxxx// //n+ n–// //выражение//                             ''|\n"
"|''**C**//xxxxxxx// //n+ n–// //значение// {IC=//начальное_напряжение//}''|\n"
"|''**C**//xxxxxxx// //n+ n–// //модель// {L=//длина//} {W=//ширина//} {TEMP=//температура//} {IC=//начальное_напряжение//}''|\n"

#. type: Plain text
#: manual/devices/capacitor.txt:31
#, no-wrap
msgid ""
"  .capacitor label n+ n– expression\n"
"Model (optional)\n"
".model mname C {args}\n"
" .model mname TABLE {args}\n"
msgstr ""
"|''**.capacitor** обозначение n+ n– выражение''|\n"
"Модель (наличие не обязательно):\n"
"|''**.model** //имя_модели// C     {//аргументы//}''|\n"
"|''**.model** //имя_модели// TABLE {//аргументы//}''|\n"

#. type: Plain text
#: manual/devices/capacitor.txt:35
msgid "Capacitor, or general charge storage element."
msgstr "Конденсатор или общий элемент хранения заряда."

#. type: Plain text
#: manual/devices/capacitor.txt:38
msgid ""
"N+ and n– are the positive and negative element nodes, respectively. Value "
"is the capacitance in Farads."
msgstr ""
"//''n+''// и //''n–''// представляют собой соответственно положительный и "
"отрицательный узлы элемента. Значением компонента является ёмкость в фарадах."

#. type: Plain text
#: manual/devices/capacitor.txt:40
msgid ""
"The (optional) initial condition is the initial (time = 0) value of the "
"capacitor voltage (in Volts). Note that the initial conditions (if any) "
"apply only if the UIC option is specified on the transient command."
msgstr ""
"Начальным (необязательным) условием является начальное (в момент времени "
"равный 0) значение напряжения конденсатора (в вольтах). Учтите, что "
"начальные условия (если они вообще заданы) применяются только в том случае, "
"когда в строке команды [[gnucap:manual:commands:transient.ru|transient]] "
"указана опция ''UIC''."

#. type: Plain text
#: manual/devices/capacitor.txt:43
msgid ""
"You may specify the value in any of these forms: A simple value. This is the "
"capacitance in Farads."
msgstr ""
"Значение можно задавать в одном из следующих видов:\n"
"\n"
"просто как значение. Это будет ёмкость в фарадах;"

#. type: Plain text
#: manual/devices/capacitor.txt:45
msgid ""
"An expression, as described in the behavioral modeling chapter. The "
"expression can specify the charge as a function of voltage, or the "
"capacitance as a function of time."
msgstr ""
"в виде выражения, как описано [[gnucap:manual:devices:basic:"
"inline_behavioral_modeling.ru|в главе по поведенческому моделированию]]. В "
"этом выражении может определяться заряд в виде функции напряжения, или "
"ёмкость в виде функции времени;"

#. type: Plain text
#: manual/devices/capacitor.txt:47
msgid ""
"A model, as described in the behavioral modeling chapter. The table model "
"describes a table of charge vs. voltage."
msgstr ""
"в виде модели, как описано [[gnucap:manual:devices:basic:"
"inline_behavioral_modeling.ru|в главе по поведенческому моделированию]]. В "
"табличной модели (''TABLE'') находится таблица соответствия зарядов и "
"напряжений;"

#. type: Plain text
#: manual/devices/capacitor.txt:48
msgid ""
"A model, which calculates the capacitance as a function of length and width, "
"referencing a .model statement of type C. This is compatible with the "
"Spice-3 “semiconductor capacitor”."
msgstr ""
"в виде модели, для которой ёмкость рассчитывается в зависимости от длины и "
"ширины, ссылающейся на оператор ''.model'' типа ''C''. Это совместимо с "
"«полупроводниковым конденсатором» SPICE-3."

#. type: Title ======
#: manual/devices/lossless_transmission_line.txt:1
#, no-wrap
msgid "Transmission Line"
msgstr "Линия передачи"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:6
#, no-wrap
msgid "  Txxxxxxx (n1+ n1- n2+ n2-) args\n"
msgstr "|''**T**//xxxxxxx// (//n1+ n1- n2+ n2-//) //аргументы//''|\n"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:10
msgid "Lossless transmission line."
msgstr "Линия передачи без потерь."

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:14
msgid ""
"n1+ and n1- are the nodes at one end.  n2+ and n2- are the nodes at the "
"other end."
msgstr ""
"''n1+'' и ''n1-'' --- узлы концов с одной стороны линии.  ''n2+'' и ''n2-'' "
"--- узлы с другой стороны."

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:21
msgid ""
"The parameters TD, Freq, and NL determine the length of the line.  Either "
"{\\tt TD} or {\\tt Freq} and {\\tt NL} must be specified.  If only {\\tt "
"Freq} is specified, {\\tt NL} is assumed to be .25.  The other will be "
"calculated based on the one you specify.  If you specify too many "
"parameters, {\\tt Freq} and {\\tt NL} dominate, and a warning is issued."
msgstr ""
"Параметры ''TD'', ''Freq'' и ''NL'' определяют длину линии. Должны быть "
"заданы либо ''TD'', либо ''Freq'' и ''NL''.  Если задан только параметр "
"''Freq'', то ''NL'' принимается равным 0,25. Другие параметры будут "
"рассчитываться на основе тех, что были указаны.  Если задать слишком много "
"параметров, то за основу будут взяты ''Freq'' и ''NL'', а также будет выдано "
"предупреждение."

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:21
#, no-wrap
msgid "Element Parameters"
msgstr "Параметры элемента"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:26
#, no-wrap
msgid ""
"Many parameters are offered.  You should not specify them all.\n"
"^Parameters that always work.  ^^\n"
"|len  |Length multiplier.  (Default = 1) The effective length, regardless of its method of calculation is multiplied by this number.  |\n"
msgstr ""
"Для линии предлагается множество параметров. Нет смысла указывать их все.\n"
"^Параметры, работающие всегда  ^^^\n"
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''len'' |  **''1''**  |Множитель длины.  На это число умножается эффективная длина, независимо от метода её расчёта  |\n"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:32
#, no-wrap
msgid ""
"^Direct specification of electrical characteristics.  ^^\n"
"|z0    |Characteristic impedance.  If not specified, it is calculated by sqrt(L/C).  If neither //z0// nor //L// and //C// are specified, the default value is 50 Ohms.  |\n"
"|td    |Time delay.  If not specified, it will be calculated, either by nl/freq or by sqrt(L*C).  |\n"
"|freq  |Frequency for //nl//.  |\n"
"|nl    |Number of wavelengths at //freq//.  |\n"
msgstr ""
"^Параметры для прямого задания электрических характеристик  ^^^\n"
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''z0''    |  **''50 Ом''**  | Характеристический импеданс. Если не указан, рассчитывается по формуле ''sqrt(L/C)''.  Значение по умолчанию используется только тогда, когда не указаны ни ''z0'', ни ''L'' и ''C''  |\n"
"|''td''    | | Временная задержка. Если параметр не указан, он будет рассчитан по одной из формул: ''nl/freq'' или ''sqrt(L*C)''  |\n"
"|''freq''  | | Частота для ''nl''  |\n"
"|''nl''    | | Количество длин волн при частоте ''freq''  |\n"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:36
#, no-wrap
msgid ""
"^Physical parameters  ^^\n"
"|L  |Inductance per unit length.  This value is used only if //z0// and //td// are both not specified.  |\n"
"|C  |Capacitance per unit length.  This value is used only if //z0// and //td// are both not specified.  |\n"
msgstr ""
"^ Физические параметры ^^^\n"
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''L'' | | Индуктивность на единицу длины. Это значение используется только тогда, когда не указаны ни ''z0'', ни ''td''  |\n"
"|''C'' | | Ёмкость       на единицу длины. Это значение используется только тогда, когда не указаны ни ''z0'', ни ''td''  |\n"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:40
msgid "The standard probes for all basic elements are all available."
msgstr ""
"Доступны все стандартные датчики, используемые для всех базовых элементов."

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:44
msgid ""
"Transient time steps are limited to be no larger than the delay of the "
"transmission line.  Aside from this, there is no attempt to synchronize, "
"because synchronization would result in a significant run speed penalty."
msgstr ""
"На временные шаги [[gnucap:manual:commands:transient.ru|временного анализа]] "
"накладывается ограничение в том, что они не должны быть больше задержки "
"линии передачи.  Кроме того, в этом случае программа не пытается "
"использовать синхронизацию, поскольку это могло бы привести к значительному "
"снижению скорости расчётов."

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:46
msgid "There is significant room for improvement, if there is demand for it."
msgstr ""
"Здесь имеется большой простор для улучшений, если в этом есть потребность."

#. type: Title =====
#: manual/devices/lossless_transmission_line.txt:47
#: manual/devices/switches.txt:83
#, no-wrap
msgid "Convergence"
msgstr "Сходимость"

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:50
msgid ""
"Transmission lines are linear devices, so it would seem they would not be a "
"factor in convergence."
msgstr ""
"Линии передачи являются линейными устройствами, поэтому может показаться, "
"что они никак не должны влиять на сходимость."

#. type: Plain text
#: manual/devices/lossless_transmission_line.txt:51
msgid ""
"Transmission lines can be used to decouple problem circuits.  If a circuit "
"is having convergence problems, sometimes inserting a short transmission "
"line in an appropriate place can solve the problem by adding a small delay.  "
"Parts of circuits separated by transmission lines are considered to be "
"separate circuits.  Convergence problems in one part do not influence the "
"other part."
msgstr ""
"Линии передачи могут использоваться для развязки проблемных контуров. Если "
"схема имеет проблемы со сходимостью, эту проблему иногда может решить "
"вставка в подходящее место короткой линии передачи, добавляющей маленькую "
"задержку.  Части схемы, разделённые линиями передачи считаются отдельными "
"схемами. Проблемы сходимости в одной части не оказывают влияния на другую."

#. type: Title ======
#: manual/devices/mutual_inductance.txt:1
#, no-wrap
msgid "Coupled (Mutual) Inductors"
msgstr "Индуктивно-связанные катушки (взаимная индуктивность)"

#. type: Plain text
#: manual/devices/mutual_inductance.txt:6
#, no-wrap
msgid "  Kxxxxxxx Lyyyyyyy Lzzzzzzz value\n"
msgstr "|''**K**//xxxxxxx// L//yyyyyyy// L//zzzzzzz// //значение//''|\n"

#. type: Plain text
#: manual/devices/mutual_inductance.txt:10
msgid "Coupled mutual inductance."
msgstr "Взаимная индуктивность."

#. type: Plain text
#: manual/devices/mutual_inductance.txt:14
msgid ""
"K couples two inductors.  The value is the coefficient of coupling.  Using "
"the dot convention, place a dot on the first node of each inductor."
msgstr ""
"Устройство **K** связывает две катушки индуктивности. Значение представляет "
"собой коэффициент связи. В соответствии с соглашением о точках точки "
"помещаются на первых узлах каждой из катушек."

#. type: Plain text
#: manual/devices/mutual_inductance.txt:16
msgid ""
"The coefficient of coupling is given by K = m[i][j] / sqrt(L[i] L[j]).  K is "
"always positive and less than 1."
msgstr ""
"Коэффициент связи задаётся выражением  ''K = m[i][j] / sqrt(L[i] L[j])''.  "
"Значение ''K'' всегда положительно и меньше 1."

#. type: Title =====
#: manual/devices/mutual_inductance.txt:17
#, no-wrap
msgid "Bugs"
msgstr "Программные ошибки"

#. type: Plain text
#: manual/devices/mutual_inductance.txt:20
msgid ""
"This version of mutual inductance is only supported in Spice syntax, because "
"the connections are inductors.  If you are using any other syntax, you can "
"make a Spice subcircuit containing the entire transformer."
msgstr ""
"Эта версия элемента взаимной индуктивности поддерживается только для работы "
"с синтаксисом SPICE, потому что соединения представляют собой катушки "
"индуктивности.  Для работы с использованием синтаксиса другого языка можно "
"сделать подсхему в формате SPICE, содержащую весь трансформатор целиком."

#. type: Title ======
#: manual/devices/other.txt:1
#, no-wrap
msgid "Other \"spice\" devices"
msgstr "Прочие устройства SPICE"

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:mutual inductance]]\n"
msgstr "[[.:mutual inductance.ru|Взаимная индуктивность]]\n"

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:switches]]\n"
msgstr "[[.:switches.ru|Ключи]]\n"

#. type: Bullet: '  * '
#: manual/devices/other.txt:5
#, no-wrap
msgid "[[.:Lossless transmission line]]\n"
msgstr "[[.:Lossless transmission line.ru|Линия передачи без потерь]]\n"

#. type: Title ======
#: manual/devices/semi.txt:1
#, no-wrap
msgid "Semiconductor devices"
msgstr "Полупроводниковые устройства"

#. type: Plain text
#: manual/devices/semi.txt:4
msgid ""
"Gnucap supports both native and industry standard semiconductor devices."
msgstr ""
"В gnucap поддерживаются как собственные полупроводниковые устройства, так и "
"те, что считаются промышленным стандартом."

#. type: Plain text
#: manual/devices/semi.txt:6
msgid ""
"Native models are optimized models compiled with the \"gnucap-modelgen\" "
"model compiler.  A BJT, diode, and several MOSFET models are available as "
"native models."
msgstr ""
"Собственные модели --- это оптимизированные модели, скомпилированные с "
"помощью компилятора gnucap-modelgen. В наличии имеются собственные модели "
"биполярного транзистора (BJT), диода и несколько моделей полевых "
"транзисторов (MOSFET)."

#. type: Plain text
#: manual/devices/semi.txt:8
msgid ""
"C-models designed for Spice can also be used as plugins.  Several variants "
"of spice models are supported, including 3e, 3f, NGspice, and Jspice.  "
"Usually, the models can be used without any modifications."
msgstr ""
"В качестве плагинов могут также использоваться C-модели, разработанные для "
"SPICE. Поддерживается модели нескольких версий SPICE, в том числе 3e, 3f, "
"NGspice и Jspice.  Обычно эти модели возможно использовать совершенно без "
"каких бы то ни было изменений."

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:diode]]\n"
msgstr "[[.:semi:diode.ru|Диоды]]\n"

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:bjt]]\n"
msgstr "[[.:semi:bjt.ru|Биполярные транзисторы (BJT)]]\n"

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:jfet]]\n"
msgstr "[[.:semi:jfet.ru|jfet]]\n"

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:mosfet]]\n"
msgstr "[[.:semi:mosfet.ru|mosfet]]\n"

#. type: Bullet: '  * '
#: manual/devices/semi.txt:14
#, no-wrap
msgid "[[.:semi:mesfet]]\n"
msgstr "[[.:semi:mesfet.ru|mesfet]]\n"

#. type: Title ======
#: manual/devices/semi/bjt.txt:1 manual/devices/semi/diode.txt:1
#, no-wrap
msgid "Semiconductor models"
msgstr "Модели полупроводниковых устройств"

#. type: Title =====
#: manual/devices/semi/bjt.txt:3
#, no-wrap
msgid "BJT's"
msgstr "Биполярные транзисторы"

#. type: Title ====
#: manual/devices/semi/bjt.txt:5 manual/devices/semi/diode.txt:5
#, no-wrap
msgid "Native models"
msgstr "Собственные модели"

#. type: Bullet: '  * '
#: manual/devices/semi/bjt.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man076.html|bjt]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man076.html|bjt]]\n"

#. type: Title ====
#: manual/devices/semi/bjt.txt:8 manual/devices/semi/diode.txt:9
#, no-wrap
msgid "Spice models"
msgstr "Модели SPICE"

#. type: Plain text
#: manual/devices/semi/bjt.txt:11 manual/devices/semi/diode.txt:12
msgid ""
"Several Spice diode models are available.  They are not documented here."
msgstr ""
"В наличии есть несколько SPICE-моделей диодов. Документация на них здесь не "
"приводится."

#. type: Plain text
#: manual/devices/semi/bjt.txt:18
#, no-wrap
msgid ""
"^Gnucap tarball      ^Name  ^Level  ^Origin        ^Status              ^Comments             ^\n"
"|models-spice3f5     |bjt   |       |Spice 3f5     |+++++ supported     |The standard model   |\n"
"|models-jspice3-2.5  |bjt   |       |Jspice 3-2.5  |+++-  inconsistent  |Not recommended      |\n"
"|models-ngspice17    |bjt   |1      |NGspice-17    |++++  works         |similar to standard  |\n"
"|models-ngspice17    |bjt2  |2      |NGspice-17    |+++   works         |similar to standard  |\n"
"|models-ngspice17    |vbic  |4      |NGspice-17    |++++  works         |Colin McAndrew's VBIC model  |\n"
msgstr ""
"^ tar-архив gnucap   ^ Имя  ^ Уровень  ^ Происхождение ^ Состояние           ^ Комментарии                        ^\n"
"|models-spice3f5     |bjt   |          |SPICE 3f5      |+++++ поддерживается | Стандартная модель                 |\n"
"|models-jspice3-2.5  |bjt   |          |Jspice 3-2.5   |+++-  несовместимая  | Не рекомендуется                   |\n"
"|models-ngspice17    |bjt   |1         |NGspice-17     |++++  работает       | Похожа на стандартную              |\n"
"|models-ngspice17    |bjt2  |2         |NGspice-17     |+++   работает       | Похожа на стандартную              |\n"
"|models-ngspice17    |vbic  |4         |NGspice-17     |++++  работает       | Модель VBIC, автор Colin McAndrew  |\n"

#. type: Title =====
#: manual/devices/semi/diode.txt:3
#, no-wrap
msgid "Diodes"
msgstr "Диоды"

#. type: Bullet: '  * '
#: manual/devices/semi/diode.txt:8
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man063.html|diode]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man063.html|diode]]\n"

#. type: Plain text
#: manual/devices/semi/diode.txt:17
#, no-wrap
msgid ""
"^Gnucap tarball      ^Origin        ^Status           ^Comments  ^\n"
"|models-spice3f5     |Spice 3f5     |+++++ supported  |The standard model  |\n"
"|models-ngspice17    |NGspice-17    |+++++ supported  |Enhanced, with some additional parameters  |\n"
"|models-jspice3-2.5  |Jspice 3-2.5  |+++++ supported  |The standard model  |\n"
msgstr ""
"^ tar-архив gnucap   ^ Происхождение ^ Состояние            ^ Комментарии                                           ^\n"
"|models-spice3f5     |SPICE 3f5      |+++++ поддерживается  | Стандартная модель                                    |\n"
"|models-ngspice17    |NGspice-17     |+++++ поддерживается  | Улучшенная, с несколькими дополнительными параметрами |\n"
"|models-jspice3-2.5  |Jspice 3-2.5   |+++++ поддерживается  | Стандартная модель                                    |\n"

#. type: Title ======
#: manual/devices/switches.txt:2
#, no-wrap
msgid "Switches"
msgstr "Ключи"

#. type: Title ==
#: manual/devices/switches.txt:6
#, no-wrap
msgid "Voltage controlled switch"
msgstr "Ключ, управляемый напряжением"

#. type: Plain text
#: manual/devices/switches.txt:9
msgid "Device:"
msgstr "Устройство:"

#. type: Plain text
#: manual/devices/switches.txt:11
#, no-wrap
msgid "  Sxxxxxxx (n+ n- nc+ nc-) modelname ic\n"
msgstr "|''**S**//xxxxxxx// (//n+ n- nc+ nc-//) //имя_модели// ic''|\n"

#. type: Plain text
#: manual/devices/switches.txt:13 manual/devices/switches.txt:23
msgid "Model (required):"
msgstr "Модель (наличие обязательно):"

#. type: Plain text
#: manual/devices/switches.txt:15
#, no-wrap
msgid "  .model modelname SW args\n"
msgstr "|''**.model** //имя_модели// SW //аргументы//''|\n"

#. type: Title ==
#: manual/devices/switches.txt:17
#, no-wrap
msgid "Current controlled switch"
msgstr "Ключ, управляемый током"

#. type: Plain text
#: manual/devices/switches.txt:21
#, no-wrap
msgid ""
"Device:\n"
"  Wxxxxxxx (n+ n- ce) modelname ic\n"
msgstr ""
"Устройство:\n"
"|''**W**//xxxxxxx// (//n+ n- ce//) //имя_модели// ic''|\n"

#. type: Plain text
#: manual/devices/switches.txt:25
#, no-wrap
msgid "  .model modelname CSW args\n"
msgstr "|''**.model** //имя_модели// CSW //аргументы//''|\n"

#. type: Plain text
#: manual/devices/switches.txt:29
msgid "Voltage or current controlled switch."
msgstr "Ключ, управляемый напряжением или током."

#. type: Title =====
#: manual/devices/switches.txt:30
#, no-wrap
msgid "Comments ======"
msgstr "Описание ====="

#. type: Plain text
#: manual/devices/switches.txt:33
msgid ""
"//N+// and //n-// are the positive and negative element nodes, respectively."
msgstr ""
"''n+'' и ''n-'' представляют собой соответственно положительный и "
"отрицательный узлы элемента."

#. type: Plain text
#: manual/devices/switches.txt:35
msgid ""
"For voltage controlled switch, //Nc+// and //nc-// are the controlling nodes."
msgstr ""
"''nc+'' и ''nc-'' для ключа, управляемого напряжением, являются управляющими "
"узлами."

#. type: Plain text
#: manual/devices/switches.txt:37
msgid ""
"For current controlled switch, //ce// is the name of a controlling element."
msgstr ""
"''ce'' для ключа, управляемого током, определяет имя управляющего элемента."

#. type: Plain text
#: manual/devices/switches.txt:39
msgid "//Modelname// is the model name."
msgstr "Параметр ''имя_модели'' определяет имя модели."

#. type: Plain text
#: manual/devices/switches.txt:42
msgid ""
"A switch is a resistor between //n+// and //n-//.  The value of the resistor "
"is determined by the state of the switch."
msgstr ""
"Ключ представляет собой резистор между ''n+'' и ''n-''.  Значение резистора "
"определяется состоянием ключа."

#. type: Plain text
#: manual/devices/switches.txt:47
#, no-wrap
msgid ""
"^control                 ^resistance  ^\n"
"|vc > von\\\\  ic > ion    |Ron         |\n"
"|vc < voff\\\\  ic < ioff  |Roff        |\n"
"|otherwise               |no change   |\n"
msgstr ""
"^ Управление                   ^ Сопротивление     ^\n"
"|''vc > von\\\\  ic > ion''    |''Ron''            |\n"
"|''vc < voff\\\\  ic < ioff''  |''Roff''           |\n"
"|иначе                         |без изменения      |\n"

#. type: Plain text
#: manual/devices/switches.txt:51
msgid ""
"You may specify ''ON'' or ''OFF'' to indicate the initial state of the "
"switch when the controlling voltage is in the hysteresis region."
msgstr ""
"Для указания исходного состояния ключа, когда управляющее напряжение "
"находится в области гистерезиса, можно указать ''ON'' (ключ замкнут) или "
"''OFF'' (ключ разомкнут)."

#. type: Plain text
#: manual/devices/switches.txt:53
msgid "The parameters //ron// and //roff// must have finite positive values."
msgstr ""
"Параметры ''ron'' и ''roff'' должны иметь конечные положительные значения."

#. type: Title =====
#: manual/devices/switches.txt:53
#, no-wrap
msgid "Model Parameters"
msgstr "Параметры модели"

#. type: Plain text
#: manual/devices/switches.txt:62
#, no-wrap
msgid ""
"^Voltage controlled switch  ^^\n"
"|vt    |Threshold voltage.  (Default = 0.)         |\n"
"|vh    |Hysteresis voltage.  (Default = 0.)        |\n"
"|von   |On control voltage.  (Default = vt + vh)   |\n"
"|voff  |Off control voltage.  (Default = vt - vh)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""
"| **Ключ, управляемый напряжением**  |||\n"
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''vt''    |  **''0''**        | Пороговое напряжение                                 |\n"
"|''vh''    |  **''0''**        | Напряжение гистерезиса                               |\n"
"|''von''   |  ''vt **+** vh''  | Управляющее напряжение включения                     |\n"
"|''voff''  |  ''vt **-** vh''  | Управляющее напряжение отключения                    |\n"
"|''ron''   |  **''1''**        | Сопротивление во включенном (замкнутом)   состоянии  |\n"
"|''roff''  |  **''1e12''**     | Сопротивление в отключенном (разомкнутом) состоянии  |\n"

#. type: Plain text
#: manual/devices/switches.txt:70
#, no-wrap
msgid ""
"^Current controlled switch  ^^\n"
"|it    |Threshold current.  (Default = 0.)         |\n"
"|ih    |Hysteresis current.  (Default = 0.)        |\n"
"|ion   |On control current.  (Default = it + ih)   |\n"
"|ioff  |Off control current.  (Default = it - ih)  |\n"
"|ron   |On resistance.  (Default = 1.)             |\n"
"|roff  |Off resistance.  (Default = 1e12)          |\n"
msgstr ""
"| **Ключ, управляемый током**  |||\n"
"^ Имя параметра  ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''it''    |  **''0''**        | Пороговый ток                                        |\n"
"|''ih''    |  **''0''**        | Ток гистерезиса                                      |\n"
"|''ion''   |  ''it **+** ih''  | Управляющий ток включения                            |\n"
"|''ioff''  |  ''it **-** ih''  | Управляющий ток отключения                           |\n"
"|''ron''   |  **''1''**        | Сопротивление во включенном (замкнутом)   состоянии  |\n"
"|''roff''  |  **''1e12''**     | Сопротивление в отключенном (разомкнутом) состоянии  |\n"

#. type: Title =====
#: manual/devices/switches.txt:71
#, no-wrap
msgid "Time step control"
msgstr "Управление временным шагом"

#. type: Plain text
#: manual/devices/switches.txt:76
msgid ""
"A change of state is considered to be an analog event.  An input crossing a "
"threshold is a \"cross event\".  Cross events will generate extra time steps "
"so the switch timing is accurate."
msgstr ""
"Изменение состояния ключа считается аналоговым событием. Пересечение входным "
"сигналом порогового значения является «[[gnucap:manual:measure:cross.ru|"
"событием пересечения]]». Для событий пересечений генерируются дополнительные "
"временные шаги, поэтому выбор моментов времени для переключений будет точным."

#. type: Plain text
#: manual/devices/switches.txt:79
msgid ""
"A switch can be used anywhere in a circuit to improve timing accuracy by "
"sensing cross events."
msgstr ""
"Ключ можно использовать для увеличения точности временной синхронизации "
"сигналов, поставив его в любое место схемы, так как это заставит программу "
"обрабатывать события пересечения."

#. type: Plain text
#: manual/devices/switches.txt:82
msgid ""
"Switches also influence time step control as resistors, which control "
"smoothness by curve fitting."
msgstr ""
"Ключи также влияют на управление временным шагом как резисторы, в которых "
"гладкость настраивается с помощью аппроксимации."

#. type: Plain text
#: manual/devices/switches.txt:85
msgid ""
"Switches are linear devices that do not iterate unless there is a state "
"change."
msgstr ""
"Ключи представляют собой линейные устройства, не пересчитываемые в процессе "
"расчёта до тех пор, пока не произойдёт смена состояния."

#. type: Title ======
#: manual/examples.txt:1
#, no-wrap
msgid "Examples, tutorial"
msgstr "Примеры, руководства"

#. type: Title =====
#: manual/examples.txt:2
#, no-wrap
msgid "Hosted here"
msgstr "На этом сайте"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Hello world]]\n"
msgstr "[[gnucap:manual:examples:Hello world.ru|Привет, мир]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Resistors and sources]]\n"
msgstr "[[gnucap:manual:examples:Resistors and sources.ru|Резисторы и источники напряжения и тока]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Things that can go wrong]]\n"
msgstr "[[gnucap:manual:examples:Things that can go wrong.ru|Кое-что, что может пойти не так]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Nonlinear devices -- diodes]]\n"
msgstr "[[gnucap:manual:examples:Nonlinear devices -- diodes.ru|Нелинейные устройства -- диоды]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Multiplying two voltages using diode nonlinearity]]\n"
msgstr "[[gnucap:manual:examples:Multiplying two voltages using diode nonlinearity.ru|Умножение двух напряжений с помощью нелинейности диодов]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Using the generator in transient analysis]]\n"
msgstr "[[gnucap:manual:examples:Using the generator in transient analysis.ru|Использование генератора во временном анализе]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Experimentally finding model parameters]]\n"
msgstr "[[gnucap:manual:examples:Experimentally finding model parameters.ru|Экспериментальное определение параметров модели]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Simple Power supply]]\n"
msgstr "[[gnucap:manual:examples:Simple Power supply.ru|Простой источник питания]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:Phase shift oscillator]]\n"
msgstr "[[gnucap:manual:examples:Phase shift oscillator.ru|Фазосдвигающий генератор]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:14
#, no-wrap
msgid "[[gnucap:manual:examples:FM spectrum analysis]]\n"
msgstr "[[gnucap:manual:examples:FM spectrum analysis.ru|Анализ частотно-модулированного спектра]]\n"

#. type: Title =====
#: manual/examples.txt:14
#, no-wrap
msgid "Hosted elsewhere"
msgstr "Где-то ещё"

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, no-wrap
msgid "[[http://www.johannes-bauer.com/electronics/]] [[http://www.johannes-bauer.com/electronics/|gEDA and Gnucap, getting started, by Johannes Bauer]]\n"
msgstr "[[http://www.johannes-bauer.com/electronics/]] [[http://www.johannes-bauer.com/electronics/|gEDA and Gnucap, getting started, by Johannes Bauer]]\n"

#. type: Bullet: '  * '
#: manual/examples.txt:17
#, no-wrap
msgid "[[http://geekwentfreak.wordpress.com/2009/12/11/spice-gschem-gnetlist-gnucap-gwave-gspiceui-linux/]]\n"
msgstr "[[http://geekwentfreak.wordpress.com/2009/12/11/spice-gschem-gnetlist-gnucap-gwave-gspiceui-linux/]]\n"

#. type: Title ======
#: manual/examples/experimentally_finding_model_parameters.txt:1
#, no-wrap
msgid "Experimentally finding model parameters"
msgstr "Экспериментальное определение параметров модели"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:4
msgid ""
"Sometimes you need to determine model parameters, based on having no real "
"information."
msgstr ""
"Иногда необходимо определить параметры модели, не имея никакой реальной "
"информации."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:6
msgid ""
"In this example, we find the parameter \"IS\" of a diode, based on its "
"forward voltage."
msgstr ""
"В данном примере мы найдём параметр «''IS''» диода, взяв за основу прямое "
"падение напряжения на нём."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:8
msgid "We would like to have a diode..."
msgstr "Нам хотелось бы иметь диод..."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:10
#, no-wrap
msgid "  D2 (a k) 1n4004\n"
msgstr "  D2 (a k) 1n4004\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:12
msgid "Now you need a model statement ..."
msgstr "Теперь нужен оператор ''model'' ..."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:14
#, no-wrap
msgid "  .model 1n4004 d (a whole bunch of parameters)\n"
msgstr "  .model 1n4004 d (целая куча параметров)\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:17
msgid ""
"You could do a web search for a detailed model, but usually you can just do "
"some experimenting.."
msgstr ""
"Подробную модель можно было бы поискать во всемирной паутине, но обычно "
"можно просто немного поэкспериментировать.."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:21
msgid ""
"If you are at the stage where you are asking about this, the detail will "
"only confuse you, most likely of the worst kind of confusion, where you "
"don't realize it."
msgstr ""
"Если вы находитесь на том этапе, когда об этом спрашиваете, то вы лишь "
"запутаетесь, и скорее всего весьма основательно, в тех подробностях, которые "
"вам не ясны."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:24
msgid ""
"Most of the time, the only parameter you need for a diode is saturation "
"current, which of course isn't in the data sheet."
msgstr ""
"Чаще всего единственный параметр, который нужно знать для диода, это ток "
"насыщения, которого, конечно, в спецификации нет."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:26
msgid "ok .. so how do I figure that out??"
msgstr "Хорошо... итак, как же его найти??"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:29
msgid ""
"Well ...  Look at the specs, or measure it.  Let's say we found that the "
"forward voltage at 1 amp is .7 volts."
msgstr ""
"Ну...  Посмотреть характеристики, или измерить их. Допустим, мы нашли, что "
"прямое напряжение при токе 1 А составляет 0,7 В."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:31
msgid "Use the simulator to build a test circuit .."
msgstr "Используем программу моделирования для построения схемы проверки.."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:34
#, no-wrap
msgid ""
"  I1 (0 1) dc 1\n"
"  D1 (1 0) my_diode\n"
msgstr ""
"  I1 (0 1) dc 1\n"
"  D1 (1 0) my_diode\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:37
#, no-wrap
msgid ""
"You need a model statement ..\n"
"  .model my_diode d (is=something)\n"
msgstr ""
"Нам нужно выражение для модели...\n"
"  .model my_diode d (is=something)\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:39
msgid "but I don't know what the value of something is."
msgstr "...но я не знаю, чему это ''something'' равно."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:41
msgid "With gnucap .. try this......."
msgstr "Берём gnucap... и пробуем так:"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:85
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >i1 (0 1) dc 1\n"
"  >d1 (1 0) my_diode\n"
"  >.model my_diode d is=something\n"
"  >                   ******** blank line to exit build mode\n"
"  gnucap> probe  op  v(1)\n"
"  parameter something has no value\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.83376                    **** using default IS\n"
"  gnucap> param something=1u\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.35733\n"
"  gnucap> param something=1n\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.53599\n"
"  gnucap> param something=1p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.71465\n"
"  gnucap> param something=2p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69673\n"
"  gnucap> param something=1.5p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70417\n"
"  gnucap> param something=1.8p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69945\n"
"  gnucap> param something=1.7p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70093\n"
"  gnucap> param something=1.75p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70018\n"
"  gnucap> exit\n"
msgstr ""
"  gnucap> build\n"
"  >i1 (0 1) dc 1\n"
"  >d1 (1 0) my_diode\n"
"  >.model my_diode d is=something\n"
"  >                   ******** пустая строка для выхода из режима build\n"
"  gnucap> probe  op  v(1)\n"
"  parameter something has no value\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.83376        **** используется значение IS по умолчанию\n"
"  gnucap> param something=1u\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.35733\n"
"  gnucap> param something=1n\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.53599\n"
"  gnucap> param something=1p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.71465\n"
"  gnucap> param something=2p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69673\n"
"  gnucap> param something=1.5p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70417\n"
"  gnucap> param something=1.8p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.69945\n"
"  gnucap> param something=1.7p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70093\n"
"  gnucap> param something=1.75p\n"
"  gnucap> op\n"
"  #           v(1)\n"
"   27.        0.70018\n"
"  gnucap> exit\n"

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:89
msgid "There ..  close enough ,,, Now use the value 1.75p for IS."
msgstr ""
"Ну вот...  довольно близко. Теперь для ''IS'' используем значение 1.75p."

#. type: Plain text
#: manual/examples/experimentally_finding_model_parameters.txt:91
#, no-wrap
msgid ""
"Here's your model statement:\n"
"  .model my_diode d is=1.75p\n"
msgstr ""
"Вот и оператор для нашей модели:\n"
"  .model my_diode d is=1.75p\n"

#. type: Title ======
#: manual/examples/fm_spectrum_analysis.txt:1
#, no-wrap
msgid "FM spectrum analysis"
msgstr "Анализ частотно-модулированного спектра"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:4
msgid ""
"In this demo, we will look at the spectrum of a frequency modulated signal, "
"with the intent of exploring the effect of overmodulation on bandwidth."
msgstr ""
"В этом примере мы посмотрим спектр частотно-модулированного сигнала с целью "
"исследования эффекта перемодулирования на ширине спектра сигнала."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:6
msgid ""
"The circuit is simple, just a voltage source, with a Spice-style \"SFFM\" "
"waveform.  We will use parameters to tinker with the signal, and the Fourier "
"command to display the spectrum.  You could calculate the spectrum using "
"Bessel functions, but we will look at it with simulation."
msgstr ""
"Схема проста, один лишь источник напряжения с сигналом ''SFFM'' в стиле "
"SPICE. Чтобы повозиться с этим сигналом, мы воспользуемся [[..:commands:"
"parameter.ru|параметрами]], а для отображения спектра --- командой [[..:"
"commands:fourier.ru|fourier]]. Спектр можно было бы рассчитать с помощью "
"функций Бесселя, но мы попробуем его промоделировать."

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:6
#: manual/examples/phase_shift_oscillator.txt:56
#, no-wrap
msgid "Setting up"
msgstr "Настройка"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:9
msgid "First, the circuit.  Enter it with the \"build\" command:"
msgstr ""
"Сначала схема. Введём её с помощью команды [[..:commands:build.ru|build]]:"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:14
#, no-wrap
msgid ""
"  gnucap> build\n"
"  > v1 ( 1 0 ) sffm (carrier={carrier} modindex={mod/signal} signal={signal})\n"
"  >       **** blank line exits build mode\n"
"  gnucap>\n"
msgstr ""
"  gnucap> build\n"
"  > v1 ( 1 0 ) sffm (carrier={carrier} modindex={mod/signal} signal={signal})\n"
"  >       **** пустая строка для выхода из режима построения схемы\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:16
msgid "Now, set up the parameters:"
msgstr "Теперь настроим параметры:"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:20
#, no-wrap
msgid ""
"  gnucap> param carrier=10Meg\n"
"  gnucap> param signal=10K\n"
"  gnucap> param mod=75K\n"
msgstr ""
"  gnucap> param carrier=10Meg\n"
"  gnucap> param signal=10K\n"
"  gnucap> param mod=75K\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:22
msgid ""
"This sets up a signal of 10 KHz with the usual maximum deviation of 75 KHz.  "
"This is not overmodulated.  I chose a carrier frequency of 10 MHz for "
"convenience.  100 MHz would be more realistic but would take longer to run.  "
"It doesn't really matter, and 10 MHz is close to the usual intermediate "
"frequency of 10.7 MHz."
msgstr ""
"Это настройка сигнала в 10 кГц с обычной максимальной частотной девиацией в "
"75 кГц.  Сигнал не перемодулирован. Для удобства я выбрал несущую частоту в "
"10 МГц. Частота 100 МГц была бы более реалистичной, но расчёт занял бы тогда "
"больше времени.  На самом деле это не имеет особого значения, и 10 МГц "
"близко к обычной промежуточной частоте 10.7 МГц."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:24
msgid "Now, set up the sweep parameters:"
msgstr "Теперь настроим параметры диапазона развёртки частоты:"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:28
#, no-wrap
msgid ""
"  gnucap> param start={carrier-2*(mod+signal)}\n"
"  gnucap> param stop={carrier+2*(mod+signal)}\n"
"  gnucap> param step={signal}\n"
msgstr ""
"  gnucap> param start={carrier-2*(mod+signal)}\n"
"  gnucap> param stop={carrier+2*(mod+signal)}\n"
"  gnucap> param step={signal}\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:30
msgid ""
"Carson's rule estimates the bandwidth to be 2*(mod+signal), so we will cover "
"a range of twice that, in steps equal to the modulating frequency.  If you "
"look at the Bessel functions, you will see that this is corresponds to the "
"actual signal."
msgstr ""
"Правило Карсона приближённо определяет полосу частот как ''2*(mod+signal)'', "
"поэтому мы перекроем этот диапазон вдвойне, установив шаг равным частоте "
"модуляции. Если взглянуть на функции Бесселя, то можно увидеть, что это "
"соответствует реальному сигналу."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:32
msgid "Now, set up a probe:"
msgstr "Теперь настроим датчик:"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:34
#, no-wrap
msgid "  gnucap> probe fourier v(1)\n"
msgstr "  gnucap> probe fourier v(1)\n"

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:35
#, no-wrap
msgid "The first run"
msgstr "Первый запуск"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:38
msgid "Try one .. look at the spectrum:"
msgstr "Попробуем запустить... взглянем на спектр:"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:40
#, no-wrap
msgid "  gnucap> fourier {start} {stop} {step}\n"
msgstr "  gnucap> fourier {start} {stop} {step}\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:42
msgid ""
"You will see the time points of a transient run, then the spectrum over the "
"range you asked for."
msgstr ""
"Мы увидим точки [[..:commands:transient.ru|временного анализа]], а затем "
"спектр для запрошенного диапазона."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:83
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.83Meg    7.2578u   -102.78   93.604  20.494u    -93.77 -179.033\n"
" 9.84Meg    31.322u    -90.08  -86.484  88.446u    -81.07    0.879\n"
" 9.85Meg    126.38u    -77.97   93.428  356.88u    -68.95 -179.209\n"
" 9.86Meg    474.21u    -66.48  -86.660  0.0013391  -57.46    0.703\n"
" 9.87Meg    0.001644   -55.68   93.252  0.0046423  -46.67 -179.385\n"
" 9.88Meg    0.005225   -45.64  -86.836  0.014754   -36.62    0.527\n"
" 9.89Meg    0.015076   -36.43   93.076  0.042571   -27.42 -179.561\n"
" 9.9Meg     0.038998   -28.18  -87.012  0.11012    -19.16    0.352\n"
" 9.91Meg    0.088919   -21.02   92.900  0.25108    -12.00 -179.736\n"
" 9.92Meg    0.17441    -15.17  -87.188  0.49248     -6.15    0.176\n"
" 9.93Meg    0.28315    -10.96   92.725  0.79954     -1.94 -179.912\n"
" 9.94Meg    0.35414     -9.02  -87.363  1.           0.00   -0.000\n"
" 9.95Meg    0.28347    -10.95   92.549  0.80046     -1.93  179.912\n"
" 9.96Meg    0.023825   -32.46  -87.539  0.067275   -23.44   -0.176\n"
" 9.97Meg    0.25806    -11.77  -87.627  0.7287      -2.75   -0.264\n"
" 9.98Meg    0.23027    -12.76   92.285  0.65023     -3.74  179.648\n"
" 9.99Meg    0.13525    -17.38   92.197  0.38191     -8.36  179.561\n"
" 10.Meg     0.26634    -11.49  -87.891  0.75207     -2.47   -0.527\n"
" 10.01Meg   0.13525    -17.38  -87.979  0.38191     -8.36   -0.615\n"
" 10.02Meg   0.23027    -12.76   91.934  0.65023     -3.74  179.297\n"
" 10.03Meg   0.25806    -11.77   91.846  0.7287      -2.75  179.209\n"
" 10.04Meg   0.023825   -32.46  -88.242  0.067275   -23.44   -0.879\n"
" 10.05Meg   0.28347    -10.95  -88.330  0.80046     -1.93   -0.967\n"
" 10.06Meg   0.35414     -9.02  -88.418  1.          -0.00   -1.055\n"
" 10.07Meg   0.28315    -10.96  -88.506  0.79954     -1.94   -1.143\n"
" 10.08Meg   0.17441    -15.17  -88.594  0.49248     -6.15   -1.230\n"
" 10.09Meg   0.088919   -21.02  -88.682  0.25108    -12.00   -1.318\n"
" 10.1Meg    0.038998   -28.18  -88.770  0.11012    -19.16   -1.406\n"
" 10.11Meg   0.015076   -36.43  -88.857  0.042571   -27.42   -1.494\n"
" 10.12Meg   0.005225   -45.64  -88.945  0.014754   -36.62   -1.582\n"
" 10.13Meg   0.001644   -55.68  -89.033  0.0046423  -46.67   -1.670\n"
" 10.14Meg   474.22u    -66.48  -89.121  0.0013391  -57.46   -1.758\n"
" 10.15Meg   126.38u    -77.97  -89.209  356.88u    -68.95   -1.846\n"
" 10.16Meg   31.323u    -90.08  -89.297  88.447u    -81.07   -1.934\n"
" 10.17Meg   7.2581u   -102.78  -89.385  20.495u    -93.77   -2.021\n"
"gnucap>\n"
"</code>\n"
msgstr ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.83Meg    7.2578u   -102.78   93.604  20.494u    -93.77 -179.033\n"
" 9.84Meg    31.322u    -90.08  -86.484  88.446u    -81.07    0.879\n"
" 9.85Meg    126.38u    -77.97   93.428  356.88u    -68.95 -179.209\n"
" 9.86Meg    474.21u    -66.48  -86.660  0.0013391  -57.46    0.703\n"
" 9.87Meg    0.001644   -55.68   93.252  0.0046423  -46.67 -179.385\n"
" 9.88Meg    0.005225   -45.64  -86.836  0.014754   -36.62    0.527\n"
" 9.89Meg    0.015076   -36.43   93.076  0.042571   -27.42 -179.561\n"
" 9.9Meg     0.038998   -28.18  -87.012  0.11012    -19.16    0.352\n"
" 9.91Meg    0.088919   -21.02   92.900  0.25108    -12.00 -179.736\n"
" 9.92Meg    0.17441    -15.17  -87.188  0.49248     -6.15    0.176\n"
" 9.93Meg    0.28315    -10.96   92.725  0.79954     -1.94 -179.912\n"
" 9.94Meg    0.35414     -9.02  -87.363  1.           0.00   -0.000\n"
" 9.95Meg    0.28347    -10.95   92.549  0.80046     -1.93  179.912\n"
" 9.96Meg    0.023825   -32.46  -87.539  0.067275   -23.44   -0.176\n"
" 9.97Meg    0.25806    -11.77  -87.627  0.7287      -2.75   -0.264\n"
" 9.98Meg    0.23027    -12.76   92.285  0.65023     -3.74  179.648\n"
" 9.99Meg    0.13525    -17.38   92.197  0.38191     -8.36  179.561\n"
" 10.Meg     0.26634    -11.49  -87.891  0.75207     -2.47   -0.527\n"
" 10.01Meg   0.13525    -17.38  -87.979  0.38191     -8.36   -0.615\n"
" 10.02Meg   0.23027    -12.76   91.934  0.65023     -3.74  179.297\n"
" 10.03Meg   0.25806    -11.77   91.846  0.7287      -2.75  179.209\n"
" 10.04Meg   0.023825   -32.46  -88.242  0.067275   -23.44   -0.879\n"
" 10.05Meg   0.28347    -10.95  -88.330  0.80046     -1.93   -0.967\n"
" 10.06Meg   0.35414     -9.02  -88.418  1.          -0.00   -1.055\n"
" 10.07Meg   0.28315    -10.96  -88.506  0.79954     -1.94   -1.143\n"
" 10.08Meg   0.17441    -15.17  -88.594  0.49248     -6.15   -1.230\n"
" 10.09Meg   0.088919   -21.02  -88.682  0.25108    -12.00   -1.318\n"
" 10.1Meg    0.038998   -28.18  -88.770  0.11012    -19.16   -1.406\n"
" 10.11Meg   0.015076   -36.43  -88.857  0.042571   -27.42   -1.494\n"
" 10.12Meg   0.005225   -45.64  -88.945  0.014754   -36.62   -1.582\n"
" 10.13Meg   0.001644   -55.68  -89.033  0.0046423  -46.67   -1.670\n"
" 10.14Meg   474.22u    -66.48  -89.121  0.0013391  -57.46   -1.758\n"
" 10.15Meg   126.38u    -77.97  -89.209  356.88u    -68.95   -1.846\n"
" 10.16Meg   31.323u    -90.08  -89.297  88.447u    -81.07   -1.934\n"
" 10.17Meg   7.2581u   -102.78  -89.385  20.495u    -93.77   -2.021\n"
"gnucap>\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:85
msgid ""
"As a quick check ..  For a modulation index of 7.5, the fourth sideband "
"should have a null, or close to it.  It does."
msgstr ""
"Для быстрой проверки... Для индекса частотной модуляции 7,5 для четвёртой "
"боковой полосы частот должен быть ноль или около того. Так и есть."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:87
msgid ""
"Another quick check .. Carson's rule says the bandwidth should be about 2*"
"(mod+signal) or 2*(10K+75K), or 85K on each side.  It's pretty close.  It "
"looks like the real bandwidth is probably a little more."
msgstr ""
"Другая быстрая проверка... Правило Карсона говорит, что ширина полосы "
"пропускания должна быть около ''2*(mod+signal)'' или ''2*(10K+75K)'', или по "
"85K с каждой стороны. Весьма близко. Кажется, будто на самом деле полоса, "
"наверно, немного больше."

#. type: Title =====
#: manual/examples/fm_spectrum_analysis.txt:87
#, no-wrap
msgid "Now experiment"
msgstr "Теперь поэкспериментируем"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:90
msgid ""
"Let's try a modulating frequency of 50 KHz, roughly the top of the stereo "
"subcarrier."
msgstr ""
"Попробуем частоту модуляции в 50 кГц, приблизительно верх поднесущей "
"стереосигнала."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:98
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=50k\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.0025    -0.99968\n"
" 0.0025     0.8\n"
"</code>\n"
msgstr ""
"<code>\n"
"gnucap> param signal=50k\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.0025    -0.99968\n"
" 0.0025     0.8\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:116
#, no-wrap
msgid ""
"<code>\n"
" 0.0025199  0.76861\n"
" 0.00252   -0.99968\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.75Meg    0.0017994  -54.90   94.307  0.0032251  -49.83    1.758\n"
" 9.8Meg     0.011768   -38.59  -86.133  0.021092   -33.52 -178.682\n"
" 9.85Meg    0.060964   -24.30   93.428  0.10927    -19.23    0.879\n"
" 9.9Meg     0.23209    -12.69  -87.012  0.41598     -7.62 -179.561\n"
" 9.95Meg    0.55794     -5.07   92.549  1.           0.00    0.000\n"
" 10.Meg     0.51183     -5.82  -87.891  0.91736     -0.75  179.561\n"
" 10.05Meg   0.55794     -5.07  -88.330  1.          -0.00  179.121\n"
" 10.1Meg    0.23209    -12.69  -88.770  0.41598     -7.62  178.682\n"
" 10.15Meg   0.060964   -24.30  -89.209  0.10927    -19.23  178.242\n"
" 10.2Meg    0.011768   -38.59  -89.648  0.021092   -33.52  177.803\n"
" 10.25Meg   0.0017994  -54.90  -90.088  0.0032251  -49.83  177.363\n"
"gnucap>\n"
"</code>\n"
msgstr ""
"<code>\n"
" 0.0025199  0.76861\n"
" 0.00252   -0.99968\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.75Meg    0.0017994  -54.90   94.307  0.0032251  -49.83    1.758\n"
" 9.8Meg     0.011768   -38.59  -86.133  0.021092   -33.52 -178.682\n"
" 9.85Meg    0.060964   -24.30   93.428  0.10927    -19.23    0.879\n"
" 9.9Meg     0.23209    -12.69  -87.012  0.41598     -7.62 -179.561\n"
" 9.95Meg    0.55794     -5.07   92.549  1.           0.00    0.000\n"
" 10.Meg     0.51183     -5.82  -87.891  0.91736     -0.75  179.561\n"
" 10.05Meg   0.55794     -5.07  -88.330  1.          -0.00  179.121\n"
" 10.1Meg    0.23209    -12.69  -88.770  0.41598     -7.62  178.682\n"
" 10.15Meg   0.060964   -24.30  -89.209  0.10927    -19.23  178.242\n"
" 10.2Meg    0.011768   -38.59  -89.648  0.021092   -33.52  177.803\n"
" 10.25Meg   0.0017994  -54.90  -90.088  0.0032251  -49.83  177.363\n"
"gnucap>\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:118
msgid ""
"Mod index is 1.5, so the spectrum is simpler, Carson's rule predicts 50K"
"+75K, or 125K each side.  Again, it seems the real signal takes more space.  "
"Check the Bessel functions, from a graph ...  about .55, .55, .2 ..  it "
"matches as well as I read the graph."
msgstr ""
"Индекс частотной модуляции 1,5, поэтому спектр проще, правило Карсона "
"предсказывает 50K+75K, или 125K с каждой стороны.  Снова, кажется, реальный "
"сигнал занимает больше места.  Проверим функции Бесселя по графику... "
"примерно 0,55, 0,55, 0,2...  также совпадает, как я вижу из графика."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:120
msgid "The signal is really pretty wide.  Try half of the deviation .."
msgstr ""
"Сигнал на самом деле довольно широкий. Попробуем половину частотной "
"девиации ..."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:127
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param mod=37.5K\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.00252   -0.99952\n"
"</code>\n"
msgstr ""
"<code>\n"
"gnucap> param mod=37.5K\n"
"gnucap> fourier\n"
"#Time       v(1)\n"
" 0.00252   -0.99952\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:142
#, no-wrap
msgid ""
"<code>\n"
" 0.0025399  0.75896\n"
" 0.00254   -0.99952\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.85Meg    0.0084844  -41.43   93.428  0.0098171  -40.16 -178.682\n"
" 9.9Meg     0.067074   -23.47  -87.012  0.07761    -22.20    0.879\n"
" 9.95Meg    0.34924     -9.14   92.549  0.4041      -7.87 -179.561\n"
" 10.Meg     0.86424     -1.27  -87.891  1.           0.00   -0.000\n"
" 10.05Meg   0.34924     -9.14  -88.330  0.4041      -7.87   -0.439\n"
" 10.1Meg    0.067074   -23.47  -88.770  0.07761    -22.20   -0.879\n"
" 10.15Meg   0.0084844  -41.43  -89.209  0.0098171  -40.16   -1.318\n"
" 10.2Meg    801.07u    -61.93  -89.648  926.9u     -60.66   -1.758\n"
"gnucap>\n"
"</code>\n"
msgstr ""
"<code>\n"
" 0.0025399  0.75896\n"
" 0.00254   -0.99952\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.85Meg    0.0084844  -41.43   93.428  0.0098171  -40.16 -178.682\n"
" 9.9Meg     0.067074   -23.47  -87.012  0.07761    -22.20    0.879\n"
" 9.95Meg    0.34924     -9.14   92.549  0.4041      -7.87 -179.561\n"
" 10.Meg     0.86424     -1.27  -87.891  1.           0.00   -0.000\n"
" 10.05Meg   0.34924     -9.14  -88.330  0.4041      -7.87   -0.439\n"
" 10.1Meg    0.067074   -23.47  -88.770  0.07761    -22.20   -0.879\n"
" 10.15Meg   0.0084844  -41.43  -89.209  0.0098171  -40.16   -1.318\n"
" 10.2Meg    801.07u    -61.93  -89.648  926.9u     -60.66   -1.758\n"
"gnucap>\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:144
msgid ""
"So now you see why the FCC limit on deviation is lower for higher modulation "
"frequencies."
msgstr ""
"Итак, теперь вы видите, почему для более высоких частот модуляции предел FCC "
"((Federal Communications Commission --- Федеральная комиссия связи, ФКС. --- "
"Прим. перев.)) на девиацию частоты меньше."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:146
msgid "Let's try overmodulating."
msgstr "Попробуем перемодулирование."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:152
#, no-wrap
msgid ""
"<code>\n"
"gnucap> param signal=10K\n"
"gnucap> param mod=150K\n"
"gnucap> fourier\n"
"</code>\n"
msgstr ""
"<code>\n"
"gnucap> param signal=10K\n"
"gnucap> param mod=150K\n"
"gnucap> fourier\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:222
#, no-wrap
msgid ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.68Meg    6.6294n   -163.57    0.001  23.786n   -152.47 -179.999\n"
" 9.69Meg    26.707n   -151.47  180.000  95.822n   -140.37   -0.000\n"
" 9.7Meg     103.74n   -139.68    0.000  372.23n   -128.58 -180.000\n"
" 9.71Meg    388.29n   -128.22  180.000  1.3931u   -117.12   -0.000\n"
" 9.72Meg    1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 9.73Meg    4.8295u   -106.32  180.000  17.328u    -95.23   -0.000\n"
" 9.74Meg    15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 9.75Meg    50.597u    -85.92  180.000  181.54u    -74.82   -0.000\n"
" 9.76Meg    152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 9.77Meg    437.95u    -67.17  180.000  0.0015713  -56.07   -0.000\n"
" 9.78Meg    0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 9.79Meg    0.0030538  -50.30  180.000  0.010957   -39.21   -0.000\n"
" 9.8Meg     0.0073602  -42.66   -0.000  0.026408   -31.57 -180.000\n"
" 9.81Meg    0.016574   -35.61  180.000  0.059464   -24.51    0.000\n"
" 9.82Meg    0.034626   -29.21   -0.000  0.12423    -18.12 -180.000\n"
" 9.83Meg    0.066529   -23.54  180.000  0.2387     -12.44    0.000\n"
" 9.84Meg    0.11617    -18.70   -0.000  0.41682     -7.60 -180.000\n"
" 9.85Meg    0.18131    -14.83  180.000  0.65051     -3.73    0.000\n"
" 9.86Meg    0.24644    -12.17   -0.000  0.8842      -1.07 -180.000\n"
" 9.87Meg    0.27871    -11.10  180.000  1.           0.00    0.000\n"
" 9.88Meg    0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 9.89Meg    0.09995    -20.00  180.000  0.35861     -8.91   -0.000\n"
" 9.9Meg     0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 9.91Meg    0.22005    -13.15   -0.000  0.7895      -2.05  180.000\n"
" 9.92Meg    0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 9.93Meg    0.034464   -29.25  180.000  0.12365    -18.16   -0.000\n"
" 9.94Meg    0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 9.95Meg    0.13046    -17.69  180.000  0.46806     -6.59   -0.000\n"
" 9.96Meg    0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 9.97Meg    0.19402    -14.24   -0.000  0.69612     -3.15  180.000\n"
" 9.98Meg    0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 9.99Meg    0.2051     -13.76  180.000  0.73589     -2.66   -0.000\n"
" 10.Meg     0.014224   -36.94  180.000  0.051036   -25.84   -0.000\n"
" 10.01Meg   0.2051     -13.76   -0.000  0.73589     -2.66  180.000\n"
" 10.02Meg   0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 10.03Meg   0.19402    -14.24  180.000  0.69612     -3.15   -0.000\n"
" 10.04Meg   0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 10.05Meg   0.13046    -17.69   -0.000  0.46806     -6.59  180.000\n"
" 10.06Meg   0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 10.07Meg   0.034464   -29.25   -0.000  0.12365    -18.16  180.000\n"
" 10.08Meg   0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 10.09Meg   0.22005    -13.15  180.000  0.7895      -2.05   -0.000\n"
" 10.1Meg    0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 10.11Meg   0.09995    -20.00   -0.000  0.35861     -8.91  180.000\n"
" 10.12Meg   0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 10.13Meg   0.27871    -11.10   -0.000  1.          -0.00  180.000\n"
" 10.14Meg   0.24644    -12.17   -0.000  0.8842      -1.07  180.000\n"
" 10.15Meg   0.18131    -14.83   -0.000  0.65051     -3.73  180.000\n"
" 10.16Meg   0.11617    -18.70   -0.000  0.41682     -7.60  180.000\n"
" 10.17Meg   0.066529   -23.54   -0.000  0.2387     -12.44  180.000\n"
" 10.18Meg   0.034626   -29.21   -0.000  0.12423    -18.12  180.000\n"
" 10.19Meg   0.016574   -35.61   -0.000  0.059464   -24.51  180.000\n"
" 10.2Meg    0.0073602  -42.66   -0.000  0.026408   -31.57  180.000\n"
" 10.21Meg   0.0030538  -50.30   -0.000  0.010957   -39.21  180.000\n"
" 10.22Meg   0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 10.23Meg   437.95u    -67.17   -0.000  0.0015713  -56.07 -180.000\n"
" 10.24Meg   152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 10.25Meg   50.597u    -85.92    0.000  181.54u    -74.82 -180.000\n"
" 10.26Meg   15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 10.27Meg   4.8295u   -106.32    0.000  17.328u    -95.23 -180.000\n"
" 10.28Meg   1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 10.29Meg   388.29n   -128.22    0.000  1.3932u   -117.12 -180.000\n"
" 10.3Meg    103.75n   -139.68    0.000  372.26n   -128.58 -180.000\n"
" 10.31Meg   26.712n   -151.47    0.000  95.838n   -140.37 -180.000\n"
" 10.32Meg   6.6384n   -163.56    0.001  23.818n   -152.46 -179.999\n"
"gnucap>\n"
"</code>\n"
msgstr ""
"<code>\n"
"# v(1)      --------- actual ---------  -------- relative --------\n"
"#freq       value        dB      phase  value        dB      phase\n"
" 9.68Meg    6.6294n   -163.57    0.001  23.786n   -152.47 -179.999\n"
" 9.69Meg    26.707n   -151.47  180.000  95.822n   -140.37   -0.000\n"
" 9.7Meg     103.74n   -139.68    0.000  372.23n   -128.58 -180.000\n"
" 9.71Meg    388.29n   -128.22  180.000  1.3931u   -117.12   -0.000\n"
" 9.72Meg    1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 9.73Meg    4.8295u   -106.32  180.000  17.328u    -95.23   -0.000\n"
" 9.74Meg    15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 9.75Meg    50.597u    -85.92  180.000  181.54u    -74.82   -0.000\n"
" 9.76Meg    152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 9.77Meg    437.95u    -67.17  180.000  0.0015713  -56.07   -0.000\n"
" 9.78Meg    0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 9.79Meg    0.0030538  -50.30  180.000  0.010957   -39.21   -0.000\n"
" 9.8Meg     0.0073602  -42.66   -0.000  0.026408   -31.57 -180.000\n"
" 9.81Meg    0.016574   -35.61  180.000  0.059464   -24.51    0.000\n"
" 9.82Meg    0.034626   -29.21   -0.000  0.12423    -18.12 -180.000\n"
" 9.83Meg    0.066529   -23.54  180.000  0.2387     -12.44    0.000\n"
" 9.84Meg    0.11617    -18.70   -0.000  0.41682     -7.60 -180.000\n"
" 9.85Meg    0.18131    -14.83  180.000  0.65051     -3.73    0.000\n"
" 9.86Meg    0.24644    -12.17   -0.000  0.8842      -1.07 -180.000\n"
" 9.87Meg    0.27871    -11.10  180.000  1.           0.00    0.000\n"
" 9.88Meg    0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 9.89Meg    0.09995    -20.00  180.000  0.35861     -8.91   -0.000\n"
" 9.9Meg     0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 9.91Meg    0.22005    -13.15   -0.000  0.7895      -2.05  180.000\n"
" 9.92Meg    0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 9.93Meg    0.034464   -29.25  180.000  0.12365    -18.16   -0.000\n"
" 9.94Meg    0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 9.95Meg    0.13046    -17.69  180.000  0.46806     -6.59   -0.000\n"
" 9.96Meg    0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 9.97Meg    0.19402    -14.24   -0.000  0.69612     -3.15  180.000\n"
" 9.98Meg    0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 9.99Meg    0.2051     -13.76  180.000  0.73589     -2.66   -0.000\n"
" 10.Meg     0.014224   -36.94  180.000  0.051036   -25.84   -0.000\n"
" 10.01Meg   0.2051     -13.76   -0.000  0.73589     -2.66  180.000\n"
" 10.02Meg   0.041572   -27.62   -0.000  0.14915    -16.53  180.000\n"
" 10.03Meg   0.19402    -14.24  180.000  0.69612     -3.15   -0.000\n"
" 10.04Meg   0.11918    -18.48  180.000  0.4276      -7.38   -0.000\n"
" 10.05Meg   0.13046    -17.69   -0.000  0.46806     -6.59  180.000\n"
" 10.06Meg   0.20615    -13.72   -0.000  0.73964     -2.62  180.000\n"
" 10.07Meg   0.034464   -29.25   -0.000  0.12365    -18.16  180.000\n"
" 10.08Meg   0.17398    -15.19  180.000  0.62424     -4.09   -0.000\n"
" 10.09Meg   0.22005    -13.15  180.000  0.7895      -2.05   -0.000\n"
" 10.1Meg    0.090072   -20.91  180.000  0.32317     -9.81   -0.000\n"
" 10.11Meg   0.09995    -20.00   -0.000  0.35861     -8.91  180.000\n"
" 10.12Meg   0.23667    -12.52   -0.000  0.84913     -1.42  180.000\n"
" 10.13Meg   0.27871    -11.10   -0.000  1.          -0.00  180.000\n"
" 10.14Meg   0.24644    -12.17   -0.000  0.8842      -1.07  180.000\n"
" 10.15Meg   0.18131    -14.83   -0.000  0.65051     -3.73  180.000\n"
" 10.16Meg   0.11617    -18.70   -0.000  0.41682     -7.60  180.000\n"
" 10.17Meg   0.066529   -23.54   -0.000  0.2387     -12.44  180.000\n"
" 10.18Meg   0.034626   -29.21   -0.000  0.12423    -18.12  180.000\n"
" 10.19Meg   0.016574   -35.61   -0.000  0.059464   -24.51  180.000\n"
" 10.2Meg    0.0073602  -42.66   -0.000  0.026408   -31.57  180.000\n"
" 10.21Meg   0.0030538  -50.30   -0.000  0.010957   -39.21  180.000\n"
" 10.22Meg   0.0011904  -58.49   -0.000  0.0042709  -47.39 -180.000\n"
" 10.23Meg   437.95u    -67.17   -0.000  0.0015713  -56.07 -180.000\n"
" 10.24Meg   152.67u    -76.32   -0.000  547.76u    -65.23 -180.000\n"
" 10.25Meg   50.597u    -85.92    0.000  181.54u    -74.82 -180.000\n"
" 10.26Meg   15.989u    -95.92    0.000  57.365u    -84.83 -180.000\n"
" 10.27Meg   4.8295u   -106.32    0.000  17.328u    -95.23 -180.000\n"
" 10.28Meg   1.3976u   -117.09    0.000  5.0145u   -106.00 -180.000\n"
" 10.29Meg   388.29n   -128.22    0.000  1.3932u   -117.12 -180.000\n"
" 10.3Meg    103.75n   -139.68    0.000  372.26n   -128.58 -180.000\n"
" 10.31Meg   26.712n   -151.47    0.000  95.838n   -140.37 -180.000\n"
" 10.32Meg   6.6384n   -163.56    0.001  23.818n   -152.46 -179.999\n"
"gnucap>\n"
"</code>\n"

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:224
msgid "As expected, the bandwidth is a a little more than 2*160k."
msgstr "Как и ожидалось, ширина спектра немного больше, чем 2*160k."

#. type: Plain text
#: manual/examples/fm_spectrum_analysis.txt:226
msgid "That's enough for now."
msgstr "Пока всё."

#. type: Title ======
#: manual/examples/hello_world.txt:1
#, no-wrap
msgid "Hello world"
msgstr "Привет, мир"

#. type: Plain text
#: manual/examples/hello_world.txt:4
msgid "Copyright 1999 Telford Tendys (with mods by Albert Davis)"
msgstr "Copyright 1999 Telford Tendys (с изменениями от Albert Davis)"

#. type: Plain text
#: manual/examples/hello_world.txt:12
msgid ""
"This is not an alternative to reading the manual. The manual is very nicely "
"presented in LaTeX and you should print it out and keep it handy when "
"working. This document is organised starting from easy and working towards "
"difficult and presumes that you have some idea of what electrical circuits "
"are but don't know much about simulators.  The manual is organised in "
"alphabetical order and in groups of concepts and it presumes that you know "
"SPICE already."
msgstr ""
"Чтение настоящего документа не заменит чтения руководства. Руководство, со "
"вкусом свёрстанное в LaTeX, желательно распечатать и в процессе работы "
"держать под рукой. Настоящий документ построен на постепенном переходе от "
"простого к сложному, и здесь предполагается, что вы имеете некоторое "
"представление о том, что такое электрические схемы, но недостаточно "
"разбираетесь в программах схемотехнического моделирования. Руководство "
"построено в алфавитном порядке и организовано по группам понятий, исходя из "
"предположения, что вы уже знакомы с программой SPICE."

#. type: Title =====
#: manual/examples/hello_world.txt:13
#, no-wrap
msgid "The basic concept of a nodal analysis"
msgstr "Основные понятия анализа цепей методом узловых потенциалов"

#. type: Plain text
#: manual/examples/hello_world.txt:20
msgid ""
"Using nodes is one way to describe a lumped element circuit.  Lumped "
"elements are used because there is no consideration of what is occurring "
"inside a given component, only what is happening on the terminals of the "
"component. For example, this analysis makes no attempt to find the voltage "
"in the middle of a resistor, only at the ends of the resistor."
msgstr ""
"Использование узлов --- это один из способов описания цепей из элементов с "
"сосредоточенными параметрами (дискретных элементов). Использование "
"дискретных элементов обусловлено тем, что здесь не ставится задача "
"рассмотрения процессов, идущих внутри заданных компонентов, но "
"рассматривается только то, что происходит на их выводах. К примеру, в этом "
"анализе даже не рассматривается поиск напряжения в середине резистора, "
"ищутся напряжения только на его концах."

#. type: Plain text
#: manual/examples/hello_world.txt:27
msgid ""
"The whole circuit model consists of \"nodes\" and \"components\".  A node is "
"(electrically speaking) a single point, it has exactly one voltage value at "
"any given time value. A component will connect to two or more nodes (usually "
"two) and represents some method by which the voltages at those nodes affect "
"one another. Describing which components connect to which nodes will "
"completely describe the structure of the circuit."
msgstr ""
"Полная модель схемы состоит из «узлов» и «компонентов». Узел (с "
"электрической точки зрения) представляет собой одну точку, которая имеет "
"одно единственное значение величины напряжения для любого конкретного "
"значения времени. Компонент обычно соединяется с двумя или более узлами "
"(обычно с двумя) и является представлением некоторого метода взаимовлияния "
"напряжений указанных узлов друг на друга. Описание того, какие компоненты "
"присоединяются к каким узлам, будет полным описанием структуры схемы."

#. type: Plain text
#: manual/examples/hello_world.txt:33
msgid ""
"One additional concept is a \"branch\". The current though a branch is the "
"amount of current flowing from a node into a component that connects to that "
"node. Some branch currents (such as the current through a voltage source)  "
"are explicitly calculated, others (such as the current through a resistor) "
"are implicitly calculated as a result of calculating the node voltages."
msgstr ""
"Одним из вспомогательных понятий является «ветвь». Током ветви называется "
"величина тока, текущего из узла в компонент, присоединённый к этому узлу. "
"Токи некоторых ветвей (такие как токи через источники напряжения) "
"рассчитываются явно, другие (такие как токи через резисторы) рассчитываются "
"косвенно как результат расчёта напряжений узлов."

#. type: Title =====
#: manual/examples/hello_world.txt:33
#, no-wrap
msgid "The basic concept of a circuit file"
msgstr "Общее представление о файлах схем"

#. type: Plain text
#: manual/examples/hello_world.txt:39
msgid ""
"Tradition has it that Gnucap input files have the extension \"''.ckt''\". "
"The format is similar to that used by version 2 of the SPICE simulator; it "
"is a line oriented format with items separated by whitespace. The overall "
"file structure is:"
msgstr ""
"Традиционно входные файлы gnucap имеют расширение «''.ckt''». Формат сродни "
"тому, что используется в версии 2 программы моделирования SPICE; это строчно-"
"ориентированный формат, в котором элементы разделяются пробельными "
"символами. Общая структура файла выглядит так:"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "Header line (first line of the file) usually contains the name of the circuit.  It should be marked as a comment.\n"
msgstr "Строка заголовка (первая строка файла) обычно содержит название схемы. Она должна быть помечена как комментарий.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "blank lines do nothing\n"
msgstr "Пустые строки ни на что не влияют.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "comment lines are any line beginning with a star \"''*''\".  These can be anywhere in the file except the header line.\n"
msgstr "К комментариям относятся только строки, начинающиеся со звёздочки «''*''».  Они могут находиться где угодно в файле, за исключением строки заголовка.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "component lines begin with a letter and represent some component that is in the circuit. The order that components are listed does not matter because the topology is described by the nodes that the components are connected to.\n"
msgstr "Строки компонентов начинаются с буквы и являются представлением каких-нибудь компонентов в схеме. Порядок перечисления компонентов роли не играет, потому что топология схемы описывается узлами, к которым эти компоненты присоединены.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "continuation lines begin with a plus \"''+''\" and continue the previous line so that long lines can be written neatly.\n"
msgstr "Строки-расширения начинаются со знака плюс «''+''» и служат продолжением предшествующих строк, позволяя более аккуратную запись длинных строк.\n"

#. type: Bullet: '  * '
#: manual/examples/hello_world.txt:46
#, no-wrap
msgid "command lines begin with a dot \"''.''\" and are not considered to be part of the circuit, they cause the simulator to execute some analysis or change some options. They are also used to delimit special parts of the file such as subcircuits.\n"
msgstr "Строки команд начинаются с точек «''.''» и частью схемы не считаются, они заставляют программу моделирования выполнить какой-либо анализ или изменить какие-нибудь опции. Кроме того, они используются для определения границ особых частей файла, таких как подсхемы.\n"

#. type: Title =====
#: manual/examples/hello_world.txt:47
#, no-wrap
msgid "Building a simple circuit"
msgstr "Построение простой схемы"

#. type: Plain text
#: manual/examples/hello_world.txt:50
msgid "The \"build\" command lets you enter a circuit from the keyboard."
msgstr ""
"Команда [[..:commands:build.ru|build]] позволяет ввести схему с клавиатуры."

#. type: Plain text
#: manual/examples/hello_world.txt:56
#, no-wrap
msgid ""
"  gnucap> build\n"
"  >Vsupply 0 2 10\n"
"  >R1 0 2 1k\n"
"  >\n"
"  gnucap>\n"
msgstr ""
"  gnucap> build\n"
"  >Vsupply 0 2 10\n"
"  >R1 0 2 1k\n"
"  >\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:58
msgid "A blank line exits the build mode."
msgstr "Ввод пустой строки приводит к выходу из режима построения схемы."

#. type: Plain text
#: manual/examples/hello_world.txt:60
msgid "See what you have with the \"list\" command."
msgstr "Посмотрим, что у нас есть, командой [[..:commands:list.ru|list]]."

#. type: Plain text
#: manual/examples/hello_world.txt:65
#, no-wrap
msgid ""
"  gnucap> list\n"
"  Vsupply ( 0 2 )  DC  10.\n"
"  R1 ( 0 2 )  1.K\n"
"  gnucap>\n"
msgstr ""
"  gnucap> list\n"
"  Vsupply ( 0 2 )  DC  10.\n"
"  R1 ( 0 2 )  1.K\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:67
msgid "Do a quick check of the voltages:"
msgstr "Быстрая проверка напряжений:"

#. type: Plain text
#: manual/examples/hello_world.txt:73
#, no-wrap
msgid ""
"  gnucap> probe op v(nodes)\n"
"  gnucap> op\n"
"  #           v(2)\n"
"   27.       -10.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> probe op v(nodes)\n"
"  gnucap> op\n"
"  #           v(2)\n"
"   27.       -10.\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:75
msgid "You can save it to a file now:"
msgstr "Теперь схему можно сохранить в файл:"

#. type: Plain text
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid ""
"  gnucap> save eg1.ckt\n"
"  gnucap>\n"
msgstr ""
"  gnucap> save eg1.ckt\n"
"  gnucap>\n"

#. type: Title =====
#: manual/examples/hello_world.txt:78
#, no-wrap
msgid "The simplest possible circuit file"
msgstr "Файл самой простой возможной схемы"

#. type: Plain text
#: manual/examples/hello_world.txt:83
#, no-wrap
msgid ""
"  #RESISTOR DRIVEN BY VOLTAGE SOURCE\n"
"  Vsupply 0 2 10\n"
"  R1 0 2 1k\n"
msgstr ""
"<file spice eg1.ckt>\n"
"#РЕЗИСТОР, ПОДКЛЮЧЕННЫЙ К ИСТОЧНИКУ НАПРЯЖЕНИЯ\n"
"Vsupply 0 2 10\n"
"R1 0 2 1k\n"
"</file>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:91
msgid ""
"This file defines a circuit containing two nodes and two components.  The "
"components have the names \"Vsupply\" and \"R1\", the first letter of the "
"component name tells what that component is so \"Vsupply\" is a voltage "
"source and \"R1\" is a resistor. Each component has a value, the voltage "
"source is 10 volts and the resistor is 1000 ohms. The nodes have the numbers "
"\"0\" and \"2\". Note that there is no node \"1\" but this doesn't matter, "
"not every node number needs to be used."
msgstr ""
"В этом файле определена электрическая цепь, содержащая два компонента. Эти "
"компоненты называются «Vsupply» и «R1», первая буква имени компонента "
"определяет тип компонента, поэтому «Vsupply» является источником напряжения "
"(«**V**oltage source»), а «R1» --- это резистор («**R**esistor»). Для "
"каждого компонента указано значение, для источника напряжения 10 вольт, а "
"для резистора 1000 ом. Узлы имеют номера «0» и «2». Заметьте, что узла «1» "
"здесь нет, но это не важно, для номеров узлов не обязательно использовать "
"последовательную нумерацию."

#. type: Plain text
#: manual/examples/hello_world.txt:93
#: manual/examples/phase_shift_oscillator.txt:59
msgid "Run it interactively ..."
msgstr "Запустим это в интерактивном режиме..."

#. type: Plain text
#: manual/examples/hello_world.txt:107
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2009.02.02 RCS 26.109\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get eg1.ckt\n"
"  '\n"
"  gnucap>\n"
msgstr ""
"  $$$$$$$gnucap\n"
"  Gnucap 2009.02.02 RCS 26.109\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get eg1.ckt\n"
"  '\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:111
msgid ""
"From the interactive mode it is possible to exercise the circuit model, "
"firstly by putting a probe on the node that needs measuring (using the print "
"statement) then by starting the simulation:"
msgstr ""
"В интерактивном режиме можно поупражняться с моделью схемы, сначала задав "
"датчик для узла, для которого нужно произвести измерение (с помощью "
"оператора [[..:commands:print.ru|print]]), затем, запустив моделирование:"

#. type: Plain text
#: manual/examples/hello_world.txt:117
#, no-wrap
msgid ""
"  gnucap> print dc v(2)\n"
"  gnucap> dc\n"
"  #           v(2)\n"
"   0.        -10.\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc v(2)\n"
"  gnucap> dc\n"
"  #           v(2)\n"
"   0.        -10.\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:132
msgid ""
"Needless to say, \"dc\" is a steady state direct current analysis and the "
"\"print\" command used here is saying, \"when you do a DC analysis, tell me "
"the voltage at node 2\". The result should be -10 volts. At first glance, it "
"might seem like it should be 10 volts... but (same as SPICE)  the voltage "
"sources are listed with their positive terminal first, then their negative "
"terminal. Node 0 is the ground node (or reference node) which is always 0 "
"volts so node 2 is at -10 volts. Wiring \"Vsupply\" the other way around "
"would change the answer to 10 volts. Things get trickier when dealing with "
"current sources where the node at the tail end of the current source arrow "
"is listed first (and called \"+\") and the pointy head end of the arrow is "
"listed second (and called \"-\"). Although this convention may seem "
"disorienting to someone who was brought up testing their circuits with "
"batteries or a bench power supply and poking their meter probes into things, "
"it is a well established SPICE convention and probably never going to change."
msgstr ""
"Излишне говорить, что [[..:commands:dc.ru|dc]] --- это расчёт статического "
"режима по постоянному току, и используемая здесь команда [[..:commands:print."
"ru|print]] говорит: «когда произведёшь расчёт статического режима, скажи мне "
"напряжение узла 2». В результате должно быть -10 вольт. На первый взгляд "
"могло показаться, будто должно было быть +10 вольт... но (так же, как и в "
"SPICE) для источников напряжения первым указывается их положительный зажим, "
"а затем уже отрицательный. Узел 0 является узлом земли (или опорным узлом), "
"потенциал которого всегда равен 0 вольт, поэтому напряжение узла 2 "
"составляет -10 вольт. При обратном подключении ''Vsupply'' результат "
"изменился бы на +10 вольт. Всё становится ещё сложнее при работе с "
"источниками тока, где узел со стороны хвоста стрелки источника тока "
"считается первым (и называется «''+''»), а узел с той стороны, куда стрелка "
"указывает, считается вторым (и называется «''-''»). Хотя это соглашение и "
"может показаться сбивающим с толку для кого-то, кто возмужал и заматерел, "
"исследуя свои схемы с питанием от батарей или от стендового источника "
"питания и тыкая щупами в разные точки, это хорошо устоявшееся соглашение "
"SPICE, и поэтому, наверно, оно никогда не изменится."

#. type: Plain text
#: manual/examples/hello_world.txt:136
msgid ""
"However, the voltage of the node may not be the answer required. What about "
"the current going through the source? We can move our probe to look at "
"current instead:"
msgstr ""
"Однако, напряжение узла может и не быть искомым решением. Как насчёт тока, "
"протекающего через источник? Мы можем выбрать другой датчик и взглянуть "
"вместо напряжения на ток:"

#. type: Plain text
#: manual/examples/hello_world.txt:142
#, no-wrap
msgid ""
"  gnucap> print dc i(R1) i(Vsupply)\n"
"  gnucap> dc\n"
"  #           i(R1)      i(Vsupply)\n"
"   0.         0.01      -0.01\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc i(R1) i(Vsupply)\n"
"  gnucap> dc\n"
"  #           i(R1)      i(Vsupply)\n"
"   0.         0.01      -0.01\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:157
msgid ""
"Now we can see 10 milliamps going through both components, note the sign "
"convention when probing current; once more this is something that you must "
"simply learn, you might draw diagrams of the main components and mark the "
"important conventions of [+] terminal, [-] terminal and current flow.  You "
"might also realise that this convention does have its own logical "
"consistency which makes it easier to remember. For example, consider a "
"resistor: the terminal called [+] is listed first and the internal current "
"flow is positive when current flows into the [+] terminal, through the "
"resistor and out of the [-] terminal. In the case of a resistor this sounds "
"quite sensible because the [+] terminal WOULD be more positive when the "
"current flows in this manner. The sources merely maintain the same "
"convention as is applied to a resistor, what is important to remember is "
"that [+] and [-] terminals are just names that provide a sign convention "
"they don't insist that one terminal is a higher voltage than the other."
msgstr ""
"Теперь мы можем видеть 10 миллиампер, текущие через оба компонента, с учётом "
"соглашения о знаке при контроле тока. Ещё раз, это то, что вы просто должны "
"выучить, можете даже нарисовать диаграммы основных компонентов и отметить "
"для них эти важные соглашения, связывающие обозначения выводов «+» и «-» и "
"направление тока. Вы также сможете понять, что это соглашение имеет свою "
"логику, позволяющую легче его запомнить. Например, рассмотрим резистор: "
"вывод под названием «+» считается первым, и внутреннее направление тока "
"положительно, когда ток течёт через резистор от вывода «+» к выводу «-». В "
"случае резистора это звучит вполне разумно, так как вывод «+» БУДЕТ более "
"положительным, когда ток течёт таким образом. Для источников напряжения и "
"тока просто поддерживается то же самое соглашение, которое применяется к "
"резистору, и что важно запомнить, так это то, что «+» и «-» --- это просто "
"обозначения выводов, обеспечивающие лишь поддержку соглашения о знаке, и не "
"требующие, чтобы один вывод имел большее напряжение, чем другой."

#. type: Plain text
#: manual/examples/hello_world.txt:161
msgid ""
"This example should provide enough information for analysis of any network "
"of voltage sources and resistors and for inspection of any current or "
"voltage in such a circuit. The power and resistance of each component can be "
"measured:"
msgstr ""
"Данный пример должен был дать вам достаточно информации для анализа любых "
"цепей, состоящих из источников напряжения и резисторов, и для контроля любых "
"токов или напряжений в подобного рода схемах. Для каждого из компонентов "
"можно измерить их мощность и сопротивление:"

#. type: Plain text
#: manual/examples/hello_world.txt:167
#, no-wrap
msgid ""
"  gnucap> print dc p(R1) p(Vsupply) r(R1) r(Vsupply)\n"
"  gnucap> dc\n"
"  #           p(R1)      p(Vsupply) r(R1)      r(Vsupply)\n"
"   0.         0.1       -0.1        1.K        Inf\n"
"  gnucap>\n"
msgstr ""
"  gnucap> print dc p(R1) p(Vsupply) r(R1) r(Vsupply)\n"
"  gnucap> dc\n"
"  #           p(R1)      p(Vsupply) r(R1)      r(Vsupply)\n"
"   0.         0.1       -0.1        1.K        Inf\n"
"  gnucap>\n"

#. type: Plain text
#: manual/examples/hello_world.txt:173
msgid ""
"Note that the supply shows negative power to it is putting power into the "
"system while the resistor shows positive power meaning that it is taking "
"power out of the system. Also notice that the resistance measurement will "
"attempt to find the resistance of the source without error but the resulting "
"value is huge (this seems wrong, I would expect it to be zero)."
msgstr ""
"Обратите внимание, что источник питания, величина мощности которого "
"отрицательна, выдаёт мощность в систему, в то время как мощность, "
"рассчитанная для резистора, положительна, а это значит, что он потребляет "
"мощность из системы. Также заметьте, что при измерении сопротивления "
"программа попытается найти сопротивление источника напряжения без ошибок, но "
"результирующее значение огромно (это кажется неправильным, я бы ожидал, что "
"оно должно быть нулевым)."

#. type: Plain text
#: manual/examples/hello_world.txt:175
msgid "All done, for now."
msgstr "Вот и всё на этот раз."

#. type: Plain text
#: manual/examples/hello_world.txt:177
#, no-wrap
msgid ""
"  gnucap> quit\n"
"  $$$$$$$\n"
msgstr ""
"  gnucap> quit\n"
"  $$$$$$$\n"

#. type: Title ======
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:1
#, no-wrap
msgid "Multiplying Two Voltages Using Diode Nonlinearity"
msgstr "Умножение двух напряжений с помощью нелинейности диода"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:11
msgid ""
"The above example shows diode voltage drop behaviour but the diode can also "
"be used as an exponential function. In this example, a group of diodes are "
"used to construct a voltage multiplier. Most circuit components add and "
"subtract voltages and currents but multiplication is a bit special.  What is "
"done in this circuit is to use the exponential behaviour of the diodes to "
"take the logarithm of two input voltages, then add those up and use another "
"diode to find the exponential of the sum. This works in the same way as a "
"slide rule does."
msgstr ""
"В примере выше показан режим падения напряжения на диоде, но диод можно "
"использовать и для получения экспоненциальной функции. В настоящем примере "
"группа диодов используется для конструирования умножителя напряжения. В "
"большинстве компонентов электрических схем напряжения и токи складываются "
"или вычитаются, но функция умножения несколько специфична. Что делается в "
"этой схеме, так это с помощью экспоненциальной характеристики диодов берутся "
"логарифмы от двух входных напряжений, затем они складываются, а для "
"нахождения экспоненты суммы используется другой диод. Схема работает по тому "
"же принципу, что и логарифмическая линейка."

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:13
msgid "eg7.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:16
#, no-wrap
msgid ""
"<code>\n"
"MULTILPLY TWO NUMBERS\n"
msgstr ""
"<file spice eg7.ckt>\n"
"УМНОЖЕНИЕ ДВУХ ЧИСЕЛ\n"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:37
#, no-wrap
msgid ""
".subckt multiplier 1 2 3\n"
"*                        1 = input A (voltage)\n"
"*                        2 = input B (voltage)\n"
"*                        3 = output  (voltage)\n"
"* Note that there are scaling factors on inputs and output to keep\n"
"* diodes in the exponential region.\n"
".model dexp D EG=0 CJ=0 FC=0 gparallel=0\n"
"G1 0 4 1 0 1e-3\n"
"D1 4 0 dexp\n"
"G2 0 5 2 0 1e-3\n"
"D2 5 0 dexp\n"
"I3 0 6 1\n"
"D3 6 0 dexp\n"
"E1 7 0 4 0 1\n"
"E2 8 7 5 0 1\n"
"E3 8 9 6 0 1\n"
"V1 9 10 0\n"
"D4 10 0 dexp\n"
"H1 3 0 V1 1e6\n"
".ends\n"
msgstr ""
".subckt multiplier 1 2 3\n"
"*                        1 = вход A (напряжение)\n"
"*                        2 = вход B (напряжение)\n"
"*                        3 = выход  (напряжение)\n"
"* Обратите внимание, что для обоих входов и выхода заданы коэффициенты\n"
"* масштабирования, позволяющие диодам оставаться в области экспоненты.\n"
".model dexp D EG=0 CJ=0 FC=0 gparallel=0\n"
"G1 0 4 1 0 1e-3\n"
"D1 4 0 dexp\n"
"G2 0 5 2 0 1e-3\n"
"D2 5 0 dexp\n"
"I3 0 6 1\n"
"D3 6 0 dexp\n"
"E1 7 0 4 0 1\n"
"E2 8 7 5 0 1\n"
"E3 8 9 6 0 1\n"
"V1 9 10 0\n"
"D4 10 0 dexp\n"
"H1 3 0 V1 1e6\n"
".ends\n"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:42
msgid "V1 1 0 0 V2 2 0 0.5 X1 1 2 3 multiplier R1 3 0 1"
msgstr ""
"V1 1 0 0\n"
"V2 2 0 0.5\n"
"X1 1 2 3 multiplier\n"
"R1 3 0 1"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:52
msgid ""
".options vmin=-1e5 vmax=1e5 .print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1."
"E3)  .!rm eg7_1.dat eg7_2.dat eg7_3.dat .dc v1 0 1 0.01 > eg7_1.dat .modify "
"V2=100 .dc v1 0 1 0.01 > eg7_2.dat .dc v1 0 1000 1 > eg7_3.dat .end </code>"
msgstr ""
".options vmin=-1e5 vmax=1e5\n"
".print dc V(3) V(2) V(X1.E1) V(X1.E2) V(X1.E3)\n"
".!rm eg7_1.dat eg7_2.dat eg7_3.dat\n"
".dc v1 0 1 0.01 > eg7_1.dat\n"
".modify V2=100\n"
".dc v1 0 1 0.01 > eg7_2.dat\n"
".dc v1 0 1000 1 > eg7_3.dat\n"
".end\n"
"</file>"

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:60
msgid ""
"This example does not attempt to go beyond the multiplication of two "
"numbers, using the DC sweep to test a few ranges of the inputs.  The output "
"files can be plotted to check the linearity of the outputs.  If you wanted "
"to build a real circuit to perform analog multiplication, you would need "
"something a lot more complex than the above example because the dependent "
"voltage and current sources used in this example would not be possible to "
"construct in a real circuit."
msgstr ""
"В этом примере, используя для тестирования нескольких диапазонов входных "
"сигналов команду развёртки в диапазоне изменения статического режима по "
"постоянному току [[gnucap:manual:commands:dc.ru|dc]], мы не пытаемся выйти "
"за рамки умножения двух чисел. Для проверки линейности выходных данных можно "
"вывести графики выходных файлов. Если для выполнения аналогового умножения "
"нужно было бы построить реальную схему, понадобилось бы нечто более сложное, "
"чем указанный выше пример, потому что из используемых в нём зависимых "
"источников напряжения и тока нельзя составить реальную схему."

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:65
msgid ""
"Even with those ideal simulator components available, this example will "
"still only multiply correctly within a limited range. Using it outside that "
"range requires adjustment of the input and output scaling factors so that "
"the diodes themselves stay close to exponential functions."
msgstr ""
"Даже при наличии таких идеальных компонентов программы моделирования "
"умножение в этом примере будет правильным только в пределах ограниченного "
"диапазона. Работа вне этого диапазона требует подстройки коэффициентов "
"масштабирования входа и выхода, чтобы функции самих диодов оставались близки "
"к экспоненциальным."

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:74
msgid ""
"This example introduces the concept of a subcircuit which is like a macro "
"facility for circuit simulation. The subcircuit is contained between the \"."
"subckt\" and \".ends\" lines and nodes within the subcircuit can use their "
"own numbering, independent of the outside world. The subcircuit gets a name "
"(in this case \"multiplier\") and the component \"X1\" becomes an instance "
"of that subcircuit. Note the way that probes can be put on devices inside "
"the subcircuit, for example \"X1.E1\" refers to the sub-component named "
"\"E1\" inside the subcircuit \"X1\"."
msgstr ""
"В этом примере вводится понятие подсхемы, которая в схемотехническом "
"моделировании представляет собой средство, подобное макросу. Подсхема "
"содержится между строками «''.subckt''» и «''.ends''», а для узлов в "
"подсхеме может использоваться своя собственная нумерация, независимая от "
"внешней схемы. Подсхеме задаётся имя (в данном случае «''multiplier''»), и "
"компонент ''X1'' становится экземпляром этой подсхемы. Обратите внимание на "
"то, каким образом можно задавать датчики для устройств внутри подсхем, "
"например ''X1.E1'' относится к внутреннему компоненту ''E1'' подсхемы ''X1''."

#. type: Plain text
#: manual/examples/multiplying_two_voltages_using_diode_nonlinearity.txt:80
msgid ""
"Another new command here is \".modify\". In this example, we want to test "
"the multiplier on a few DC sweeps but want to change the value of \"V2\" "
"between the sweeps. This allows a single batch run to test multiple "
"possibilities, or it can also be used interactively to trim a component "
"value into the value that gives the desired operating point."
msgstr ""
"Ещё одна новая команда здесь --- это [[gnucap:manual:commands:alter.ru|."
"modify]]. В этом примере нам хочется протестировать умножитель в нескольких "
"диапазонах изменения режима по постоянному току, но между командами "
"развёртки желательно поменять значение ''V2''. Эта команда позволяет "
"использовать один пакетный запуск для тестирования нескольких вариантов. "
"Кроме того, её же можно использовать в интерактивном режиме работы для "
"регулировки значения компонента с целью получения нужной рабочей точки."

#. type: Title ======
#: manual/examples/nonlinear_devices_--_diodes.txt:1
#, no-wrap
msgid "Nonlinear Devices -- Diodes"
msgstr "Нелинейные устройства -- диоды"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:11
msgid ""
"All of the previous circuits have been linear. This is to say that all the "
"devices (voltage sources, current sources, dependent source and resistors) "
"are linear devices and the overall \"shape\" of the problem does not change "
"as the values of the system are scaled up or down.  For example, if a "
"circuit is solved once, then after that all of the voltage sources in the "
"circuit are doubled, the circuit doesn't need to be solved a second time "
"because all the node voltages will merely be double those of the first "
"solution. Try it yourself if you disbelieve."
msgstr ""
"Все предыдущие схемы были линейными. То есть, иными словами, все устройства "
"(источники напряжения, источники тока, зависимые источники и резисторы) "
"являются линейными устройствами, и при пропорциональном изменении значений в "
"системе в большую или меньшую сторону «общий вид» проблемы не меняется. "
"Если, например, схема решена однажды, то после удвоения напряжений всех "
"источников напряжения в схеме ещё одного решения не потребуется, потому что "
"напряжения всех узлов просто удвоятся по сравнению с теми, что были найдены "
"при решении в первый раз. Попробуйте это сами, если не верите."

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:18
msgid ""
"Linear circuits also obey the principle of \"superposition\" which is to say "
"that the circuit can be solved for each source separately and then all of "
"those solutions can be added up to get the solution of a circuit containing "
"many sources. A textbook in basic circuit theory will explain superposition "
"in linear circuits and you can try working through the textbook examples on "
"the simulator using what has been explained so far."
msgstr ""
"Кроме того, линейные схемы подчиняются принципу «суперпозиции», то есть "
"схему можно решить для каждого источника в отдельности, а затем все эти "
"решения сложить, чтобы получить решение для схемы, содержащей много "
"источников. Учебник по теоретическим основам электротехники объяснит "
"суперпозицию в линейных схемах, и вы можете попробовать проработать примеры "
"учебника в программе моделирования, используя то, что объяснялось до сих пор."

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:22
msgid ""
"At this point, we take the step into nonlinear circuits which do NOT obey "
"superposition and do NOT scale. The most elementary nonlinear component is a "
"diode."
msgstr ""
"В этой точке мы делаем шаг в мир нелинейных цепей, НЕ подчиняющихся принципу "
"суперпозиции и НЕ имеющих возможность пропорционального масштабирования. "
"Самым элементарным нелинейным компонентом является диод."

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:24
msgid "eg6.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:27
#, no-wrap
msgid ""
"<code>\n"
"DIODE CASCADE\n"
msgstr ""
"<file spice eg6.ckt>\n"
"ДИОДНЫЙ КАСКАД\n"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:29
msgid ".model 1N414 D IS=2e-14"
msgstr ".model 1N414 D IS=2e-14"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:37
#, no-wrap
msgid ""
"Vcc  1   0   5\n"
"Dx   1  10   1N414\n"
"Dy  10  20   1N414\n"
"Dz  20  30   1N414\n"
"Rd1 10   0   1k\n"
"Rd2 20   0   1k\n"
"Rd3 30   0   1k\n"
msgstr ""
"Vcc  1   0   5\n"
"Dx   1  10   1N414\n"
"Dy  10  20   1N414\n"
"Dz  20  30   1N414\n"
"Rd1 10   0   1k\n"
"Rd2 20   0   1k\n"
"Rd3 30   0   1k\n"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:42
msgid ".print dc v(10) v(20) v(30)  .dc Vcc 0 5 0.5 >eg6.dat .end </code>"
msgstr ""
".print dc v(10) v(20) v(30)\n"
".dc Vcc 0 5 0.5 >eg6.dat\n"
".end\n"
"</file>"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:45
msgid "You can run this example and look at the results like so:"
msgstr ""
"Вы можете запустить данный пример и посмотреть результаты примерно так:"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:51
#, no-wrap
msgid ""
"\tgnucap -b eg6.ckt\n"
"\tgnuplot\n"
"\tset style data lines\n"
"\tplot 'eg6.dat' using 1:2, 'eg6.dat' using 1:3, 'eg6.dat' using 1:4\n"
"\texit\n"
msgstr ""
"\tgnucap -b eg6.ckt\n"
"\tgnuplot\n"
"\tset style data lines\n"
"\tplot 'eg6.dat' using 1:2, 'eg6.dat' using 1:3, 'eg6.dat' using 1:4\n"
"\texit\n"

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:61
msgid ""
"You may not like using gnuplot and may prefer some other plotting program "
"such as gwave or gle. Gnucap output can be used by most plotting programs in "
"much the same manner as above by using the redirection arrow on the command "
"that runs the simulation (\"dc\" in this case). Note that it usually won't "
"work to redirect the normal output to a file using your shell and then cut "
"and paste that output into your plotting program because the normal output "
"does not use standard scientific notation, using the internal redirection "
"option provided also guarantees you get a nice, portable data file in "
"standard exponential notation."
msgstr ""
"Может быть вам не нравится gnuplot и вы предпочитаете другую программу "
"вывода графиков, такую как, например, gwave или gle. Вывод gnucap может "
"использоваться большинством программ черчения графиков тем же способом, что "
"указан выше, то есть путём использования стрелки перенаправления в строке "
"команды, запускающей моделирование (в данном случае [[gnucap:manual:commands:"
"dc.ru|dc]]).  Обратите внимание, что обычно перенаправление нормального "
"вывода в файл с помощью командной оболочки, а затем вырезка и вставка "
"полученных данных в программу вывода графиков, работать не будут, потому что "
"при обычном выводе стандартная научная нотация не используется, "
"использование же данной специально предусмотренной внутренней опции "
"перенаправления гарантирует также, что вы получите аккуратный файл с "
"машинонезависимыми данными в стандартной экспоненциальной нотации."

#. type: Plain text
#: manual/examples/nonlinear_devices_--_diodes.txt:69
msgid ""
"If the above did work you should have been able to see the node voltages as "
"a function of supply voltage and see the diodes move into their conductive "
"band one by one. And see the traditional 0.7 volt drop across each diode.  "
"However, various diodes behave differently so gnucap needs to know what sort "
"of diode you are using. That is what the \".model\" command line is doing "
"for you -- it associated parameters in the diode model with a name that you "
"choose to assign to your diodes. (By the way, I have no idea what the true "
"measured parameters are for a real 1N414)."
msgstr ""
"Если вышеуказанные команды сработали, вы должны были получить возможность "
"увидеть напряжения узлов в функции питающего напряжения и посмотреть, как "
"диоды один за другим переходят в зону своей проводимости. И увидеть "
"традиционное падение 0.7 вольт на каждом диоде. Однако, различные диоды "
"ведут себя по-разному, поэтому программе gnucap нужно знать, какого типа "
"диоды используются у вас. Это то, что делает для вас команда «''.model''», "
"--- она привязывает параметры модели диода к тому имени, которым вы решили "
"свои диоды обозвать. (Я, кстати, не имею представления, какие фактические "
"измеренные параметры должны быть у настоящего 1N414)."

#. type: Title ======
#: manual/examples/phase_shift_oscillator.txt:1
#, no-wrap
msgid "Phase shift oscillator"
msgstr "Фазосдвигающий генератор"

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:3
#: manual/examples/simple_power_supply.txt:3
#, no-wrap
msgid "Getting started"
msgstr "Приступаем к работе"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:6
msgid ""
"In this example, we will analyze a phase shift oscillator.  It was designed "
"in a hurry, so the specs are not expected to be very good.  We will see."
msgstr ""
"В данном примере мы проанализируем фазосдвигающий генератор. Он был "
"разработан наспех, поэтому на хорошие характеристики я не рассчитываю. "
"Поглядим --- увидим."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:8
msgid ""
"It uses a single BJT, plus an emitter follower, and runs on a single-ended "
"12 volt supply."
msgstr ""
"В нём используется один биполярный транзистор, плюс эмиттерный повторитель, "
"и работает он от несимметричного 12-вольтового питания."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:10
msgid "Some measurements might include:"
msgstr "Можно померить:"

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Oscillation frequency\n"
msgstr "Частоту генерации\n"

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Start-up time (how long it takes to stabilize)\n"
msgstr "Время запуска (как долго идёт стабилизация)\n"

#. type: Bullet: '  - '
#: manual/examples/phase_shift_oscillator.txt:14
#, no-wrap
msgid "Distortion\n"
msgstr "Искажения\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:16
msgid "Of course, we will look at the waveform."
msgstr "Конечно же, мы посмотрим и форму сигнала."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:18
msgid ""
"I did this on the 2008-07-07 development snapshot, using some new features.  "
"I am not showing some of the mistake and trial steps, so your results may be "
"a little different."
msgstr ""
"Я делал это с помощью среза разработки 2008-07-07, используя кое-какие новые "
"возможности. Некоторые ошибочные и пробные шаги здесь не показаны, поэтому "
"ваши результаты могут слегка отличаться от моих."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:20
msgid ""
"I am using an external waveform viewer \"gwave\" to display the waveforms."
msgstr "Для отображения сигналов я использую стороннюю программу «gwave»."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:22
msgid "That's enough for now, let's go..."
msgstr "На данный момент достаточно, поехали..."

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:23
#, no-wrap
msgid "The circuit"
msgstr "Схема"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:26
msgid "{{gnucap:pso.tar.gz|Here's a netlist for the circuit:}}"
msgstr " "

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:43
#, no-wrap
msgid ""
"  ' phase shift oscillator\n"
"  .model npn npn bf=100\n"
"  Vcc (vcc 0) pulse(iv=0 pv=12 rise=.01)\n"
"  Rb1 (vcc b) 100k\n"
"  Rb2 (b 0)   10k\n"
"  Rc  (vcc c) 10k\n"
"  Re  (e 0)   1k\n"
"  Ce  (e 0)   5000u\n"
"  Re2 (e2 0)  1k\n"
"  Q1  (c b e)    npn\n"
"  Q2  (vcc c e2) npn\n"
"  C1  (e2 f1) .01u\n"
"  C2  (f1 f2) .01u\n"
"  C3  (f2 b)  .01u\n"
"  Rf1 (f1 0)  10k\n"
"  Rf2 (f2 0)  10k\n"
msgstr ""
"<file spice pso.ckt>\n"
"' phase shift oscillator\n"
".model npn npn bf=100\n"
"Vcc (vcc 0) pulse(iv=0 pv=12 rise=.01)\n"
"Rb1 (vcc b) 100k\n"
"Rb2 (b 0)   10k\n"
"Rc  (vcc c) 10k\n"
"Re  (e 0)   1k\n"
"Ce  (e 0)   5000u\n"
"Re2 (e2 0)  1k\n"
"Q1  (c b e)    npn\n"
"Q2  (vcc c e2) npn\n"
"C1  (e2 f1) .01u\n"
"C2  (f1 f2) .01u\n"
"C3  (f2 b)  .01u\n"
"Rf1 (f1 0)  10k\n"
"Rf2 (f2 0)  10k\n"
"</file>\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:45
msgid "There are some tricks here .."
msgstr "Здесь есть несколько трюков ..."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:47
msgid ""
"First, the power supply (Vcc).  It is a voltage source, but instead of just "
"saying \"DC=12\" to make it a constant 12 volt supply, I made it a pulse.  "
"It starts at zero, and waits until time=.01 to switch on.  I did this "
"because I want to see how it starts."
msgstr ""
"Сначала источник питания (Vcc). Это источник напряжения, но вместо того, "
"чтобы просто сказать «DC=12», чтобы сделать его источником постоянного "
"питания 12 вольт, я делаю его [[gnucap:manual:devices:basic:pulse.ru|"
"источником импульсного напряжения]].  Он запускается в нулевой момент "
"времени и ждёт 0,01 с до включения. Я сделал так, потому что хочу увидеть, "
"как он запускается. "

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:49
msgid ""
"With just plain \"DC=12\" it would still oscillate, but I cannot be sure of "
"the actual start waveform.  For one, the emitter bypass would already be "
"charged."
msgstr ""
"Если задать только «DC=12», генератор бы, конечно, заработал, но я не мог бы "
"точно знать действительную начальную форму сигнала. Например, блокировочный "
"конденсатор в цепи эмиттера был бы уже заряжен."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:51
msgid "Next, I used a simple model of the BJT, specifying only the beta."
msgstr ""
"Далее, я использовал простую модель биполярного транзистора (BJT), где "
"указывал только β."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:53
msgid ""
"The emitter bypass gives a time constant of 5 seconds, which should make the "
"start-up nice and slow."
msgstr ""
"Блокировочный конденсатор даёт постоянную времени 5 секунд, что должно "
"сделать запуск красивым и медленным."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:55
msgid ""
"Finally, to show some contempt for good design, I just picked R and C for "
"the filter arbitrarily, with no real idea what the frequency would be."
msgstr ""
"Наконец, чтобы показать некоторое презрение к хорошим проектам, я совершенно "
"произвольно выбрал R и C для фильтра, абсолютно не представляя себе, какой "
"должна быть частота."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:72
#, no-wrap
msgid ""
"  $$$$$$$gnucap\n"
"  Gnucap 2008.07.07 RCS 26.86\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get pso.ckt\n"
"  ' phase shift oscillator\n"
msgstr ""
"  $$$$$$$gnucap\n"
"  Gnucap 2008.07.07 RCS 26.86\n"
"  The Gnu Circuit Analysis Package\n"
"  Never trust any version less than 1.0\n"
"  Copyright 1982-2007, Albert Davis\n"
"  Gnucap comes with ABSOLUTELY NO WARRANTY\n"
"  This is free software, and you are welcome\n"
"  to redistribute it under the terms of\n"
"  the GNU General Public License, version 3 or later.\n"
"  See the file \"COPYING\" for details.\n"
"  gnucap> get pso.ckt\n"
"  ' phase shift oscillator\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:74
msgid "Load the circuit .. it echos the title line."
msgstr "Загружаем схему ... выдаётся строка заголовка."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:76
msgid "As a check, list it, see if it is what you expected."
msgstr "Для проверки выведем её, посмотрим, то ли это, что ожидалось."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:95
#, no-wrap
msgid ""
"  gnucap> list\n"
"  .model npn npn ( level=1 kf=NA( 0.) af=NA( 1.) bf= 100. br=NA( 1.) is=NA( 100.E-18) nf=NA( 1.) nr=NA( 1.) isc=NA(\n"
"   0.) re=NA( 0.) rc=NA( 0.) cjc=NA( 0.) cje=NA( 0.) cjs=NA( 0.) fc=NA( 0.5) mjc=NA( 0.33) mje=NA( 0.33) mjs=NA( 0.)\n"
"   tf=NA( 0.) tr=NA( 0.) xtf=NA( 0.) xtb=NA( 0.) xti=NA( 3.) eg=NA( 1.11))\n"
"  Vcc ( vcc 0 ) pulse iv= 0. pv= 12. delay=NA( 0.) rise= 0.01 fall=NA( 0.) width=NA( Inf) period=NA( Inf)\n"
"  Rb1 ( vcc b )  100.K\n"
"  Rb2 ( b 0 )  10.K\n"
"  Rc ( vcc c )  10.K\n"
"  Re ( e 0 )  1.K\n"
"  Ce ( e 0 )  0.005\n"
"  Re2 ( e2 0 )  1.K\n"
"  Q1 ( c b e )  npn NA( 1.)\n"
"  Q2 ( vcc c e2 )  npn NA( 1.)\n"
"  C1 ( e2 f1 )  10.n\n"
"  C2 ( f1 f2 )  10.n\n"
"  C3 ( f2 b )  10.n\n"
"  Rf1 ( f1 0 )  10.K\n"
"  Rf2 ( f2 0 )  10.K\n"
msgstr ""
"  gnucap> list\n"
"  .model npn npn ( level=1 kf=NA( 0.) af=NA( 1.) bf= 100. br=NA( 1.) is=NA( 100.E-18) nf=NA( 1.) nr=NA( 1.) isc=NA(\n"
"   0.) re=NA( 0.) rc=NA( 0.) cjc=NA( 0.) cje=NA( 0.) cjs=NA( 0.) fc=NA( 0.5) mjc=NA( 0.33) mje=NA( 0.33) mjs=NA( 0.)\n"
"   tf=NA( 0.) tr=NA( 0.) xtf=NA( 0.) xtb=NA( 0.) xti=NA( 3.) eg=NA( 1.11))\n"
"  Vcc ( vcc 0 ) pulse iv= 0. pv= 12. delay=NA( 0.) rise= 0.01 fall=NA( 0.) width=NA( Inf) period=NA( Inf)\n"
"  Rb1 ( vcc b )  100.K\n"
"  Rb2 ( b 0 )  10.K\n"
"  Rc ( vcc c )  10.K\n"
"  Re ( e 0 )  1.K\n"
"  Ce ( e 0 )  0.005\n"
"  Re2 ( e2 0 )  1.K\n"
"  Q1 ( c b e )  npn NA( 1.)\n"
"  Q2 ( vcc c e2 )  npn NA( 1.)\n"
"  C1 ( e2 f1 )  10.n\n"
"  C2 ( f1 f2 )  10.n\n"
"  C3 ( f2 b )  10.n\n"
"  Rf1 ( f1 0 )  10.K\n"
"  Rf2 ( f2 0 )  10.K\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:97
msgid ""
"Looks good ..  note the \"NA\" fields ....  NA(5) means that the value is "
"unspecified, but assumed to be 5.  You can see what parameters were "
"specified, and which took the defaults."
msgstr ""
"Выглядит неплохо, обратите внимание на поля «NA»...  «NA(5)» значит, что "
"значение не определено, но принимается равным 5.  Можно увидеть, какие "
"параметры были заданы, а какие принимают значения по умолчанию."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:99
msgid "Before making a run, you need to set a few things up ..."
msgstr "Перед запуском нужно кое-что настроить..."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:102
#, no-wrap
msgid ""
"Pick the points you want to view (all node voltages):\n"
"  gnucap> print tran v(nodes)\n"
msgstr ""
"Выберем значения, которые нужно посмотреть (напряжения всех узлов):\n"
"  gnucap> print tran v(nodes)\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:105
#, no-wrap
msgid ""
"Pick the points you want to be able to do things like \"measure\" on (all probes named \"v\" on anything, including nodes, devices, etc):\n"
"  gnucap> store tran v(*)\n"
msgstr ""
"Выберем точки, в которых хотелось бы иметь возможность делать такие вещи как «[[gnucap:manual:commands:measure.ru|measure]]» (все датчики под названием «v» на всём, чём угодно, включая узлы, устройства и т. д.):\n"
"  gnucap> store tran v(*)\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:114
#, no-wrap
msgid ""
"Now, check the options.  We may want to change some:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7\n"
"  0  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6  itl4=20  itl5=5000\n"
"  er  dampmax= 1.  dampmin= 0.5  dampstrategy=0  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  s\n"
"  ansits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtm\n"
"  old= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2= 0.04166667  trstepcoe\n"
"   units=spice\n"
msgstr ""
"Теперь проверим [[gnucap:manual:commands:options.ru|опции]]. Может быть мы захотим изменить какие-нибудь из них:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7\n"
"  0  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6  itl4=20  itl5=5000\n"
"  er  dampmax= 1.  dampmin= 0.5  dampstrategy=0  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  s\n"
"  ansits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtm\n"
"  old= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2= 0.04166667  trstepcoe\n"
"   units=spice\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:117
#, no-wrap
msgid ""
"The only one I will change now is the printing precision .. Set it to 8 digits.  Starting an oscillator takes a long time.\n"
"  gnucap> opt numdgt=8\n"
msgstr ""
"Единственное, что я сейчас поменяю, это точность вывода... Установим его в 8 цифр. Запуск генератора длится долго.\n"
"  gnucap> opt numdgt=8\n"

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:118
#, no-wrap
msgid "Get started, run to steady state"
msgstr "Запуск, достижение установившегося режима"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:121
msgid ""
"For starters, let's run it for 10 seconds, with a trial time step of .01.  "
"\"trace all\" says to output all of the internal time steps too.  Otherwise, "
"you will just get the ones you asked for."
msgstr ""
"Для начала давайте запустим его на 10 секунд с пробным шагом времени 0,01. "
"Опция «''trace all''» говорит выводить все внутренние шаги тоже. Иначе мы "
"получим только те, что запросили."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:123
msgid ""
"I directed it to a file, boringly called \"z\".  Then look at it with \"gwave"
"\".  The bang (!) says to run a command through the shell.  The ampersand "
"(&) says to leave it running and return, just like a shell command.  That "
"way we can keep the waveforms on the screen and keep going."
msgstr ""
"Я направил вывод в файл под скучным именем «z».  Затем гляжу его с помощью "
"gwave.  Восклицательный знак (!) говорит запускать команду в оболочке. "
"Амперсанд (&) говорит оставить её запущенной в фоне и вернуться, прямо как "
"для команд в shell. Таким образом сигналы можно держать на экране и "
"продолжать работу."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:126
#, no-wrap
msgid ""
"  gnucap> tran 0 10 .01 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""
"  gnucap> tran 0 10 .01 trace all >z\n"
"  gnucap> !gwave z &\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:132
msgid ""
"Here's the waveform.  It looks like it doesn't start oscillating until about "
"1 second.  Then takes until about 5 seconds to settle.  It looks like 10 "
"seconds was a good guess."
msgstr ""
"Вот и форма сигнала.  Кажется, что колебания не начинаются примерно до 1 "
"секунды. Затем где-то до 5 секунд идёт переход в установившийся режим. "
"Кажется, 10 секунд было неплохим предположением."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:134
msgid "{{gnucap:w1.png}}"
msgstr "{{gnucap:w1.png}}"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:136
msgid "Here's an expanded view just as it starts to oscillate:"
msgstr "А вот увеличенный вид момента начала колебаний: "

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:138
msgid "{{gnucap:w7.png}}"
msgstr "{{gnucap:w7.png}}"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:140
msgid "The last few cycles at the end of the run:"
msgstr "Последние несколько периодов в конце работы:"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:142
msgid "{{gnucap:w8.png}}"
msgstr "{{gnucap:w8.png}}"

#. type: Title =====
#: manual/examples/phase_shift_oscillator.txt:143
#, no-wrap
msgid "The measurements we want"
msgstr "Измерения, которые нам нужны"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:146
msgid ""
"Now, tighten the tolerance, so we can get good measurements.  The default "
"settings are fine most of the time, but for this we need better."
msgstr ""
"Теперь зажмём [[gnucap:manual:commands:options.ru|допуски]], чтобы можно "
"было добиться хороших измерений. Чаще всего вполне подходят стандартные "
"настройки, но для данного случая нужны настройки получше."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:156
#, no-wrap
msgid ""
"See what they are:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7.  chgtol= 10.f  pivtol= 100.f\n"
"  pivrel= 0.001  numdgt=8  tnom= 27.  cptime=30000  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6\n"
"  itl4=20  itl5=5000  itl6=0  itl7=1  itl8=99  defl= 100.u  defw= 100.u  defad= 0.  defas= 0.  clobber  dampmax= 1.  dampmin= 0.5  dampstrategy=0\n"
"  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  short= 10.u  out=9999  ydivisions= 4.  phase=degrees  order=auto  mode=mixed\n"
"  transits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtmin= 1.p  dtratio= 1.G  rstray\n"
"  cstray  harmonics=9  trstepgrow= 1.E+99  trstephold= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2=\n"
"  0.04166667  trstepcoef3= 0.005208333  noquitconvfail  edit  recursion=20  language=acs  insensitive  units=spice\n"
msgstr ""
"Посмотрим, каковы они:\n"
"  gnucap> opt\n"
"  .options  noacct  nolist  mod  nopage  nonode  noopts  gmin= 1.p  reltol= 0.001  abstol= 1.p  vntol= 1.u  trtol= 7.  chgtol= 10.f  pivtol= 100.f\n"
"  pivrel= 0.001  numdgt=8  tnom= 27.  cptime=30000  limtim=2  limpts=201  lvlcod=2  lvltim=2  method=trap  maxord=2  itl1=100  itl2=50  itl3=6\n"
"  itl4=20  itl5=5000  itl6=0  itl7=1  itl8=99  defl= 100.u  defw= 100.u  defad= 0.  defas= 0.  clobber  dampmax= 1.  dampmin= 0.5  dampstrategy=0\n"
"  floor= 1.E-21  vfloor= 1.f  roundofftol= 100.f  temperature= 27.  short= 10.u  out=9999  ydivisions= 4.  phase=degrees  order=auto  mode=mixed\n"
"  transits=2  nodupcheck  bypass  incmode  lcbypass  lubypass  fbbypass  traceload  itermin=1  vmax= 5.  vmin=-5.  dtmin= 1.p  dtratio= 1.G  rstray\n"
"  cstray  harmonics=9  trstepgrow= 1.E+99  trstephold= 1.E+99  trstepshrink= 2.  trreject= 0.5  trsteporder=3  trstepcoef1= 0.25  trstepcoef2=\n"
"  0.04166667  trstepcoef3= 0.005208333  noquitconvfail  edit  recursion=20  language=acs  insensitive  units=spice\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:159
#, no-wrap
msgid ""
"Now tighten \"reltol\" and \"trtol\".\n"
"  gnucap> opt reltol=.0001 trtol=1\n"
msgstr ""
"Теперь уменьшим ''reltol'' и ''trtol''...\n"
"  gnucap> opt reltol=.0001 trtol=1\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:163
#, no-wrap
msgid ""
"and run for another .01 seconds, continuing...\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
msgstr ""
"и запустим моделирование ещё на .01 секунды, продолжая далее...\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> !gwave z &\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:172
#, no-wrap
msgid ""
"and make some measurements...\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.00943\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.00778\n"
"  gnucap> param frequency={1/(t2-t1)}\n"
"  gnucap> eval frequency\n"
"  frequency= 606.060606060714\n"
msgstr ""
"и сделаем несколько измерений...\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.00943\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.00778\n"
"  gnucap> param frequency={1/(t2-t1)}\n"
"  gnucap> eval frequency\n"
"  frequency= 606.060606060714\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:174
msgid ""
"For the Fourier analysis, pick a fundamental of half of the real "
"fundamental, as an indicator of accuracy.  We all know, there should be "
"nothing there.  If the component at the odd frequencies is too big, it means "
"the frequency we specified is slightly in error, and we need to tighten "
"tolerances and fine tune."
msgstr ""
"Для [[gnucap:manual:commands:fourier.ru|анализа Фурье]] выберем основную "
"частоту в половину настоящей основной частоты, как индикатор точности. Мы "
"все знаем, что там ничего не должно быть. Если составляющая на частотах "
"нечётных гармоник слишком велика, это значит, что частота, которую мы "
"задали, слегка ошибочна, и нам нужно зажать допуски и произвести тонкую "
"настройку."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:183
#, no-wrap
msgid ""
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 303.030303030357\n"
"  gnucap> print fourier v(e2)\n"
"  gnucap> fourier 0 10k 303.030303030357\n"
"  #Time          v(e2)\n"
"   10.0133       8.9974012\n"
"   10.013326     8.7969959\n"
"   10.013352     8.5847199\n"
msgstr ""
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 303.030303030357\n"
"  gnucap> print fourier v(e2)\n"
"  gnucap> fourier 0 10k 303.030303030357\n"
"  #Time          v(e2)\n"
"   10.0133       8.9974012\n"
"   10.013326     8.7969959\n"
"   10.013352     8.5847199\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:197
#, no-wrap
msgid ""
"   10.016574     9.0517243\n"
"   10.0166       8.8549586\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0656      16.98   90.000  2.2861       7.18  -44.748\n"
"   303.03     0.034076   -29.35  118.607  0.011025   -39.15  -16.141\n"
"   606.06     3.0907       9.80  134.748  1.           0.00    0.000\n"
"   909.09     0.040746   -27.80  -43.182  0.013183   -37.60 -177.930\n"
"   1.2121K    0.3894      -8.19  -94.915  0.12599    -17.99  130.337\n"
"   1.5152K    0.017954   -34.92   17.761  0.0058088  -44.72 -116.987\n"
"   1.8182K    0.15704    -16.08    4.083  0.05081    -25.88 -130.665\n"
"   2.1212K    0.0042367  -47.46   67.220  0.0013708  -57.26  -67.528\n"
"   2.4242K    0.079307   -22.01   94.762  0.02566    -31.82  -39.986\n"
msgstr ""
"   10.016574     9.0517243\n"
"   10.0166       8.8549586\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0656      16.98   90.000  2.2861       7.18  -44.748\n"
"   303.03     0.034076   -29.35  118.607  0.011025   -39.15  -16.141\n"
"   606.06     3.0907       9.80  134.748  1.           0.00    0.000\n"
"   909.09     0.040746   -27.80  -43.182  0.013183   -37.60 -177.930\n"
"   1.2121K    0.3894      -8.19  -94.915  0.12599    -17.99  130.337\n"
"   1.5152K    0.017954   -34.92   17.761  0.0058088  -44.72 -116.987\n"
"   1.8182K    0.15704    -16.08    4.083  0.05081    -25.88 -130.665\n"
"   2.1212K    0.0042367  -47.46   67.220  0.0013708  -57.26  -67.528\n"
"   2.4242K    0.079307   -22.01   94.762  0.02566    -31.82  -39.986\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:199
msgid "303 Hz has a relative amplitude of -39 db.  Not very good."
msgstr "Относительная амплитуда для 303 Гц составляет -39 дБ. Не очень хорошо."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:201
msgid "Tighten the tolerances and measure again:"
msgstr "Ещё раз зажмём допуски и померим снова:"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:206
#, no-wrap
msgid ""
"  gnucap> opt reltol=.00001 trtol=1\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= Inf\n"
msgstr ""
"  gnucap> opt reltol=.00001 trtol=1\n"
"  gnucap> tran 10.01 .001 trace all >z\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= Inf\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:208
msgid ""
"Error ....  we already went past 10.01 seconds ..  Move ahead and try again."
msgstr ""
"Ошибка...  мы уже прошли через 10.01 секунды...  Продолжим и попробуем ещё "
"раз."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:224
#, no-wrap
msgid ""
"  gnucap> tran 10.03 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.02911\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.02747\n"
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 304.878048780472\n"
"  gnucap> eval frequency\n"
"  frequency= 609.756097560944\n"
"  gnucap> fourier 0 10k 304.878048780472\n"
"  #Time          v(e2)\n"
"   10.029986     6.3978311\n"
"   10.030012     6.1507251\n"
"   10.030037     5.9090503\n"
msgstr ""
"  gnucap> tran 10.03 .001 trace all >z\n"
"  gnucap> !gwave z &\n"
"  gnucap> measure t2=cross(\"v(e2)\", cross=7, rise, last)\n"
"  t2= 10.02911\n"
"  gnucap> measure t1=cross(\"v(e2)\", cross=7, rise, last, before=t2)\n"
"  t1= 10.02747\n"
"  gnucap> eval frequency/2\n"
"  (frequency / 2)= 304.878048780472\n"
"  gnucap> eval frequency\n"
"  frequency= 609.756097560944\n"
"  gnucap> fourier 0 10k 304.878048780472\n"
"  #Time          v(e2)\n"
"   10.029986     6.3978311\n"
"   10.030012     6.1507251\n"
"   10.030037     5.9090503\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:248
#, no-wrap
msgid ""
"   10.033189     7.1588976\n"
"   10.033215     6.9059126\n"
"   10.03324      6.6531773\n"
"   10.033266     6.4023893\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0581      16.97   90.000  2.2836       7.17 -104.675\n"
"   304.88     256.82u    -71.81   -1.240  83.092u    -81.61  164.086\n"
"   609.76     3.0908       9.80 -165.325  1.           0.00    0.000\n"
"   914.63     0.0011098  -59.09 -171.143  359.08u    -68.90   -5.817\n"
"   1.2195K    0.38362     -8.32   21.927  0.12412    -18.12 -172.748\n"
"   1.5244K    103.52u    -79.70  178.156  33.493u    -89.50  -16.518\n"
"   1.8293K    0.14832    -16.58 -177.459  0.047988   -26.38  -12.133\n"
"   2.1341K    357.2u     -68.94 -179.519  115.57u    -78.74  -14.193\n"
"   2.439K     0.079273   -22.02  -23.966  0.025648   -31.82  141.360\n"
"   2.7439K    132.94u    -77.53 -126.976  43.011u    -87.33   38.350\n"
"   3.0488K    0.049584   -26.09  126.722  0.016043   -35.89  -67.952\n"
"   3.3537K    168.29u    -75.48  163.828  54.45u     -85.28  -30.847\n"
"   3.6585K    0.033637   -29.46  -84.750  0.010883   -39.27   80.575\n"
"   3.9634K    163.24u    -75.74 -138.899  52.816u    -85.54   26.426\n"
"   4.2683K    0.024012   -32.39   63.711  0.0077689  -42.19 -130.964\n"
"   4.5732K    52.818u    -85.54  168.840  17.089u    -95.35  -25.834\n"
"   4.878K     0.018021   -34.88 -148.890  0.0058308  -44.69   16.435\n"
msgstr ""
"   10.033189     7.1588976\n"
"   10.033215     6.9059126\n"
"   10.03324      6.6531773\n"
"   10.033266     6.4023893\n"
"  # v(e2)     --------- actual ---------  -------- relative --------\n"
"  #freq       value        dB      phase  value        dB      phase\n"
"   0.         7.0581      16.97   90.000  2.2836       7.17 -104.675\n"
"   304.88     256.82u    -71.81   -1.240  83.092u    -81.61  164.086\n"
"   609.76     3.0908       9.80 -165.325  1.           0.00    0.000\n"
"   914.63     0.0011098  -59.09 -171.143  359.08u    -68.90   -5.817\n"
"   1.2195K    0.38362     -8.32   21.927  0.12412    -18.12 -172.748\n"
"   1.5244K    103.52u    -79.70  178.156  33.493u    -89.50  -16.518\n"
"   1.8293K    0.14832    -16.58 -177.459  0.047988   -26.38  -12.133\n"
"   2.1341K    357.2u     -68.94 -179.519  115.57u    -78.74  -14.193\n"
"   2.439K     0.079273   -22.02  -23.966  0.025648   -31.82  141.360\n"
"   2.7439K    132.94u    -77.53 -126.976  43.011u    -87.33   38.350\n"
"   3.0488K    0.049584   -26.09  126.722  0.016043   -35.89  -67.952\n"
"   3.3537K    168.29u    -75.48  163.828  54.45u     -85.28  -30.847\n"
"   3.6585K    0.033637   -29.46  -84.750  0.010883   -39.27   80.575\n"
"   3.9634K    163.24u    -75.74 -138.899  52.816u    -85.54   26.426\n"
"   4.2683K    0.024012   -32.39   63.711  0.0077689  -42.19 -130.964\n"
"   4.5732K    52.818u    -85.54  168.840  17.089u    -95.35  -25.834\n"
"   4.878K     0.018021   -34.88 -148.890  0.0058308  -44.69   16.435\n"

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:250
msgid "That's better.  Noise is -68 db or better.  305 Hz is -81 db."
msgstr "Это лучше. Помехи в районе -68 дБ или лучше. Для 305 Гц это -81 дБ."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:252
msgid ""
"As I said, the oscillator isn't very good.  The second harmonic is only 18 "
"db below the fundamental."
msgstr ""
"Как я сказал, генератор не очень хорош. Вторая гармоника только на 18 дБ "
"ниже основной частоты."

#. type: Plain text
#: manual/examples/phase_shift_oscillator.txt:253
msgid "Enough for now..."
msgstr "Хватит на этот раз..."

#. type: Title ======
#: manual/examples/resistors_and_sources.txt:1
#, no-wrap
msgid "Resistors and sources"
msgstr "Резисторы и источники напряжения и тока"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:6
msgid ""
"The previous example covers enough concepts to model arbitrarily complex "
"networks of resistors and sources. These are essentially linear circuits "
"that have no relation to time. A more elaborate example is presented below:"
msgstr ""
"В предыдущем примере рассмотрено достаточно понятий, чтобы моделировать "
"процессы в цепях произвольной сложности, состоящих из резисторов и "
"источников напряжения и тока. Это, в сущности, цепи линейные, не имеющие "
"временной зависимости. Более сложный пример приводится ниже:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:8
msgid "eg2.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:21
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND VOLTAGE SOURCES\n"
"V1 2 1 10\n"
"V2 4 3 5\n"
"V3 0 3 3\n"
"R1 1 2 220\n"
"R2 2 3 4.7k\n"
"R3 4 5 3.3k\n"
"R4 3 5 10k\n"
"R5 0 1 22k\n"
"R6 0 5 15k\n"
"</code>\n"
msgstr ""
"<file spice eg2.ckt>\n"
"ЦЕПЬ ИЗ РЕЗИСТОРОВ И ИСТОЧНИКОВ НАПРЯЖЕНИЯ\n"
"V1 2 1 10\n"
"V2 4 3 5\n"
"V3 0 3 3\n"
"R1 1 2 220\n"
"R2 2 3 4.7k\n"
"R3 4 5 3.3k\n"
"R4 3 5 10k\n"
"R5 0 1 22k\n"
"R6 0 5 15k\n"
"</file>\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:23
msgid "Run this with:"
msgstr "Запустим это следующим образом:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:32
#, no-wrap
msgid ""
"<code>\n"
"gnucap> get eg2.ckt\n"
"gnucap> print dc v(1) v(2) v(3) v(4) v(5)\n"
"gnucap> dc\n"
"#           v(1)       v(2)       v(3)       v(4)       v(5)\n"
" 0.        -10.712    -0.71161   -3.         2.         0.65161\n"
"gnucap>\n"
"</code>\n"
msgstr ""
"<code>\n"
"gnucap> get eg2.ckt\n"
"gnucap> print dc v(1) v(2) v(3) v(4) v(5)\n"
"gnucap> dc\n"
"#           v(1)       v(2)       v(3)       v(4)       v(5)\n"
" 0.        -10.712    -0.71161   -3.         2.         0.65161\n"
"gnucap>\n"
"</code>\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:34
msgid ""
"Note that this is about the limit of what can be done with these two "
"components. Other components that offer further possibilities are the "
"current source (any component with a name that begins with \"I\" is a "
"current source) and the dependent sources:"
msgstr ""
"Учтите, что это почти предел того, что может быть сделано с этими двумя "
"типами компонентов. К другим компонентам, предоставляющим дополнительные "
"возможности, относятся источники тока (источником тока является любой "
"компонент, имя которого начинается с «I») и зависимые источники напряжения и "
"тока:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:40
#, no-wrap
msgid ""
"|first letter of name |output type |input type |\n"
"|E                    |voltage     |voltage    |\n"
"|F                    |current     |current    |\n"
"|G                    |current     |voltage    |\n"
"|H                    |voltage     |current    |\n"
msgstr ""
"| Первая буква имени  | Тип выхода | Тип входа  |\n"
"| E                   | напряжение | напряжение |\n"
"| F                   | ток        | ток        |\n"
"| G                   | ток        | напряжение |\n"
"| H                   | напряжение | ток        |\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:49
msgid ""
"Each of these has a gain value expressing the relation between its output "
"and its input and they allow the modeling of linear amplifiers and other "
"such devices. As mentioned above, none of these components understand time "
"nor can they be used to represent a nonlinear device.  Thus, any network "
"constructed from the components that have been seen so far will be reducible "
"to a Thevenin or Norton equivalent circuit when considered from the point of "
"view of one particular node and the ground node 0."
msgstr ""
"Значение коэффициента усиления для каждого из этих компонентов выражает "
"взаимосвязь между выходом и входом, и с их помощью можно моделировать "
"линейные усилители и другие подобные им устройства. Как было отмечено выше, "
"ни один из этих компонентов не понимает время, а также не может "
"использоваться для представления нелинейных устройств. Таким образом, любая "
"цепь, собранная из тех компонентов, что рассматривались до сих пор, может "
"быть сведена к эквивалентной схеме Тевенина или Нортона, при рассмотрении её "
"с точки зрения одного конкретного узла и узла земли 0."

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:51
msgid "eg3.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:77
#, no-wrap
msgid ""
"<code>\n"
"NETWORK OF RESISTORS AND DEPENDENT SOURCES\n"
"*\n"
"* Reduce this complicated collection of dependencies\n"
"* down to a single Thevenin equivalent between node 2 and\n"
"* the ground node 0\n"
"*\n"
"I1 1 4 2\n"
"V1 1 0 5\n"
"E1 5 2 1 3 0.4\n"
"F1 5 6 R1 3e-2\n"
"G1 2 3 4 6 1.3\n"
"H1 3 0 R3 1\n"
"R1 4 5 2.2\n"
"R2 1 2 470\n"
"R3 0 2 330\n"
"R4 3 6 1k\n"
"R5 5 6 1e4\n"
"*\n"
"* Look at the voltage at node 2 and the impedance looking into node 2\n"
"*\n"
".print dc v(2) z(2)\n"
".dc\n"
".end\n"
"</code>\n"
msgstr ""
"<file spice eg3.ckt>\n"
"ЦЕПЬ ИЗ РЕЗИСТОРОВ И ЗАВИСИМЫХ ИСТОЧНИКОВ НАПРЯЖЕНИЯ И ТОКА\n"
"*\n"
"* Упростим этот сложный набор зависимостей\n"
"* до эквивалентной схемы Тевенина между узлом 2 и\n"
"* узлом земли 0\n"
"*\n"
"I1 1 4 2\n"
"V1 1 0 5\n"
"E1 5 2 1 3 0.4\n"
"F1 5 6 R1 3e-2\n"
"G1 2 3 4 6 1.3\n"
"H1 3 0 R3 1\n"
"R1 4 5 2.2\n"
"R2 1 2 470\n"
"R3 0 2 330\n"
"R4 3 6 1k\n"
"R5 5 6 1e4\n"
"*\n"
"* Посмотреть напряжение и импеданс для узла 2\n"
"*\n"
".print dc v(2) z(2)\n"
".dc\n"
".end\n"
"</file>\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:86
msgid ""
"Notice that this example file contains some lines that begin with a dot.  "
"These are command lines and behave exactly like the commands you type in "
"interactive mode. These command lines are dotted because of the old SPICE "
"tradition of executing all of the component lines first and then the command "
"lines, gnucap doesn't bother with this, it executes every line in the order "
"that it sees them, but it still follows the old idea of dotting the command "
"lines as a little tribute to SPICE and to make it easier to see what is "
"going on when you read a .ckt file."
msgstr ""
"Обратите внимание, что файл данного примера содержит несколько строк, "
"начинающихся с точки. Это строки команд, и ведут они себя точно так же, как "
"команды, которые вводятся в интерактивном режиме. Они начинаются с точек из-"
"за старой, доставшейся от SPICE традиции обрабатывать сначала все строки "
"компонентов, а строки команд выполнять потом. Программа gnucap на этот счёт "
"не беспокоится, она выполняет строки в том порядке, в котором их видит, но "
"всё же ради того, чтобы отдать небольшую дань уважения SPICE, а также, чтобы "
"при чтении файла ''.ckt'' было легче видно, что там идёт дальше, следует "
"старой традиции начинать строки команд с точек."

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:88
msgid "When you run this example, you might try:"
msgstr "Можно попробовать запустить этот пример так:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:90
#, no-wrap
msgid "  gnucap -b eg3.ckt\n"
msgstr "  gnucap -b eg3.ckt\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:97
msgid ""
"And (all going well) you will see that node 2 is equivalent to a source of "
"54.343 volts in series with an 0.83888 ohm resistor.  You should also notice "
"that gnucap never goes into interactive command mode.  This is because of "
"the \".end\" command that tells gnucap to finish at this point.  You may "
"want to use this example circuit in interactive mode, to achieve this you "
"could either delete the \".end\" command, or (from the system prompt) type:"
msgstr ""
"И (если всё пойдёт нормально) вы увидите, что узел 2 эквивалентен источнику "
"напряжения в 54.343 вольт последовательно с резистором 0.83888 ом. Вам "
"следует также отметить, что gnucap не перейдёт в интерактивный режим работы. "
"Это из-за  команды [[..:commands:end.ru|.end]], которая даёт программе "
"команду завершить работу в этой точке. Если вам захочется воспользоваться "
"схемой из этого примера в интерактивном режиме, можно либо стереть команду "
"[[..:commands:end.ru|.end]], либо набрать в оболочке после её приглашения "
"следующее:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:100
#, no-wrap
msgid ""
"  gnucap\n"
"  get eg3.ckt\n"
msgstr ""
"  gnucap\n"
"  get eg3.ckt\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:104
msgid ""
"Then you can use other interactive commands. Note that you can modify the "
"circuit interactively too. Consider adding another resistor by typing the "
"following at the interactive prompt:"
msgstr ""
"Затем можно использовать другие интерактивные команды. Заметьте, что схему "
"можно менять и в интерактивном режиме. Давайте посмотрим, как добавить ещё "
"один резистор, для этого после приглашения программы нужно набрать:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:108
#, no-wrap
msgid ""
"  build R3\n"
"  R6 3 4 12k\n"
"  <blank line>\n"
msgstr ""
"  build R3\n"
"  R6 3 4 12k\n"
"  <пустая строка>\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:114
msgid ""
"Which allows you to adjust the topology of the circuit in memory. This "
"includes adding components and modifying existing components. You can "
"interactively remove components from the circuit using the \"delete\" "
"command or you can wipe out the entire circuit using the \"clear\" command.  "
"To put the adjusted topology into a file you use the save command:"
msgstr ""
"Эта команда позволяет корректировать топологию загруженной в память схемы. "
"Сюда входит как добавление новых, так и редактирование уже существующих "
"компонентов. В интерактивном режиме можно удалять компоненты из схемы с "
"помощью команды [[..:commands:delete.ru|delete]] или командой [[..:commands:"
"delete.ru|clear]] стирать схемы целиком.  Для сохранения изменённой "
"топологии в файл используйте команду [[..:commands:save.ru|save]]:"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:118
#, no-wrap
msgid ""
"  save eg3_mod.ckt\n"
"  quit\n"
"  cat eg3_mod.ckt\n"
msgstr ""
"  save eg3_mod.ckt\n"
"  quit\n"
"  cat eg3_mod.ckt\n"

#. type: Plain text
#: manual/examples/resistors_and_sources.txt:124
msgid ""
"Looking at what you have saved you will probably notice a few things: "
"firstly, gnucap has remembered your comment lines and command lines and "
"saved them too; secondly, your extra line was inserted into the file before "
"the line containing component \"R3\", this is caused by the argument on the "
"\"build\" command and allows you to insert your build lines where you want "
"them."
msgstr ""
"Посмотрев на результаты сохранения, вы, возможно, заметите несколько вещей: "
"во-первых, программа gnucap запомнила и строки с вашими комментариями, и "
"строки команд, и сохранила всё вместе; во-вторых, добавленная вами строка "
"была вставлена в файл до строки определения компонента ''R3'', что было "
"вызвано использованием аргумента для команды [[..:commands:build.ru|build]], "
"что даёт вам возможность при построении схемы вставлять строки в любое "
"нужное место."

#. type: Title ======
#: manual/examples/simple_power_supply.txt:1
#, no-wrap
msgid "A simple power supply"
msgstr "Простой источник питания"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:6
msgid "In this example, we will analyze a simple power supply."
msgstr "В этом примере мы проанализируем простой источник питания."

#. type: Plain text
#: manual/examples/simple_power_supply.txt:8
msgid ""
"The power supply consists of a \"lump\" power transformer with fairly loose "
"coupling for short circuit protection, a full wave bridge rectifier, and a "
"filter capacitor.  The desired output is about 50 volts at .5 amps (100 Ohm "
"load), with less than 1 volt of ripple.  The power supply should be able to "
"handle a short with no damage, with no fuse."
msgstr ""
"Источник питания состоит из трансформатора из внешнего адаптера питания с "
"довольно слабой трансформаторной связью для защиты от коротких замыканий, "
"двухполупериодного мостового выпрямителя и фильтрующего конденсатора. "
"Желаемый выход составляет около 50 вольт при 0,5 Ампер (нагрузка в 100 Ом), "
"с пульсацией менее 1 вольта.  Источник питания должен без предохранителя "
"выдерживать короткое замыкание без повреждения."

#. type: Plain text
#: manual/examples/simple_power_supply.txt:10
msgid ""
"An inexperienced engineer has chosen a transformer with primary inductance "
"of 1 Henry, secondary inductance of .1 Henry, a turns ratio of 3.16:1.  The "
"stock transformer has a coefficient of coupling of .9.  He has also chosen "
"1N4004 diodes, and a 5000 uf filter capacitor."
msgstr ""
"Неопытный инженер выбрал трансформатор с индуктивностью первичной обмотки "
"равной 1 Гн, индуктивностью вторичной обмотки равной 0,1 Гн, и отношением "
"числа витков 3,16:1. Имеющийся в наличии трансформатор имеет коэффициент "
"связи равный 0,9.  Он также выбрал диоды 1N4004 и фильтрующий конденсатор на "
"5000 мкФ."

#. type: Plain text
#: manual/examples/simple_power_supply.txt:12
msgid ""
"The first goal of simulation is to validate the design.  Then, make "
"adjustments to the design to meet the specs."
msgstr ""
"Первая цель моделирования --- проверить правильность разработки. Затем --- "
"скорректировать её для получения соответствия характеристикам."

#. type: Plain text
#: manual/examples/simple_power_supply.txt:14
msgid ""
"To validate the design, the following measurements need to be made, not "
"necessarily in this order."
msgstr ""
"Для проверки правильности разработки необходимо провести следующие "
"измерения, не обязательно в указанном порядке."

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "DC output voltage, loaded (100 Ohm) and unloaded.\n"
msgstr "Постоянное напряжение выхода, под нагрузкой (100 Ом) и без.\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Ripple voltage.\n"
msgstr "Напряжение пульсаций.\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Current in diodes: waveform, average, steady state peak, power-on surge, AC.\n"
msgstr "Ток в диодах: вид сигнала, среднее значение, пиковое значение в установившемся режиме, выброс тока при включении, значение переменного тока.\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Current in filter cap: as above\n"
msgstr "Ток в фильтрующих конденсаторах: то же, что и выше\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input current: as above\n"
msgstr "Входной ток: то же, что и выше\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Input power, VAR, and power factor: as above\n"
msgstr "Входная мощность, реактивная мощность и коэффициент мощности: то же, что и выше\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Above currents and power for load = nominal (100 Ohm), unloaded, and shorted (.01 Ohm)\n"
msgstr "Вышеуказанные токи и мощность для номинальной нагрузки (100 Ом), холостого хода и короткого замыкания (.01 Ом)\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Diode voltages, PIV, etc.\n"
msgstr "Напряжения диодов, максимальное обратное напряжение и т. д.\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Transformer voltages\n"
msgstr "Напряжения трансформатора\n"

#. type: Bullet: '  - '
#: manual/examples/simple_power_supply.txt:25
#, no-wrap
msgid "Impact of high line (132 volts) and low line (108 volts)\n"
msgstr "Влияние повышенного (132 вольт) и пониженного (108 вольт) сетевого напряжения\n"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:27
msgid ""
"This example will show how to do some of these.  The rest are left as an "
"exercise.  You can make all of these measurements with gnucap."
msgstr ""
"В этом примере будет показано, как сделать кое-что из этого. Остальное "
"остаётся в качестве упражнения.  Все эти измерения можно произвести с "
"помощью gnucap."

#. type: Title =====
#: manual/examples/simple_power_supply.txt:29
#, no-wrap
msgid "Building the circuit"
msgstr "Построение схемы"

#. type: Title =====
#: manual/examples/simple_power_supply.txt:31 about/plugins/models.txt:2
#, no-wrap
msgid "Models"
msgstr "Модели"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:34
msgid "First, let's make subcircuits for the transformer and diode bridge:"
msgstr "Сначала сделаем подсхемы для трансформатора и диодного моста:"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:40
#, no-wrap
msgid ""
"  .subckt transformer (p1 p2 s1 s2)\n"
"  L1 (p1 p2) 1\n"
"  L2 (s1 s2) .1\n"
"  K1 (L1 L2) .9\n"
"  .ends\n"
msgstr ""
"  .subckt transformer (p1 p2 s1 s2)\n"
"  L1 (p1 p2) 1\n"
"  L2 (s1 s2) .1\n"
"  K1 (L1 L2) .9\n"
"  .ends\n"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:48
#, no-wrap
msgid ""
"  .subckt bridge (in1 in2 minus plus)\n"
"  .model 1n4004 d is=1n\n"
"  D1 (in1 plus) 1n4004\n"
"  D2 (in2 plus) 1n4004\n"
"  D3 (minus in1) 1n4004\n"
"  D4 (minus in2) 1n4004\n"
"  .ends\n"
msgstr ""
"  .subckt bridge (in1 in2 minus plus)\n"
"  .model 1n4004 d is=1n\n"
"  D1 (in1 plus) 1n4004\n"
"  D2 (in2 plus) 1n4004\n"
"  D3 (minus in1) 1n4004\n"
"  D4 (minus in2) 1n4004\n"
"  .ends\n"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:50
msgid "Save it in the file \"models\"."
msgstr "Сохраним их в файл ''models''."

#. type: Title ====
#: manual/examples/simple_power_supply.txt:51
#, no-wrap
msgid "Main circuit"
msgstr "Основная схема"

#. type: Plain text
#: manual/examples/simple_power_supply.txt:54
msgid "Now, let's run it interactively..  Type in the circuit..."
msgstr "Теперь давайте запустим это в интерактивном режиме... Введём схему..."

#. type: Plain text
#: manual/examples/simple_power_supply.txt:68
#, no-wrap
msgid ""
"  $ gnucap\n"
"  ..... (signs on)\n"
"  gnucap> include models\n"
"  gnucap> list\n"
"     ..... (list of circuit so far)\n"
"  gnucap> spice\n"
"  gnucap-spice>Vin (in 0) sin (freq=60 ampl=170) ac 120\n"
"  gnucap-spice>X1 (in 0 s1 s2) transformer\n"
"  gnucap-spice>X2 (s1 s2 0 out) bridge\n"
"  gnucap-spice>Rload (out 0) rload\n"
"  gnucap-spice>Cfilter (out 0) cfilter\n"
"  gnucap-spice>.control\n"
"  gnucap>\n"
msgstr ""
"  $ gnucap\n"
"  ..... (начало сеанса работы)\n"
"  gnucap> include models\n"
"  gnucap> list\n"
"     ..... (описание схемы, введённой до этого момента)\n"
"  gnucap> spice\n"
"  gnucap-spice>Vin (in 0) sin (freq=60 ampl=170) ac 120\n"
"  gnucap-spice>X1 (in 0 s1 s2) transformer\n"
"  gnucap-spice>X2 (s1 s2 0 out) bridge\n"
"  gnucap-spice>Rload (out 0) rload\n"
"  gnucap-spice>Cfilter (out 0) cfilter\n"
"  gnucap-spice>.control\n"
"  gnucap>\n"

#. type: Title =====
#: manual/examples/simple_power_supply.txt:69
#, no-wrap
msgid "Simulate"
msgstr "Моделирование"

#. type: Title ====
#: manual/examples/simple_power_supply.txt:71
#, no-wrap
msgid "Set up and first run"
msgstr "Настройка и первый запуск"

#. type: Title ======
#: manual/examples/things_that_can_go_wrong.txt:1
#, no-wrap
msgid "Things that can go wrong"
msgstr "Кое-что, что может пойти не так"

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:3
#, no-wrap
msgid "Voltage sources in parallel"
msgstr "Параллельное соединение источников напряжения"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:6
msgid "eg4.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:9
#, no-wrap
msgid ""
"<code>\n"
"VOLTAGE SOURCES IN PARALLEL\n"
msgstr ""
"<file spice eg4.ckt>\n"
"ПАРАЛЛЕЛЬНОЕ СОЕДИНЕНИЕ ИСТОЧНИКОВ НАПРЯЖЕНИЯ\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:16
msgid "V1 1 0 10.0 V2 1 0 10.2 .print dc v(1) i(V1) i(V2)  .dc .end </code>"
msgstr ""
"V1 1 0 10.0\n"
"V2 1 0 10.2\n"
".print dc v(1) i(V1) i(V2)\n"
".dc\n"
".end\n"
"</file>"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:26
msgid ""
"Here we have V1 and V2 both driving the same node at about 10 volts.  "
"Actually, V2 is very slightly higher than 10 volts so there will be some "
"argument between V1 and V2 as to exactly what the final voltage at node 1 "
"really is. You should see that huge currents are flowing through the "
"supplies (10,000 amps) just due to this small voltage difference. Also note "
"that gnucap does not throw in the towel and give up, nor does it fail to "
"converge... the answer that it gets for v(1)  is a compromise, halfway "
"between the two sources."
msgstr ""
"Здесь у нас V1 и V2 оба запитывают один и тот же узел напряжением около 10 "
"вольт.  На самом деле V2 чуть больше 10 вольт, поэтому V1 и V2 будут спорить "
"насчёт того, какое напряжение должно на самом деле получиться в итоге на "
"узле 1. Вы должны увидеть, что как раз вследствие этого небольшого различия "
"в напряжении через источники питания текут огромные токи (10000 ампер). "
"Также заметьте, что gnucap не только не сдаётся и не отказывается работать, "
"но и не имеет проблем со сходимостью... Решение, которое программа находит "
"для v(1), является компромиссным, равным среднему значению напряжений двух "
"источников."

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:31
msgid ""
"What is does is introduce a slight imperfection in the voltage sources so "
"that they do have a small internal series resistor. This allows it to make "
"the best guess that it can in a difficult situation. How much is this "
"resistance? You can find out like so:"
msgstr ""
" Что она делает, так это вводит в источник напряжения маленькое "
"несовершенство, маленький внутренний последовательный резистор. В трудной "
"ситуации это позволит сделать наиболее вероятный приблизительный расчёт. "
"Какой величины это сопротивление? Его величину можно найти так:"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:34
#, no-wrap
msgid ""
"\tacs\n"
"\toptions\n"
msgstr ""
"\tacs\n"
"\toptions\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:41
msgid ""
"Look at the value of the option called \"short\" (near the middle of the "
"block of options), this is the value (in ohms) of the internal resistance of "
"a voltage source. The \"u\" character means \"micro\" or 1e-6 so the default "
"value of a short circuit is 1e-5 ohms. You might decide that a different "
"short circuit value is more appropriate for running the above circuit so you "
"can type (from the prompt):"
msgstr ""
"Взгляните на значение [[gnucap:manual:commands:options.ru|опции]] "
"''short'' (примерно в середине блока опций), это значение внутреннего "
"сопротивления источника напряжения (в омах). Приставка «u» означает «микро» "
"или 1e-6, поэтому по умолчанию значение сопротивления короткого замыкания "
"составляет 1e-5 Ом. Допустим вы решили, что для указанной выше схемы более "
"подходит другое значение короткого замыкания, тогда вы можете набрать (после "
"приглашения):"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:46
#, no-wrap
msgid ""
"\toptions short=0.5\n"
"\tget eg4.ckt\n"
"\tdc\n"
"\texit\n"
msgstr ""
"\toptions short=0.5\n"
"\tget eg4.ckt\n"
"\tdc\n"
"\texit\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:53
msgid ""
"Which should show you the same voltage (10.1) but now the current has "
"reduced to only one fifth of an Amp (still not small but a lot more "
"reasonable if you were building this with real supplies).  Other option "
"values can be altered in much the same way and input files can contain \"."
"options\" command lines in order to set these options whenever the circuit "
"is loaded."
msgstr ""
"В результате должно быть показано то же самое напряжение (10.1), но ток "
"уменьшится теперь лишь до одной пятой ампера (всё еще не мал, но в гораздо "
"более разумных пределах, если сравнивать это с реальными источниками "
"питания).  Примерно так же можно менять и значения других опций, а команды "
"[[gnucap:manual:commands:options.ru|.options]] можно добавлять во входные "
"файлы, чтобы устанавливать нужные опции каждый раз при загрузке схемы."

#. type: Title =====
#: manual/examples/things_that_can_go_wrong.txt:54
#, no-wrap
msgid "Current sources in series"
msgstr "Последовательное соединение источников тока"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:57
msgid "eg5.ckt"
msgstr " "

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:60
#, no-wrap
msgid ""
"<code>\n"
"CURRENT SOURCES IN SERIES\n"
msgstr ""
"<file spice eg5.ckt>\n"
"ПОСЛЕДОВАТЕЛЬНОЕ СОЕДИНЕНИЕ ИСТОЧНИКОВ ТОКА\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:67
msgid "I1 0 1 2.0001 I2 1 0 2.0 .print dc v(1) i(I1) i(I2)  .dc .end </code>"
msgstr ""
"I1 0 1 2.0001\n"
"I2 1 0 2.0\n"
".print dc v(1) i(I1) i(I2)\n"
".dc\n"
".end\n"
"</file>"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:77
msgid ""
"The case of putting two current sources in series is much the same concept "
"as two voltage sources in parallel. However notice that gnucap copes with it "
"in a different manner. It cannot find a compromise current that is partway "
"between the two sources and it always gives a huge value for the voltage at "
"node 1. At least it doesn't crash and it does give results that give some "
"suggestion as to where the problem might be. There is an option \"gmin\" "
"that introduces resistance into a current source, or you can explicitly add "
"these resistors if you like by putting the resistor in parallel with the "
"current source."
msgstr ""
"Случай с последовательным соединением двух источников тока имеет много "
"общего со случаем параллельного соединения двух источников напряжения. "
"Однако заметьте, что с ним gnucap справляется по-другому. Программа не может "
"найти компромиссный ток, то есть какое-то среднее значение для двух "
"источников, и всегда выдаёт огромное значение для напряжения на узле 1. "
"Фатального сбоя, по крайней мере, не будет, и программа выдаст результаты, "
"дающие некоторые указания в отношении того, где может быть проблема. "
"Существует [[gnucap:manual:commands:options.ru|опция]] ''gmin'', вводящая в "
"источник тока сопротивление, или, если хочется, такие сопротивления можно "
"добавить явно, подключив параллельно источникам тока резисторы."

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:82
msgid ""
"What if you had a big, complex circuit, you messed up by putting two current "
"sources in series but you never thought about checking the strange node? How "
"would you ever know that the circuit was broken? Try this exercise:"
msgstr ""
"А что если бы у вас была большая, сложная схема, и вы ошиблись, добавив "
"последовательно два источника тока, но никогда даже не собирались проверять "
"этот странный узел? Как бы вы вообще узнали, что схема испорчена? Попробуйте "
"это упражнение:"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:88
#, no-wrap
msgid ""
"\tacs\n"
"\tget eg5.ckt\n"
"\talarm dc v(*)(-1e3,1e3)\n"
"\tdc\n"
"\tquit\n"
msgstr ""
"\tacs\n"
"\tget eg5.ckt\n"
"\talarm dc v(*)(-1e3,1e3)\n"
"\tdc\n"
"\tquit\n"

#. type: Plain text
#: manual/examples/things_that_can_go_wrong.txt:94
msgid ""
"Now you get a warning whenever any component gets more that 1000 volts "
"across it. This can be used to test component breakdown if you know that you "
"are using components that cannot tolerate high voltages. It can also be used "
"to ensure that your simulated circuit stays within what you might expect to "
"be the absolute maximum values."
msgstr ""
"Теперь вы будете получать предупреждения всякий раз, когда на любом из "
"компонентов будет напряжение более 1000 вольт. Это можно использовать для "
"проверки компонентов на пробой, если вы знаете, что используемые у вас "
"компоненты не выдерживают высоких напряжений. Это можно использовать и для "
"гарантии того, что моделируемая схема останется в рамках тех величин, "
"которые по вашим расчётам должны быть абсолютными максимальными значениями."

#. type: Title ======
#: manual/howto.txt:1
#, no-wrap
msgid "How to"
msgstr "Как сделать"

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:probes]]\n"
msgstr "[[gnucap:manual:howto:probes.ru     |Датчики]]\n"

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:expressions]]\n"
msgstr "[[gnucap:manual:howto:expressions.ru|Выражения]]\n"

#. type: Bullet: '  * '
#: manual/howto.txt:5
#, no-wrap
msgid "[[gnucap:manual:howto:measure|measurements]]\n"
msgstr "[[gnucap:manual:howto:measure.ru    |Измерения]]\n"

#. type: Title ======
#: manual/howto/expressions.txt:1
#, no-wrap
msgid "Parameter expressions"
msgstr "Выражения с параметрами"

#. type: Plain text
#: manual/howto/expressions.txt:4
msgid "Gnucap supports expressions for almost all parameters."
msgstr ""
"В gnucap почти для всех [[gnucap:manual:commands:parameter.ru|параметров]] "
"поддерживается возможность использования выражений."

#. type: Plain text
#: manual/howto/expressions.txt:6
msgid ""
"Ideally, the usual syntax is supported.  Actually, in some cases you must "
"enclose the expression in quotes or curly braces."
msgstr ""
"В идеале поддерживается обычный синтаксис. Фактически, в некоторых случаях, "
"выражения следует заключать в кавычки или фигурные скобки."

#. type: Plain text
#: manual/howto/expressions.txt:8
msgid ""
"Expressions use late evaluation and dynamic scoping, like a functional "
"language."
msgstr ""
"В выражениях используются отложенные вычисления и динамический контекст, как "
"в функциональных языках программирования."

#. type: Plain text
#: manual/howto/expressions.txt:10
msgid ""
"The \"eval\" command evaluates and prints the present value of an expression."
msgstr ""
"Команда [[..:commands:eval.ru|eval]] служит для вычисления и вывода текущего "
"значения выражения."

#. type: Plain text
#: manual/howto/expressions.txt:12
msgid ""
"The \"measure\" command evaluates and assigns the present value of an "
"expression.  For now, it only takes simple function calls used in "
"measurements."
msgstr ""
"Команда [[..:commands:measure.ru|measure]] служит для вычисления текущих "
"значений выражений и присваивания их параметрам. В настоящее время она "
"принимает лишь вызовы простых функций, используемых в измерениях."

#. type: Plain text
#: manual/howto/expressions.txt:21
#, no-wrap
msgid ""
"  gnucap> param a=5\n"
"  gnucap> param b=a+3\n"
"  gnucap> eval a\n"
"  a= 5.\n"
"  gnucap> eval b\n"
"  b= 8.\n"
msgstr ""
"  gnucap> param a=5\n"
"  gnucap> param b=a+3\n"
"  gnucap> eval a\n"
"  a= 5.\n"
"  gnucap> eval b\n"
"  b= 8.\n"

#. type: Plain text
#: manual/howto/expressions.txt:23
msgid "Now change the value of \"a\"."
msgstr "Теперь изменим значение «a»."

#. type: Plain text
#: manual/howto/expressions.txt:27
#, no-wrap
msgid ""
"  gnucap> param a=9\n"
"  gnucap> eval b\n"
"  b= 12.\n"
msgstr ""
"  gnucap> param a=9\n"
"  gnucap> eval b\n"
"  b= 12.\n"

#. type: Plain text
#: manual/howto/expressions.txt:29
msgid "Thanks to late evaluation, the value of \"b\" also changed."
msgstr "Благодаря отложенным вычислениям значение «b» также изменилось."

#. type: Plain text
#: manual/howto/expressions.txt:31
msgid "This is so you can do things like this:"
msgstr "Поэтому можно сделать следующее:"

#. type: Plain text
#: manual/howto/expressions.txt:34
#, no-wrap
msgid ""
"  r1 (in out) resistor r={rtotal*ratio}\n"
"  r2 (out 0)  resistor r={rtotal*(1-ratio)}\n"
msgstr ""
"  r1 (in out) resistor r={rtotal*ratio}\n"
"  r2 (out 0)  resistor r={rtotal*(1-ratio)}\n"

#. type: Plain text
#: manual/howto/expressions.txt:37
#, no-wrap
msgid ""
"  param rtotal=100k\n"
"  param ratio=.5\n"
msgstr ""
"  param rtotal=100k\n"
"  param ratio=.5\n"

#. type: Plain text
#: manual/howto/expressions.txt:39
msgid "r1 and r2 are both 50k."
msgstr "r1 и r2 оба по 50k."

#. type: Plain text
#: manual/howto/expressions.txt:41
#, no-wrap
msgid "  param rtotal=10k\n"
msgstr "  param rtotal=10k\n"

#. type: Plain text
#: manual/howto/expressions.txt:43
msgid "r1 and r2 are both 5k."
msgstr "r1 и r2 оба по 5k."

#. type: Plain text
#: manual/howto/expressions.txt:45
#, no-wrap
msgid "  param ratio = .3\n"
msgstr "  param ratio = .3\n"

#. type: Plain text
#: manual/howto/expressions.txt:47
msgid "r1 is 3k.  r2 is 7k."
msgstr "Сопротивление r1 равно 3k,  r2 равно 7k."

#. type: Title =====
#: manual/howto/expressions.txt:48
#, no-wrap
msgid "Operators"
msgstr "Операторы"

#. type: Plain text
#: manual/howto/expressions.txt:51
msgid ""
"The usual binary operators (+ - * /) are supported in the usual way with the "
"usual precedence."
msgstr ""
"Обычные двоичные операторы (''+'', ''-'', ''*'', ''/'') поддерживаются как "
"обычно с обычным приоритетом."

#. type: Plain text
#: manual/howto/expressions.txt:53
msgid ""
"The usual comparison operators ( < > <''''= >= == != ) are supported.  The "
"result is 1 if it evaluates to true, 0 if it evaluates to false."
msgstr ""
"Поддерживаются обычные операторы сравнения ( ''<'', ''>'', ''<''''='', "
"''>='', ''=='', ''!='' ). Результат равен 1, если выражение истинно, и 0, "
"если ложно."

#. type: Plain text
#: manual/howto/expressions.txt:55
msgid "The binary operators (&& ||) are supported, and evaluate to 1 or 0."
msgstr ""
"Поддерживаются двоичные операторы (''&&'' и ''||'') и дают в результате 1 "
"или 0."

#. type: Plain text
#: manual/howto/expressions.txt:59
msgid ""
"These functions are included by default.  More functions can be added as "
"plugins."
msgstr ""
"Функции, указанные ниже, поддерживаются по умолчанию. Поддержку других "
"функций можно добавить с помощью плагинов."

#. type: Plain text
#: manual/howto/expressions.txt:73
#, no-wrap
msgid ""
"|abs(x)    |Magnitude of x.  |\n"
"|cos(x)    |Cosine of x.  |\n"
"|cosh(x)   |Hyperbolic cosine of x.  |\n"
"|eval(x)   |Evaluate x.  |\n"
"|exp(x)    |e raised to the x power.  |\n"
"|int(x)    |Integer part of x.  |\n"
"|log(x)    |Natural log of x.  |\n"
"|na(x)     |\"Not available\".  Returns \"NA\" regardless of its argument.  |\n"
"|pow(x,y)  |x raised to the y power.  |\n"
"|sin(x)    |Sine of x.  |\n"
"|sinh(x)   |Hyperbolic sine of x.  |\n"
"|sqrt(x)   |Square root of x.  |\n"
"|tan(x)    |Tangent of x.  |\n"
"|tanh(x)   |Hyperbolic tangent of x.  |\n"
msgstr ""
"| ''abs(x)''    |Модуль                        x |\n"
"| ''cos(x)''    |Косинус                       x |\n"
"| ''cosh(x)''   |Гиперболический косинус       x |\n"
"| ''eval(x)''   |Вычисление значения выражения x |\n"
"| ''exp(x)''    |Экспонента x (e<sup>x</sup>)    |\n"
"| ''int(x)''    |Целая часть                   x |\n"
"| ''log(x)''    |Натуральный логарифм          x |\n"
"| ''na(x)''     |«Not available». (Не доступно.) Возвращает «NA» независимо от аргумента функции  |\n"
"| ''pow(x,y)''  |x в степени y (x<sup>y</sup>)   |\n"
"| ''sin(x)''    |Синус                         x |\n"
"| ''sinh(x)''   |Гиперболический синус         x |\n"
"| ''sqrt(x)''   |Квадратный корень             x |\n"
"| ''tan(x)''    |Тангенс                       x |\n"
"| ''tanh(x)''   |Гиперболический тангенс       x |\n"

#. type: Plain text
#: manual/howto/probes.txt:4
msgid ""
"Gnucap offers a comprehensive set of probes.  This section lists system "
"probes, node probes, and common element probes."
msgstr ""
"В gnucap предлагается исчерпывающий набор датчиков. В этом разделе "
"приводится перечень системных датчиков, датчиков узлов и общих датчиков "
"элементов."

#. type: Plain text
#: manual/howto/probes.txt:6
msgid ""
"Probes always have the syntax name_of_probe(device_or_node).  Example: vdd"
"(m1)."
msgstr ""
"Для датчиков всегда используется следующий синтаксис: ''имя_датчика"
"(устройство_или_узел)''. Пример: ''vdd(m1)''."

#. type: Plain text
#: manual/howto/probes.txt:8
msgid ""
"You can access components in subcircuits by connecting the names with dots. "
"For example: Xone.X67.R56 is R56 in X67 in Xone. Some built-in elements, "
"including diodes, transistors, and mosfets, contain subcircuits with "
"internal elements. M12.Cgd is the gate to drain capacitor of mosfet M12."
msgstr ""
"Доступ к компонентам в подсхемах можно получить, перечисляя имена через "
"точку. Например: ''Xone.X67.R56'' --- это ''R56'' в ''X67'' в ''Xone''. "
"Некоторые встроенные элементы, в том числе диоды, биполярные и полевые "
"транзисторы, содержат подсхемы с внутренними элементами. ''M12.Cgd'' "
"представляет собой конденсатор транзистора ''M12'', представляющий ёмкость "
"между затвором и стоком."

#. type: Title =====
#: manual/howto/probes.txt:9
#, no-wrap
msgid "System probes"
msgstr "Системные датчики"

#. type: Plain text
#: manual/howto/probes.txt:12
msgid "For system probes, use the device name \"0\"."
msgstr "Для системных датчиков следует использовать имя устройства «0»."

#. type: Plain text
#: manual/howto/probes.txt:21
#, no-wrap
msgid ""
"|iter       |The number of iterations needed for convergence for this printed step including any hidden steps.  |\n"
"|bypass     |Prints a code indicating whether model evaluation can be bypassed.\\\\  0=bypass turned off by user.\\\\  1=bypass enabled by user, but not active now.\\\\  11=bypass is possible.  |\n"
"|control    |A number indicating why the simulator chose this time to simulate at.\\\\  1=The user requested it. One of the steps in a sweep.\\\\  2=A scheduled discrete event. An element required a solution at this time.\\\\  3=The effect of the “skip” parameter.\\\\  4=The iteration count exceeded ITL4 so the last step was rejected and is being redone at a smaller time step.\\\\  5=The iteration count exceeded ITL3 so the increase in time step is limited.\\\\  6=Determined by local truncation error or some other device dependent approximation in hopes of controlling accuracy.\\\\  7=Determined by a movable analog event. An element required a solution at this time.\\\\  8=The step size was limited due to iteration count.\\\\  9=This is an initial step. The size was arbitrarily set to 1/100 of the user step size.\\\\  10+x=The previous step was rejected.\\\\  20+x=A zero time step was replaced by mrt.\\\\  30+x=The required step size less than mrt, so it was replaced by mrt.  |\n"
"|damp       |Newton damping factor.  |\n"
"|generator  |The output of the “signal generator”. In a transient analysis, it shows the output of the signal generator, as set up by the generator command. In a DC analysis, it shows the DC input voltage (not the power supply). In an OP analysis, it shows the DC input, normally zero.  |\n"
"|hidden     |The number of hidden steps.  |\n"
"|temp       |The simulation temperature in degrees Celsius.  |\n"
"|time       |The current time in a transient analysis. In AC analysis it shows the time at which the bias point was set, 0 if it was set in a DC or OP analysis, or -1 if it is the bias was not set (power off).  |\n"
msgstr ""
"|''iter''       | Количество итераций, понадобившееся для сходимости для данного выведенного на экран шага, включая любые скрытые шаги  |\n"
"|''bypass''     | Выводит код, отражающий возможность пропуска расчёта модели:\\\\  0: пропуск отключен пользователем\\\\  1: пропуск включен пользователем, но в данный момент не активен\\\\  11: пропуск возможен  |\n"
"|''control''    | Число, указывающее причину, по которой программа выбрала для моделирования данный момент времени:\\\\  1: запрос пользователя. Один из шагов в диапазоне развёртки\\\\  2: запланированное дискретное событие. Элемент затребовал решение для этого момента времени\\\\  3: действие параметра ''skip''\\\\  4: число итераций превысило ''[[..:commands:options.ru|itl4]]'', поэтому последний шаг был отвергнут и пересчитывается для меньшего шага времени\\\\  5: число итераций превысило ''[[..:commands:options.ru|itl3]]'', поэтому увеличение шага времени ограничено\\\\  6: определено в соответствии с локальной погрешностью численного метода («local truncation error», LTE) или в соответствии с какой-то другой зависимой от устройства аппроксимацией в надежде управления точностью\\\\  7: определено перемещаемым аналоговым событием. Элемент затребовал решение в это время\\\\  8: размер шага был ограничен из-за количества итераций\\\\  9: данный шаг является начальным. Размер был произвольно установлен в 1/100 от размера шага, определённого пользователем\\\\  10+x: предыдущий шаг был отвергнут\\\\  20+x: шаг в нулевое время был заменён параметром ''mrt''\\\\  30+x: требуемый размер шага меньше, чем ''mrt'', поэтому он был заменён значением ''mrt''  |\n"
"|''damp''       | Коэффициент затухания Ньютона  |\n"
"|''generator''  | Выход «[[..:commands:generator.ru|генератора сигналов]]». Во [[..:commands:transient.ru|временном анализе]] показывает выход генератора сигналов, настроенный командой [[..:commands:generator.ru|generator]]. В [[..:commands:dc.ru|анализе статического режима]] показывает входное постоянное напряжение (не источника питания). В [[..:commands:op.ru|расчёте рабочей точки]] показывает вход по постоянному току, обычно ноль  |\n"
"|''hidden''     | Количество скрытых шагов  |\n"
"|''temp''       | Температура моделирования в градусах Цельсия  |\n"
"|''time''       | Текущее время во [[..:commands:transient.ru|временном анализе]]. В анализе [[..:commands:ac.ru|ac]] показывает время, в которое была установлена точка смещения, 0 если она была установлена в анализах [[..:commands:dc.ru|dc]] или [[..:commands:op.ru|op]], или -1 если смещение не было установлено (питание отключено)  |\n"

#. type: Title =====
#: manual/howto/probes.txt:22
#, no-wrap
msgid "Node probes"
msgstr "Датчики узлов"

#. type: Plain text
#: manual/howto/probes.txt:25
msgid "All modes."
msgstr "**Для всех режимов**"

#. type: Plain text
#: manual/howto/probes.txt:30
#, no-wrap
msgid ""
"|v    |Voltage.  |\n"
"|z    |Impedance looking into the node.  |\n"
"|mdy  |Matrix diagonal \"y\".  |\n"
"|mdz  |Matrix diagonal \"z\".  (1/mdy)  |\n"
msgstr ""
"|''v''    | Напряжение                           |\n"
"|''z''    | Импеданс со стороны указанного узла  |\n"
"|''mdy''  | Диагональ матрицы «y»                |\n"
"|''mdz''  | Диагональ матрицы «z» (''1/mdy'')    |\n"

#. type: Plain text
#: manual/howto/probes.txt:32
msgid "Transient, DC, OP, only."
msgstr ""
"**Только для анализов [[gnucap:manual:commands:transient.ru|transient]], "
"[[gnucap:manual:commands:dc.ru|dc]], [[gnucap:manual:commands:op.ru|op]]**"

#. type: Plain text
#: manual/howto/probes.txt:38
#, no-wrap
msgid ""
"|logic  |A numeric interpretation of the logic value at the node. The value is displayed encoded in a number of the form a.bc where\\\\ \\\\ a is the logic state:\\\\ 0 = logic 0\\\\ 1 = rising\\\\ 2 = falling\\\\ 3 = logic 1\\\\ 4 = unknown\\\\ \\\\ b is an indication of the quality of the digital signal.\\\\ 0 is a fully valid logic signal.\\\\ Nonzero indicates it does not meet the criteria for logic simulation.\\\\ \\\\ c indicates how the node was calculated:\\\\ 0 indicates logic simulation.\\\\ 1 indicates analog simulation of a logic device.\\\\ 2 indicates analog simulation of analog devices.  |\n"
"|lastchange  |The most recent time at which the logic state changed.  |\n"
"|finaltime   |The scheduled time a pending logic state change will occur.  |\n"
"|diter       |Iteration number for last digital update.  |\n"
"|aiter       |Iteration number for last analog update.  |\n"
msgstr ""
"|''logic''       | Числовая интерпретация логического значения для узла. Это значение отображается в виде закодированного числа в формате ''a.bc'', где\\\\ \\\\ ''a'' это логическое состояние:\\\\ 0 = логический 0;\\\\ 1 = нарастающий фронт;\\\\ 2 = ниспадающий фронт;\\\\ 3 = логическая 1\\\\ 4 = неизвестное\\\\ \\\\ ''b'' является индикацией качества цифрового сигнала:\\\\ 0 это полностью допустимый логический сигнал;\\\\ ненулевое значение означает, что сигнал не соответствует критериям для логического моделирования\\\\ \\\\ ''c'' отражает способ расчёта для узла:\\\\ 0 означает логическое моделирование;\\\\ 1 означает аналоговое моделирование логического устройства;\\\\ 2 означает аналоговое моделирование аналоговых устройств  |\n"
"|''lastchange''  | Время самого последнего изменения логического состояния  |\n"
"|''finaltime''   | Время, в которое запланировано выполнение отложенного изменения логического состояния  |\n"
"|''diter''       | Число итераций для последнего цифрового   обновления  |\n"
"|''aiter''       | Число итераций для последнего аналогового обновления  |\n"

#. type: Plain text
#: manual/howto/probes.txt:40
msgid "AC only."
msgstr "**Только для [[..:commands:ac.ru|ac]]**"

#. type: Plain text
#: manual/howto/probes.txt:42
msgid ""
"In addition to those listed here, you can add a suffix (M, P, R, I and db) "
"for magnitude, phase, real part, imaginary part, and decibels, to any valid "
"probe."
msgstr ""
"В дополнение к перечисленным здесь датчикам, к имени любого допустимого "
"датчика можно добавлять суффиксы ''M'', ''P'', ''R'', ''I'' и ''DB'' для "
"измерения, соответственно, амплитуды, фазы, вещественной части, мнимой части "
"и уровня величины в децибелах."

#. type: Title =====
#: manual/howto/probes.txt:43
#, no-wrap
msgid "Element probes"
msgstr "Датчики элементов"

#. type: Plain text
#: manual/howto/probes.txt:46
msgid ""
"Each element type has several parameters that can be probed. In general, the "
"form is Parameter(element). Wild cards are allowed in element names to allow "
"probing the same parameter of a group of elements."
msgstr ""
"Для каждого типа элемента имеется несколько параметров, которые можно "
"измерить. Общий формат датчика: ''параметр(элемент)''. В именах элементов "
"допускается использовать метасимволы для измерения одного и того же "
"параметра у группы элементов."

#. type: Plain text
#: manual/howto/probes.txt:48
msgid ""
"For components in a subcircuit, the names are connected with dots. For "
"example X13.R12 is R12 in the subcircuit X13."
msgstr ""
"Имена компонентов, входящих в подсхемы, образуются из имён подсхем и имён "
"компонентов и точек в качестве разделителей. Например, ''X13.R12'' --- это "
"''R12'' в подсхеме ''X13''."

#. type: Plain text
#: manual/howto/probes.txt:54
msgid "All devices:"
msgstr "**Все устройства**"

#. type: Plain text
#: manual/howto/probes.txt:59
#, no-wrap
msgid ""
"|v<sub>n</sub>  |Voltage at a port.  v2(m2) is the voltage at the second port.  |\n"
"|errortime      |Suggestion of next time point based on truncation or interpolation error.  |\n"
"|eventtime      |Suggestion of next time point based on movable events.  |\n"
"|timefuture     |Suggestion of next time point, the sooner of errortime and eventtime.  |\n"
msgstr ""
"|''v//n//''      | Напряжение порта. ''v2(m2)'' означает напряжение на втором порту  |\n"
"|''errortime''   | Следующая точка времени, предлагаемая на основе погрешности численного метода («truncation error») или погрешности интерполяции  |\n"
"|''eventtime''   | Следующая точка времени, предлагаемая на основе подвижных событий  |\n"
"|''timefuture''  | Следующая точка времени, предлагаемая как ближайшая из ''errortime'' и ''eventtime''  |\n"

#. type: Plain text
#: manual/howto/probes.txt:63
msgid ""
"Most elements,\\\\ devices that do not have an internal subcircuit,\\\\ "
"devices that can be defined simply by y=f(x)."
msgstr ""
"**Большинство элементов**\n"
"  * Устройства, которые не имеют внутренней подсхемы\n"
"  * Устройства, которые могут быть определены просто выражением y=f(x)\n"

#. type: Plain text
#: manual/howto/probes.txt:86
#, no-wrap
msgid ""
"|v\\\\ vout  |Branch voltage for two terminal devices, output voltage for four terminal devices. The first node in the net list is assumed positive.  |\n"
"|vin       |Input voltage.  The voltage across the “input” terminals. For two terminal elements, input and output voltages are the same.  |\n"
"|i         |Branch current. It flows into the first node in the net list, out of the second.  |\n"
"|p         |Power. Positive power indicates dissipation. Negative power indicates that the part is supplying power. Its value is the same as (PD - PS). In AC analysis, it is the real part only.  |\n"
"|pd        |Power dissipated. The power dissipated in the part. It is always positive and does not include power sourced.  |\n"
"|ps        |Branch power sourced. The power sourced by the part. It is always positive and does not consider its own dissipation.  |\n"
"|input     |The “input” of the device. It is the current through a resistor or inductor, the voltage across a capacitor or admittance, etc. It is the value used to evaluate nonlinearities.  |\n"
"|f         |The result of evaluating the function related to the part. It is the voltage across a resistor, the charge stored in a capacitor, the flux in an inductor, etc.  |\n"
"|df\\\\ ev   |The derivative of f with respect to input.  Usually this is also the effective value of the part, in its units. If the part is ordinary, it will just show its value, but if it is time variant or nonlinear, it shows what it is now.  |\n"
"|nv        |Nominal value. In most cases, this is just the value which is constant, but it can vary for internal elements of complex devices.  |\n"
"|eiv       |Equivalent input voltage.  The voltage on which the matrix stamp is based.  |\n"
"|y         |Matrix stamp admittance.  |\n"
"|istamp    |Matrix stamp current.  |\n"
"|ipassive  |Passive part of matrix stamp current.  |\n"
"|ioffset   |Offset part of matrix stamp current.  |\n"
"|iloss     |Loss part of device current.  |\n"
"|dt        |Delta time.  Time step for this device.  |\n"
"|dtr\\\\ dtrequired  |dt required.  Recommended dt for next step.  |\n"
"|time      |Time at most recent actual calculation.  It is usually the present time.  |\n"
"|timeold   |Time at the previous actual calculation.  |\n"
"|z         |Circuit impedance seen by this device, with this device not counted.  Prints a meaningless number in transient analysis.  |\n"
"|zraw      |Circuit impedance looking across this device, including this device.  Prints a meaningless number in transient analysis.  |\n"
msgstr ""
"|''v''\\\\ ''vout''  | Напряжение ветви для двухвыводных устройств, выходное напряжение для четырёхвыводных устройств. Первый узел в списке соединений считается положительным  |\n"
"|''vin''         | Входное напряжение. Напряжение на «входных» выводах. Для двухвыводных элементов входное и выходное напряжения одинаковы  |\n"
"|''i''           | Ток ветви. Ток втекает в первый узел списка соединений и вытекает из второго  |\n"
"|''p''           | Мощность. Положительное значение мощности означает её рассеяние. Отрицательное значение означает, что компонент подаёт питание в схему. Значение данного параметра равно ''(pd - ps)''. В анализе [[gnucap:manual:commands:ac.ru|ac]] он представляет только вещественную часть  |\n"
"|''pd''          | Рассеиваемая мощность. Мощность, рассеиваемая в компоненте. Её значение всегда положительно и не включает питание, выдаваемое в схему |\n"
"|''ps''          | Отдаваемая в схему мощность ветви. Мощность, отдаваемая компонентом. Её значение всегда положительно и не учитывает мощности, рассеиваемой в самом компоненте  |\n"
"|''input''       | «Вход» устройства. Это ток через резистор или катушку индуктивности, напряжение на конденсаторе или проводимости и т. д. Это значение, используемое для оценки нелинейностей  |\n"
"|''f''           | Результат оценки функции компонента. Для резистора это падение напряжения, для конденсатора --- сохранённый в нём заряд, для катушки индуктивности --- магнитный поток, и т. д.  |\n"
"|''df''\\\\ ''ev''   | Производная от ''f'' по отношению ко входу. Обычно это также эффективное значение компонента, в единицах его величины. Для обычных компонентов просто отображаются их значения, но для изменяемых во времени или нелинейных компонентов отображаются значения в настоящий момент времени  |\n"
"|''nv''          | Номинальное значение. В большинстве случаев это просто значение, которое является константой, но оно может изменяться для внутренних элементов комплексных устройств  |\n"
"|''eiv''         | Эквивалентное входное напряжение. Напряжение, на основе которого заполняется подматрица  |\n"
"|''y''           | Проводимость подматрицы  |\n"
"|''istamp''      | Ток подматрицы  |\n"
"|''ipassive''    | Пассивная часть тока подматрицы  |\n"
"|''ioffset''     | Часть смещения тока подматрицы  |\n"
"|''iloss''       | Часть потерь тока устройства  |\n"
"|''dt''          | Время «дельта». Временной шаг для данного устройства  |\n"
"|''dtr''\\\\ ''dtrequired''  |''dt'' требуемое. Значение ''dt'', рекомендуемое для следующего шага  |\n"
"|''time''        | Значение времени, для которого производилось самое последнее вычисление. Обычно это настоящее время  |\n"
"|''timeold''     | Значение времени, для которого производилось предпоследнее вычисление  |\n"
"|''z''           | Импеданс схемы, видимый со стороны устройства без учёта его самого. Во [[gnucap:manual:commands:transient.ru|временном анализе]] выводится значение, не имеющее смысла  |\n"
"|''zraw''        | Импеданс схемы, видимый со стороны устройства с учётом его самого. Во [[gnucap:manual:commands:transient.ru|временном анализе]] выводится значение, не имеющее смысла  |\n"

#. type: Title ======
#: manual/languages.txt:1
#, no-wrap
msgid "Languages"
msgstr "Языки"

#. type: Plain text
#: manual/languages.txt:4
msgid ""
"By use of plugins, Gnucap gives you a choice of simulation languages.  The "
"following are the simulation languages supported in this release."
msgstr ""
"Поддержка плагинов в gnucap даёт вам возможность выбрать язык моделирования. "
"В настоящей версии программы поддерживаются следующие языки:"

#. type: Plain text
#: manual/languages.txt:8
msgid ""
"[[gnucap:manual:languages:Verilog]]\\\\ [[gnucap:manual:languages:Spectre]]\\"
"\\ [[gnucap:manual:languages:Spice]]\\\\ [[gnucap:manual:languages:ACS]]"
msgstr ""
"[[gnucap:manual:languages:Verilog.ru|Verilog]]\\\\ [[gnucap:manual:languages:"
"Spectre.ru|Spectre]]\\\\ [[gnucap:manual:languages:Spice.ru|SPICE]]\\\\ "
"[[gnucap:manual:languages:ACS.ru|ACS]]"

#. type: Title ======
#: manual/languages/spectre.txt:1 spectre.txt:1
#, no-wrap
msgid "Language : Spectre"
msgstr "Язык Spectre"

#. type: Plain text
#: manual/languages/spectre.txt:4 spectre.txt:4
msgid ""
"The Spectre language plugin attempts to support the syntax of the Cadence "
"Spectre simulator."
msgstr ""
"С помощью плагина для языка Spectre в программе gnucap предпринята попытка "
"реализовать поддержку синтаксиса программы моделирования Spectre от Cadence."

#. type: Plain text
#: manual/languages/spectre.txt:6 spectre.txt:6
msgid ""
"Not all features of Spectre are supported, but those that work will work "
"with Spectre syntax.  Wherever possible, Gnucap features will work in "
"Spectre mode, even if they don't work in Spectre."
msgstr ""
"Не все возможности Spectre поддерживаются плагином, но те, что работают, "
"будут работать и в режиме работы с синтаксисом Spectre. Программные "
"возможности gnucap в этом режиме будут работать всюду, где только можно, "
"даже если собственно в программе Spectre аналогичных возможностей нет."

#. type: Plain text
#: manual/languages/spectre.txt:8 spectre.txt:8
msgid "The Spectre mode is case sensitive, and uses \"SI\" units."
msgstr "Режим Spectre регистрозависим, и в нём используются единицы СИ."

#. type: Plain text
#: manual/languages/spectre.txt:10 manual/languages/verilog.txt:10
#: spectre.txt:10
msgid ""
"The \"SI\" units are case sensitive.  1p is 1e-12.  1P is 1e15.  1m is "
"1e-3.  1M is 1e6."
msgstr ""
"Единицы величин СИ регистрозависимы: 1p соответствует 1e-12, 1P --- 1e15,  "
"1m --- 1e-3, 1M --- 1e6."

#. type: Plain text
#: manual/languages/spectre.txt:12 manual/languages/verilog.txt:12
#: spectre.txt:12
msgid "Comments are preceded by /****/ and extend to the end of the line."
msgstr "Комментарии начинаются с «%%//%%» и длятся до конца строки."

#. type: Plain text
#: manual/languages/spectre.txt:14 spectre.txt:14
msgid ""
"The format is line oriented.  A newline terminates a statement.  You can "
"extend a line by ending it with \\ ."
msgstr ""
"Формат строчноориентированный. Операторы завершаются символами новой строки. "
"Если закончить строку символом «\\», следующая строка будет считаться её "
"продолжением."

#. type: Plain text
#: manual/languages/spectre.txt:16 spectre.txt:16
msgid "From startup, you can set Spectre mode with the command line:"
msgstr ""
"После запуска программы режим Spectre можно задать из командной строки:"

#. type: Plain text
#: manual/languages/spectre.txt:18 spectre.txt:18
#, no-wrap
msgid "  simulator lang=spectre\n"
msgstr "  simulator lang=spectre\n"

#. type: Plain text
#: manual/languages/spectre.txt:20
msgid "or"
msgstr "или"

#. type: Plain text
#: manual/languages/spectre.txt:22
#, no-wrap
msgid "  spectre\n"
msgstr "  spectre\n"

#. type: Title ======
#: manual/languages/spectre.txt:23 manual/languages/verilog.txt:24
#: spectre.txt:36
#, no-wrap
msgid "Components"
msgstr "Компоненты"

#. type: Plain text
#: manual/languages/spectre.txt:26 manual/languages/verilog.txt:27
msgid "All components have the same syntax:"
msgstr "Для всех компонентов используется одинаковый синтаксис:"

#. type: Plain text
#: manual/languages/spectre.txt:28
#, no-wrap
msgid "  label (port list) type arguments\n"
msgstr "|''//обозначение// (//список портов//) //тип аргументы//''|\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 manual/languages/verilog.txt:34
#: spectre.txt:46
#, no-wrap
msgid "**Label** : a string.  The first letter has no significance.\n"
msgstr "''//обозначение//'' --- строка. Первая буква роли не играет.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 spectre.txt:46
#, no-wrap
msgid "**Port list** : A list of the ports (connections), whitespace delimited.  Mapping is determined by order.  The port list should be surrounded by parentheses.\n"
msgstr "''//список портов//'' --- список портов (соединений), разделённых пробельными символами. Соответствие портов соединениям определяется порядком записи. Список портов должен быть заключён в круглые скобки.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33 spectre.txt:46
#, no-wrap
msgid "**Type** : The type of component.  If there is a \"model\" statement, this is the name in the model statement.  Otherwise, it could be the name of a \"subckt\", a Verilog \"module\" or \"paramset\", or a standard device.  This is called \"master\" in the Spectre manual.\n"
msgstr "''//тип//'' --- тип компонента. Если имеется оператор ''model'', это имя типа, заданное в данном операторе. В противном случае, это может быть имя ''[[#subckt]]'', ''[[.:verilog.ru#module]]'' или ''[[.:verilog.ru#paramset]]'' в Verilog, или какого-то стандартного устройства. В руководстве по Spectre это называется //оригиналом// («master»).\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:33
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name = value pairs, of the form \"name = value\", whitespace delimited.  The value may be an expression.\n"
msgstr "''//аргументы//'' --- список аргументов ([[gnucap:manual:commands:parameter.ru|параметры]] или значения). Все аргументы задаются в виде пар в формате «имя=значение» и отделяются друг от друга пробельными символами. Значение аргумента может быть [[gnucap:manual:howto:expressions.ru|выражением]].\n"

#. type: Plain text
#: manual/languages/spectre.txt:36
#, no-wrap
msgid ""
"  Rload (out 0) resistor r=10K\n"
"  X1 (out in vc) amp rload=100K\n"
msgstr ""
"  Rload (out 0) resistor r=10K\n"
"  X1 (out in vc) amp rload=100K\n"

#. type: Plain text
#: manual/languages/spectre.txt:38
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Spectre mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""
"Имеется несколько компонентов, для которых используется синтаксис других "
"языков, и которые в режиме Spectre не поддерживаются, но их всё же можно "
"использовать, если переключиться в какой-нибудь режим, в котором этот "
"синтаксис поддерживается."

#. type: Plain text
#: manual/languages/spectre.txt:41
#, no-wrap
msgid ""
"  Vcc (vc  0) vsource  dc=15 // Spice-style source arguments are not supported.\n"
"  Vin (in  0) vsource  ac=1  // Spice-style source arguments are not supported.\n"
msgstr ""
"  Vcc (vc  0) vsource  dc=15 // Аргументы источников напряжения и тока в стиле SPICE не поддерживаются\n"
"  Vin (in  0) vsource  ac=1  // Аргументы источников напряжения и тока в стиле SPICE не поддерживаются\n"

#. type: Plain text
#: manual/languages/spectre.txt:44 manual/languages/verilog.txt:46
msgid "But you can switch modes, to one that does support the syntax:"
msgstr ""
"Но можно переключить режим, выбрав тот, в котором поддерживается этот "
"синтаксис:"

#. type: Plain text
#: manual/languages/spectre.txt:53
#, no-wrap
msgid ""
"  // assume it is starting in Spectre mode\n"
"  - spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .spectre\n"
"  // Now it is back in Spectre mode.\n"
msgstr ""
"  // Предположим, программа запущена в режиме Spectre\n"
"  - spice\n"
"  * Теперь используется синтаксис SPICE\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Команды в режиме SPICE начинаются с точки\n"
"  .spectre\n"
"  // Теперь программа снова в режиме Spectre\n"

#. type: Title ======
#: manual/languages/spectre.txt:54 manual/languages/verilog.txt:58
#: spectre.txt:19
#, no-wrap
msgid "Top-level blocks"
msgstr "Блоки верхнего уровня"

#. type: Plain text
#: manual/languages/spectre.txt:57 spectre.txt:22
msgid "Two top level blocks are supported: model and subckt."
msgstr ""
"Поддерживается два блока верхнего уровня: ''[[#model]]'' и ''[[#subckt]]''."

#. type: Title =====
#: manual/languages/spectre.txt:58 spectre.txt:23
#, no-wrap
msgid "model"
msgstr "model"

#. type: Plain text
#: manual/languages/spectre.txt:61 spectre.txt:26
msgid ""
"A \"model\" statement sets parameters based on an existing compiled model.  "
"This will be extended to cover all \"masters\".  It becomes a \"master\" "
"that can be instantiated later.  It is equivalent to a spice \".model\" or a "
"Verilog \"paramset\"."
msgstr ""
"Оператор ''model'' задаёт параметры на основе существующей скомпилированной "
"модели. Это будет распространяться на все «оригиналы». Модель становится "
"«оригиналом», экземпляры которого могут добавляться позже. Это эквивалентно "
"ключевому слову ''.model'' в SPICE или ''[[.:verilog.ru#paramset]]'' в "
"Verilog."

#. type: Plain text
#: manual/languages/spectre.txt:64
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"model\" newname itsmaster parameters\n"
msgstr ""
"Синтаксис:\n"
"|''**model** //новый_тип имя_оригинала аргументы//''|\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 spectre.txt:33
#, no-wrap
msgid "**model** : Keyword identifies a model statement.\n"
msgstr "''**model**'' --- ключевое слово, идентифицирующее оператор описания модели.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75
#: spectre.txt:33
#, no-wrap
msgid "**newtype** : The new type being defined.  This can be used as a device type later.\n"
msgstr "''//новый_тип//'' --- новый тип, который здесь определяется. Позднее он может использоваться как тип устройства.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69 manual/languages/verilog.txt:75
#: spectre.txt:33
#, no-wrap
msgid "**itsmaster** : The type it is derived from.\n"
msgstr "''//имя_оригинала//'' --- тип, производным от которого будет ''//новый_тип//''.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:69
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \"name = value\", whitespace delimited.  The value may be an expression.\n"
msgstr "''//аргументы//'' --- список аргументов ([[gnucap:manual:commands:parameter.ru|параметры]] или значения). Все аргументы задаются в виде пар в формате «имя=значение» и отделяются друг от друга пробельными символами. Значение аргумента может быть [[gnucap:manual:howto:expressions.ru|выражением]].\n"

#. type: Plain text
#: manual/languages/spectre.txt:71
#, no-wrap
msgid "  model gp_npn npn bf=150\n"
msgstr "  model gp_npn npn bf=150\n"

#. type: Title =====
#: manual/languages/spectre.txt:72
#, no-wrap
msgid "subckt"
msgstr "subckt"

#. type: Plain text
#: manual/languages/spectre.txt:88
#, no-wrap
msgid ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1   (base vcc)      resistor  r=1M  // 1 megohm\n"
"  Rb2   (base 0  )      resistor  r=100k\n"
"  Rc    (col  vcc)      resistor  r=100k\n"
"  Re    (emit 0  )      resistor  r=10k\n"
"  Ce    (emit 0  )      capacitor c=1m  // 1 millifarad\n"
"  Cin   (base in )      capacitor c=1u\n"
"  Q1    (col base emit) gp-npn\n"
"  Q2    (vcc col e2)    gp-npn\n"
"  Re2   (e2   0  )      resistor  r=1k\n"
"  Cout  (e2   out)      capacitor c=10u\n"
"  Rload (out 0  )       resistor  r=rload\n"
"  ends amp\n"
msgstr ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1   (base vcc)      resistor  r=1M  // 1 мегаом\n"
"  Rb2   (base 0  )      resistor  r=100k\n"
"  Rc    (col  vcc)      resistor  r=100k\n"
"  Re    (emit 0  )      resistor  r=10k\n"
"  Ce    (emit 0  )      capacitor c=1m  // 1 миллифарад\n"
"  Cin   (base in )      capacitor c=1u\n"
"  Q1    (col base emit) gp-npn\n"
"  Q2    (vcc col e2)    gp-npn\n"
"  Re2   (e2   0  )      resistor  r=1k\n"
"  Cout  (e2   out)      capacitor c=10u\n"
"  Rload (out 0  )       resistor  r=rload\n"
"  ends amp\n"

#. type: Plain text
#: manual/languages/spectre.txt:93
#, no-wrap
msgid ""
"  X1    (out in vc)     amp      rload=100k\n"
"  Vcc   (vc  0)         vsource  dc=15\n"
"  Vin   (in  0)         vsource  ac=1\n"
"  Rload (out 0)         resistor r=10k\n"
msgstr ""
"  X1    (out in vc)     amp      rload=100k\n"
"  Vcc   (vc  0)         vsource  dc=15\n"
"  Vin   (in  0)         vsource  ac=1\n"
"  Rload (out 0)         resistor r=10k\n"

#. type: Plain text
#: manual/languages/spectre.txt:97 spectre.txt:69
msgid ""
"Commands usually have the same syntax as components, but there is no port "
"list."
msgstr ""
"Для команд обычно используется тот же синтаксис, что и для [[#компоненты|"
"компонентов]], но не задаётся список портов."

#. type: Plain text
#: manual/languages/spectre.txt:99 spectre.txt:71
msgid ""
"The Spectre mode does not introduce any new commands.  The only change is "
"the syntax."
msgstr ""
"Для режима Spectre никаких новых команд не вводится. Единственным изменением "
"является синтаксис."

#. type: Plain text
#: manual/languages/spectre.txt:101 spectre.txt:73
msgid ""
"In Spectre mode, there is a label before the command, like a component.  The "
"label names a file which will contain the results of the command.  The "
"filename extension is the command."
msgstr ""
"В режиме Spectre перед командой указывается обозначение, как и для "
"компонента. Это обозначение станет именем файла, в который будут выводиться "
"результаты данной команды. В качестве расширения имени файла будет "
"использоваться имя самой команды."

#. type: Plain text
#: manual/languages/spectre.txt:103 spectre.txt:75
msgid ""
"As an non-standard extension, using a dash '-' as the label sends the "
"command output to the standard output."
msgstr ""
"Нестандартным расширением является перенаправление вывода команды на "
"стандартный вывод при задании обозначения в виде дефиса («-»)."

#. type: Plain text
#: manual/languages/spectre.txt:105 spectre.txt:77
msgid "Commands are executed in the order given."
msgstr "Команды выполняются в порядке их задания."

#. type: Plain text
#: manual/languages/spectre.txt:109 spectre.txt:81
#, no-wrap
msgid ""
"  setbias op\n"
"  response ac start=20 stop=20K dec=10\n"
"  - ac\n"
msgstr ""
"  setbias op\n"
"  response ac start=20 stop=20K dec=10\n"
"  - ac\n"

#. type: Plain text
#: manual/languages/spectre.txt:111 spectre.txt:83
msgid "This is equivalent to the native mode:"
msgstr ""
"Это эквивалентно следующим командам в режиме работы с собственной системой "
"команд gnucap:"

#. type: Plain text
#: manual/languages/spectre.txt:115 spectre.txt:87
#, no-wrap
msgid ""
"  op >setbias.op\n"
"  ac start=20 stop=20K dec=10 >response.ac\n"
"  ac\n"
msgstr ""
"  op >setbias.op\n"
"  ac start=20 stop=20K dec=10 >response.ac\n"
"  ac\n"

#. type: Title ======
#: manual/languages/spectre.txt:116 manual/languages/verilog.txt:126
#: spectre.txt:88
#, no-wrap
msgid "Extras"
msgstr "Кроме того..."

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:119 spectre.txt:91
#, no-wrap
msgid "You can switch languages any time with the appropriate command.  The command must be in spectre syntax, with a label or dash first.  The command to switch back must be issued in the language you switched to.\n"
msgstr "В любой момент соответствующей командой можно переключиться на другой язык. Для этой команды должен использоваться синтаксис Spectre, то есть сначала должно быть указано обозначение или дефис. Команда для переключения обратно должна задаваться на том языке, который был включен.\n"

#. type: Plain text
#: manual/languages/spectre.txt:123 spectre.txt:95
msgid ""
"The current implementation in gnucap differs slightly from the Cadence "
"product."
msgstr "Текущая реализация в gnucap слегка отличается от продукта Cadence."

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid "The \"master\" must be defined before it is referenced.\n"
msgstr "«Оригинал» должен быть определён до обращения к нему.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 spectre.txt:99
#, no-wrap
msgid "The devices and commands are whatever gnucap has installed, which are probably different from what Spectre (the simulator) provides.\n"
msgstr "В качестве устройств и команд используются все те, что устанавливаются вместе с gnucap, и они, вероятно, отличаются от предоставляемых в Spectre (в программе моделирования).\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 manual/languages/verilog.txt:143
#, no-wrap
msgid "The circuit must be defined before any commands using it, unless you want to simulate a partial circuit.  Scripted and interactive modifications to the circuit are done the way gnucap usually does.\n"
msgstr "Схема должна быть полностью определена до вызова любой работающей с ней команды, за исключением случаев, когда нужно произвести моделирование для части схемы. Изменения схемы скриптовым и интерактивным способом производятся так же, как они делаются в gnucap и обычно.\n"

#. type: Bullet: '  * '
#: manual/languages/spectre.txt:127 spectre.txt:99
#, no-wrap
msgid "There is an interactive mode, with spectre syntax.\n"
msgstr "Имеется интерактивный режим с поддержкой синтаксиса Spectre.\n"

#. type: Title ======
#: manual/languages/verilog.txt:1
#, no-wrap
msgid "Language : Verilog"
msgstr "Язык Verilog"

#. type: Plain text
#: manual/languages/verilog.txt:4
msgid ""
"The Verilog language plugin attempts to support the syntax of the Verilog-"
"AMS language."
msgstr ""
"С помощью плагина для языка Verilog в программе gnucap предпринята попытка "
"реализовать поддержку синтаксиса Verilog-AMS."

#. type: Plain text
#: manual/languages/verilog.txt:6
msgid ""
"Not all features of Verilog-AMS are supported, but those that work will work "
"with Verilog-AMS syntax.  Wherever possible, Gnucap features will work in "
"Verilog-AMS mode, even if they don't work in Verilog-AMS."
msgstr ""
"Не все возможности Verilog-AMS поддерживаются плагином, но те, что работают, "
"будут работать и в режиме работы с синтаксисом Verilog-AMS. Программные "
"возможности gnucap в этом режиме будут работать всюду, где только можно, "
"даже если собственно в Verilog-AMS аналогичных возможностей нет."

#. type: Plain text
#: manual/languages/verilog.txt:8
msgid "The Verilog mode is case sensitive, and uses \"SI\" units."
msgstr "Режим Verilog регистрозависим, и в нём используются единицы СИ."

#. type: Plain text
#: manual/languages/verilog.txt:14
msgid ""
"The format is not line oriented.  A semicolon terminates a statement.  You "
"can extend a line by ending it with \\ ."
msgstr ""
"Формат не строчно-ориентированный. Операторы завершаются точками с запятой. "
"Если закончить строку символом «\\», следующая строка будет считаться её "
"продолжением."

#. type: Plain text
#: manual/languages/verilog.txt:16
msgid ""
"In gnucap, for now, you must have one statement per line.  This is non-"
"standard."
msgstr ""
"В настоящее время в gnucap строка может содержать только один оператор. Это "
"не соответствует стандарту."

#. type: Plain text
#: manual/languages/verilog.txt:18
msgid "From startup, you can set Verilog mode with the command line:"
msgstr ""
"После запуска программы режим Verilog можно задать из командной строки:"

#. type: Plain text
#: manual/languages/verilog.txt:20
#, no-wrap
msgid "  simulator lang=verilog\n"
msgstr "  simulator lang=verilog\n"

#. type: Plain text
#: manual/languages/verilog.txt:23
#, no-wrap
msgid ""
"or\n"
"  verilog\n"
msgstr ""
"или\n"
"  verilog\n"

#. type: Plain text
#: manual/languages/verilog.txt:29
#, no-wrap
msgid "  type #(arguments) label (port list) ;\n"
msgstr "|''//тип// #(//аргументы//) //обозначение// (//список портов//) ;''|\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Type** : The type of component.  If there is a \"paramset\" statement, this is the name in the paramset statement.  Otherwise, it could be the name of a \"subckt\", \"model\", or a standard device.  This is called \"master\" in the Spectre manual.\n"
msgstr "''//тип//'' --- тип компонента. Если имеется оператор ''[[#paramset]]'', это имя типа, заданное в данном операторе.  В противном случае, это может быть имя ''[[.:spectre.ru#subckt]]'', ''[[.:spectre.ru#model]]'', или стандартного устройства. В руководстве по Spectre это называется //оригиналом// («master»).\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \".name(value)\", separated by a comma.  The value may be an expression.  In some cases, a principal value can be given just by value, without its name.  The argument list is surrounded by parentheses, and prefixed by \"#\".\n"
msgstr "''//аргументы//'' --- список аргументов ([[gnucap:manual:commands:parameter.ru|параметры]] или значения). Все аргументы задаются в виде пар в формате «''.имя(значение)''» и отделяются друг от друга запятыми. Значение аргумента может быть [[gnucap:manual:howto:expressions.ru|выражением]]. В некоторых случаях для основного аргумента достаточно задать только значение и не указывать имя. Список аргументов заключается в круглые скобки и перед ними ставится префикс «#».\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:34
#, no-wrap
msgid "**Port list** : A list of the ports (connections), separated by a comma.  Mapping can be determined by order or by name.  The port list should be surrounded by parentheses.  By order, list them, comma separated.  By name, they use the same syntax as arguments.  .name(value)\n"
msgstr "''//список портов//'' --- список портов (соединений), разделённых запятыми. Соответствие портов соединениям может определяться порядком записи или именами. Список портов должен быть заключён в круглые скобки. При определении соответствия по порядку порты следует перечислить в нужной последовательности, отделяя друг от друга запятыми. При определении соответствия по имени используется тот же синтаксис, что и для аргументов, то есть «''.имя(значение)''».\n"

#. type: Plain text
#: manual/languages/verilog.txt:37
#, no-wrap
msgid ""
"  resistor #(10K)     Rload (out, 0);         // one unnamed argument, ports by order\n"
"  resistor #(.r(10K)) Rload (.p(out), .n(0)); // the same component, arguments by name, ports by name\n"
msgstr ""
"  resistor #(10K)     Rload (out, 0);         // один безымянный аргумент, соответствие соединений\n"
"                                              // портам определяется порядком записи\n"
"  resistor #(.r(10K)) Rload (.p(out), .n(0)); // тот же компонент, аргументы и порты заданы по имени\n"

#. type: Plain text
#: manual/languages/verilog.txt:39
#, no-wrap
msgid "  amp #(.rload(100K)) X1 (.out(out), .in(in), .vcc(vc));\n"
msgstr "  amp #(.rload(100K)) X1 (.out(out), .in(in), .vcc(vc));\n"

#. type: Plain text
#: manual/languages/verilog.txt:41
msgid ""
"There are some components that exploit the syntax in other languages that "
"are not supported in Verilog mode, but you can use them by switching to a "
"mode that does support that syntax."
msgstr ""
"Имеется несколько компонентов, для которых используется синтаксис других "
"языков, и которые в режиме Verilog не поддерживаются, но их всё же можно "
"использовать, если переключиться в какой-нибудь режим, в котором этот "
"синтаксис поддерживается."

#. type: Plain text
#: manual/languages/verilog.txt:44
#, no-wrap
msgid ""
"  // vsource  #(.dc(15)) Vcc (.p(vc), .n(0)); // Spice-style source arguments are not supported.\n"
"  // vsource  #(.ac(1))  Vin (.p(in), .n(0)); // Spice-style source arguments are not supported.\n"
msgstr ""
"  // vsource  #(.dc(15)) Vcc (.p(vc), .n(0)); // Аргументы источников напряжения и тока в стиле SPICE не поддерживаются\n"
"  // vsource  #(.ac(1))  Vin (.p(in), .n(0)); // Аргументы источников напряжения и тока в стиле SPICE не поддерживаются\n"

#. type: Plain text
#: manual/languages/verilog.txt:55
#, no-wrap
msgid ""
"  // assume it is starting in Verilog mode\n"
"  spice\n"
"  * It takes Spice syntax now\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Commands in Spice mode start with a dot.\n"
"  .verilog\n"
"  // Now it is back in Verilog mode.\n"
msgstr ""
"  // Предположим, программа запущена в режиме Verilog\n"
"  spice\n"
"  * Теперь используется синтаксис SPICE\n"
"  Vcc (vc 0) dc 15\n"
"  Vin (in 0) ac 1\n"
"  * Команды в режиме SPICE начинаются с точки\n"
"  .verilog\n"
"  // Теперь программа снова в режиме Verilog\n"

#. type: Plain text
#: manual/languages/verilog.txt:61
msgid "Two top level blocks are supported: module and paramset."
msgstr ""
"Поддерживается два блока верхнего уровня: ''[[#module]]'' и "
"''[[#paramset]]''."

#. type: Title =====
#: manual/languages/verilog.txt:62
#, no-wrap
msgid "paramset"
msgstr "paramset"

#. type: Plain text
#: manual/languages/verilog.txt:65
msgid ""
"A \"paramset\" statement sets parameters based on an existing compiled "
"model.  This will be extended to cover all \"masters\".  It becomes a "
"\"master\" that can be instantiated later.  It is equivalent to a spice \"."
"model\"."
msgstr ""
"Оператор **''paramset''** задаёт параметры на основе существующей "
"скомпилированной модели. Это будет распространяться на все «оригиналы». "
"Модель становится «оригиналом», экземпляры которого могут добавляться позже. "
"Это эквивалентно ключевому слову ''.model'' в SPICE."

#. type: Plain text
#: manual/languages/verilog.txt:70
#, no-wrap
msgid ""
"The syntax is:\n"
"  \"paramset\" newname itsmaster \";\"\n"
"    parameters\n"
"  \"endparamset\"\n"
msgstr ""
"Синтаксис:\n"
"|''**paramset** //новый_тип// //имя_оригинала// **;**\\\\ // параметры//\\\\ **endparamset**''|\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid "**paramset** : Keyword identifies a paramset statement.\n"
msgstr "''**paramset**'' --- ключевое слово, идентифицирующее оператор описания модели.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:75
#, no-wrap
msgid "**Parameters** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \".name = value;\".  (dot name equals value semicolon) The value may be an expression.\n"
msgstr "''//параметры//'' --- список аргументов ([[gnucap:manual:commands:parameter.ru|параметры]] или значения). Все аргументы задаются в виде пар в формате «''.имя=значение;''» (точка, имя, знак равенства, значение, точка с запятой). Значение аргумента может быть [[gnucap:manual:howto:expressions.ru|выражением]].\n"

#. type: Plain text
#: manual/languages/verilog.txt:79
#, no-wrap
msgid ""
"  paramset gp_npn npn;\\\n"
"    .bf=150;\\\n"
"  endparamset\n"
msgstr ""
"  paramset gp_npn npn;\\\n"
"    .bf=150;\\\n"
"  endparamset\n"

#. type: Plain text
#: manual/languages/verilog.txt:81
msgid ""
"According to the standard, lines are not significant.  In gnucap, for now, "
"all must be on one line or lines extended by ending with \"\\\"."
msgstr ""
"Согласно стандарту разбиение на строки не имеет существенного значения. В "
"gnucap, на данный момент, всё должно быть в одной строке или, чтобы "
"следующие строки считались продолжением предыдущих, последние должны "
"заканчиваться символами «\\»."

#. type: Plain text
#: manual/languages/verilog.txt:83
msgid ""
"Note that the parameter syntax in paramset is different from the parameter "
"syntax instantiating a device."
msgstr ""
"Обратите внимание, что синтаксис параметров в **''paramset''** отличается от "
"синтаксиса параметров в представлении экземпляров устройства."

#. type: Title =====
#: manual/languages/verilog.txt:83
#, no-wrap
msgid "module"
msgstr "module"

#. type: Plain text
#: manual/languages/verilog.txt:86
msgid ""
"The basic building block is called a \"module\".  Modules are descriptions "
"of individual components.  Gnucap directly supports only the structural "
"subset of Verilog, so a \"module\" here is equivalent to a Spice \"subckt\"."
msgstr ""
"Основной строительный блок называется модулем (**''module''**).  Модули "
"представляют собой описания индивидуальных компонентов. gnucap "
"непосредственно поддерживает только структурное подмножество языка Verilog, "
"поэтому **''module''** здесь эквивалентно **''subckt''** в SPICE."

#. type: Plain text
#: manual/languages/verilog.txt:88
msgid "Modules take the form:"
msgstr "Формат модулей:"

#. type: Plain text
#: manual/languages/verilog.txt:98
#, no-wrap
msgid ""
"  * A header line\n"
"    * Keyword \"module\".\n"
"    * The name of the new module being defined.\n"
"    * The list of ports, separated by commas, in parentheses\n"
"    * semicolon \";\"\n"
"  * Parameter statements.\n"
"  * The \"netlist\".\n"
"  * A closing line\n"
"    * Keyword \"endmodule\".\n"
msgstr ""
"  * Строка заголовка\n"
"    * Ключевое слово **''module''**\n"
"    * Имя нового, определяемого здесь модуля\n"
"    * Список портов, отделённых друг от друга запятыми, в скобках\n"
"    * **'';''** (точка с запятой)\n"
"  * Операторы ''parameter''\n"
"  * «Список соединений» внутренней схемы\n"
"  * Строка завершения\n"
"    * Ключевое слово **''endmodule''**\n"

#. type: Plain text
#: manual/languages/verilog.txt:114
#, no-wrap
msgid ""
"  module amp (out, in, vcc);\n"
"    parameter rload=10k;\n"
"    resistor  #(.r(1M))   Rb1  (base, vcc);        // 1 megohm\n"
"    resistor  #(.r(100K)) Rb2  (base, 0  );\n"
"    resistor  #(100K)     Rc   (col,  vcc);\n"
"    resistor  #(.r(10K))  Re   (.p(emit), .n(0));\n"
"    capacitor #(.c(1m))   Ce   (.p(emit), .n(0));  // 1 millifarad\n"
"    capacitor #(.c(1u))   Cin  (base, in );\n"
"    gp_npn                Q1   (.c(col), .b(base), .e(emit));\n"
"    gp_npn                Q2   (.c(vcc), .b(col), .e(e2));\n"
"    resistor  #(.r(1K))   Re2  (e2,  0  );\n"
"    capacitor #(.c(10u))  Cout (e2,  out);\n"
"    resistor  #(.r(rload))Rload(out, 0 );\n"
"  endmodule\n"
msgstr ""
"  module amp (out, in, vcc);\n"
"    parameter rload=10k;\n"
"    resistor  #(.r(1M))   Rb1  (base, vcc);        // 1 мегаом\n"
"    resistor  #(.r(100K)) Rb2  (base, 0  );\n"
"    resistor  #(100K)     Rc   (col,  vcc);\n"
"    resistor  #(.r(10K))  Re   (.p(emit), .n(0));\n"
"    capacitor #(.c(1m))   Ce   (.p(emit), .n(0));  // 1 миллифарад\n"
"    capacitor #(.c(1u))   Cin  (base, in );\n"
"    gp_npn                Q1   (.c(col), .b(base), .e(emit));\n"
"    gp_npn                Q2   (.c(vcc), .b(col), .e(e2));\n"
"    resistor  #(.r(1K))   Re2  (e2,  0  );\n"
"    capacitor #(.c(10u))  Cout (e2,  out);\n"
"    resistor  #(.r(rload))Rload(out, 0 );\n"
"  endmodule\n"

#. type: Plain text
#: manual/languages/verilog.txt:119
#, no-wrap
msgid ""
"  amp      #(.rload(100K)) X1    (.out(out), .in(in), .vcc(vc));\n"
"  vsource  #(.dc(15))      Vcc   (.p(vc), .n(0));\n"
"  vsource  #(.ac(1))       Vin   (.p(in), .n(0));\n"
"  resistor #(10K)          Rload (out, 0);\n"
msgstr ""
"  amp      #(.rload(100K)) X1    (.out(out), .in(in), .vcc(vc));\n"
"  vsource  #(.dc(15))      Vcc   (.p(vc), .n(0));\n"
"  vsource  #(.ac(1))       Vin   (.p(in), .n(0));\n"
"  resistor #(10K)          Rload (out, 0);\n"

#. type: Plain text
#: manual/languages/verilog.txt:123
msgid "The Verilog language has no concept of commands."
msgstr "В языке Verilog нет понятия команд."

#. type: Plain text
#: manual/languages/verilog.txt:125
msgid ""
"In gnucap, commands are executed at top level the same as the native mode."
msgstr ""
"Команды gnucap выполняются в схеме верхнего уровня так же, как и в режиме "
"работы с собственной системой команд."

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can switch languages any time with the appropriate command.  In most cases, just name the language you want to switch to.  More generally, you can do \".option lang=xxx\".  The command to switch back must be issued in the language you switched to.\n"
msgstr "В любой момент соответствующей командой можно переключиться на другой язык. В большинстве случаев достаточно набрать имя языка, на который надо переключиться.  Как ещё более общий вариант можно использовать «''.option lang=имя_языка''». Команда для переключения обратно должна задаваться на том языке, который был включен.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can define a top-level circuit in Verilog syntax.  The Verilog standard provides no way to define a top level circuit.\n"
msgstr "Используя синтаксис Verilog, можно определять схемы верхнего уровня. В стандарте Verilog не предусматривается никаких способов определения схем верхнего уровня.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:131
#, no-wrap
msgid "You can include commands, which work the same as the Gnucap native mode.\n"
msgstr "Можно включать команды, которые работают так же, как и в режиме работы с собственной системой команд gnucap.\n"

#. type: Plain text
#: manual/languages/verilog.txt:135
msgid "The current implementation in gnucap is a very preliminary subset."
msgstr ""
"Текущая реализация в gnucap представляет собой очень ограниченное "
"подмножество языка."

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "The devices and commands are whatever gnucap has installed, not necessarily what is defined in any standard.\n"
msgstr "В качестве устройств и команд используются все те, что устанавливаются вместе с gnucap, причём не обязательно те, что определены в каком бы то ни было стандарте.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "The main circuit can also be in Verilog syntax.  The Verilog standard has no concept of components at top level.\n"
msgstr "Синтаксис Verilog может использоваться и для описания основной схемы. В стандарте Verilog нет понятия компонентов верхнего уровня.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "To simulate, there must be a component at top level.  Uninstantiated modules do nothing.\n"
msgstr "Для моделирования необходим хотя бы один компонент в схеме верхнего уровня.  Модули, не представленные экземплярами, работать не будут.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Port direction statements like \"inout\" are not supported.\n"
msgstr "Операторы направления порта, такие как ''inout'', не поддерживаются.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Discipline statements like \"electrical\" are not supported.\n"
msgstr "Операторы типа **''discipline''**, такие как ''electrical'', не поддерживаются.\n"

#. type: Bullet: '  * '
#: manual/languages/verilog.txt:143
#, no-wrap
msgid "Some components, and some types of arguments, are not supported in Verilog mode, but you can switch modes at any time.\n"
msgstr "Некоторые компоненты и некоторые типы аргументов в режиме Verilog не поддерживаются, но режим можно переключить в любой момент.\n"

#. type: Title ======
#: manual/measure/at.txt:1
#, no-wrap
msgid "\"at\" measure"
msgstr "Измерение «at»"

#. type: Plain text
#: manual/measure/at.txt:6
msgid "Measure a signal at a time or frequency."
msgstr "Измерение сигнала в определённое время или при определённой частоте."

#. type: Plain text
#: manual/measure/at.txt:10
#, no-wrap
msgid "  at(probe=\"p(d)\"  at=time  derivative)\n"
msgstr "|''**at**(probe=%%\"%%//д//(//у//)%%\"%%  at=//время//  derivative)''|\n"

#. type: Plain text
#: manual/measure/at.txt:15
#, no-wrap
msgid ""
"|probe       |The name of a probe to measure.  |\n"
"|at\\\\ x      |Measure the value here.  |\n"
"|derivative  |Flag: measure the derivative instead of the value.  |\n"
msgstr ""
"^ Имя аргумента  ^ Описание  ^\n"
"|''probe''       |Имя измеряемого [[gnucap:manual:howto:probes.ru|датчика]]  |\n"
"|''at\\\\ x''    |Измерить значение в данной точке                           |\n"
"|''derivative''  |Флажок: измерение производной вместо значения              |\n"

#. type: Plain text
#: manual/measure/at.txt:19
msgid ""
"If you specify x to be out of range, it returns the value at the end, with a "
"derivative of zero."
msgstr ""
"Если указать значение ''x'' вне диапазона, то будет возвращено значение в "
"точке конца диапазона с производной равной нулю."

#. type: Plain text
#: manual/measure/at.txt:21 manual/measure/cross.txt:33
msgid ""
"If you didn't store the waveform (see store command), it throws a \"no match"
"\" exception, which prints \"no match\"."
msgstr ""
"Если сигнал не был сохранён (см. [[gnucap:manual:commands:store.ru|описание "
"команды store]]), будет выдано исключение «о несоответствии», выводящее "
"строку «no match»."

#. type: Plain text
#: manual/measure/at.txt:27
#, no-wrap
msgid ""
"  measure sample = at(probe=\"v(out)\", at=4u)\n"
"Measure the value of \"v(out)\" at 4 microseconds.\n"
"  measure sample = at(probe=\"v(out)\", at=4u, derivative)\n"
"Measure the derivative of \"v(out)\" at 4 microseconds.\n"
msgstr ""
"  measure sample = at(probe=\"v(out)\", at=4u)\n"
"Измерить значение «v(out)» в момент времени 4 мкс.\n"
"  measure sample = at(probe=\"v(out)\", at=4u, derivative)\n"
"Измерить производную от «v(out)» в момент времени 4 мкс.\n"

#. type: Title ======
#: manual/measure/cross.txt:1
#, no-wrap
msgid "\"cross\" measure"
msgstr "Измерение «cross»"

#. type: Plain text
#: manual/measure/cross.txt:6
msgid "Find the time or frequency where a probed value crosses a reference."
msgstr ""
"Поиск времени или частоты, где измеренное значение пересекает опорное "
"значение. "

#. type: Plain text
#: manual/measure/cross.txt:10
#, no-wrap
msgid "  cross(probe=\"p(d)\" cross=value begin=time end=time rise fall last first)\n"
msgstr "|''**cross**(probe=%%\"%%//д//(//у//)%%\"%% cross=//значение// begin=//время// end=//время// rise fall last first)''|\n"

#. type: Plain text
#: manual/measure/cross.txt:21
#, no-wrap
msgid ""
"^arg name       ^default  ^description  ^\n"
"|probe          |required   |The name of a probe to measure.  |\n"
"|cross          |0          |The value it crosses.  |\n"
"|begin\\\\ after  |-infinity  |The window begins at this time or frequency.  |\n"
"|end\\\\ before   |+infinity  |The window ends at this time or frequency.  |\n"
"|first          |true       |Find the first crossing in the window.  (Cancels last.)  |\n"
"|last           |false      |Find the last crossing in the window.  (Cancels first.)  |\n"
"|rise           |true       |Consider only rising crossings.  (Cancels fall.)  |\n"
"|fall           |false      |Consider only falling crossings.  (Cancels rise.)  |\n"
msgstr ""
"^ Имя аргумента       ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''probe''            |  //обязательный//        | Имя измеряемого [[gnucap:manual:howto:probes.ru|датчика]]     |\n"
"|''cross''            |  **''0''**               | Опорное значение                                              |\n"
"|''begin\\\\ after''  |  **''-infinity''** (-∞)  | Начало окна измерений (время или частота)                     |\n"
"|''end\\\\ before''   |  **''+infinity''** (+∞)  | Конец  окна измерений (время или частота)                     |\n"
"|''first''            |  **''true''**            | Поиск первого    пересечения в окне     (отменяет  ''last'')  |\n"
"|''last''             |  **''false''**           | Поиск последнего пересечения в окне     (отменяет ''first'')  |\n"
"|''rise''             |  **''true''**            | Учитывать только восходящие пересечения (отменяет  ''fall'')  |\n"
"|''fall''             |  **''false''**           | Учитывать только нисходящие пересечения (отменяет  ''rise'')  |\n"

#. type: Title =====
#: manual/measure/cross.txt:21
#, no-wrap
msgid "Caveats"
msgstr "Предостережения"

#. type: Plain text
#: manual/measure/cross.txt:27
#, no-wrap
msgid ""
"For this function to detect a crossing, it must actually cross.\n"
"  * A steady state at the cross value is not a crossing.\n"
"  * Being at the cross value and leaving is not a crossing.\n"
"  * Merely touching (becoming equal to) the cross value and leaving from the same side is not a crossing.\n"
msgstr ""
"Для того, чтобы данная функция могла определить пересечение, опорное значение должно пересекаться на самом деле.\n"
"  * Режим постоянного равенства измеряемого значения опорному пересечением не является.\n"
"  * Исходное равенство измеряемого значения опорному и уход с него пересечением не является.\n"
"  * Простое касание измеряемым значением опорного (достижение равенства между ними) и уход с него с той же стороны пересечением не является.\n"

#. type: Plain text
#: manual/measure/cross.txt:31
msgid ""
"If there is no crossing within the specified range, it returns \"Inf"
"\" (infinity)."
msgstr ""
"Если в пределах указанного диапазона пересечений нет, функция возвращает "
"«Inf» (бесконечность)."

#. type: Plain text
#: manual/measure/cross.txt:42
#, no-wrap
msgid ""
"  measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Find the last time that v(out) crosses 0, going up.\n"
"  measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Find the last rising zero crossing before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
msgstr ""
"  measure t2 = cross(probe=\"v(out)\" cross=0 rise last)\n"
"Найти последний момент времени, когда v(out) пересекает 0 снизу вверх.\n"
"  measure t1 = cross(probe=\"v(out)\" cross=0 rise last before=t2)\n"
"Найти последнее время пересечения нуля при восходящем изменении сигнала до момента времени t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Параметры интерпретируются как в функциональных языках программирования, поэтому их обновление будет производиться при любом изменении t1 или t2.\n"

#. type: Title ======
#: manual/measure/mean.txt:1
#, no-wrap
msgid "\"mean\", \"integrate\", \"rms\" measures"
msgstr "Измерения «mean», «integrate», «rms»"

#. type: Plain text
#: manual/measure/mean.txt:8
#, no-wrap
msgid ""
"| mean      |Find the mean or average value of a waveform.  |\n"
"|integrate  |Find the integral of a waveform, the area under the curve.  |\n"
"|rms        |Find the RMS (root mean square) value of a waveform.  |\n"
msgstr ""
"  * **mean**:      определение среднего значения сигнала\n"
"  * **integrate**: определение интеграла для сигнала, области под кривой\n"
"  * **rms**:       определение среднеквадратичного значения сигнала\n"

#. type: Plain text
#: manual/measure/mean.txt:14
#, no-wrap
msgid ""
"  mean(probe=\"p(d)\"  begin=time  end=time)\n"
"  integrate(probe=\"p(d)\"  begin=time  end=time)\n"
"  rms(probe=\"p(d)\"  begin=time  end=time)\n"
msgstr ""
"|''**mean**(probe=%%\"%%//д//(//у//)%%\"%%       begin=//время//  end=//время//)''|\n"
"|''**integrate**(probe=%%\"%%//д//(//у//)%%\"%%  begin=//время//  end=//время//)''|\n"
"|''**rms**(probe=%%\"%%//д//(//у//)%%\"%%        begin=//время//  end=//время//)''|\n"

#. type: Plain text
#: manual/measure/mean.txt:21
#, no-wrap
msgid ""
"^arg name  ^default  ^description  ^\n"
"|probe     |required    |The name of a probe to measure.  |\n"
"|begin     |- infinity  |Start averaging at this time or frequency.  |\n"
"|end       |+ infinity  |Stop averaging at this time or frequency.  |\n"
msgstr ""
"^ Имя аргумента ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''probe''      |  //обязательный//        | Имя измеряемого [[gnucap:manual:howto:probes.ru|датчика]]   |\n"
"|''begin''      |  **''-infinity''** (-∞)  | Время или частота начала определения среднего значения      |\n"
"|''end''        |  **''+infinity''** (+∞)  | Время или частота конца  определения среднего значения      |\n"

#. type: Plain text
#: manual/measure/mean.txt:25
msgid ""
"The \"mean\" measure gives you the true average or mean value.  The mean "
"value of a sine over a full cycle is zero."
msgstr ""
"**mean** служит для измерения точного среднего значения. Среднее значение "
"синусоиды за полный период равно нулю."

#. type: Plain text
#: manual/measure/mean.txt:27
msgid ""
"The \"integrate\" measure gives you the integral, or area under the curve, "
"signed.  The integral of a sine over a full cycle is zero."
msgstr ""
"**integrate** служит для измерения интеграла или области под кривой с учётом "
"знака. Интеграл синусоиды за полный период равен нулю."

#. type: Plain text
#: manual/measure/mean.txt:29
msgid "The \"rms\" measure gives you the RMS (root mean square) value."
msgstr "**rms** служит для измерения среднеквадратичного значения."

#. type: Plain text
#: manual/measure/mean.txt:38
#, no-wrap
msgid ""
"  measure sample = mean(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the mean value of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = mean(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
"  measure sample = mean(probe=\"v(out)\" begin=4u)\n"
"Find the mean value of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""
"  measure sample = mean(probe=\"v(out)\" begin=4u end=6u)\n"
"Найти среднее значение v(out) за время от 4 мкс до 6 мкс.\n"
"  measure sample = mean(probe=\"v(out)\")\n"
"Найти среднее значение v(out) за всё время работы.\n"
"  measure sample = mean(probe=\"v(out)\" begin=4u)\n"
"Найти среднее значение v(out) начиная с 4 мкс и до конца.\n"

#. type: Plain text
#: manual/measure/mean.txt:44
#, no-wrap
msgid ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the area under the curve of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Find the area under of v(out) for an entire run.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Find the area under of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Найти область под кривой v(out) за время от 4 мкс до 6 мкс.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Найти область под кривой v(out) за всё время работы.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Найти область под кривой v(out) начиная с 4 мкс и до конца.\n"

#. type: Title ======
#: manual/measure/minmax.txt:1
#, no-wrap
msgid "\"min\", \"max\" measure"
msgstr "Измерения «min», «max»"

#. type: Plain text
#: manual/measure/minmax.txt:6
msgid ""
"Find the time or frequency where a probed value hits a maximum or minimum."
msgstr ""
"Определение значения времени или частоты, при котором измеряемое значение "
"достигает максимума или минимума."

#. type: Plain text
#: manual/measure/minmax.txt:10
#, no-wrap
msgid "  min(probe=\"p(d)\" begin=time end=time last first arg)\n"
msgstr "|''**min**(probe=%%\"%%//д//(//у//)%%\"%% begin=//время// end=//время// last first arg)''|\n"

#. type: Plain text
#: manual/measure/minmax.txt:20
#, no-wrap
msgid ""
"^arg name  ^default    ^description  ^\n"
"|probe     |required   |The name of a probe to measure.  |\n"
"|arg       |false      |Find the time or frequency at which the min or max occurs. (instead of the value)  |\n"
"|begin     |-infinity  |The window begins at this time or frequency.  |\n"
"|end       |+infinity  |The window ends at this time or frequency.  |\n"
"|first     |true       |Find the first min or max in the window.  (Cancels last.)  |\n"
"|last      |false      |Find the last min or max in the window.  (Cancels first.)  |\n"
msgstr ""
"^ Имя аргумента ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''probe''      |  //обязательный //       | Имя измеряемого [[gnucap:manual:howto:probes.ru|датчика]]            |\n"
"|''arg''        |  **''false''**           | Определение времени или частоты появления минимума или максимума (вместо значения)  |\n"
"|''begin''      |  **''-infinity''** (-∞)  | Начало окна измерений (время или частота)                            |\n"
"|''end''        |  **''+infinity''** (+∞)  | Конец  окна измерений (время или частота)                            |\n"
"|''first''      |  **''true''**            | Поиск первого    минимума или максимума в окне (отменяет ''last'')   |\n"
"|''last''       |  **''false''**           | Поиск последнего минимума или максимума в окне (отменяет ''first'')  |\n"

#. type: Plain text
#: manual/measure/minmax.txt:35
#, no-wrap
msgid ""
"  measure maxvalue = max(probe=\"v(out)\" cross=0 last)\n"
"Find the maximum value of v(out).\n"
"  measure t2 = max(probe=\"v(out)\" last arg)\n"
"Find the last time when a maximum occurred.\n"
"  measure t1 = max(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a maximum occurred before t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Params are interpreted like a functional language so they will be updated whenever t1 or t2 changes.\n"
"  measure t0 = min(probe=\"v(out)\" arg last before=t2)\n"
"Find the last time when a minimum occurred before t2.\n"
"  param risetime = {t2-t0}\n"
msgstr ""
"  measure maxvalue = max(probe=\"v(out)\" cross=0 last)\n"
"Найти максимальное значение v(out).\n"
"  measure t2 = max(probe=\"v(out)\" last arg)\n"
"Найти последний момент времени, когда появлялся максимум.\n"
"  measure t1 = max(probe=\"v(out)\" arg last before=t2)\n"
"Найти время последнего максимума до момента времени t2.\n"
"  param period = {t2-t1}\n"
"  param frequency = {1/period}\n"
"Параметры интерпретируются как в функциональных языках программирования, поэтому их обновление будет производиться при любом изменении t1 или t2.\n"
"  measure t0 = min(probe=\"v(out)\" arg last before=t2)\n"
"Найти время последнего минимума до момента времени t2.\n"
"  param risetime = {t2-t0}\n"

#. type: Title ======
#: manual/measure/slope.txt:1
#, no-wrap
msgid "\"slope\" measure"
msgstr "Измерение «slope»"

#. type: Plain text
#: manual/measure/slope.txt:6
msgid "Find the slope or slew rate of a waveform."
msgstr "Найти наклон кривой или скорость нарастания сигнала."

#. type: Plain text
#: manual/measure/slope.txt:10
#, no-wrap
msgid "  slope(probe=\"p(d)\" initial=value final=value begin=time end=time expression)\n"
msgstr "|''**slope**(probe=%%\"%%//д//(//у//)%%\"%% initial=//значение// final=//значение// begin=//время// end=//время// expression)''|\n"

#. type: Plain text
#: manual/measure/slope.txt:22
#, no-wrap
msgid ""
"^arg name    ^default  ^description  ^\n"
"|probe       |required   |The name of a probe to measure.  |\n"
"|initial     |0          |The initial value.  |\n"
"|final       |0          |The final value.  |\n"
"|begin       |-infinity  |The window begins at this time or frequency.  |\n"
"|end         |+infinity  |The window ends at this time or frequency.  |\n"
"|first       |true       |Find the first crossing in the window.  (Cancels last.)  |\n"
"|last        |false      |Find the last crossing in the window.  (Cancels first.)  |\n"
"|expression  |false      |The result is an unreduced expression.  |\n"
msgstr ""
"^ Имя аргумента ^  Значение по\\\\ умолчанию  ^ Описание  ^\n"
"|''probe''       |  //обязательный//        | Имя измеряемого [[gnucap:manual:howto:probes.ru|датчика]]  |\n"
"|''initial''     |  **''0''**               | Начальное значение                                         |\n"
"|''final''       |  **''0''**               | Конечное значение                                          |\n"
"|''begin''       |  **''-infinity''** (-∞)  | Начало окна измерений (время или частота)                  |\n"
"|''end''         |  **''+infinity''** (+∞)  | Конец  окна измерений (время или частота)                  |\n"
"|''first''       |  **''true''**            | Найти первое пересечение в окне     (Отменяет  ''last'')   |\n"
"|''last''        |  **''false''**           | Найти последнее пересечение в окне  (Отменяет ''first'')   |\n"
"|''expression''  |  **''false''**           | Результатом является нераскрытое выражение                 |\n"

#. type: Plain text
#: manual/measure/slope.txt:26
msgid ""
"Ordinarily, the result is a number.  If the probe is a voltage probe the "
"units would be volts per second."
msgstr ""
"Обычно результатом является число. Если измерение производится для датчика "
"напряжения, единицей измерения будет В/c (вольт в секунду)."

#. type: Plain text
#: manual/measure/slope.txt:28
msgid ""
"If the \"expression\" keyword is given the result is an unreduced expression."
msgstr ""
"При задании ключевого слова «''expression''» результатом будет нераскрытое "
"выражение."

#. type: Plain text
#: manual/measure/slope.txt:34
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as a number.\n"
"  sr= 30.15738K\n"
msgstr ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last)\n"
"Найти наклон кривой (скорость нарастания) сигнала за последний переход от -2 до 2 как число.\n"
"  sr= 30.15738K\n"

#. type: Plain text
#: manual/measure/slope.txt:37
#, no-wrap
msgid ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last expression)\n"
"Find the slope (slew rate) for the last transition from -2 to 2, as an unreduced expression.\n"
"  sr={( 2.--2.)/( 0.001066319- 933.6812u)}\n"
msgstr ""
"  measure sr = slope(probe=\"v(out)\" initial=-2 final=2 last expression)\n"
"Найти наклон кривой (скорость нарастания) сигнала за последний переход от -2 до 2 как нераскрытое выражение.\n"
"  sr={( 2.--2.)/( 0.001066319- 933.6812u)}\n"

#. type: Title ======
#: manual/tech.txt:1
#, no-wrap
msgid "Tech notes"
msgstr "Техническая информация"

#. type: Plain text
#: manual/tech.txt:4
msgid "This section describes technical aspects of Gnucap."
msgstr "В данном разделе рассматриваются технические аспекты gnucap."

#. type: Plain text
#: manual/tech.txt:6
msgid ""
"Here, you will find information that will help you understand how it works "
"and to extend it."
msgstr ""
"Здесь вы найдёте информацию, которая поможет вам понять, как программа "
"работает и каким образом можно расширить её функциональность."

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[gnucap:manual:tech:plugins]]\n"
msgstr "[[gnucap:manual:tech:plugins.ru|Плагины]]\n"

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[gnucap:manual:tech:testing]]\n"
msgstr "[[gnucap:manual:tech:testing.ru|Тестирование]]\n"

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man105.html|adding models (old)]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man105.html|Добавление моделей (старая версия)]]\n"

#. type: Bullet: '  * '
#: manual/tech.txt:10
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/gnucap-man107.html|old tech notes]]\n"
msgstr "[[http://gnucap.org/gnucap-man-html/gnucap-man107.html|Старые технические заметки]]\n"

#. type: Title ======
#: manual/tech/plugins.txt:1 manual/tech/plugins/coding.txt:1
#: manual/tech/plugins/files.txt:1 about/plugins/commands.txt:1
#: about/plugins/languages.txt:1 about/plugins/measurements.txt:1
#: about/plugins/methods.txt:1 about/plugins/models.txt:1 about/plugins.txt:1
#, no-wrap
msgid "Plugins"
msgstr "Плагины"

#. type: Plain text
#: manual/tech/plugins.txt:4
msgid "This section describes the Gnucap plugin system, for programmers."
msgstr ""
"В настоящем разделе приводится описание системы плагинов gnucap для "
"программистов."

#. type: Title =====
#: manual/tech/plugins.txt:5 manual/tech/plugins/coding.txt:3
#: manual/tech/plugins/files.txt:3 user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Concepts"
msgstr "Понятия"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Files]]\n"
msgstr "[[gnucap:manual:tech:plugins:Files.ru|Файлы]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:Coding]]\n"
msgstr "[[gnucap:manual:tech:plugins:Coding.ru|Программирование]]\n"

#. type: Title =====
#: manual/tech/plugins.txt:9
#, no-wrap
msgid "Plugin types"
msgstr "Типы плагинов "

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:commands]]\n"
msgstr "[[gnucap:manual:tech:plugins:commands.ru|Команды]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:devices]]\n"
msgstr "[[gnucap:manual:tech:plugins:devices.ru|Устройства]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:languages|simulation languages]]\n"
msgstr "[[gnucap:manual:tech:plugins:languages.ru|Языки моделирования]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:behavioral functions]]\n"
msgstr "[[gnucap:manual:tech:plugins:behavioral functions.ru|Поведенческие функции]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins.txt:16
#, no-wrap
msgid "[[gnucap:manual:tech:plugins:parameter functions and measurements]]\n"
msgstr "[[gnucap:manual:tech:plugins:parameter functions and measurements.ru|Функции для работы с параметрами и измерениями]]\n"

#. type: Title ======
#: manual/tech/plugins/devices.txt:1
#: manual/tech/plugins/devices/ac_analysis.txt:1
#: manual/tech/plugins/devices/allocation_and_setup.txt:1
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:1
#: manual/tech/plugins/devices/parameters.txt:1
#: manual/tech/plugins/devices/ports.txt:1
#: manual/tech/plugins/devices/probes.txt:1
#: manual/tech/plugins/devices/query.txt:1
#, no-wrap
msgid "Device plugins"
msgstr "Плагины устройств"

#. type: Title =====
#: manual/tech/plugins/devices.txt:3 manual/tech/plugins/commands.txt:3
#: manual/tech/plugins/parameter_functions_and_measurements.txt:3
#: manual/tech/plugins/languages.txt:3
#, no-wrap
msgid "Framework"
msgstr "Инфраструктура"

#. type: Plain text
#: manual/tech/plugins/devices.txt:6
msgid ""
"Devices, model definitions, commands, and subcircuit definitions are all "
"stored in a linked list, and are defined by classes derived from \"CARD\".  "
"The container is a CARD_LIST."
msgstr ""
"Устройства, определения моделей, команды и определения подсхем, все "
"сохраняются в связанном списке и определяются классами, производными от "
"''CARD''.  Контейнером является ''CARD_LIST''."

#. type: Plain text
#: manual/tech/plugins/devices.txt:8
msgid ""
"Device instances are derived from COMPONENT, which is derived from CARD."
msgstr ""
"Экземпляры устройств являются потомками класса ''COMPONENT'', который "
"является потомком класса ''CARD''."

#. type: Plain text
#: manual/tech/plugins/devices.txt:10
msgid ""
"Model and paramset statements are derived from MODEL_CARD, which is derived "
"from CARD."
msgstr ""
"Операторы [[gnucap:manual:languages:spectre.ru#model]] и [[gnucap:manual:"
"languages:verilog.ru#paramset]] происходят от ''MODEL_CARD'', который "
"является потомком класса ''CARD''."

#. type: Plain text
#: manual/tech/plugins/devices.txt:12
msgid "There are special classes of devices that are derived from COMPONENT."
msgstr ""
"Имеются особые классы устройств, которые являются потомками класса "
"''COMPONENT''."

#. type: Plain text
#: manual/tech/plugins/devices.txt:17
#, no-wrap
msgid ""
"|COMPONENT   |e_compon.h |all devices, including those defined by subcircuit expansion. |\n"
"|BASE_SUBCKT |e_subckt.h |devices that are defined in terms of other devices, as subcircuits, with an internal hierarchy. |\n"
"|ELEMENT     |e_elemnt.h |devices that are not defined in terms of other devices. |\n"
"|STORAGE     |e_storag.h |elements that store some historical information, such as previous states. |\n"
msgstr ""
"|''COMPONENT''   | //e_compon.h// | все устройства, включая те, что определяются путём развёртывания подсхем  |\n"
"|''BASE_SUBCKT'' | //e_subckt.h// | устройства, которые определяются в терминах других устройств, такие как подсхемы, с внутренней иерархической структурой  |\n"
"|''ELEMENT''     | //e_elemnt.h// | устройства, которые не определяются в терминах других устройств  |\n"
"|''STORAGE''     | //e_storag.h// | элементы, в которых сохраняется некоторая историческая информация, например, о предыдущих состояниях  |\n"

#. type: Plain text
#: manual/tech/plugins/devices.txt:19
msgid ""
"Devices do not contain any parsing or printing code, but do contain methods "
"for setting and reading parameters."
msgstr ""
"Объекты устройств не содержат никакого кода синтаксического разбора или "
"вывода, но имеют методы для установки и чтения параметров."

#. type: Plain text
#: manual/tech/plugins/devices.txt:21
msgid ""
"Some devices do contain parsing or printing code in methods with a name that "
"includes \"obsolete_callback\".  That is not documented here, and will "
"eventually be removed."
msgstr ""
"Для некоторых устройств есть код синтаксического разбора или вывода, "
"прописанный в методах с именами, содержащими ''obsolete_callback''.  "
"Информация об этом здесь не приводится и в конце концов этот код будет "
"удалён."

#. type: Plain text
#: manual/tech/plugins/devices.txt:23
msgid ""
"One static object of every type is created at program startup or when a "
"plugin is loaded.  A pointer to that static object is installed in a "
"dispatcher, and later accessed by name or through that pointer.  This is the "
"only interface."
msgstr ""
"Для каждого типа создаётся по одному статическому объекту при запуске "
"программы или при загрузке плагина. В диспетчере на этот статический объект "
"устанавливается указатель, и после этого доступ к объекту производится либо "
"по имени, либо через этот указатель. Это единственный интерфейс."

#. type: Title =====
#: manual/tech/plugins/devices.txt:23 manual/tech/plugins/commands.txt:16
#: manual/tech/plugins/devices/ac_analysis.txt:2
#: manual/tech/plugins/devices/allocation_and_setup.txt:2
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:2
#: manual/tech/plugins/devices/parameters.txt:2
#: manual/tech/plugins/devices/ports.txt:2
#: manual/tech/plugins/devices/probes.txt:2
#: manual/tech/plugins/devices/query.txt:2
#: manual/tech/plugins/parameter_functions_and_measurements.txt:24
#: manual/tech/plugins/languages/instance/label.txt:3
#: manual/tech/plugins/languages/instance/ports.txt:3
#: manual/tech/plugins/languages/instance/type.txt:3
#: manual/tech/plugins/languages.txt:34
#: manual/tech/plugins/languages/type.txt:3
#, no-wrap
msgid "Implementation"
msgstr "Реализация "

#. type: Plain text
#: manual/tech/plugins/devices.txt:26
msgid ""
"Device plugins need to include at least one file, defining its base class.  "
"Often, that is the only include file needed."
msgstr ""
"В плагинах устройств должен подключаться с помощью ''#include'' по крайней "
"мере один файл с определением их основного класса.  Часто это единственный "
"файл, который необходимо подключить."

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:query|Simple query functions]]\n"
msgstr "[[.:devices:query.ru|Функции простых запросов]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Ports]]\n"
msgstr "[[.:devices:Ports.ru|Порты]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Parameters]]\n"
msgstr "[[.:devices:Parameters.ru|Параметры]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:Allocation and setup]]\n"
msgstr "[[.:devices:Allocation and setup.ru|Выделение памяти и настройка]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:DC and transient analysis]]\n"
msgstr "[[.:devices:DC and transient analysis.ru|Анализы «dc» и «transient»]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:AC analysis]]\n"
msgstr "[[.:devices:AC analysis.ru|Анализ «ac»]]\n"

#. type: Bullet: '  * '
#: manual/tech/plugins/devices.txt:33
#, no-wrap
msgid "[[.:devices:probes]]\n"
msgstr "[[.:devices:probes.ru|Датчики]]\n"

#. type: Title ====
#: manual/tech/plugins/coding.txt:5
#, no-wrap
msgid "Coding"
msgstr "Программирование"

#. type: Plain text
#: manual/tech/plugins/coding.txt:8
msgid ""
"This section describes the internals of a plugin, including how it "
"interfaces to the core simulator."
msgstr ""
"В настоящем разделе приводится описание внутренностей плагина, в том числе "
"описание его интерфейса к ядру программы моделирования."

#. type: Plain text
#: manual/tech/plugins/coding.txt:12
msgid ""
"The interface to plugins is through C++ derived classes, virtual functions, "
"and a dispatcher."
msgstr ""
"Интерфейс к плагинам осуществляется через классы-потомки C++, виртуальные "
"функции и диспетчер."

#. type: Plain text
#: manual/tech/plugins/coding.txt:14
msgid ""
"There are several types of plugins.  The type is determined by the base "
"class that is used.  When a plugin is loaded, a single static object is "
"created, and registered with a dispatcher.  The dispatcher allows a lookup "
"by name."
msgstr ""
"Существует несколько типов плагинов. Тип определяется используемым базовым "
"классом. При загрузке плагина создаётся одиночный статический объект и "
"регистрируется диспетчером. Диспетчер позволяет производить поиск плагинов "
"по имени."

#. type: Plain text
#: manual/tech/plugins/coding.txt:23
#, no-wrap
msgid ""
"Plugin types may include:\n"
"  * devices and models\n"
"  * commands\n"
"  * measurements\n"
"  * languages\n"
"  * functions for use in expressions\n"
"  * I/O interface\n"
"  * compatibility\n"
msgstr ""
"Могут быть плагины следующих типов:\n"
"  * устройства и модели\n"
"  * команды\n"
"  * измерения\n"
"  * языки\n"
"  * функции для использования в выражениях\n"
"  * интерфейс ввода-вывода\n"
"  * совместимость\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:25
msgid ""
"It is intended that the entire interface, all models, and almost all "
"functionality will determined by plugins."
msgstr ""
"То, что весь интерфейс, все модели, и почти вся функциональность "
"определяются плагинами, сделано намеренно."

#. type: Plain text
#: manual/tech/plugins/coding.txt:28
msgid ""
"Most plugins will create new subtypes of something.  To explain how it "
"works, I will use parameter functions as an example."
msgstr ""
"Для большинства плагинов создаются новые подтипы чего-нибудь. Чтобы "
"объяснить, как это работает, в качестве примера я буду использовать "
"параметрические функции."

#. type: Plain text
#: manual/tech/plugins/coding.txt:30
msgid "We have a base class:"
msgstr "У нас есть базовый класс:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:37
#, no-wrap
msgid ""
"<code cpp>\n"
"class FUNCTION {\n"
"public:\n"
"  virtual double eval(double arg)const = 0;\n"
"};\n"
"</code>\n"
msgstr ""
"<code cpp>\n"
"class FUNCTION {\n"
"public:\n"
"  virtual double eval(double arg)const = 0;\n"
"};\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:39
msgid "This is in a header file \"u_function.h\""
msgstr "Это в заголовочном файле ''u_function.h''"

#. type: Plain text
#: manual/tech/plugins/coding.txt:41
msgid ""
"This base class is simple.  It has one member function, which a number as "
"input, performs some operation on it, and returns the result."
msgstr ""
"Этот базовый класс прост. Его членом является одна функция, которая "
"принимает на входе число, выполняет над ним некоторые операции и возвращает "
"результат."

#. type: Plain text
#: manual/tech/plugins/coding.txt:44
msgid ""
"Let's make a function to take the absolute value of a numeric argument, as a "
"plugin.  You need to include the header:"
msgstr ""
"Давайте сделаем функцию, получающую абсолютное значение числового аргумента, "
"в виде плагина. Вам нужно включить заголовочный файл:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:48
msgid "<code cpp> #include \"u_function.h\" </code>"
msgstr ""
"<code cpp>\n"
"#include \"u_function.h\"\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:50
msgid "Then make a derived class, and create one instance of it."
msgstr "Затем сделаем класс-потомок и создадим один его экземпляр."

#. type: Plain text
#: manual/tech/plugins/coding.txt:60
#, no-wrap
msgid ""
"<code cpp>\n"
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return std::abs(arg);\n"
"  }\n"
"} p;\n"
"</code>\n"
msgstr ""
"<code cpp>\n"
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return std::abs(arg);\n"
"  }\n"
"} p;\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:62
msgid "Now, register it with the dispatcher so we can find it:"
msgstr ""
"Теперь, чтобы его можно было найти, зарегистрируем с помощью диспетчера:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:66
msgid ""
"<code cpp> DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"abs\", "
"&p); </code>"
msgstr ""
"<code cpp>\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"abs\", &p);\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:68
msgid "If you want to also access it by another name, you can do that too:"
msgstr ""
"Если нужен ещё доступ к нему под другим именем, это тоже можно сделать:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:72
msgid ""
"<code cpp> DISPATCHER<FUNCTION>::INSTALL d2(&function_dispatcher, "
"\"absolute_value\", &p); </code>"
msgstr ""
"<code cpp> DISPATCHER<FUNCTION>::INSTALL d2(&function_dispatcher, "
"\"absolute_value\", &p); </code>"

#. type: Plain text
#: manual/tech/plugins/coding.txt:74
msgid ""
"That's all.  The names of the class and instances don't matter because they "
"are local to the plugin.  You find it through the dispatcher, with the name "
"you use to INSTALL it.  In this case, either \"abs\" or \"absolute_value\" "
"will find this plugin."
msgstr ""
"Вот и всё. Имена класса и экземпляров не имеют значения, потому что они "
"являются локальными для плагина. Найти его можно через диспетчер по имени, "
"которое использовалось для его установки (INSTALL).  В данном случае плагин "
"можно найти по имени «abs» или «absolute_value»."

#. type: Plain text
#: manual/tech/plugins/coding.txt:76
msgid ""
"If you want to also be able to static-link this plugin, enclose the class "
"and dispatcher installs in an anonymous namespace."
msgstr ""
"Если для этого плагина нужна ещё возможность статического связывания, "
"заключите установку класса и диспетчера в анонимное пространство имён."

#. type: Title ====
#: manual/tech/plugins/coding.txt:77
#, no-wrap
msgid "Another Example"
msgstr "Ещё один пример"

#. type: Plain text
#: manual/tech/plugins/coding.txt:80
msgid ""
"Here's an example of another one with the same base, all together so you can "
"see it as a unit:"
msgstr ""
"Вот пример ещё одного плагина с такой же основой, где всё в одном месте, "
"поэтому он представлен здесь в виде одного блока:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:83
msgid "<code cpp> #include \"u_function.h\""
msgstr "<code cpp> #include \"u_function.h\""

#. type: Plain text
#: manual/tech/plugins/coding.txt:93
#, no-wrap
msgid ""
"class square : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return arg * arg;\n"
"  }\n"
"} p;\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"square\", &p);\n"
"</code>\n"
msgstr ""
"class square : public FUNCTION {\n"
"public:\n"
"  std::string eval(double arg)const\n"
"  {\n"
"    return arg * arg;\n"
"  }\n"
"} p;\n"
"DISPATCHER<FUNCTION>::INSTALL d1(&function_dispatcher, \"square\", &p);\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:95
msgid "That's all!"
msgstr "Вот и всё!"

#. type: Title ====
#: manual/tech/plugins/coding.txt:96
#, no-wrap
msgid "Compiling it"
msgstr "Компиляция"

#. type: Plain text
#: manual/tech/plugins/coding.txt:99
msgid ""
"The procedure for compiling it is system dependent, and is usually set up "
"when you install the main simulator."
msgstr ""
"Процедура компиляции плагина зависит от системы, и обычно настраивается при "
"установке основной программы моделирования."

#. type: Plain text
#: manual/tech/plugins/coding.txt:101
msgid ""
"In general, you need to make a \"shared object\" or \"dynamic link\" module."
msgstr ""
"В целом нужно сделать «разделяемый объектный» модуль или модуль "
"«динамического связывания»."

#. type: Plain text
#: manual/tech/plugins/coding.txt:103
msgid "On Linux, usually this works:"
msgstr "В Linux обычно работает такая команда:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:107
#, no-wrap
msgid ""
"<code>\n"
"g++ -shared -fPIC -o outfile.so infile.cc\n"
"</code>\n"
msgstr ""
"<code>\n"
"g++ -shared -fPIC -o outfile.so infile.cc\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/coding.txt:109
msgid ""
"This take a source file \"infile.cc\", and generates a plugin file \"outfile."
"so\"."
msgstr ""
"Здесь берётся исходный файл ''infile.cc'' и генерируется файл плагина "
"''outfile.so''."

#. type: Plain text
#: manual/tech/plugins/coding.txt:111
msgid "Then you can load it:"
msgstr "Затем его можно загрузить:"

#. type: Plain text
#: manual/tech/plugins/coding.txt:115
#, no-wrap
msgid ""
"<code>\n"
"gnucap> load ./outfile.so\n"
"</code>\n"
msgstr ""
"<code>\n"
"gnucap> load ./outfile.so\n"
"</code>\n"

#. type: Title ======
#: manual/tech/plugins/commands.txt:1
#, no-wrap
msgid "Command plugins"
msgstr "Плагины для реализации команд"

#. type: Plain text
#: manual/tech/plugins/commands.txt:6
msgid "Command plugins are called by a command interpreter, in a loop."
msgstr ""
"Плагины, реализующие команды, вызываются в цикле интерпретатором команд."

#. type: Plain text
#: manual/tech/plugins/commands.txt:8
msgid ""
"Usually, the main loop reads from the standard input or a file, line by "
"line.  Extension lines are combined when the file is read, so the command "
"code doesn't see them.  The string is converted to a \"command string\", an "
"object of type \"CS\", which is defined in \"ap.h\".  This command string "
"contains the data, an index showing how far it has been read, and some "
"status."
msgstr ""
"Обычно в основном цикле программа читает строки по очереди из стандартного "
"ввода или файла. В процессе чтения файла строки-расширения комбинируются, "
"поэтому код команды их не видит. Строка преобразовывается в «строку "
"команды», объект типа «CS» («command string»), который определяется в «ap."
"h».  Эта строка команды содержит данные, индекс, отражающий позицию чтения, "
"и некоторую информацию о состоянии."

#. type: Plain text
#: manual/tech/plugins/commands.txt:10
msgid ""
"The command string begins with the name of the command.  This is looked up "
"in the \"command_dispatcher\" using the subscript operator.  The dispatcher "
"returns a pointer to a static object that will interpret the command, or a "
"NULL pointer if there is no match."
msgstr ""
"Строка команды начинается с имени этой команды. Оно ищется в диспетчере "
"команд («command_dispatcher») с помощью операции индексирования. Диспетчер "
"возвращает указатель на статический объект, который будет интерпретировать "
"команду с указанным именем, или NULL, если не найдёт соответствия."

#. type: Plain text
#: manual/tech/plugins/commands.txt:12
msgid ""
"Then, the method \"do_it\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current \"scope\" so parameter expressions can be evaluated correctly.  If "
"\"do_it\" returns, it is assumed to have correctly done what was requested.  "
"If something is wrong, it may throw an exception."
msgstr ""
"Затем для этого объекта вызывается метод «do_it», передающий сначала строку "
"команды, с перенесённым на список аргументов индексом, и текущим контекстом "
"(«Scope»), поэтому выражения с параметрами могут быть вычислены правильно. "
"Если метод «do_it» возвращает значение, считается, что он правильно выполнил "
"запрошенное действие. Если что-то пойдёт не так, он может выдать сигнал "
"исключения."

#. type: Plain text
#: manual/tech/plugins/commands.txt:14
msgid ""
"Each command defines a new class, derived from \"CMD\" which is defined in "
"\"c_comand.h\"."
msgstr ""
"Для каждой команды в «c_comand.h» определяется новый класс, потомок от «CMD»."

#. type: Plain text
#: manual/tech/plugins/commands.txt:16
msgid ""
"The header file \"globals.h\" is needed because it contains the declaration "
"of the dispatcher."
msgstr ""
"Заголовочный файл «globals.h» необходим, потому что он содержит объявление "
"диспетчера."

#. type: Plain text
#: manual/tech/plugins/commands.txt:19
msgid "Plugins need to #include two files: \"c_comand.h\" and \"globals.h\"."
msgstr ""
"В плагинах должны подключаться с помощью #include два файла: «c_comand.h» и "
"«globals.h»."

#. type: Plain text
#: manual/tech/plugins/commands.txt:21
msgid ""
"Only one method is needed for each command: \"''do_it(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""
"Только один метод необходим для каждой команды: «''do_it(CS& Cmd, CARD_LIST* "
"Scope)''»."

#. type: Plain text
#: manual/tech/plugins/commands.txt:23
#: manual/tech/plugins/parameter_functions_and_measurements.txt:31
msgid ""
"Declare one static object of this new type, and INSTALL it in the DISPATCHER."
msgstr ""
"Объявите один статический объект данного нового типа и установите (с помощью "
"INSTALL) его в диспетчере (DISPATCHER)."

#. type: Plain text
#: manual/tech/plugins/commands.txt:27
msgid "<code cpp> #include \"gnucap/c_comand.h\" #include \"gnucap/globals.h\""
msgstr "<code cpp>\n"
"#include \"gnucap/c_comand.h\"\n"
"#include \"gnucap/globals.h\"\n"

#. type: Plain text
#: manual/tech/plugins/commands.txt:36
#, no-wrap
msgid ""
"class CMD_HELLO : public CMD {\n"
"  void do_it(CS& Cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // code goes here\n"
"  }\n"
"} so;\n"
"DISPATCHER<CMD>::INSTALL d(&command_dispatcher, \"hello\", &so);\n"
"</code>\n"
msgstr ""
"class CMD_HELLO : public CMD {\n"
"  void do_it(CS& Cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // здесь идёт код\n"
"  }\n"
"} so;\n"
"DISPATCHER<CMD>::INSTALL d(&command_dispatcher, \"hello\", &so);\n"
"</code>\n"

#. type: Title ====
#: manual/tech/plugins/devices/ac_analysis.txt:3
#, no-wrap
msgid "AC analysis"
msgstr "Анализ «ac»"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:6
msgid ""
"The AC functions in Gnucap correspond to a combination of the AC and PZ "
"functions in Spice.  Actually, they are more like the PZ functions, in the "
"sense that frequency (SIM::jomega) is complex."
msgstr ""
"Функции [[gnucap:manual:commands:ac.ru|ac]] в gnucap соответствуют "
"комбинации функций **ac** и **pz** в SPICE.  Фактически они более похожи на "
"функции **pz**, в том смысле, что частота (''SIM::jomega'') является "
"комплексной."

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:7
#, no-wrap
msgid "void ac_iwant_matrix()"
msgstr "void ac_iwant_matrix()"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:9
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:7
msgid "Notify the sparse matrix of what nodes this device uses."
msgstr ""
"Предоставить для разреженной матрицы сведения об используемых данным "
"устройством узлах."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:11
msgid ""
"AC analysis uses a single matrix \"acx\", which serves as both the nodal "
"admittance matrix and the LU factors.  This is likely to change in the "
"future to two matrices like in transient analysis."
msgstr ""
"Для анализа [[gnucap:manual:commands:ac.ru|ac]] используется единая матрица "
"''acx'', которая служит и как матрица узловых проводимостей, и как матрица "
"множителей LU-разложения. Вероятно, в будущем это будет изменено и будут "
"использоваться две матрицы, как во [[gnucap:manual:commands:transient.ru|"
"временном анализе]]."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:16
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node pairs that need allocating.\n"
"This line:\n"
"  acx.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and _n[1].  This is usually four places in the matrix.\n"
msgstr ""
"Предоставление этих сведений производится с помощью вызова матрицы ''iwant'' с парами узлов, которые нужно разместить.\n"
"Следующая строка запрашивает выделение пространства для подматрицы элемента, соединяющего ''_n[0]'' и ''_n[1]'':\n"
"  acx.iwant(_n[0].m_(),_n[1].m_());\n"
"Обычно это четыре места в матрице.\n"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:21
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * ac_iwant_matrix_passive(), for two-terminal elements like resistors, with a symmetric stamp\n"
"  * ac_iwant_matrix_active(), for controlled sources, with an asymmetric stamp\n"
"  * ac_iwant_matrix_extended(), the general case, allocates all combinations\n"
msgstr ""
"Обычно это не делается напрямую, а вызывается другая функция:\n"
"  * ''ac_iwant_matrix_passive()'', для двухвыводных элементов вроде резисторов, имеющих симметричную подматрицу;\n"
"  * ''ac_iwant_matrix_active()'', для управляемых источников, имеющих несимметричную подматрицу;\n"
"  * ''ac_iwant_matrix_extended()'', для общего случая, размещает все комбинации.\n"

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:22
#, no-wrap
msgid "void ac_begin()"
msgstr "void ac_begin()"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:24
msgid ""
"This is called at the beginning of every AC analysis.  It should call BASE::"
"ac_begin() before doing anything else.  It sets the value of any AC "
"variables that remain constant through a run."
msgstr ""
"Данная функция вызывается в начале каждого анализа **ac**. Прежде чем что-"
"либо делать, она должна вызвать ''BASE::ac_begin()''. В ней задаются "
"значения любых переменных **ac**, которые остаются постоянными на всё время "
"анализа."

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:25
#, no-wrap
msgid "void do_ac()"
msgstr "void do_ac()"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:27
msgid ""
"In most cases, the do_ac functions do the real work, or call the ac_eval "
"function to do it."
msgstr ""
"В большинстве случаев функции ''do_ac'' выполняют реальную работу или "
"вызывают для её выполнения функцию ''ac_eval''."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:29
msgid ""
"If necessary, it evaluates the model. Calling this function more than once "
"on an iteration is harmless, except for the waste of time.  Usually, it uses "
"state variables from a previous DC or transient analysis to compute AC "
"values."
msgstr ""
"Если необходимо, в этой функции рассчитывается модель. Вызов этой функции "
"более чем раз за итерацию безвреден, за исключением расхода времени. Обычно "
"для расчёта значений **ac** в ней используются переменные состояния из "
"предыдущего анализа **dc** или из временного анализа."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:31
msgid "Unlike Spice, Gnucap does not actually load the matrix here."
msgstr "В отличие от SPICE, gnucap на самом деле не загружает здесь матрицу."

#. type: Title ==
#: manual/tech/plugins/devices/ac_analysis.txt:32
#, no-wrap
msgid "void ac_load()"
msgstr "void ac_load()"

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:34
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_ac."
msgstr ""
"Данная функция создаёт видимость загрузки матрицы проводимостей и вектора "
"тока значениями, рассчитанными в ''do_ac''."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:36
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:69
msgid ""
"The actual loading is done by one or more of a small group of general "
"functions, depending on whether the element is active, passive, poly, or a "
"source. Only certain patterns can be stamped. Complex devices use a "
"combination of these patterns."
msgstr ""
"Фактическая загрузка производится одной или более маленькими группами общих "
"функций, в зависимости от того, является ли элемент активным, пассивным, "
"полиномиальным или источником тока или напряжения. В матрицу могут "
"заноситься только определённые шаблоны подматриц. Для комплексных устройств "
"используется комбинация этих шаблонов."

#. type: Plain text
#: manual/tech/plugins/devices/ac_analysis.txt:37
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:71
msgid "WARNING to model developers: DO NOT stamp the matrix directly!"
msgstr ""
"ПРЕДУПРЕЖДЕНИЕ для разработчиков моделей: НЕ заполняйте подматрицы в матрице "
"напрямую!"

#. type: Title ====
#: manual/tech/plugins/devices/allocation_and_setup.txt:3
#, no-wrap
msgid "Allocation and setup"
msgstr "Выделение памяти и настройка"

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:5
#, no-wrap
msgid "default constructor"
msgstr "default constructor"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:7
msgid ""
"A default constructor is required.  It is used to construct the static "
"object that is registered with the dispatcher.  It should do what a default "
"constructor usually does."
msgstr ""
"Стандартный конструктор, обязателен. Используется для создания статического "
"объекта, который регистрируется диспетчером.  Должен делать то, чем обычно "
"занимается стандартный конструктор."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:8
#, no-wrap
msgid "copy constructor"
msgstr "copy constructor"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:10
msgid ""
"A copy constructor is required.  Most objects are created by the copy "
"constructor, as copies of the object registered with the dispatcher.  "
"Usually, it should do a SHALLOW copy.  In particular, a COMMON should be "
"linked and not copied.  A copy constructor must explicitly invoke the copy "
"constructor of the base class."
msgstr ""
"Копировочный конструктор, обязателен. Большинство объектов создаются "
"копировочным конструктором, как копии объекта, зарегистрированные "
"диспетчером. Обычно он должен делать поверхностную (SHALLOW) копию. В "
"частности, ''COMMON'' должно передаваться по ссылке, а не копироваться. "
"Копировочный конструктор должен явно вызывать копировочный конструктор "
"базового класса."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:11
#, no-wrap
msgid "destructor"
msgstr "destructor"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:13
msgid ""
"Usually a destructor is not required, but it is a good idea to provide one "
"anyway even if it is empty.  It must deallocate any dynamic memory that is "
"used."
msgstr ""
"Обычно деструктор не обязателен, но в любом случае будет хорошо "
"предоставлять его, даже если он будет пустым. Его задача --- освобождать всю "
"используемую динамическую память."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:14
#, no-wrap
msgid "CARD* clone()const"
msgstr "CARD* clone()const"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:16
msgid ""
"Create a new object as a copy of this one, using the copy constructor with "
"the argument \"*this\"."
msgstr ""
"Создать новый объект как копию данного, используя копировочный конструктор с "
"аргументом «''*this''»."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:17
#, no-wrap
msgid "void expand()"
msgstr "void expand()"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:19
msgid ""
"The expand function expands subcircuits and models, as needed.  Unlike "
"Spice, it does not really flatten the circuit, but it allocate space for the "
"additional storage, attaches models, and related tasks.  It is called once "
"after reading the circuit, and possibly later when the topology of the "
"circuit is changed."
msgstr ""
"Функция ''expand'' развёртывает подсхемы и модели нужным образом. В отличие "
"от SPICE, она на самом деле не создаёт плоский список соединений для схемы, "
"но резервирует пространство для дополнительного хранилища, прикрепляет "
"модели и связанные задачи. Функция вызывается один раз после чтения схемы и, "
"возможно, потом, когда меняется топология схемы."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:21
msgid ""
"It is possible that it may be called more than once.  If it is called twice "
"in succession, the result must be the same as if it were called once.  "
"Either it frees then re-expands, or (preferably) it keeps what it can and "
"checks to make sure it is correct."
msgstr ""
"Существует возможность вызова функции более одного раза. Если она вызвана "
"два раза подряд, результат должен быть таким же, как если бы вызов был "
"один.  Функция либо освобождает память, а затем развёртывает схему заново, "
"либо (что предпочтительно) сохраняет то, что может, и проверяет данные, "
"чтобы убедиться, что они корректны."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:23
msgid ""
"Most simple elements do not have expand functions. Most advanced components "
"do."
msgstr ""
"У большинства простых элементов функции ''expand'' нет. У большинства "
"сложных компонентов есть."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:25
msgid ""
"It is not expected to compute any values, but it is allowed to call \"precalc"
"\" if needed in case the values affect topology.  It is preferred that the "
"action of expand is the same regardless of parameter values."
msgstr ""
"Не ожидается, что функция будет рассчитывать какие-то значения, но при "
"необходимости ей позволяется вызывать ''precalc'' в случаях, когда значения "
"влияют на топологию. Предпочтительным является вариант, когда ''expand'' "
"действует одинаково независимо от значений параметров."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:27
msgid ""
"Expanding a subcircuit makes a copy of it, and remaps the nodes. Most "
"components use a shallow copy. That is, if something is attached through a "
"pointer, the value of the pointer is copied, not the attachment. Commons are "
"never copied when the owner components are copied, but commons may be "
"duplicated later if something changes."
msgstr ""
"Развёртывание подсхемы означает создание её копии и перераспределение узлов. "
"Для большинства компонентов используется поверхностная копия. То есть, если "
"что-то прикрепляется посредством указателя, то копируется значение этого "
"указателя, а не то, что прикреплено. При копировании компонента владельца "
"никогда не копируются общие блоки, но копии общих частей могут быть сделаны "
"позже, если что-то изменится."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:28
#, no-wrap
msgid "void expand_first()"
msgstr "void expand_first()"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:30
msgid ""
"The expand_first function is an expand function that is done first, before "
"any plain expand functions.  Usually it is not needed, but sometimes there "
"are order dependencies, so this provides a way to control the calling "
"order.  As an example, for current controlled sources with a sense element, "
"the controlled source can send a message to the controlling element that can "
"result in a different expansion."
msgstr ""
"Функция ''expand_first'' это функция развёртывания, выполняемая в первый "
"раз, перед запуском любой простой функции ''expand''. Обычно она не нужна, "
"но иногда имеются порядковые зависимости, и это даёт возможность управления "
"порядком вызовов. Как пример, для источников, управляемых током, имеющих "
"чувствительный элемент, управляемый источник может посылать сообщение "
"управляющему элементу, что в итоге может привести к отличающемуся "
"развёртыванию."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:31
#, no-wrap
msgid "void expand_last()"
msgstr "void expand_last()"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:33
msgid ""
"The expand_last function is an expand function that is done last, after any "
"plain expand functions.  Usually it is not needed, but sometimes there are "
"order dependencies, so this provides a way to control the calling order.  As "
"an example, for current controlled sources with a sense element, the "
"controlled source must be expanded after the sense element."
msgstr ""
"Функция ''expand_last'' это функция развёртывания, выполняемая последней, "
"после любой функции плоского развёртывания. Обычно она не нужна, но иногда "
"имеются порядковые зависимости, и это даёт возможность управления порядком "
"вызовов. Как пример, для источников, управляемых током, имеющих "
"чувствительный элемент, развёртывание для самого управляющего источника "
"должно производиться после развёртывания для его чувствительного элемента."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:34
#, no-wrap
msgid "void precalc_first(), void precalc_last()"
msgstr "void precalc_first(), void precalc_last()"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:36
msgid ""
"The precalc functions attempt to pre-calculate anything that will remain "
"constant during a simulation run. This includes size dependent transistor "
"parameters and the stamp values for linear elements.  It also evaluates "
"parameter expressions."
msgstr ""
"В функциях ''precalc'' производится попытка заранее посчитать всё, что будет "
"оставаться постоянным в процессе выполнения моделирования. Сюда входят "
"параметры транзисторов, зависящие от размера, и значения подматрицы для "
"линейных элементов. Здесь также вычисляются [[gnucap:manual:howto:"
"expressions.ru|выражения с параметрами]]."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:38
msgid ""
"It is possible that it may be called more than once.  It must not change its "
"input data in any way.  If it is called twice in succession, the result must "
"be the same as if it were called once."
msgstr ""
"Возможно, что функция может вызываться более одного раза. Она никоим образом "
"не должна менять свои входные данные. Если она вызывается два раза подряд, "
"результат должен быть таким же, как если бы она вызывалась однажды."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:40
msgid ""
"Some values must be calculated before determining structure.  These go in "
"precalc_first."
msgstr ""
"Некоторые значения должны рассчитываться до определения структуры. Такие "
"значения идут в ''precalc_first''."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:42
msgid ""
"Some values must be calculated after structure is determined.  These go in "
"precalc_last."
msgstr ""
"Некоторые значения должны рассчитываться после определения структуры. Такие "
"значения идут в ''precalc_last''."

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:46
msgid ""
"Some values don't matter whether they are calculated before or after "
"structure is determined.  It strictly doesn't matter whether they are in "
"precalc_first or precalc_last.  By convention, evaluation of parameter "
"expressions goes in precalc_first, calculation of other values that are done "
"only once goes in precalc_last."
msgstr ""
"Для некоторых значений не важно, будут ли они рассчитаны до или после "
"определения структуры. Абсолютно не имеет значения, будут ли они находиться "
"в ''precalc_first'' или ''precalc_last''. По соглашению вычисление выражений "
"с параметрами производится в ''precalc_first'', расчёт других значений, "
"который выполняется только один раз, производится в ''precalc_last''."

#. type: Title ==
#: manual/tech/plugins/devices/allocation_and_setup.txt:47
#, no-wrap
msgid "void map_nodes()"
msgstr "void map_nodes()"

#. type: Plain text
#: manual/tech/plugins/devices/allocation_and_setup.txt:48
msgid ""
"Map the user node names to internal node numbers.  Almost always, the "
"inherited function does what is needed, which is to loop over all nodes "
"(both ports and internal) and call their \"map\" function, and recursively "
"map subcircuits."
msgstr ""
"Установка соответствия пользовательских имён узлов их внутренним номерам. "
"Почти всегда эта унаследованная функция делает то, что нужно, то есть "
"циклически проходится по всем узлам (и по портам, и по внутренним узлам), "
"вызывает их функции «map» и рекурсивно определяет карту соответствия для "
"подсхем."

#. type: Title ====
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:3
#, no-wrap
msgid "DC and transient analysis"
msgstr "Анализы «dc» и «transient»"

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:5
#, no-wrap
msgid "void tr_iwant_matrix()"
msgstr "void tr_iwant_matrix()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:9
msgid ""
"Two matrices are used, \"aa\" and \"lu\".  The matrix \"aa\" is the nodal "
"admittance matrix.  The matrix \"lu\" is the LU factors of the admittance "
"matrix.  Both need to be notified, and have identical patterns."
msgstr ""
"Используются две матрицы, ''aa'' и ''lu''. Матрица ''aa'' --- это матрица "
"узловых проводимостей. Матрица ''lu'' --- это матрица множителей LU-"
"разложения матрицы проводимостей. Для обеих должны предоставляться сведения "
"об узлах и обе должны иметь идентичные шаблоны подматриц."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:15
#, no-wrap
msgid ""
"This notification is done by invoking the matrix \"iwant\" call with node pairs that need allocating.\n"
"This line:\n"
"  aa.iwant(_n[0].m_(),_n[1].m_());\n"
"  lu.iwant(_n[0].m_(),_n[1].m_());\n"
"requests allocation of space for an element stamp connecting _n[0] and _n[1].  This is usually four places in the matrix.\n"
msgstr ""
"Предоставление указанных сведений производится вызовом матрицы ''iwant'' с указанием пар узлов, которые нужно разместить.\n"
"Следующие строки:\n"
"  aa.iwant(_n[0].m_(),_n[1].m_());\n"
"  lu.iwant(_n[0].m_(),_n[1].m_());\n"
"запрашивают выделение пространства для подматрицы элементов, связывающих ''_n[0]'' и ''_n[1]''.  Обычно это четыре места в матрице.\n"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:20
#, no-wrap
msgid ""
"Usually, this is not done directly, but calls another function:\n"
"  * tr_iwant_matrix_passive(), for two-terminal elements like resistors, with a symmetric stamp\n"
"  * tr_iwant_matrix_active(), for controlled sources, with an asymmetric stamp\n"
"  * tr_iwant_matrix_extended(), the general case, allocates all combinations\n"
msgstr ""
"Обычно это не делается напрямую, а вызывается другая функция:\n"
"  * ''tr_iwant_matrix_passive()'', для двухвыводных элементов вроде резисторов, имеющих симметричную подматрицу;\n"
"  * ''tr_iwant_matrix_active()'', для управляемых источников, имеющих несимметричную подматрицу;\n"
"  * ''tr_iwant_matrix_extended()'', для общего случая, размещает все комбинации.\n"

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:21
#, no-wrap
msgid "void tr_begin()"
msgstr "void tr_begin()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:23
msgid ""
"This is called at the beginning of every DC or OP analysis, and transient "
"analysis unless it is continuing a previous run.  It initializes all state "
"variables, sets up the initial guess for nonlinear analysis, and fills in "
"reasonable values for historical states.  It should call BASE::tr_begin() "
"before doing anything else."
msgstr ""
"Данная функция вызывается в начале каждого анализа [[gnucap:manual:commands:"
"dc.ru|dc]] или [[gnucap:manual:commands:op.ru|op]], и [[gnucap:manual:"
"commands:transient.ru|временного анализа]], кроме случаев, когда "
"продолжается выполнение предыдущего анализа. Она инициализирует все "
"переменные состояния, устанавливает исходные приближения для нелинейного "
"анализа и вписывает приемлемые значения для исторических состояний. Прежде "
"чем что-либо делать, она должна вызвать ''BASE::tr_begin()''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:24
#, no-wrap
msgid "void tr_restore()"
msgstr "void tr_restore()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:26
msgid ""
"This is called when continuing a transient analysis.  It must restore state "
"variables and history to a consistent state if the previous analysis was "
"stopped uncleanly.  It should call BASE::tr_restore() before doing anything "
"else."
msgstr ""
"Данная функция вызывается при продолжении временного анализа. Она должна "
"восстановить непротиворечивое состояние переменных состояния и истории, если "
"предыдущий анализ не был завершён чисто. Прежде чем что-либо делать, она "
"должна вызвать ''BASE::tr_restore()''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:27
#, no-wrap
msgid "void dc_advance()"
msgstr "void dc_advance()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:29
msgid ""
"This is called first when moving to a new DC sweep point.  It saves old "
"values of state variables as needed, and advances local time.  It also sets "
"up the initial values for iteration if needed.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::dc_advance() before doing "
"anything else."
msgstr ""
"Данная функция вызывается первой при переходе к новой точке развёртки DC. "
"Она сохраняет как положено старые значения переменных состояния и "
"увеличивает локальное время. Также, при необходимости, в ней настраиваются "
"исходные значения для итераций. Это может производиться путём использования "
"старых значений или через экстраполяцию.  Прежде чем что-либо делать, "
"функция должна вызвать ''BASE::dc_advance()''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:30
#, no-wrap
msgid "void tr_advance()"
msgstr "void tr_advance()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:32
msgid ""
"This is called first when moving to a new time step.  It saves old values of "
"state variables as needed, and advances local time.  It also sets up the "
"initial values for iteration at the new time.  It may do this by using old "
"values, or by extrapolation.  It should call BASE::tr_advance() before doing "
"anything else."
msgstr ""
"Данная функция вызывается первой при переходе к новому шагу времени. Она как "
"положено сохраняет старые значения переменных состояния и увеличивает "
"локальное время. Также в ней настраиваются начальные значения для итерации в "
"это новое время. Это может производиться путём использования старых значений "
"или через экстраполяцию. Прежде чем что-либо делать, функция должна вызвать "
"''BASE::tr_advance()''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:34
msgid ""
"For delay elements like logic devices and transmission lines, this function "
"does the real work. It takes previous results and applies them, generating "
"data that will be later loaded into the matrix."
msgstr ""
"Для элементов задержки, таких как логические устройства и линии передачи, "
"эта функция выполняет реальную работу. Она берёт предыдущие результаты и "
"употребляет их для получения данных, которые будут потом загружены в матрицу."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:35
#, no-wrap
msgid "void tr_regress()"
msgstr "void tr_regress()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:37
msgid ""
"This is called instead of tr_advance() when moving backwards in time.  The "
"usual code throws away the most recent state variables, restores the values "
"from the previous step, and backs up all of the stored state data.  It "
"should call BASE::tr_regress() before doing anything else."
msgstr ""
"Эта функция вызывается вместо ''tr_advance()'' при переходе во времени в "
"обратную сторону. Обычно в коде функции выбрасываются самые последние "
"переменные состояния, восстанавливаются значения из предыдущего шага и "
"откатываются все сохранённые данные состояний.  Прежде чем что-либо делать, "
"функция должна вызвать ''BASE::tr_regress()''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:38
#, no-wrap
msgid "bool tr_needs_eval()const"
msgstr "bool tr_needs_eval()const"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:40
msgid ""
"Return a judgment of whether or not this device is in need of evaluation at "
"this time and this iteration.  In the simplest case, you can defer writing "
"this function by just returning \"true\", but that leads to needless full "
"evaluations.  The main purpose of this function is to wake up a latent "
"device.  For a general example of this function, look in spice_wrapper.cc."
msgstr ""
"Вернуть суждение о том, требуется ли расчёт для данного устройства в данный "
"момент времени и в этой итерации или нет. В простейшем случае, написание "
"этой функции можно отложить, просто возвращая «true», но это ведёт к "
"излишним полным вычислениям. Основная цель этой функции --- разбудить "
"латентное устройство. На предмет общего примера этой функции взгляните в //"
"spice_wrapper.cc//."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:41
#, no-wrap
msgid "void tr_queue_eval()"
msgstr "void tr_queue_eval()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:43
msgid ""
"Conditionally queue this component for evaluation.  In most cases, you can "
"omit this function and use the inherited version which does ''{if"
"(tr_needs_eval()){q_eval();}}''.  The function \"''q_eval()''\" "
"unconditionally queues this component for evaluation."
msgstr ""
"Поставить по условию указанный компонент в очередь для расчёта. В "
"большинстве случаев эту функцию можно опустить и использовать унаследованную "
"версию, которая делает ''{if(tr_needs_eval()){q_eval();}}''.  Функция "
"''q_eval()'' ставит компонент в очередь для расчёта безусловно."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:44
#, no-wrap
msgid "bool do_tr()"
msgstr "bool do_tr()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:46
msgid ""
"In most cases, the do_tr functions do the real work, or call the tr_eval "
"function to do it. It evaluates the model, checks convergence, and queues it "
"for loading. Calling this function more than once on an iteration is "
"harmless, except for the waste of time."
msgstr ""
"В большинстве случаев функции ''do_tr'' сами выполняют реальную работу или "
"вызывают функцию ''tr_eval'' для её выполнения. Функция рассчитывает модель, "
"проверяет сходимость, и ставит её в очередь для загрузки. Вызов этой функции "
"более чем один раз за итерацию безвреден, за исключением расхода времени."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:48
msgid ""
"Usually, it calculates the function and derivative. It may also do "
"integration, interpolation, iteration, or whatever is required. The result "
"is a set of values ready to stamp into the admittance matrix and current "
"vector."
msgstr ""
"Обычно в ней рассчитывается сама функция и её производная. В ней может также "
"производиться интегрирование, интерполяция, итерация или всё остальное, что "
"нужно. Результатом является набор значений, готовых для заполнения матрицы "
"проводимостей, и вектор тока."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:50
msgid "There are several distinct steps within this function."
msgstr "В рамках этой функции несколько различных этапов."

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The first step is to gather the information necessary to make the computations. Usually, this is the node voltages, but it could be currents, temperature, charge, or something else.\n"
msgstr "На первом этапе собирается необходимая для расчётов информация. Обычно это напряжения узлов, но могут быть и токи, температура, заряд и что-то ещё.\n"

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The next step is to evaluate any attached function. This could be done in line, or by a call to tr_eval. The result of this evaluation is stored in _y0 (of type FPOLY1. The tr_eval function reads the value of x from _y0, and fills in the f0 with the result of function evaluation, and f1 with its derivative. The tr_eval function must also check for convergence by comparing the new _y0 with the old value, _y1. This attached function is generic in the sense that it is the same for all device types. This is the y = f(x) that is referred to in the behavioral modeling documentation.\n"
msgstr "Следующий шаг --- вычисление любой прикреплённой функции. Это может производиться либо в коде самой функции, либо вызовом ''tr_eval''. Результат вычислений сохраняется в ''_y0'' (типа ''FPOLY1''). Функция ''tr_eval'' читает значение ''x'' из ''_y0'', и заполняет ''f0'' результатом вычисления функции, а ''f1'' --- её производной. Функция ''tr_eval'' должна также проверять наличие сходимости, сравнивая новое значение ''_y0'' со старым ''_y1''. Указанная прикреплённая функция является родовой в том смысле, что она одинакова для всех типов устройств. Это та самая ''y = f(x)'', на которую ссылается [[gnucap:manual:devices:basic:inline_behavioral_modeling.ru|документация по поведенческому моделированию]].\n"

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "These values are stored for convergence checking and probing.\n"
msgstr "Эти значения сохраняются для проверки на сходимость и для измерений.\n"

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "After that, it must be converted to a current and admittance so it can be used in the system of nodal equations. This step is dependent on what type of device it is. For a conductance element, tr_eval directly returns the correct information, so nothing needs to be done here. For a capacitor, this step does numerical integration. Capacitors store this in _i0. Most other elements do not store this result directly.\n"
msgstr "После этого результат должен быть преобразован в ток и проводимость, чтобы его можно было использовать в системе узловых уравнений. Выполнение этого шага зависит от типа обрабатываемого устройства. Для элемента проводимости ''tr_eval'' возвращает непосредственно корректную информацию, поэтому здесь ничего делать не нужно. Для конденсатора на этом этапе выполняется числовая интеграция. Для конденсаторов результат сохраняется в ''_i0''. Для большинства других элементов этот результат непосредственно не сохраняется.\n"

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "Then, it must be converted into CPOLY form to meet the requirements of the system of equations.\n"
msgstr "Затем модель должна быть преобразована в вид ''CPOLY'', чтобы отвечать требованиям системы уравнений.\n"

#. type: Bullet: '  - '
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:57
#, no-wrap
msgid "The device is queued for loading. Unlike Spice, Gnucap does not actually load the matrix here.\n"
msgstr "Это устройство ставится в очередь на загрузку. В отличие от SPICE, gnucap на самом деле матрицу здесь не загружает.\n"

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:58
#, no-wrap
msgid "bool do_tr_last()"
msgstr "bool do_tr_last()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:60
msgid ""
"This is the same as do_tr, except that it is called last.  It is used when "
"there is a dependency on a do_tr of another device when it the other device "
"must be evaluated first, such as current controlled sources.  It is only "
"called if it is queued.  Most devices don't have a do_tr_last.  For devices "
"that do, the body of do_tr should be \"''{SIM::late_evalq.push_back(this); "
"return true;}''\"."
msgstr ""
"Эта функция служит для того же, что и ''do_tr'', но в отличие от неё "
"вызывается в конце. Она используется в случае наличия зависимости от "
"''do_tr'' другого устройства, когда сначала необходимо произвести расчёт для "
"другого устройства, например для источника, управляемого током. Функция "
"вызывается только в том случае, если поставлена в очередь. У большинства "
"устройств функции ''do_tr_last'' нет. У тех, у которых она имеется, тело "
"''do_tr'' должно выглядеть так: «''{SIM::late_evalq.push_back(this); return "
"true;}''»."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:61
#, no-wrap
msgid "void tr_load()"
msgstr "void tr_load()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:63
msgid ""
"This function gives the appearance of loading the admittance matrix and "
"current vector with the values calculated in do_tr."
msgstr ""
"Эта функция даёт видимость загрузки матрицы комплексных проводимостей и "
"вектора тока значениями, рассчитанными в ''do_tr''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:65
msgid ""
"Actually, it does much more. In most cases, it actually loads a correction "
"factor, assuming the old values are already loaded. To do this, it keeps "
"track of what values are actually loaded. Whether it loads a correction or "
"the actual value is determined first by the option incmode, then by status "
"information about the solution. If it is suspected that correcting would "
"cause too much roundoff error, it loads the actual value. The decision of "
"whether to do a full load or an update is global."
msgstr ""
"Фактически она делает гораздо больше. В большинстве случаев она на самом "
"деле загружает поправочный коэффициент, полагая, что старые значения уже "
"загружены. Для этого функция следит за тем, какие значения загружаются на "
"самом деле. Будет ли загружаться скорректированное или фактическое значение, "
"определяется сначала опцией ''[[gnucap:manual:commands:options."
"ru#Точность_алгоритмы|incmode]]'', затем статусной информацией об этом "
"решении. Если есть подозрение, что корректировка может вызвать слишком "
"большую ошибку округления, функция загружает фактическое значение. Решение о "
"том, делать ли полную загрузку или обновление, является глобальным."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:67
msgid ""
"In addition, it may apply damping in hopes of improving convergence. This "
"means to load a value somewhere between the new and old values, in effect "
"taking a partial step. The decision to damp is semi-global. Groups of "
"elements are adjusted together."
msgstr ""
"Вдобавок, функция может использовать затухание в надежде улучшения "
"сходимости. Это означает загрузку какого-то значения в районе между новым и "
"старым значениями, то есть в сущности частичный шаг. Решение о затухании "
"является наполовину глобальным. Группы элементов корректируются вместе."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:72
#, no-wrap
msgid "void tr_unload()"
msgstr "void tr_unload()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:74
msgid ""
"This function removes the component from the matrix, possibly by subtracting "
"off what was loaded. Usually, it sets the current values to 0 and calls "
"tr_load."
msgstr ""
"Эта функция удаляет компонент из матрицы, возможно вычитанием того, что было "
"загружено. Обычно она устанавливает текущие значения в 0 и вызывает "
"''tr_load''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:75
#, no-wrap
msgid "TIME_PAIR tr_review()"
msgstr "TIME_PAIR tr_review()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:77
msgid ""
"The tr_review function checks errors and signal conditions after a time step "
"has converged. It returns two values of an approximate time that the element "
"wants for the next step, and stores that information in the instance "
"variable _time_by."
msgstr ""
"Функция ''tr_review'' проверяет ошибки и сигнальные условия после достижения "
"сходимости для временного шага. Она возвращает два значения, приблизительно "
"определяющих точки времени, которые было бы желательно использовать в "
"качестве следующего шага для элемента, и сохраняет эту информацию в "
"переменной экземпляра ''_time_by''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:79
msgid ""
"\"''_time_by._error_estimate''\" is an estimate of the desired next time "
"based on analog error estimate.  It is used to control truncation error, "
"curve fitting error, and overall smoothness of the result.  The actual next "
"time will probably be sooner than this number suggests, and is considered to "
"be more accurate.  Usually you would set it indirectly by ''_time_by."
"min_error_estimate(suggested_next_time);''."
msgstr ""
"«''_time_by._error_estimate''» представляет собой приблизительное желаемое "
"значение следующего временного шага на основе приблизительной оценки "
"аналоговой ошибки. Это значение используется для регулирования погрешности "
"численного метода («truncation error»), ошибки аппроксимации кривой и общей "
"гладкости результата. Действительный момент времени следующего шага будет, "
"вероятно, раньше, чем предлагается в этом числе, и считается, что он должен "
"быть более точным. Обычно это значение задаётся косвенно посредством "
"''_time_by.min_error_estimate(следующее_предложенное_время);''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:81
msgid ""
"\"''_time_by._event''\" is an estimate of the desired next time based on "
"ambiguous events.  It is used to control accuracy of cross events and "
"situations where clusters of time steps are needed for accuracy.  The actual "
"time will try to match this as close as practical.  Shorter time steps do "
"not improve accuracy.  Usually you would set it indirectly by ''_time_by."
"min_event(suggested_next_time);''."
msgstr ""
"«''_time_by._event''» представляет собой приблизительное желаемое значение "
"следующего временного шага на основе неоднозначно определённых событий. Это "
"значение используется для управления точностью событий пересечения и "
"ситуаций, где для обеспечения точности необходимо использование группы "
"временных шагов. Действительный момент времени будет выбираться так, чтобы "
"он соответствовал этому значению настолько близко, насколько это "
"целесообразно. Более короткие временные шаги точности не увеличивают. Обычно "
"это значение задаётся косвенно посредством ''_time_by.min_event"
"(следующее_предложенное_время);''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:83
msgid ""
"It is usually appropriate to call BASE::tr_review before doing anything "
"else.  If not, you should call ''_time_by.reset()'' first."
msgstr ""
"Обычно, прежде чем делать что-то ещё, целесообразно вызвать ''BASE::"
"tr_review''. Если это не подходит, сначала следует вызвать ''_time_by.reset"
"()''."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:85
msgid ""
"If there is a tr_accept function, and you want it to be called, you must "
"queue it here by calling q_accept()."
msgstr ""
"Если существует функция tr_accept, и нужно, чтобы она была вызвана, её "
"необходимо поставить здесь в очередь, вызвав ''q_accept()''."

#. type: Title ==
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:86
#, no-wrap
msgid "void tr_accept()"
msgstr "void tr_accept()"

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:89
msgid ""
"This function is called after the solution at a time step has been accepted. "
"For most devices, it does nothing. For devices having storage and delayed "
"propagation, it evaluates what signal will be propagated. For a transmission "
"line, it calculates and sends on the reflections."
msgstr ""
"Эта функция вызывается после того, как решение на каком-то шаге времени уже "
"принято. Для большинства устройств она не делает ничего. Для устройств, "
"имеющих память и задержанное распространение, она рассчитывает, какой сигнал "
"будет распространяться. Для линии передачи, она рассчитывает и "
"перенаправляет отражения."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:91
msgid ""
"It is called only when queued, so either tr_review or do_tr must call "
"q_accept() to queue it."
msgstr ""
"Функция вызывается только в том случае, если поставлена в очередь, поэтому "
"либо ''tr_review'', либо ''do_tr'' должна вызвать ''q_accept()'', чтобы "
"поставить её в очередь."

#. type: Plain text
#: manual/tech/plugins/devices/dc_and_transient_analysis.txt:93
msgid ""
"Only tr_accept is allowed to add events to the event queue (SIM::new_event"
"())."
msgstr ""
"Только функции ''tr_accept'' разрешается добавлять события в очередь событий "
"(''SIM::new_event()'')."

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:6
msgid ""
"These methods provide all access to parameters.  Parameters are seen as "
"strings in this context, because it is more flexible.  Usually parameters "
"are accessed by index, as if in an array.  It is up to the implementer to "
"decide what type of storage to actually use."
msgstr ""
"Указанные здесь методы предоставляют полный доступ к параметрам. Параметры в "
"этом контексте представлены в виде строк («string»), потому что это более "
"гибко. Обычно доступ к параметрам производится по индексу, как будто бы в "
"массиве. Ответственность за решение о типе хранилища, который следует "
"использовать на самом деле, лежит на том, кто это реализует."

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:8
msgid ""
"Indexing starts at 0 in CARD, and counts up from there.  The indexing of "
"parameters should be consecutive.  For example, if the base class has "
"parameters numbered up to 16, you should start at 17.  The appropriate "
"starting number can be obtained by calling BASE::param_count().  The "
"preferred internal index method is to start at 0, and index from the value "
"BASE::param_count-1-i where i is the external index.  If the result of BASE::"
"param_count-1-i is out of range, call the matching BASE method, passing i "
"through.  In this section BASE:: refers to the most immediate base class.  "
"All of these methods are required, and will march through the class "
"hierarchy until the request is satisfied."
msgstr ""
"Индексирование начинается в ''CARD'' с 0 и далее счёт идёт вверх. "
"Индексирование параметров должно быть последовательным. Например, если "
"базовый класс имеет параметры, пронумерованные до 16, необходимо начинать с "
"17.  Подходящий начальный номер можно получить, вызвав ''BASE::param_count"
"()''. Для внутреннего индексирования предпочтителен метод, когда нумерация "
"идёт с 0 и индексирование производится от значения ''BASE::param_count-1-"
"i'', где ''i'' представляет собой внешний индекс. Если результат ''BASE::"
"param_count-1-i'' окажется вне диапазона, нужно вызвать указанный метод для "
"''BASE'', передав значение ''i'' дальше по иерархии. В этом разделе "
"''BASE::'' относится к самому ближайшему базовому классу.  Все указанные "
"методы обязательны и запросы будут проходить через иерархию классов до тех "
"пор, пока не будут удовлетворены."

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:10
msgid ""
"Some devices use another set of methods, \"obsolete_callback\".  This is not "
"documented here and not recommended for any new work.  Support for "
"\"obsolete_callback\" will be dropped at some time in the future."
msgstr ""
"Для некоторых устройств используется другой набор методов, "
"''obsolete_callback''.  Этот способ здесь не описывается и его не "
"рекомендуется использовать ни в каких новых разработках. Когда-нибудь в "
"будущем поддержка ''obsolete_callback'' будет прекращена."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:11
#, no-wrap
msgid "int param_count()const"
msgstr "int param_count()const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:13
msgid "Return (local_param_count + BASE::param_count())."
msgstr "Возвращает значение ''(local_param_count + BASE::param_count())''."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:14
#, no-wrap
msgid "bool param_is_printable(int)const"
msgstr "bool param_is_printable(int)const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:16
msgid ""
"Return true if it is appropriate to print the value of this parameter in a "
"netlist.  Some parameters should be printed regardless of their status, in "
"which case this function can just return true for that index.  You can "
"return false to always suppress the printing of a parameter and its value.  "
"Sometimes you might want to do some kind of test to determine whether or not "
"to print the parameter.  Usually, the function must determine a result for "
"its own, and return BASE::param_is_printable for others.  If you want to "
"suppress the printing of all base class parameters, return false for index "
"out of range."
msgstr ""
"Возвращает «true», если значение этого параметра подходит для вывода в "
"список соединений. Некоторые параметры должны выводиться независимо от их "
"статуса, в таком случае эта функция может просто вывести «true» для "
"соответствующего индекса. Можно возвращать «false», чтобы всегда подавлять "
"вывод параметра и его значения. Иногда может быть нужно создать некоторого "
"рода тест, чтобы определить, выводить ли параметр или нет. Обычно для себя "
"самой эта функция должна определять результат, а для других возвращать "
"''BASE::param_is_printable''.  Если нужно подавить вывод всех параметров "
"базового класса, возвращайте «false» для индекса вне диапазона."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:17
#, no-wrap
msgid "std::string param_name(int)const"
msgstr "std::string param_name(int)const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:19
msgid ""
"Return the preferred name of a parameter given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""
"Возвращает предпочтительное имя параметра по заданному индексу. Используется "
"обычная процедура для сканирования вниз по базовым классам. Если вы не "
"хотите сканировать базовые классы, возвратите пустую строку для индикации "
"того, что индекс вне диапазона."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:20
#, no-wrap
msgid "std::string param_name(int i,int j)const"
msgstr "std::string param_name(int i,int j)const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:22
msgid ""
"Return an alternative name of a parameter given an index i, and an alternate "
"index j.  When j == 0, it returns the preferred name.  When j > 0, it "
"returns either an alternative name or an empty string."
msgstr ""
"Возвращает альтернативное имя параметра по заданному индексу ''i'' и "
"дополнительному индексу ''j''.  При ''j == 0'' возвращается предпочтительное "
"имя. При ''j > 0'' возвращается либо альтернативное имя, либо пустая строка."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:23
#, no-wrap
msgid "std::string param_value(int)const"
msgstr "std::string param_value(int)const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:25
msgid ""
"Return the value of a parameter as a string given an index.  The usual "
"procedure for scanning down the base classes applies.  If you don't want to "
"scan the base classes, return an empty string to indicate an index out of "
"range."
msgstr ""
"Возвращает значение параметра по заданному индексу в виде строки. "
"Применяется обычная процедура для сканирования вниз до базовых классов. Если "
"вы не хотите сканировать базовые классы, возвратите пустую строку для "
"индикации того, что индекс вне диапазона."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:26
#, no-wrap
msgid "void set_param_by_name(std::string name, std::string value)"
msgstr "void set_param_by_name(std::string name, std::string value)"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:28
msgid ""
"Set the value of a parameter, by name.  Providing this method is optional.  "
"If you don't provide it, the base class provides a version that looks up the "
"index corresponding to the name and calls set_param_by_index.  It should "
"throw \"Exception_No_Match\" if there is no parameter corresponding to the "
"name."
msgstr ""
"Устанавливает значение параметра по имени. Предоставление этого метода не "
"обязательно. Если вы его не предоставляете, базовый класс предоставляет "
"версию, которая ищет индекс, соответствующий этому имени и вызывает "
"''set_param_by_index''. Функция должна выдать исключение "
"«Exception_No_Match», если параметра, соответствующего указанному имени, не "
"существует."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:29
#, no-wrap
msgid "void set_param_by_index(int i, std::string&, int offset)"
msgstr "void set_param_by_index(int i, std::string&, int offset)"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:31
msgid ""
"Set the value of a parameter, by index.  Providing this method is required "
"if set_param_by_name is not provided, or if you want to be able to accept a "
"list of unnamed parameters in an alternative syntax.  The usual procedure "
"for scanning down the base classes applies.  If you don't want to scan the "
"base classes, throw \"Exception_Too_Many\"."
msgstr ""
"Устанавливает значение параметра по индексу. Предоставление этого метода "
"обязательно, если ''set_param_by_name'' не предоставляется, или если вы "
"хотите иметь возможность принимать список неименованных параметров, "
"используя альтернативный синтаксис. Используется обычная процедура для "
"сканирования вниз по базовым классам. Если вы не хотите сканировать базовые "
"классы, выдайте исключение «Exception_Too_Many»."

#. type: Title ==
#: manual/tech/plugins/devices/parameters.txt:32
#, no-wrap
msgid "std::string value_name()const"
msgstr "std::string value_name()const"

#. type: Plain text
#: manual/tech/plugins/devices/parameters.txt:33
msgid ""
"Return the name of the parameter to set when just a numeric value is given, "
"as in most Spice primitives.  If you don't want to accept any unnamed "
"parameters, return an empty string."
msgstr ""
"Возвращает имя параметра, которое должно быть установлено, когда задано "
"только числовое значение, как в большинстве примитивов SPICE. Если вы не "
"хотите принимать никакие неименованные параметры, возвратите пустую строку."

#. type: Title ====
#: manual/tech/plugins/devices/ports.txt:3
#, no-wrap
msgid "Ports"
msgstr "Порты"

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:5
#, no-wrap
msgid "void set_port_by_name(std::string& name, std::string& value)"
msgstr "void set_port_by_name(std::string& name, std::string& value)"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:7
msgid ""
"Make a connection between a port and the rest of the circuit, by name as in "
"Verilog.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""
"Сделать соединение между портом и остальной частью схемы по имени, как в "
"[[gnucap:manual:languages:verilog.ru|Verilog]].  Обычно это не требуется, "
"потому что то, что надо, сделает унаследованный метод."

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:8
#, no-wrap
msgid "void set_port_by_index(int index, std::string& value)"
msgstr "void set_port_by_index(int index, std::string& value)"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:10
msgid ""
"Make a connection between a port and the rest of the circuit, by position as "
"in Spice.  Usually this is not needed because the inherited method will do "
"the right thing."
msgstr ""
"Сделать соединение между портом и остальной схемой в соответствии с его "
"позицией, как в [[gnucap:manual:languages:spice.ru|SPICE]]. Обычно это не "
"требуется, потому что то, что надо, сделает унаследованный метод."

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:11
#, no-wrap
msgid "std::string port_name(int i)const"
msgstr "std::string port_name(int i)const"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:13
msgid ""
"Return the name of a port given its index.  This is required, because all "
"devices have unique port names."
msgstr ""
"Возвратить имя порта по его индексу. Этот метод обязателен, потому что имена "
"портов у всех устройств уникальны."

#. type: Title ===
#: manual/tech/plugins/devices/ports.txt:14
#, no-wrap
msgid "Current ports"
msgstr "Токовые порты"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:17
msgid ""
"Most devices do not have current ports, so these methods are usually not "
"needed."
msgstr ""
"У большинства устройств нет токовых портов, поэтому обычно эти методы не "
"нужны."

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:18
#, no-wrap
msgid "void set_current_port_by_index(int, const std::string&)"
msgstr "void set_current_port_by_index(int, const std::string&)"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:20
msgid ""
"Make a connection between a current port and the rest of the circuit, by "
"position as in Spice.  This is required if the device has current ports."
msgstr ""
"Сделать соединение между токовым портом и остальной частью схемы в "
"соответствии с его позицией, как в [[gnucap:manual:languages:spice.ru|"
"SPICE]].  Этот метод обязателен, если устройство имеет токовые порты."

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:21
#, no-wrap
msgid "const std::string current_port_value(int)const"
msgstr "const std::string current_port_value(int)const"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:23
msgid ""
"Return the name of the element that a current port is connected to.  This is "
"required if the device has current ports."
msgstr ""
"Возвратить имя элемента, к которому присоединён токовый порт. Этот метод "
"обязателен, если устройство имеет токовые порты."

#. type: Title ==
#: manual/tech/plugins/devices/ports.txt:24
#, no-wrap
msgid "std::string current_port_name(int)const"
msgstr "std::string current_port_name(int)const"

#. type: Plain text
#: manual/tech/plugins/devices/ports.txt:25
msgid ""
"Return the name of a current port given its index.  This is required if the "
"device has current ports."
msgstr ""
"Возвратить имя токового порта по его индексу. Этот метод обязателен, если "
"устройство имеет токовые порты."

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:5
#, no-wrap
msgid "double tr_probe_num(const std::string&)const"
msgstr "double tr_probe_num(const std::string&)const"

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:8
msgid ""
"This function returns a probe value for DC, OP, and transient analysis, "
"selected by a string argument.  Any state variable or parameter may be "
"selected."
msgstr ""
"Эта функция для анализов [[gnucap:manual:commands:dc.ru|dc]], [[gnucap:"
"manual:commands:op.ru|op]] и [[gnucap:manual:commands:transient.ru|"
"transient]] возвращает значение датчика, выбранного посредством строкового "
"аргумента. Можно выбрать любую переменную состояния или любой параметр."

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:10
msgid ""
"Usually the code consists of a string of if - elseif statements.  If none "
"match, in most cases it should call BASE::tr_probe_num and return its result."
msgstr ""
"Обычно код состоит из строки операторов ''if - elseif''. Если соответствия "
"не найдено, в большинстве случаев нужно вызвать функцию ''BASE::"
"tr_probe_num'' и возвратить её результат."

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:23
#, no-wrap
msgid ""
"<code cpp>\n"
"double DEV_CAPACITANCE::tr_probe_num(const std::string& x)const\n"
"{\n"
"  if (Umatch(x, \"q{cap} |ch{arge} \")) {\n"
"    return _y[0].f0;\n"
"  }else if (Umatch(x, \"c{apacitance} \")) {\n"
"    return _y[0].f1;\n"
"  }else{\n"
"    return STORAGE::tr_probe_num(x);\n"
"  }\n"
"}\n"
"</code>\n"
msgstr ""
"<code cpp>\n"
"double DEV_CAPACITANCE::tr_probe_num(const std::string& x)const\n"
"{\n"
"  if (Umatch(x, \"q{cap} |ch{arge} \")) {\n"
"    return _y[0].f0;\n"
"  }else if (Umatch(x, \"c{apacitance} \")) {\n"
"    return _y[0].f1;\n"
"  }else{\n"
"    return STORAGE::tr_probe_num(x);\n"
"  }\n"
"}\n"
"</code>\n"

#. type: Title ==
#: manual/tech/plugins/devices/probes.txt:24
#, no-wrap
msgid "XPROBE ac_probe_ext(const std::string&)const"
msgstr "XPROBE ac_probe_ext(const std::string&)const"

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:28
msgid ""
"This function returns a probe value for AC analysis, selected by a string "
"argument.  Any state variable or parameter may be selected."
msgstr ""
"Эта функция для анализа [[gnucap:manual:commands:ac.ru|ac]] возвращает "
"значение датчика, выбранного посредством строкового аргумента. Можно выбрать "
"любую переменную состояния или любой параметр."

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:30
msgid "It returns an XPROBE object:"
msgstr "Функция возвращает объект ''XPROBE'':"

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:41
#, no-wrap
msgid ""
"<code cpp>\n"
"enum mod_t {mtNONE, mtMAG, mtPHASE, mtREAL, mtIMAG};\n"
"class XPROBE{\n"
"private:\n"
"  COMPLEX _value;\n"
"  mod_t   _modifier; // default\n"
"  double  _dbscale;  // 20 for voltage, 10 for power, etc.\n"
"// .....\n"
"}\n"
"</code>\n"
msgstr ""
"<code cpp>\n"
"enum mod_t {mtNONE, mtMAG, mtPHASE, mtREAL, mtIMAG};\n"
"class XPROBE{\n"
"private:\n"
"  COMPLEX _value;\n"
"  mod_t   _modifier; // значение по умолчанию\n"
"  double  _dbscale;  // 20 для напряжения, 10 для мощности и т. д.\n"
"// .....\n"
"}\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/devices/probes.txt:43
msgid ""
"Usually, the returned value is made by a constructor with one argument, "
"using defaults for _modifier and _dbscale.  The value is a COMPLEX number."
msgstr ""
"Обычно возвращаемое значение создаётся конструктором, запускаемым с одним "
"аргументом и использующим значения по умолчанию для ''_modifier'' и "
"''_dbscale''. Это значение является числом типа ''COMPLEX''."

#. type: Title =====
#: manual/tech/plugins/devices/query.txt:3
#: manual/tech/plugins/languages/simple_query_functions.txt:3
#, no-wrap
msgid "Simple query functions"
msgstr "Функции простых запросов"

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:5
#, no-wrap
msgid "Used by parser"
msgstr "Используемые функциями синтаксического разбора"

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:7
#, no-wrap
msgid "int max_nodes()const"
msgstr "int max_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:9
msgid ""
"Return the maximum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it returns a "
"constant."
msgstr ""
"Возвращает максимальное число портов, используемое с точки зрения функции "
"синтаксического разбора, включая как порты напряжения, так и токовые порты.  "
"Обычно возвращается константа."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:10
#, no-wrap
msgid "int min_nodes()const"
msgstr "int min_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:12
msgid ""
"Return the minimum number of ports, from the viewpoint of the parser, "
"including both voltage ports and current ports.  Usually it is the same as "
"max_nodes."
msgstr ""
"Возвращает минимальное число портов, используемое с точки зрения функции "
"синтаксического разбора, включая как порты напряжения, так и токовые порты. "
"Обычно возвращает то же самое значение, что и ''max_nodes''."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:13
#, no-wrap
msgid "int_num_current_ports()const"
msgstr "int num_current_ports()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:15
msgid ""
"Return the required number of current ports.  There are ports in a netlist "
"that are really branch elements used as current probes.  If omitted, the "
"inherited method returns zero.  If this function returns a non-zero value, "
"the device may not work with all netlist formats."
msgstr ""
"Возвращает требуемое количество токовых портов. В списке соединений есть "
"порты, которые на самом деле являются элементами ветвей, используемыми как "
"датчики тока. Если данный метод отсутствует, унаследованный метод будет "
"возвращать ноль. Если эта функция возвращает ненулевое значение, устройство "
"может работать не со всеми форматами списков соединений."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:16
#, no-wrap
msgid "int tail_size()const"
msgstr "int tail_size()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:18
msgid ""
"Return the minimum number of non-ports following the ports.  It is a hack to "
"help the Spice format parser distinguish between a port name and the device "
"type.  If omitted, the inherited method returns 0 or 1, but usually 1 is the "
"correct value."
msgstr ""
"Возвращает минимальное количество не-портов, следующих за портами. Это трюк, "
"сделанный для того, чтобы помочь функциям разбора формата [[gnucap:manual:"
"language:SPICE.ru|SPICE]] проводить разграничение между именами портов и "
"типом устройства. Если данный метод отсутствует, унаследованный метод "
"возвращает 0 или 1, но обычно корректным значением является 1."

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:19
#, no-wrap
msgid "Used by allocation functions and checking"
msgstr "Используемые функциями выделения памяти и проверки"

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:21
#, no-wrap
msgid "int net_nodes()const"
msgstr "int net_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:23
msgid ""
"Return the actual number of ports.  If max_nodes == min_nodes, the only "
"valid value is the same, so it is permissible to return that number.  "
"Otherwise, it is determined when the netlist is read.  If the syntax is "
"correct it will always be between min_nodes and max_nodes."
msgstr ""
"Возвращает фактическое число портов. Если ''max_nodes == min_nodes'', "
"единственным допустимым значением будет одно и то же число, поэтому "
"разрешается возвращать его. В противном случае это число определяется при "
"чтении списка соединений.  Если синтаксис корректен, оно всегда будет в "
"пределах между ''min_nodes'' и ''max_nodes''."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:24
#, no-wrap
msgid "int ext_nodes()const"
msgstr "int ext_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:26
msgid ""
"Return the number of external nodes.  If omitted, the inherited method "
"returns max_nodes()."
msgstr ""
"Возвращает число внешних узлов. Если этот метод отсутствует, унаследованный "
"метод возвращает ''max_nodes()''."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:27
#, no-wrap
msgid "int int_nodes()const"
msgstr "int int_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:29
msgid ""
"Return the number of internal nodes.  If omitted, the inherited method "
"return 0."
msgstr ""
"Возвращает число внутренних узлов. Если этот метод отсутствует, "
"унаследованный метод возвращает 0."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:30
#, no-wrap
msgid "int_matrix_nodes()const"
msgstr "int_matrix_nodes()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:32
msgid ""
"Return the number of nodes that stamp into the matrix.  The value is usually "
"int_nodes() + ext_nodes()."
msgstr ""
"Возвращает число узлов, которые будут заноситься в матрицу. Это значение "
"обычно равно ''int_nodes() + ext_nodes()''."

#. type: Title ===
#: manual/tech/plugins/devices/query.txt:33
#, no-wrap
msgid "Special simple element property flags (usually not needed)"
msgstr "Особые флаги свойств простых элементов (обычно не нужны)"

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:35
#, no-wrap
msgid "bool has_inode()const"
msgstr "bool has_inode()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:37
msgid ""
"Return true if the device has a hidden node that can be used as a current "
"probe.  If omitted, the inherited method returns false."
msgstr ""
"Возвращает «true», если устройство имеет скрытый узел, который может "
"использоваться как датчик тока. Если этот метод отсутствует, унаследованный "
"метод возвращает «false»."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:38
#, no-wrap
msgid "bool has_iv_probe()const"
msgstr "bool has_iv_probe()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:40
msgid ""
"Return true if the device can be used as a current probe for current "
"controlled spice devices.  If omitted, the inherited method returns false."
msgstr ""
"Возвращает «true», если устройство может использоваться как датчик тока для "
"управляемых током устройств SPICE. Если этот метод отсутствует, "
"унаследованный метод возвращает «false»."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:41
#, no-wrap
msgid "bool is_device()const"
msgstr "bool is_device()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:43
msgid ""
"Return true if the device is a device.  In this context, the inherited "
"method returns true, so it can always be omitted.  It is listed here because "
"a netlist can also include non-device objects, and this function identifies "
"the difference."
msgstr ""
"Возвращает «true», если устройство является устройством. В данном контексте "
"унаследованный метод возвращает «true», поэтому данный метод всегда можно "
"пропустить. Он упоминается здесь потому, что в список соединений могут "
"входить также объекты, не являющиеся устройствами, и эта функция может "
"определить данный факт."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:44
#, no-wrap
msgid "bool is_source()const"
msgstr "bool is_source()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:46
msgid ""
"Return true if the device is a fixed source.  If omitted, the inherited "
"method returns false."
msgstr ""
"Возвращает «true», если устройство является независимым источником тока или "
"напряжения. Если данный метод отсутствует, унаследованный метод возвращает "
"«false»."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:47
#, no-wrap
msgid "bool f_is_value()const"
msgstr "bool f_is_value()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:49
msgid ""
"Return true if the result of evaluating a behavioral function is the \"value"
"\".  If omitted, the inherited method returns false."
msgstr ""
"Возвращает «true», если результатом вычисления поведенческой функции "
"является «значение».  Если данный метод отсутствует, унаследованный метод "
"возвращает «false»."

#. type: Title ==
#: manual/tech/plugins/devices/query.txt:50
#, no-wrap
msgid "bool_makes_own_scope()const"
msgstr "bool_makes_own_scope()const"

#. type: Plain text
#: manual/tech/plugins/devices/query.txt:51
msgid ""
"Return true if the device makes its own scope for searching.  This is used "
"for the header lines of subcircuits.  For normal devices, it can be omitted, "
"which will return false."
msgstr ""
"Возвращает «true», если устройство создаёт свой собственный контекст для "
"поиска. Это используется для строк [[gnucap:manual:commands:title.ru|"
"заголовков подсхем]]. Для обычных устройств этот метод можно пропустить, в "
"таком случае будет возвращаться «false»."

#. type: Title ====
#: manual/tech/plugins/files.txt:5
#, no-wrap
msgid "Files"
msgstr "Файлы"

#. type: Plain text
#: manual/tech/plugins/files.txt:8
msgid ""
"Gnucap plugins are standard \"shared object\" or \"dynamic link\" files, "
"native to the environment."
msgstr ""
"Плагины gnucap представляют собой обычные файлы «разделяемых объектов» или "
"динамических связей, «родные» для данного окружения."

#. type: Plain text
#: manual/tech/plugins/files.txt:10
msgid ""
"Plugins must be compiled for the particular system, like shared libraries."
msgstr ""
"Плагины должны быть скомпилированы для конкретной системы, подобно "
"разделяемым библиотекам."

#. type: Title ====
#: manual/tech/plugins/files.txt:11
#, no-wrap
msgid "System Requirements"
msgstr "Требования к системе"

#. type: Plain text
#: manual/tech/plugins/files.txt:14
msgid ""
"The host system must be capable of dynamic linking, and support the "
"POSIX.1-2001 system calls for loading and unloading dynamic libraries on "
"demand.  In particular, the calls \"dlopen\", \"dlclose\", and \"dlerror\" "
"are used.  The \"dlsym\" call is not used."
msgstr ""
"Операционная система должна иметь способность динамического связывания и "
"поддерживать системные вызовы POSIX.1-2001 для загрузки и выгрузки "
"динамических библиотек по требованию. В частности, используются вызовы "
"«dlopen», «dlclose» и «dlerror». Вызов «dlsym» не используется."

#. type: Plain text
#: manual/tech/plugins/files.txt:16
msgid ""
"If the system does not support these calls directly, but does have the "
"functionality in a different form, a set of wrapper functions is needed."
msgstr ""
"Если система не поддерживает эти вызовы напрямую, но имеет эту "
"функциональность в другой форме, необходим набор функций-обёрток."

#. type: Title ====
#: manual/tech/plugins/files.txt:17
#, no-wrap
msgid "Interface"
msgstr "Интерфейс"

#. type: Plain text
#: manual/tech/plugins/files.txt:20
msgid ""
"Plugins are loaded by the \"load\" (or \"attach\") command, and unloaded by "
"the \"unload\" (or \"detach\") command.  These commands are defined in the "
"source file \"c_attach.cc\"."
msgstr ""
"Плагины загружаются командой [[gnucap:manual:commands:load.ru|load]] (или "
"[[gnucap:manual:commands:attach.ru|attach]]), и выгружаются командой "
"[[gnucap:manual:commands:load.ru|unload]] (или [[gnucap:manual:commands:"
"detach.ru|detach]]).  Эти команды определяются в файле исходного кода "
"«c_attach.cc»."

#. type: Plain text
#: manual/tech/plugins/files.txt:22
msgid ""
"As of when this is being written, the files must be compiled before "
"loading.  In the future, there will be changes to enable the ability to "
"compile plugins on demand."
msgstr ""
"На момент написания сего документа файлы должны быть скомпилированы до "
"загрузки. В будущем будут сделаны изменения для включения возможности "
"компилировать плагины по требованию."

#. type: Plain text
#: manual/tech/plugins/files.txt:24
msgid ""
"As per the specification of \"dlopen\", when a plugin is loaded, "
"constructors for all of its static objects are run.  Normally, the linkage "
"is through derived classes and a dispatcher, but other interfaces are "
"possible by callbacks in the constructor.  Also, all callbacks are resolved "
"at this time.  A plugin will fail to load if callbacks cannot be resolved."
msgstr ""
"Согласно спецификации функции «dlopen», при загрузке плагина запускаются "
"конструкторы для всех его статических объектов.  Обычно связь идёт через "
"классы-потомки и диспетчер, но возможны другие виды взаимодействия "
"посредством обратных вызовов в конструкторе. Также в это время производится "
"разрешение всех обратных вызовов. Плагин не сможет загрузиться, если "
"невозможно разрешить обратные вызовы."

#. type: Plain text
#: manual/tech/plugins/files.txt:26
msgid ""
"If it is desired to load a plugin in spite of unresolved callbacks, you can "
"load with the \"lazy\" option.  If you do this, the plugin is likely to work "
"partially but fail when it attempts to call the missing function.  This is "
"not recommended for released code and likely to not work with non-POSIX "
"systems.  It is provided as a debugging aid."
msgstr ""
"Если плагин желательно загрузить несмотря на неразрешённые обратные вызовы, "
"это можно сделать с помощью опции ''lazy''. В этом случае плагин, вероятно, "
"будет работать частично, но при попытке вызвать отсутствующую функцию будут "
"происходить сбои. Это не рекомендуется для кода вышедших версий и, вероятно, "
"не работает на не-POSIX системах. Это предусмотрено для облегчения отладки."

#. type: Plain text
#: manual/tech/plugins/files.txt:28
msgid ""
"Likewise, when a plugin is unloaded, destructors for the static objects are "
"run."
msgstr ""
"Подобным образом, когда плагин выгружается, для статических объектов "
"запускаются деструкторы."

#. type: Plain text
#: manual/tech/plugins/files.txt:30
msgid ""
"The \"dlsym\" function is not needed, because the interface is through "
"derived classes."
msgstr ""
"Функция «dlsym» не нужна, потому что взаимодействие идёт через классы-"
"потомки."

#. type: Title ====
#: manual/tech/plugins/files.txt:31
#, no-wrap
msgid "Microsoft-Windows Interface"
msgstr "Интерфейс к Microsoft-Windows"

#. type: Plain text
#: manual/tech/plugins/files.txt:34
msgid ""
"Microsoft-Windows does not support the needed POSIX system calls directly, "
"so a set of wrapper functions is used.  The MS functions are \"LoadLibrary"
"\", \"FreeLibrary\", and \"GetLastError\".  These wrapper functions are "
"defined in \"md.h\"."
msgstr ""
"Microsoft-Windows не поддерживает необходимые системные вызовы POSIX "
"напрямую, поэтому используется набор функций-обёрток. Функции MS это "
"«LoadLibrary», «FreeLibrary» и «GetLastError».  Эти обёрточные функции "
"определены в «md.h»."

#. type: Title ====
#: manual/tech/plugins/files.txt:35
#, no-wrap
msgid "Namespaces"
msgstr "Пространства имён"

#. type: Plain text
#: manual/tech/plugins/files.txt:38
msgid ""
"Normally, each plugin has its own namespace, so its symbols are not visible "
"to the main program or to other plugins."
msgstr ""
"Обычно для каждого плагина используется своё собственное пространство имён, "
"поэтому его символы невидимы для основной программы или для других плагинов."

#. type: Plain text
#: manual/tech/plugins/files.txt:40
msgid ""
"If it is desired to make the symbols visible outside, you can load with the "
"\"public\" option.  This is not recommended for released code and likely to "
"not work with non-POSIX systems.  It is provided as a debugging aid."
msgstr ""
"Если желательно сделать символы видимыми извне, плагины можно загружать с "
"опцией «public». Это не рекомендуется для кода вышедших версий и, вероятно, "
"не будет работать на не-POSIX системах. Это предусмотрено для облегчения "
"отладки."

#. type: Title ====
#: manual/tech/plugins/files.txt:41
#, no-wrap
msgid "Static linking"
msgstr "Статическое связывание"

#. type: Plain text
#: manual/tech/plugins/files.txt:44
msgid ""
"In some cases it is desirable to static link code modules that are designed "
"as plugins.  Usually, all that is needed is to add the file to the list."
msgstr ""
"В некоторых случаях для модулей кода, которые разрабатываются в виде "
"плагинов, желательно использовать статическое связывание. Обычно всё, что "
"нужно, это добавить файл в список."

#. type: Plain text
#: manual/tech/plugins/files.txt:45
msgid ""
"There may be a problem with name clashes, because static linked modules "
"share the main program's namespace.  If a plugin has only one source file, "
"you can enclose all of the code in an anonymous namespace to avoid name "
"clashes."
msgstr ""
"Могут быть проблемы с конфликтами имён, потому что статически связанные "
"модули совместно используют пространство имён основной программы. Если "
"плагин имеет только один файл исходного кода, то во избежание конфликтов "
"имён весь этот код можно заключить в анонимном пространстве имён."

#. type: Title ======
#: manual/tech/plugins/parameter_functions_and_measurements.txt:1
#, no-wrap
msgid "Parameter function and measurement plugins"
msgstr "Плагины функции «parameter» и измерений"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:6
msgid ""
"The \"measure\" command and \"parameter\" commands work differently because "
"of parsing problems.  This is will be fixed someday."
msgstr ""
"Команды [[gnucap:manual:commands:measure.ru|measure]] и [[gnucap:manual:"
"commands:parameter.ru|parameter]] работают по-разному из-за проблем "
"синтаксического анализа. Когда-нибудь это будет исправлено."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:8
msgid ""
"One important difference is that the \"measure\" command fully evaluates the "
"function call, and any expressions associated with it, at the time of the "
"command, but the \"parameter\" command defers evaluation to when the "
"parameter is actually used."
msgstr ""
"Одно важное различие состоит в том, что команда [[gnucap:manual:commands:"
"measure.ru|measure]] производит полную оценку вызова функции и любых "
"относящихся к нему выражений в момент появления этой команды, в то время как "
"команда [[gnucap:manual:commands:parameter.ru|parameter]] откладывает "
"вычисления до того момента, когда параметр будет использоваться на самом "
"деле."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:12
msgid ""
"The \"measure\" command calls a single function for evaluation, and assigns "
"its result to a parameter.  It also prints the result.  The parameter may be "
"used in parameter expressions and as an argument to another measure command."
msgstr ""
"Команда измерения [[gnucap:manual:commands:measure.ru|measure]] вызывает "
"одиночную функцию для вычисления значения выражения и присваивает её "
"результат параметру, а также выводит результат на экран. Указанный параметр "
"может использоваться в [[gnucap:manual:howto:expressions.ru|выражениях с "
"параметрами]] и как аргумент для другой команды [[gnucap:manual:commands:"
"measure.ru|measure]]."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:14
msgid ""
"The command takes the form of an assignment statement.  The target name is "
"stashed.  The name of the function is looked up in the \"function_dispatcher"
"\", using the subscript operator. The dispatcher returns a pointer to a "
"static object, or a NULL pointer if there is no match."
msgstr ""
"Эта команда принимает форму выражения присваивания. Целевое имя сохраняется "
"для будущего использования. Имя функции ищется с помощью операции "
"индексирования в диспетчере функций («function_dispatcher»). Диспетчер "
"возвращает указатель на статический объект или NULL, если соответствия не "
"найдено."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:16
msgid ""
"Then, the method \"eval\" is invoked on this object, passing first the "
"command string, with the index advanced to the argument list, and the "
"current “scope” so parameter expressions can be evaluated correctly. If "
"\"eval\" returns, it is assumed to have correctly done what was requested. "
"If something is wrong, it may throw an exception.  \"eval\" returns a //"
"string// containing the result, which is a string representation of the "
"numeric value."
msgstr ""
"Затем для этого объекта вызывается метод «eval», передающий сначала строку "
"команды с индексом, перенесённым на список аргументов, и текущим контекстом "
"(«Scope»), поэтому значения выражений параметров могут быть правильно "
"вычислены. Если метод «eval» возвращает значение, считается, что он "
"правильно выполнил запрошенное действие. Если что-то пойдёт не так, он может "
"выдать сигнал исключения. «eval» возвращает результат, представляющий "
"числовое значение в строковом виде (//string//)."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:20
msgid ""
"The \"parameter\" command simply reads and stores the arguments as a string."
msgstr ""
"Команда [[gnucap:manual:commands:parameter.ru|parameter]] просто читает и "
"сохраняет аргументы в виде строки."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:22
msgid ""
"Later, when the parameter is used, the string is evaluated, resulting in a "
"reduced version of the expression, also as a string.  Portions that cannot "
"be evaluated are preserved as expressions."
msgstr ""
"Позже, когда указанный параметр используется, производится вычисление "
"значения этой строки, что в итоге даёт уменьшенную версию выражения, также в "
"строковом представлении. Части, которые невозможно вычислить, сохраняются в "
"виде выражений."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:24
msgid ""
"As with the \"measure\", the entire argument list is passed as a \"CS\".  "
"The scope will be the scope in which the parameter is used (dynamic scoping)."
msgstr ""
"Как и для [[gnucap:manual:commands:measure.ru|measure]], весь список "
"аргументов передаётся как объект «[[commands.ru|CS]]». Контекст будет тот, в "
"котором этот параметр используется (динамический контекст)."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:27
msgid ""
"Usually, plugins need to include two files: \"u_parameter.h\" and "
"\"u_function.h\"."
msgstr ""
"Обычно, плагины должны подключать два файла: «u_parameter.h» и «u_function."
"h»."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:29
msgid ""
"Only one method is needed for each command: \"''eval(CS& Cmd, CARD_LIST* "
"Scope)''\"."
msgstr ""
"Только один метод нужен для каждой команды: «''eval(CS& Cmd, CARD_LIST* "
"Scope)''»."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:33
msgid ""
"Parameter functions use the \"function_dispatcher\".  Measure functions use "
"the \"measure_dispatcher\"."
msgstr ""
"Функции команды [[gnucap:manual:commands:parameter.ru|parameter]] используют "
"«function_dispatcher».  Функции [[gnucap:manual:commands:measure.ru|"
"измерений]] используют «measure_dispatcher»."

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:34
#, no-wrap
msgid "Parameter functions"
msgstr "Функции команды «parameter»"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:37
msgid ""
"The argument list is usually a list of expressions separated by commas, "
"similar to many programming languages."
msgstr ""
"Список аргументов это обычно список выражений, разделённых запятыми, как во "
"многих языках программирования."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:39
msgid "A simple function with one argument:"
msgstr "Простая функция с одним аргументом:"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:42
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"\n"
"#include \"u_function.h\"\n"
msgstr ""
"<code>\n"
"#include \"u_parameter.h\"\n"
"#include \"u_function.h\"\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:55
#, no-wrap
msgid ""
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x;\n"
"    Cmd >> x;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::abs(x));\n"
"  }\n"
"} p_abs;\n"
"DISPATCHER<FUNCTION>::INSTALL d_abs(&function_dispatcher, \"abs\", &p_abs);\n"
"</code>\n"
msgstr ""
"class abs : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x;\n"
"    Cmd >> x;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::abs(x));\n"
"  }\n"
"} p_abs;\n"
"DISPATCHER<FUNCTION>::INSTALL d_abs(&function_dispatcher, \"abs\", &p_abs);\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:57
msgid "A function with two arguments:"
msgstr "Функция с двумя аргументами:"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid ""
"<code>\n"
"class pow : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x, y;\n"
"    Cmd >> x >> y;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    y.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::pow(x,y));\n"
"  }\n"
"} p_pow;\n"
"DISPATCHER<FUNCTION>::INSTALL d_pow(&function_dispatcher, \"pow\", &p_pow);\n"
"</code>\n"
msgstr ""
"<code>\n"
"class pow : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    PARAMETER<double> x, y;\n"
"    Cmd >> x >> y;\n"
"    x.e_val(NOT_INPUT, Scope);\n"
"    y.e_val(NOT_INPUT, Scope);\n"
"    return to_string(std::pow(x,y));\n"
"  }\n"
"} p_pow;\n"
"DISPATCHER<FUNCTION>::INSTALL d_pow(&function_dispatcher, \"pow\", &p_pow);\n"
"</code>\n"

#. type: Title ====
#: manual/tech/plugins/parameter_functions_and_measurements.txt:71
#, no-wrap
msgid "Measurement functions"
msgstr "Функции измерений"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:74
msgid ""
"Measurement functions appear to be the same as parameter functions, but are "
"not interchangeable."
msgstr ""
"Функции [[gnucap:manual:commands:measure.ru|измерений]] и функции команды "
"[[gnucap:manual:commands:parameter.ru|parameter]] кажутся одинаковыми, но "
"они не взаимозаменяемы."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:76
msgid "Usually, the following additional includes are needed:"
msgstr "Обычно необходимы следующие дополнительные «include»:"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:83
#, no-wrap
msgid ""
"<code>\n"
"#include \"u_parameter.h\"  // parameter expressions\n"
"#include \"s__.h\"          // find the wave object\n"
"#include \"m_wave.h\"       // the \"wave\" object, containing the data to measure\n"
"#include \"u_function.h\"   // the base class\n"
"</code>\n"
msgstr ""
"<code>\n"
"#include \"u_parameter.h\"  // выражения с параметрами\n"
"#include \"s__.h\"          // найти объект «сигнал»\n"
"#include \"m_wave.h\"       // объект «сигнал» содержащий данные, которые требуется измерить\n"
"#include \"u_function.h\"   // основной класс\n"
"</code>\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:85
msgid ""
"Parameters are usually given as optional name=value pairs, with expressions, "
"in any order."
msgstr ""
"Параметры обычно задаются в виде необязательных пар «имя=значение» с "
"произвольным порядком выражений."

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:96
#, no-wrap
msgid ""
"<code>\n"
"class MEASURE : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    std::string probe_name;\n"
"    PARAMETER<double> before(BIGBIG);\n"
"    PARAMETER<double> after(-BIGBIG);\n"
"    bool last = false;\n"
"    bool arg = false;\n"
msgstr ""
"<code>\n"
"class MEASURE : public FUNCTION {\n"
"public:\n"
"  std::string eval(CS& Cmd, CARD_LIST* Scope)const\n"
"  {\n"
"    std::string probe_name;\n"
"    PARAMETER<double> before(BIGBIG);\n"
"    PARAMETER<double> after(-BIGBIG);\n"
"    bool last = false;\n"
"    bool arg = false;\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:105
#, no-wrap
msgid ""
"    unsigned here = Cmd.cursor();\n"
"    Cmd >> probe_name;\n"
"    WAVE* w = SIM::find_wave(probe_name);  // this is the wave to scan for the measurement\n"
"                                           // specified first, without saying \"probe=\"\n"
"    if (!w) { // didn't find it\n"
"      Cmd.reset(here);\n"
"    }else{\n"
"    }\n"
msgstr ""
"    unsigned here = Cmd.cursor();\n"
"    Cmd >> probe_name;\n"
"    WAVE* w = SIM::find_wave(probe_name);  // это сигнал, который должен сканироваться для измерения,\n"
"                                           // указанного первым, без задания \"probe=\"\n"
"    if (!w) { // не нашёл его\n"
"      Cmd.reset(here);\n"
"    }else{\n"
"    }\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:119
#, no-wrap
msgid ""
"    here = Cmd.cursor();                   // scan for parameters\n"
"    do {\n"
"      ONE_OF\n"
"\t|| Get(Cmd, \"probe\",  &probe_name)\n"
"\t|| Get(Cmd, \"before\", &before)\n"
"\t|| Get(Cmd, \"after\",  &after)\n"
"\t|| Get(Cmd, \"end\",    &before)\n"
"\t|| Get(Cmd, \"begin\",  &after)\n"
"\t|| Set(Cmd, \"arg\",    &arg, true)\n"
"\t|| Set(Cmd, \"last\",   &last, true)\n"
"\t|| Set(Cmd, \"first\",  &last, false)\n"
"\t;\n"
"    }while (Cmd.more() && !Cmd.stuck(&here));\n"
msgstr ""
"    here = Cmd.cursor();                   // сканирование параметров\n"
"    do {\n"
"      ONE_OF\n"
"\t|| Get(Cmd, \"probe\",  &probe_name)\n"
"\t|| Get(Cmd, \"before\", &before)\n"
"\t|| Get(Cmd, \"after\",  &after)\n"
"\t|| Get(Cmd, \"end\",    &before)\n"
"\t|| Get(Cmd, \"begin\",  &after)\n"
"\t|| Set(Cmd, \"arg\",    &arg, true)\n"
"\t|| Set(Cmd, \"last\",   &last, true)\n"
"\t|| Set(Cmd, \"first\",  &last, false)\n"
"\t;\n"
"    }while (Cmd.more() && !Cmd.stuck(&here));\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:124
#, no-wrap
msgid ""
"    if (!w) {                               // \"probe=\" .. the wave to scan\n"
"      w = SIM::find_wave(probe_name);\n"
"    }else{\n"
"    }\n"
msgstr ""
"    if (!w) {                               // \"probe=\" - сигнал для сканирования\n"
"      w = SIM::find_wave(probe_name);\n"
"    }else{\n"
"    }\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:128
#, no-wrap
msgid ""
"    if (w) {\n"
"      before.e_val(BIGBIG, Scope);          // evaluate parameters\n"
"      after.e_val(-BIGBIG, Scope);\n"
msgstr ""
"    if (w) {\n"
"      before.e_val(BIGBIG, Scope);          // вычисление значений параметров\n"
"      after.e_val(-BIGBIG, Scope);\n"

#. type: Plain text
#: manual/tech/plugins/parameter_functions_and_measurements.txt:149
#, no-wrap
msgid ""
"      // find the min.\n"
"      double time = (last) ? -BIGBIG : BIGBIG;  // what to return if there's no min.\n"
"      double m = BIGBIG;\n"
"      WAVE::const_iterator begin = lower_bound(w->begin(), w->end(), DPAIR(after, -BIGBIG));\n"
"      WAVE::const_iterator end   = upper_bound(w->begin(), w->end(), DPAIR(before, BIGBIG));\n"
"      for (WAVE::const_iterator i = begin; i < end; ++i) {\n"
"\tdouble val = i->second;\n"
"\tif (val < m || (last && (val == m))) {\n"
"\t  time = i->first;\n"
"\t  m = val;\n"
"\t}else{\n"
"\t}\n"
"      }\n"
"      return to_string((arg) ? (time) : (m));\n"
"    }else{\n"
"      throw Exception_No_Match(probe_name);\n"
"    }\n"
"  }\n"
"} p2;\n"
"DISPATCHER<FUNCTION>::INSTALL d2(&measure_dispatcher, \"min\", &p2);\n"
"</code>\n"
msgstr ""
"      // определение минимума\n"
"      double time = (last) ? -BIGBIG : BIGBIG;  // что возвратить, если минимума нет.\n"
"      double m = BIGBIG;\n"
"      WAVE::const_iterator begin = lower_bound(w->begin(), w->end(), DPAIR(after, -BIGBIG));\n"
"      WAVE::const_iterator end   = upper_bound(w->begin(), w->end(), DPAIR(before, BIGBIG));\n"
"      for (WAVE::const_iterator i = begin; i < end; ++i) {\n"
"\tdouble val = i->second;\n"
"\tif (val < m || (last && (val == m))) {\n"
"\t  time = i->first;\n"
"\t  m = val;\n"
"\t}else{\n"
"\t}\n"
"      }\n"
"      return to_string((arg) ? (time) : (m));\n"
"    }else{\n"
"      throw Exception_No_Match(probe_name);\n"
"    }\n"
"  }\n"
"} p2;\n"
"DISPATCHER<FUNCTION>::INSTALL d2(&measure_dispatcher, \"min\", &p2);\n"
"</code>\n"

#. type: Title ======
#: about.txt:1
#, no-wrap
msgid "About Gnucap"
msgstr ""

#. type: Plain text
#: about.txt:4
msgid ""
"Gnucap is a modern \"post-spice\" analog and mixed signal circuit simulator."
msgstr ""

#. type: Plain text
#: about.txt:6
msgid ""
"Gnucap is designed so it can eventually replace Spice.  Today, it can "
"replace Spice in some applications.  There are some significant technical "
"advantages.  It is a work in progress.  New features are added regularly as "
"time and demand permits."
msgstr ""

#. type: Plain text
#: about.txt:23
#, no-wrap
msgid ""
"  * [[gnucap:about:plugins|Plugins, for extreme flexibility.]]\n"
"    * [[gnucap:about:plugins:models|Models.]]\n"
"    * [[gnucap:about:plugins:commands|Commands.]]\n"
"    * [[gnucap:about:plugins:methods|Simulation methods.]]\n"
"    * [[gnucap:about:plugins:functions|Behavioral modeling functions.]]\n"
"    * [[gnucap:about:plugins:measurements|Measurements]]\n"
"    * [[gnucap:about:plugins:interface|Interface to other software.]]\n"
"    * [[gnucap:about:plugins:languages|Simulation languages and compatibility]]\n"
"    * [[gnucap:about:plugins:other:|Almost anything.]]\n"
"  * [[gnucap:about:algorithms|Modern algorithms]]\n"
"    * true mixed-mode engine, analog events, the essence of modern \"fast-spice\" simulators.\n"
"    * Improved speed with full Spice accuracy.\n"
"    * Improved accuracy through rigorous error control.\n"
"    * User control of speed vs. accuracy tradeoffs.\n"
"  * Fully interactive operation with scripting.\n"
"  * Parameters, measures.\n"
"  * Multiple simulation languages, including Spice, Verilog, and Spectre.  More are coming!\n"
msgstr ""

#. type: Title ======
#: about/algorithms.txt:1
#, no-wrap
msgid "Algorithms"
msgstr "Алгоритмы"

#. type: Plain text
#: about/algorithms.txt:4
msgid "Gnucap is the original \"Analog Fast-Spice\"."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:6
msgid ""
"Gnucap's DC, AC, and Transient analysis are based on the traditional nodal "
"analysis, similar to Spice.  As a starting point, this provides the same "
"accuracy and generality we associate with Spice-type simulation.  From this "
"well-known starting point, Gnucap has enhanced the algorithms, for improved "
"speed, accuracy, and robustness, with user defined options to select what "
"tradeoffs to apply when."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:8
msgid ""
"Gnucap uses a vector sparse matrix solver that supports low rank updates and "
"partial solutions.  For large circuits this can be significantly faster than "
"a traditional sparse matrix solver.  The vector approach provides fast "
"access, as fast as a regular dense matrix would be, while preserving cache "
"localism that you would not ordinarily get with a general sparse solver.  "
"For a full, dense matrix, it is as efficient as a full matrix solver.  For a "
"tridiagonal matrix, it is as efficient as a dedicated tridiagonal solver."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:10
msgid ""
"For a large circuit, only the parts of the circuit where there is activity "
"are solved.  It is now possible to avoid redundant processing linear and "
"latent parts of a circuit.  This improves speed significantly with no loss "
"of accuracy.  This is part of the basis of most of today's \"fast-spice\" "
"simulators, and was made available first here."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:12
msgid ""
"Transient time step control checks more than just truncation error and "
"iteration count.  There are additional checks for smoothness of most "
"voltages and state variables, even where there are no storage elements.  "
"There is also support for movable events, such as \"cross\" events, so "
"switching times, zero crossings, and waveform peaks are properly controlled."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:14
msgid ""
"This is managed by a set of queues, so time is not wasted processing devices "
"when there is nothing happening."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:16
msgid ""
"All of this is user controllable.  By setting some options, on one extreme "
"you can turn off the optimizations, reverting to a more robust (and slower) "
"derivative of the Spice algorithms, or you can choose to go for speed."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:18
msgid ""
"The core provides a library of functions that can be used to build new types "
"of analysis.  The matrix solver is a template class, so it can solve for all "
"data types, including a symbolic type for a future symbolic analysis."
msgstr ""

#. type: Plain text
#: about/algorithms.txt:20
msgid "Finally, it is all plugin based, inviting extensions and experiments."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:5 about/plugins/languages.txt:5
#: about/plugins/measurements.txt:5 about/plugins/methods.txt:5
#: about/plugins/models.txt:4
#, no-wrap
msgid "The past"
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:8
msgid ""
"Traditional simulators have most of the commands built-in, so you are stuck "
"with the commands you have. Most of them do have some kind of alias "
"mechanism, but that is all.  If you want to add real functionality, you "
"can't."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:9 about/plugins/languages.txt:13
#: about/plugins/measurements.txt:9 about/plugins/methods.txt:11
#: about/plugins/models.txt:10
#, no-wrap
msgid "The present"
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:12
msgid ""
"Unlike Spice, commands are not compiled into the simulator. Commands, all "
"commands, are plugins that can be changed by a user at run time."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:14
msgid ""
"It is possible to static-link commands if desired, but it is not recommended."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:16
msgid ""
"The distribution tarball includes most of the basic “Spice” commands, and "
"some non-basic ones."
msgstr ""

#. type: Title ====
#: about/plugins/commands.txt:17 about/plugins/languages.txt:17
#: about/plugins/measurements.txt:13 about/plugins/methods.txt:15
#: about/plugins/models.txt:28
#, no-wrap
msgid "The future"
msgstr "Будущее"

#. type: Plain text
#: about/plugins/commands.txt:20
msgid ""
"There could be wrapper plugins, so you can use other languages like Python "
"or TCL to write commands."
msgstr ""

#. type: Plain text
#: about/plugins/commands.txt:22
msgid "More commands will be added to the standard set."
msgstr ""

#. type: Title =====
#: about/plugins/languages.txt:3
#, no-wrap
msgid "Simulation languages and compatibility"
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:8
msgid ""
"The most popular simulator, and most popular circuit simulation language is "
"\"SPICE\"."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:10
msgid ""
"The SPICE format was a breakthrough when it was invented, in the 1970's, but "
"we have outgrown it."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:12
msgid ""
"The SPICE format has been extended, in many ways, by both commercial and "
"free simulators.  Each one is a little different. Until recently, Gnucap "
"used only an extended version of the SPICE format.  There is an ongoing "
"problem with tradeoffs between compatibility and growth.  It seems that they "
"are all different, and every extension breaks something."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:16
msgid ""
"Gnucap now uses \"language plugins\" to determine the source language.  Of "
"course, the traditional SPICE format is supported.  There are also plugins "
"to support netlists in Spectre and Verilog format."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:20
msgid ""
"Since the language is a plugin, there can be several to mimic the variants.  "
"It is no longer necessary to trade between compatibility and growth.  There "
"could easily be a dozen \"SPICE\" plugins, each compatible with a different "
"version."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:22
msgid ""
"New languages can be added too, including direct support for the internal "
"format of schematic capture and layout programs."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:24
msgid ""
"The plugins can also add commands, so it should be possible to make exact "
"compatibility with any other simulator."
msgstr ""

#. type: Plain text
#: about/plugins/languages.txt:26
msgid ""
"There are plans for the future to make the output pluggable too.  This will "
"enable a choice of output formats, and tight integration with other tools "
"for post-processing.  It could also make it possible for the output to mimic "
"another simulator."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:8
msgid ""
"The ability to make generalized post-measurements has been available in "
"expensive commercial simulators for a long time.  Any simulator can tell you "
"voltages and currents.  The ability to easily measure things like slew rate "
"and rise time has not been so easy in the free simulators."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:12
msgid ""
"A measure command (a plugin) can make post-measurements, interactively or "
"scripted.  Measurements like crossing time, rise time, slew rate, and "
"overshoot are available.  These are all plugins, so you can add your own "
"when you need to.  They set parameters, so you can use the results in "
"expressions to make more complex measurements, or to automatically change "
"component values or command parameters."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:16
msgid ""
"Proposed improvements in scripting will enable you to write your own more "
"complicated measurements, an optimizer, or even what seems like new analysis "
"methods."
msgstr ""

#. type: Plain text
#: about/plugins/measurements.txt:18
msgid ""
"It is also possible to write wrappers for the measurements that are provided "
"to add others, or for compatibility with the other simulators."
msgstr ""

#. type: Title =====
#: about/plugins/methods.txt:3
#, no-wrap
msgid "Simulation methods"
msgstr "Методы моделирования"

#. type: Plain text
#: about/plugins/methods.txt:8
msgid ""
"The most popular simulation methods are based on nodal analysis, which is "
"taught in every undergraduate EE program.  The basic AC, DC, and transient "
"analysis are well known."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:10
msgid ""
"Other methods are usually available only in specialized simulators.  There "
"are some special purpose academic simulators.  There are lots more expensive "
"commercial simulators."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:14
msgid ""
"Gnucap supports the traditional Spice methods, plus or minus a little.  On "
"the plus side, the transient analysis is event driven and uses some "
"technique that can give you significant speedup.  On the minus side, Gnucap "
"is missing some methods that are important, such as noise."
msgstr ""

#. type: Plain text
#: about/plugins/methods.txt:18
msgid ""
"With plugins, there is a place for the missing modes to be added.  Anyone "
"can contribute.  Works in progress can be shared, because it is your choice "
"whether to use the extension or not."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:7
msgid ""
"Traditional simulators have most of the models built-in, so you are stuck "
"with the models you have.  Most of them do have macros, and all of them have "
"subcircuits.  Some commercial simulators have more, but with the free "
"simulators, you need to dig in and recompile."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:9
msgid "Gnucap draws on the knowledge of Spice, and moves on."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:14
msgid ""
"Unlike Spice, models are not compiled into the simulator.  Models, all "
"models, are plugins that can be changed by a user at run time."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:16
msgid ""
"It is possible to static-link models if desired, but it is not recommended."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:18
msgid ""
"The distribution tarball includes most of the basic \"Spice\" models, "
"including the simple devices (resistors, sources, transistors)."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:20
msgid ""
"There is a wrapper \"spice-wrapper.cc\" that allows the use of unmodified "
"Spice C models.  You need a simple configuration file with each Spice "
"model.  There are just a few lines to configure.  It can usually be done in "
"just a few minutes."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:22
msgid ""
"Models written for several versions of Spice are supported directly.  As of "
"when this is written, there is direct support for Berkeley 3e, Berkeley 3f, "
"and NGspice 17, and Jspice 3-2.5.  Other versions may also work, but have "
"not been tested."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:24
msgid ""
"With the real Spice, you need to modify the models for the particular "
"version of Spice you have.  Also, with the real Spice, you need to change "
"some names to avoid name clashes.  In Gnucap, you don't need to do either.  "
"All of the mentioned formats are supported directly and can co-exist.  The "
"plugin system puts each model in its own namespace, so duplicate names are "
"not a problem."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:26
msgid ""
"There is a model compiler \"gnucap-modelgen\" which accepts a high-level "
"description of a model.  This is backward compatible with old versions of "
"gnucap."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:28
msgid ""
"You can also use the \"ADMS\" model compiler, to generate a Spice model, "
"then use spice-wrapper to use it with gnucap."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:31
msgid "There is work in progress to use Icarus Verilog as the model compiler."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:33
msgid ""
"There are plans to make a modified version of ADMS that generates efficient "
"Gnucap code that can be used directly."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:35
msgid ""
"There are plans to improve the plugin attachment procedure so you will be "
"able to develop and debug compiled models interactively."
msgstr ""

#. type: Plain text
#: about/plugins/models.txt:36
msgid ""
"There could be wrapper plugins, so you can use other tools like octave and "
"\"R\" to write models."
msgstr ""

#. type: Plain text
#: about/plugins.txt:4
msgid ""
"Gnucap is designed to use a light-weight, portable core that provides an "
"environment to which new features can be added as \"plugins\" which are "
"supported separately from the main simulator.  These plugins can be loaded "
"and unloaded at run time if desired.  Most plugins can also be \"static "
"linked\" if desired, giving the appearance of a traditional single "
"executable program that will run on relatively primitive systems."
msgstr ""

#. type: Plain text
#: about/plugins.txt:6
msgid ""
"Since plugins can be loaded at run time, it is possible to have the main "
"program, and a standard set of libraries and plugins, installed and managed "
"on a network, or by the system administrator, and provide a way for each "
"user to add custom features including models."
msgstr ""

#. type: Plain text
#: about/plugins.txt:8
msgid ""
"In the usual configuration, a set of plugins is loaded automatically, giving "
"the capability expected of a Spice-like simulator, with some enhancements."
msgstr ""

#. type: Plain text
#: about/plugins.txt:10
msgid ""
"Plugins are standard compiled shared object modules, usually \".so\" or \"."
"dll\" files.  The source of plugins is portable across platforms, but the "
"compiled code must be compiled for the specific system."
msgstr ""

#. type: Plain text
#: about/plugins.txt:12
msgid ""
"At the lowest level, plugins are written in C++ and compiled.  There will be "
"tools to support other languages, using preprocessors, wrappers, or both.  "
"They can be added at any time, without recompiling the simulator core."
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:models|Models.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:commands|Commands.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:methods|Simulation methods.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:functions|Behavioral modeling functions.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:measurements|Measurements]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:interface|Interface to other software.]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:languages|Simulation languages and compatibility]]\n"
msgstr ""

#. type: Bullet: '  * '
#: about/plugins.txt:21
#, no-wrap
msgid "[[gnucap:about:plugins:other:|Almost anything.]]\n"
msgstr ""

#. type: Plain text
#: manual/devices/inductor.txt:1
msgid "L"
msgstr ""

#. type: Title =====
#: manual/examples/noise_syntax.txt:1
#, no-wrap
msgid "Noise Syntax"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:4
msgid ""
"//This section contains descriptions which are not implemented yet in "
"simualtor. Work is in progress.//"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:6
msgid "Spice .noise command syntax is implemented:"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:8
msgid "''.noise V(<N1>[,<N2>]) <VIN> <ac_description>''"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<N1>, <N2> - output node numbers, if N2 is omited ground is implied;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<VIN> - input AC source at which noise power will be calculated;\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:12
#, no-wrap
msgid "<ac_description>  - gnucap AC simulation statement.\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:14
msgid "Here are some examples:"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:16
#, no-wrap
msgid "''.noise V(6) Vin dec 10 20 20k''\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:19
msgid ""
"- noise at node 6 w.r.t. ground, calculated to **Vin**, noise power densinty "
"will be calculated using **10** points per **dec**ade (logarithmic scale) in "
"frequency range from **20Hz** to **20KHz**"
msgstr ""

#. type: Bullet: '  * '
#: manual/examples/noise_syntax.txt:22
#, no-wrap
msgid "''.noise V(6,3) VSRC oct 2 10 10k''\n"
msgstr ""

#. type: Plain text
#: manual/examples/noise_syntax.txt:24
msgid ""
"- noise between nodes 6 and 3, calculated to **VSRC**, noise power densinty "
"will be calculated using **2** points per **oct**ave (logarithmic scale) in "
"frequency range from **10Hz** to **10kHz**"
msgstr ""

#. type: Title =====
#: manual/howto/measurements.txt:1
#, no-wrap
msgid "Measures"
msgstr ""

#. type: Plain text
#: manual/howto/measurements.txt:13
#, no-wrap
msgid ""
"|[[gnucap:manual:measure:at]]     |The value of a wave at a point, or its derivative.  |\n"
"|[[gnucap:manual:measure:mean|average]]\\\\ [[gnucap:manual:measure:mean]]              |Average or mean value.  |\n"
"|[[gnucap:manual:measure:cross]]  |Find crossings.  |\n"
"|[[gnucap:manual:measure:integrate]]\\\\ [[gnucap:manual:measure:integrate|area]]  |The area under the curve.  |\n"
"|[[gnucap:manual:measure:max]]    |Maximum value, or its point.  |\n"
"|[[gnucap:manual:measure:min]]    |Minimum value, or its point.  |\n"
"|[[gnucap:manual:measure:rms]]    |The RMS value.  |\n"
"|[[gnucap:manual:measure:slope|slewrate]]\\\\ [[gnucap:manual:measure:slope]]\\\\ [[gnucap:manual:measure:slope|ddt]]  |Slew rate or slope.  |\n"
msgstr ""

#. type: Title ======
#: manual/measure/integrate.txt:1
#, no-wrap
msgid "\"integrate\" measure"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:6
msgid "Find the integral of a waveform, the area under the curve."
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:10
#, no-wrap
msgid "  integrate(probe=\"p(d)\"  begin=time  end=time)\n"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:17
#, no-wrap
msgid ""
"^arg name  ^default     ^description  ^\n"
"|probe     |required    |The name of a probe to measure.  |\n"
"|begin     |- infinity  |Start averaging at this time or frequency.  |\n"
"|end       |+ infinity  |Stop averaging at this time or frequency.  |\n"
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:21
msgid ""
"This measure gives you the integral, or area under the curve, signed.  The "
"integral of a sine over a full cycle is zero."
msgstr ""

#. type: Plain text
#: manual/measure/integrate.txt:29
#, no-wrap
msgid ""
"  measure sample = integrate(probe=\"v(out)\" begin=4u end=6u)\n"
"Find the mean value of v(out) between 4 microseconds and 6 microseconds.\n"
"  measure sample = integrate(probe=\"v(out)\")\n"
"Find the mean value of v(out) for an entire run.\n"
"  measure sample = integrate(probe=\"v(out)\" begin=4u)\n"
"Find the mean value of v(out) starting at 4 microseconds, to the end.\n"
msgstr ""

#. type: Plain text
#: manual/rr.txt:1
msgid "RR"
msgstr ""

#. type: Title ====
#: manual/tech/code_coverage_testing.txt:1
#, no-wrap
msgid "Code coverage testing"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:4
msgid ""
"To assist in testing the following procedure is used.  This is a semi-"
"automated procedure, intended to assist in developing a test suite that "
"fully tests the code, and to guide the developer in a code review."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:6
msgid ""
"This procedure uses the ''untested()'' macro as a marker to indicate what "
"has been tested and not.  It is performed on each source file."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:24
#, no-wrap
msgid ""
"  - With an editor:\n"
"    - Replace all ''{'' with ''{untested();''.\n"
"    - Replace all '':'' in switch statements with '':untested();''\n"
"    - If there are any code blocks without curlys, manually insert the untested() calls.\n"
"    - Be sure to cover all cases in switch statements, and all branches of an ''if'' statement, including empty branches.\n"
"    - If it is possible to have zero passes through a loop, that case must also be tested.\n"
"    - If there are ?: or similar operators, both options must be tested.\n"
"    - Multiple paths due to #if and other preprocessor directives must also be tested on the same level.\n"
"  - Recompile, with debug enabled so the untested statements will print when run.\n"
"  - Run gnucap on the test input files.\n"
"  - Wherever you see the output from ''untested()'' (file, line, function)\n"
"    - Look at the results to verify that they are correct.\n"
"    - Look at the code to verify that it is clean and correct.\n"
"    - Remove that particular ''untested()'' call.\n"
"    - Go back to step 2.\n"
"  - Stop when you don't see any more file-line-function in the output.\n"
"  - Look at the code to see what ''untested()'' calls remain.  This indicates code that is not tested by the test files.  If this is new code, you need to create more tests to cover that code.\n"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:26
msgid ""
"When done, put a comment in the code just below the header block to indicate "
"the status:"
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:29
msgid ""
"==//testing=script 2012.12.12== This procedure was done on that date.  Some "
"''untested'' remains."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:32
msgid ""
"==//testing=script,complete 2012.12.12== This procedure was done on that "
"date.  No ''untested'' remains.  Test suite provides 100% coverage."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:35
msgid ""
"==//testing=script,sparse 2012.12.12== This procedure was done on that "
"date.  Many ''untested'' remains.  Test suite is clearly inadequate here."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:38
msgid ""
"==//testing=obsolete 2012.12.12== This procedure was done on that date.  "
"Changes have been made to the code since that date, but the procedure was "
"not repeated.  Additional testing is needed."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:41
msgid ""
"==//testing=trivial 2012.12.12== This procedure was done on that date, but "
"there is nothing to see because the file contains no executable code.  The "
"file is probably a header file."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:43
msgid ""
"The absence of the //testing comment is taken to mean that no testing or "
"only informal testing was done, so that file is considered to be still in "
"development, not ready for release."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:45
msgid ""
"If changes are made after the indicated test date, the procedure was done "
"partially on only the new code meeting the indicated test level, do not "
"change the date.  Only change the date when the full procedure is done again."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:47
msgid ""
"For new code, the \"script,complete\" level is expected in most cases, but "
"admittedly there are some cases where exception handling cannot be tested "
"completely."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:49
msgid ""
"For old code with changes, possibly done before this procedure was "
"initiated, the \"script\" level is acceptable provided the few remaining "
"blocks are marked as untested() or itested() and well understood.  itested() "
"means that it is known that it was tested, the untested message was seen, "
"but it is not in the regression suite."
msgstr ""

#. type: Plain text
#: manual/tech/code_coverage_testing.txt:51
msgid ""
"The details here assume C++ code.  For other source languages, an equivalent "
"level of testing is expected."
msgstr ""

#. type: Title =====
#: manual/tech/compiling.txt:1
#, no-wrap
msgid "Compiling for test"
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:4
msgid "Gnucap has two different modes for compiling."
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/compiling.txt:7
#, no-wrap
msgid "For regular users, only default compile options are used, for minimum clutter during compiling, so real problems will stand out.\n"
msgstr ""

#. type: Bullet: '  - '
#: manual/tech/compiling.txt:7
#, no-wrap
msgid "For developers, additional warnings are enabled, to catch minor issues that may lead to errors.  For code to be accepted into the main distribution (not plugins that are distributed separately) it must compile without warnings, with most compiler warnings enabled.\n"
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:9
msgid ""
"For g++, the following compile options are used to enable additional "
"warnings."
msgstr ""

#. type: Plain text
#: manual/tech/compiling.txt:18
#, no-wrap
msgid ""
"<code>\n"
"  -DUNIX  -g -O0 -I. -I../../include -DTRACE_UNTESTED \\\n"
"  -Wall -Wextra \\\n"
"  -Wswitch-enum -Wundef -Wpointer-arith -Woverloaded-virtual \\\n"
"  -Wcast-qual -Wcast-align -Wpacked -Wshadow -Wconversion \\\n"
"  -Winit-self -Wmissing-include-dirs -Winvalid-pch \\\n"
"  -Wvolatile-register-var -Wstack-protector \\\n"
"  -Wlogical-op -Wvla -Woverlength-strings -Wsign-conversion\n"
"</code>\n"
msgstr ""

#. type: Title ======
#: manual/tech/plugins/languages/args.txt:1
#: manual/tech/plugins/languages/command.txt:1
#: manual/tech/plugins/languages/comment.txt:1
#: manual/tech/plugins/languages/find_type_in_string.txt:1
#: manual/tech/plugins/languages/instance.txt:1
#: manual/tech/plugins/languages/label.txt:1
#: manual/tech/plugins/languages/lang_base.h.txt:1
#: manual/tech/plugins/languages/module.txt:1
#: manual/tech/plugins/languages/parse_top_item.txt:1
#: manual/tech/plugins/languages/ports.txt:1
#: manual/tech/plugins/languages/simple_query_functions.txt:1
#: manual/tech/plugins/languages/top_level.txt:1
#, no-wrap
msgid "Language plugins : Implementation"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/args.txt:3
#, no-wrap
msgid "parse, print args"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/args.txt:5
#: manual/tech/plugins/languages/command.txt:5
#: manual/tech/plugins/languages/comment.txt:5
#: manual/tech/plugins/languages/instance/label.txt:7
#: manual/tech/plugins/languages/instance/ports.txt:7
#: manual/tech/plugins/languages/instance.txt:5
#: manual/tech/plugins/languages/instance/type.txt:9
#: manual/tech/plugins/languages/label.txt:5
#: manual/tech/plugins/languages/module.txt:5
#: manual/tech/plugins/languages/ports.txt:5
#: manual/tech/plugins/languages/type.txt:9
#, no-wrap
msgid "Background"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:8
msgid "\"Args\" are the parameters of the device."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:10
msgid "Some languages read in args by order, some by name, some either way."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:12
msgid ""
"When reading by order, the meaning is determined by the order in the list.  "
"A single value, such as resistance of a resistor, specified as just a "
"number, is a simple case of reading by order.  There is also a special case "
"that allows you to identify one as the \"value\" and read the rest by name."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:14
#: manual/tech/plugins/languages/instance/ports.txt:20
#: manual/tech/plugins/languages/ports.txt:18
msgid ""
"The syntax varies.  Some separate by whitespace, some separate by a comma.  "
"Some may use \"name=value\".  Another may use \".name(value)\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:16
#: manual/tech/plugins/languages/instance/ports.txt:22
#: manual/tech/plugins/languages/ports.txt:20
msgid ""
"All of this must be considered in coding these functions.  Because of this, "
"we cannot say to \"usually\" use a particular function."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:18
msgid ""
"Some languages and devices use a different method \"obsolete_callback\" to "
"handle the args.  This is legacy code remaining from before there were "
"plugins.  Those will be recoded, and eventually obsolete_callback will be "
"removed.  It is not otherwise documented here."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/args.txt:19
#, no-wrap
msgid "parse_args"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:22
msgid "This functions reads the args from the input and stores the info."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:24
#: manual/tech/plugins/languages/instance/ports.txt:28
#: manual/tech/plugins/languages/ports.txt:26
msgid ""
"Here is an example from Verilog, which accepts either order dependent or "
"name=value pairs.  The whole list is enclosed in parentheses.  The port "
"names are separated by commas.  The format for a name=value pair is ''.name"
"(value)''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:26
#: manual/tech/plugins/languages/instance/ports.txt:30
#: manual/tech/plugins/languages/ports.txt:28
msgid ""
"Remember, in the CS stream class \"stream >> variable\" reads into the "
"variable, like the usual C++ iostream.  As an extension \"stream >> constant"
"\" reads and consumes only a matching constant from the stream."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:28
msgid ""
"While reading by order, the value is set by the function ''set_param_by_index"
"(index, value)''.  An exception ''Exception_Too_Many'' will be thrown if "
"there are too many.  Your code must catch the exception, and should print a "
"message, and move on."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:30
#: manual/tech/plugins/languages/args.txt:81
#, no-wrap
msgid "Due to the way hierarchy is implemented, the count is backwards.  The highest numbered parameter is first.  One way to do this is to use an index that starts at 0 and is incremented with every read, and subtract that from ''x->param_count()''.   Alternatively, you could start at ''x->param_count()-1'' and count down.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:32
msgid ""
"While reading by name, the value is set by the function ''set_param_by_name"
"(name, value)''.  An exception ''Exception_No_Match'' will be thrown if the "
"device type does not have a parameter that matches.  Your code must catch "
"the exception.  Probably it should print a message, and move on.  In some "
"cases, you may want to silently ignore invalid parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_args_instance(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:73
#, no-wrap
msgid ""
"  if (cmd >> \"#(\") {\n"
"    if (cmd.match1('.')) {\n"
"      // by name\n"
"      while (cmd >> '.') {\n"
"\tunsigned here = cmd.cursor();\n"
"\tstd::string name  = cmd.ctos(\"(\", \"\", \"\");\n"
"\tstd::string value = cmd.ctos(\",)\", \"(\", \")\");\n"
"\tcmd >> ',';\n"
"\ttry{\n"
"\t  x->set_param_by_name(name, value);\n"
"\t}catch (Exception_No_Match&) {untested();\n"
"\t  cmd.warn(bDANGER, here, x->long_label() + \": bad parameter \" + name + \" ignored\");\n"
"\t}\n"
"      }\n"
"    }else{\n"
"      // by order\n"
"      int index = 1;\n"
"      while (cmd.is_alnum() || cmd.match1(\"+-.\")) {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string value = cmd.ctos(\",)\", \"\", \"\");\n"
"\t  x->set_param_by_index(x->param_count() - index++, value, 0/*offset*/);\n"
"\t}catch (Exception_Too_Many& e) {untested();\n"
"\t  cmd.warn(bDANGER, here, e.message());\n"
"\t}\n"
"      }\n"
"    }\n"
"    cmd >> ')';\n"
"  }else{\n"
"    // no args\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/args.txt:74
#, no-wrap
msgid "print_args"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:77
msgid "Printing the arg list is just a loop."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:79
msgid ""
"The print loop prints them in order, the same order as the order dependent "
"readin."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:83
msgid ""
"For a device that uses the \"obsolete_callback\", no loop is needed, just "
"call ''print_args_obsolete_callback'' and let the device code do the work."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/args.txt:103
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_args(OMSTREAM& o, const MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  if (x->use_obsolete_callback_print()) {\n"
"    x->print_args_obsolete_callback(o, this);  //BUG//callback//\n"
"  }else{\n"
"    for (int ii = x->param_count() - 1;  ii >= 0;  --ii) {\n"
"      if (x->param_is_printable(ii)) {\n"
"\tstd::string arg = \" .\" + x->param_name(ii) + \"=\" + x->param_value(ii) + \";\";\n"
"\to << arg;\n"
"      }else{\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/command.txt:3
#, no-wrap
msgid "parse, print command"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:8
msgid ""
"A command object executes a command, does not store anything.  The reference "
"to \"dot\" and \"dotcard\" is historical, because in Spice, commands were "
"prefixed by a dot."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:10
msgid "This section may change as scripting is enhanced."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:12
msgid "For reference, here is the class definition from d_dot.h ."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:32
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class DEV_DOT : public CARD {\n"
"private:\n"
"  std::string\t_s;\n"
"  explicit DEV_DOT(const DEV_DOT& p) :CARD(p) {set_constant(true);}\n"
"public:\n"
"  explicit\tDEV_DOT()\t\t:CARD() {set_constant(true);}\n"
"private: // override virtual\n"
"  std::string   value_name()const\t{return \"\";}\n"
"  char\t\tid_letter()const\t{untested();return '\\0';}\n"
"  std::string\tdev_type()const\t\t{untested();return \"dotcard\";}\n"
"  CARD*\t\tclone()const\t\t{return new DEV_DOT(*this);}\n"
"public:\n"
"  void set(const std::string& S) {_s = S;}\n"
"  const std::string& s()const {return _s;}\n"
"};\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/command.txt:33
#: manual/tech/plugins/languages/comment.txt:32
#, no-wrap
msgid "parse_comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:36
msgid ""
"The parse function reads the string and executes it by calling ''CMD::"
"commandproc''.  Then the new object is deleted, and the function returns a "
"NULL pointer."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:44
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"DEV_DOT* LANG_VERILOG::parse_command(CS& cmd, DEV_DOT* x)\n"
"{\n"
"  assert(x);\n"
"  x->set(cmd.fullstring());\n"
"  CARD_LIST* scope = (x->owner()) ? x->owner()->subckt() : &CARD_LIST::card_list;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:52
#, no-wrap
msgid ""
"  cmd.reset(0);\n"
"  CMD::cmdproc(cmd, scope);\n"
"  delete x;\n"
"  return NULL;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/command.txt:53
#: manual/tech/plugins/languages/comment.txt:46
#, no-wrap
msgid "print_comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:56
msgid "For now, all that is needed is to print it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/command.txt:65
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_command(OMSTREAM& o, const DEV_DOT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->s() << '\\n';\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/comment.txt:3
#, no-wrap
msgid "parse, print comment"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:8
msgid "A comment object stores a string, otherwise does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:10
msgid "For reference, here is the class definition from d_coment.h ."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:31
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class DEV_COMMENT : public CARD {\n"
"private:\n"
"  std::string\t_s;\n"
"  explicit\tDEV_COMMENT(const DEV_COMMENT& p)\n"
"\t\t\t\t:CARD(p) {set_constant(true);}\n"
"public:\n"
"  explicit\tDEV_COMMENT()\t:CARD()  {set_constant(true);}\n"
"private: // override virtual\n"
"  char\t\tid_letter()const\t{return '\\0';}\n"
"  std::string\tdev_type()const\t\t{return \"comment\";}\n"
"  CARD*\t\tclone()const\t\t{return new DEV_COMMENT(*this);}\n"
"  std::string   value_name()const\t{return \"\";}\n"
"public:\n"
"  void set(const std::string& s) {_s = s;}\n"
"  std::string comment()const {return _s;}\n"
"};\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:35
msgid ""
"The parse function reads the string and stores it.  Usually, to \"set\" the "
"comment to the \"fullstring\" is all that is needed."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:46
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"DEV_COMMENT* LANG_VERILOG::parse_comment(CS& cmd, DEV_COMMENT* x)\n"
"{\n"
"  assert(x);\n"
"  x->set(cmd.fullstring());\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:49
msgid ""
"It would seem that all that is needed is to print it, but it is also "
"necessary to make sure that the printout is in a form that the current "
"language interprets as a comment.  You could just prefix it with the comment "
"marker, but this could cause a buildup in cases where there are repeated "
"saves and reads of the file.  Therefore, it is best to check the stored "
"prefix and only output an extra prefix if it doesn't match."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:55
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::print_comment(OMSTREAM& o, const DEV_COMMENT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/comment.txt:63
#, no-wrap
msgid ""
"  if ((x->comment().compare(0, 2, \"//\")) != 0) {\n"
"    o << \"//\";\n"
"  }else{\n"
"  }\n"
"  o << x->comment() << '\\n';\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/find_type_in_string.txt:3
#, no-wrap
msgid "find_type_in_string"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:6
msgid ""
"This function scans an input string and extracts the \"type\" from it.  In "
"some cases the type is explicitly stated and easy to find.  In others "
"finding the type can be tricky.  In any case, scanning is reset to the "
"beginning after the type is found."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:8
msgid ""
"Here is a simple case, where the type is the first word on the line, unless "
"it is a comment which begins with ''/''''/''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:26
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"std::string LANG_VERILOG::find_type_in_string(CS& cmd)\n"
"{\n"
"  unsigned here = cmd.cursor();\n"
"  std::string type;\n"
"  if ((cmd >> \"//\")) {\n"
"    assert(here == 0);\n"
"    type = \"dev_comment\";\n"
"  }else{\n"
"    cmd >> type;\n"
"  }\n"
"  cmd.reset(here);\n"
"  return type;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/find_type_in_string.txt:27
msgid ""
"This function can be considerably more complex if the type is not first in "
"line.  In some cases it is necessary to read to the end then back up."
msgstr ""

#. type: Title ======
#: manual/tech/plugins/languages/instance/label.txt:1
#: manual/tech/plugins/languages/instance/ports.txt:1
#: manual/tech/plugins/languages/instance/type.txt:1
#: manual/tech/plugins/languages.txt:1
#: manual/tech/plugins/languages/type.txt:1
#, no-wrap
msgid "Language plugins"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/instance/label.txt:5
#: manual/tech/plugins/languages/label.txt:3
#, no-wrap
msgid "parse, print label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:10
#: manual/tech/plugins/languages/label.txt:8
msgid "The label is a string by which this instance is known."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:12
#: manual/tech/plugins/languages/label.txt:10
msgid ""
"In a paramset (Spice .model) the label is the name of the new type being "
"defined."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:14
#: manual/tech/plugins/languages/label.txt:12
msgid ""
"A \"short_label\" is the simple form of the label, without scope information."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:16
#: manual/tech/plugins/languages/label.txt:14
msgid ""
"A \"long_label\" is a full label including hierarchical scope information."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/label.txt:17
#: manual/tech/plugins/languages/label.txt:15
#, no-wrap
msgid "parse_label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:20
#: manual/tech/plugins/languages/instance/type.txt:24
#: manual/tech/plugins/languages/label.txt:18
#: manual/tech/plugins/languages/type.txt:24
msgid ""
"This function usually reads the type from the input string, then calls "
"''set_dev_type'' to set it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:22
#: manual/tech/plugins/languages/instance/type.txt:26
#: manual/tech/plugins/languages/label.txt:20
#: manual/tech/plugins/languages/type.txt:26
msgid "Usually, you can use this function:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:34
#: manual/tech/plugins/languages/label.txt:32
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_label(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
"  std::string my_name;\n"
"  cmd >> my_name;\n"
"  x->set_label(my_name);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/label.txt:35
#: manual/tech/plugins/languages/label.txt:33
#, no-wrap
msgid "print_label"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:38
#: manual/tech/plugins/languages/label.txt:36
msgid "Printing the type usually simple.  Usually, you can use this function:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/label.txt:48
#: manual/tech/plugins/languages/label.txt:46
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_label(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->short_label();\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/instance/ports.txt:5
#: manual/tech/plugins/languages/ports.txt:3
#, no-wrap
msgid "parse, print ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:10
#: manual/tech/plugins/languages/ports.txt:8
msgid ""
"Ports are the connections, how this particular instance is connected to the "
"rest of the circuit."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:12
#: manual/tech/plugins/languages/ports.txt:10
msgid "Paramsets do not have ports."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:14
msgid ""
"In most languages, ports are nodes.  \"Through\" ports such as currents are "
"rarely supported.  In a language that does support current ports, the syntax "
"is the same."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:16
#: manual/tech/plugins/languages/ports.txt:14
msgid ""
"Most languages read in ports by order.  The meaning of a port is determined "
"by the order in a port list.  For example, in a diode, the first is the "
"anode, the second is the cathode."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:18
#: manual/tech/plugins/languages/ports.txt:16
msgid "Some also support name=value pairs.  Some use either."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/ports.txt:23
#: manual/tech/plugins/languages/ports.txt:21
#, no-wrap
msgid "parse_ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:26
#: manual/tech/plugins/languages/ports.txt:24
msgid "This functions reads the ports from the input and stores the info."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:32
#: manual/tech/plugins/languages/ports.txt:30
msgid ""
"While reading by order, the value is set by the function ''set_port_by_index"
"(index, value)''.  The index starts at 0 and must be incremented with every "
"read.  An exception ''Exception_Too_Many'' will be thrown if there are too "
"many.  Your code must catch the exception, and should print a message, and "
"move on."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:34
#: manual/tech/plugins/languages/ports.txt:32
msgid ""
"While reading by name, the value is set by the function ''set_port_by_name"
"(name, value)''.  An exception ''Exception_No_Match'' will be thrown if the "
"device type does not have a parameter that matches.  Your code must catch "
"the exception.  Probably it should print a message, and move on.  In some "
"cases, you may want to silently ignore invalid parameters."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:40
#: manual/tech/plugins/languages/ports.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_ports(CS& cmd, COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:75
#: manual/tech/plugins/languages/ports.txt:73
#, no-wrap
msgid ""
"  if (cmd >> '(') {\n"
"    if (cmd.is_alnum()) {\n"
"      // by order\n"
"      int index = 0;\n"
"      while (cmd.is_alnum()) {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string value;\n"
"\t  cmd >> value;\n"
"\t  x->set_port_by_index(index++, value);\n"
"\t}catch (Exception_Too_Many& e) {untested();\n"
"\t  cmd.warn(bDANGER, here, e.message());\n"
"\t}\n"
"      }\n"
"    }else{\n"
"      // by name\n"
"      while (cmd >> '.') {\n"
"\tunsigned here = cmd.cursor();\n"
"\ttry{\n"
"\t  std::string name, value;\n"
"\t  cmd >> name >> '(' >> value >> ')' >> ',';\n"
"\t  x->set_port_by_name(name, value);\n"
"\t}catch (Exception_No_Match&) {untested();\n"
"\t  cmd.warn(bDANGER, here, \"mismatch, ignored\");\n"
"\t}\n"
"      }\n"
"    }\n"
"    cmd >> ')';\n"
"  }else{untested();\n"
"    cmd.warn(bDANGER, \"'(' required (parse ports)\");\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance/ports.txt:76
#: manual/tech/plugins/languages/ports.txt:74
#, no-wrap
msgid "print_ports"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:85
#: manual/tech/plugins/languages/ports.txt:86
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_ports_long(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  // print in long form ...    .name(value)\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:103
#: manual/tech/plugins/languages/ports.txt:104
#, no-wrap
msgid ""
"  o << \" (\";\n"
"  std::string sep = \".\";\n"
"  for (int ii = 0;  x->port_exists(ii);  ++ii) {\n"
"    o << sep << x->port_name(ii) << '(' << x->port_value(ii) << ')';\n"
"    sep = \",.\";\n"
"  }\n"
"  for (int ii = 0;  x->current_port_exists(ii);  ++ii) {\n"
"    o << sep << x->current_port_name(ii) << '(' << x->current_port_value(ii) << ')';\n"
"    sep = \",.\";\n"
"  }\n"
"  o << \")\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_ports_short(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  // print in short form ...   value only\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/ports.txt:117
#: manual/tech/plugins/languages/ports.txt:118
#, no-wrap
msgid ""
"  o << \" (\";\n"
"  std::string sep = \"\";\n"
"  for (int ii = 0;  x->port_exists(ii);  ++ii) {\n"
"    o << sep << x->port_value(ii);\n"
"    sep = \",\";\n"
"  }\n"
"  for (int ii = 0;  x->current_port_exists(ii);  ++ii) {\n"
"    o << sep << x->current_port_value(ii);\n"
"    sep = \",\";\n"
"  }\n"
"  o << \")\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:3
#: manual/tech/plugins/languages/instance/type.txt:5
#: manual/tech/plugins/languages/type.txt:5
#, no-wrap
msgid "parse, print instance, paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:8
msgid "A netlist is primarily a list of instances."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:10
msgid "Synonyms for instance include component, device, element."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:12
msgid "Examples of instances include resistors, transistors."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:14
msgid ""
"A paramset is a prototype for an instance.  Internally, it is the same "
"except that a paramset has no ports, but most languages have a different "
"syntax for it.  The word \"paramset\" is from Verilog syntax.  In Spice, "
"this would be a \"model\" statement."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:16
msgid "In most cases, the data can clearly be divided into four parts:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:21
#, no-wrap
msgid ""
"**type**  -- The type of this instance.  (resistor)\\\\\n"
"**label** -- The name of this instance.  (R22)\\\\\n"
"**ports** -- Connections, nodes, ports, pins.\\\\\n"
"**args**  -- Arguments, parameters, values.  (R=10k, tolerance=5%)\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:23
msgid ""
"To simplify coding, it is usually best to set up four separate functions to "
"parse, and four to print.  These should be \"static\" or \"private member\" "
"functions, so they are visible only in this file.  The top level "
"''parse_instance'' and ''print_instance'' can be just a set of calls to "
"these functions, in the appropriate order."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:type]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:label]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:ports]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/instance.txt:28
#, no-wrap
msgid "[[.:args]]\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:29
#, no-wrap
msgid "parse_instance, parse_paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:32
msgid ""
"The parse function reads the input string, interprets it, and stores the "
"data as interpreted.  The string itself is not stored."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:60
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"COMPONENT* LANG_SPECTRE::parse_instance(CS& cmd, COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  cmd.reset(0);\n"
"  parse_label(cmd, x);\n"
"  parse_ports(cmd, x);\n"
"  parse_type(cmd, x);\n"
"  parse_args(cmd, x);\n"
"  cmd.check(bWARNING, \"what's this?\");\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"MODEL_CARD* LANG_SPECTRE::parse_paramset(CS& cmd, MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  cmd.reset(0).skipbl();\n"
"  cmd >> \"model \";\n"
"  parse_label(cmd, x);\n"
"  parse_type(cmd, x);\n"
"  parse_args(cmd, x);\n"
"  cmd.check(bWARNING, \"what's this?\");\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:62
msgid ""
"''cmd.reset(0)'' at the beginning resets the parser/scanner to the beginning "
"of the line."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:64
msgid ""
"''cmd.check(bWARNING, \"what's this?\")'' checks that the line is used up, "
"the cursor should be at the end of the line.  If not, there is something "
"wrong, so it prints a warning."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:65
#, no-wrap
msgid "print_instance, print_paramset"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:68
msgid ""
"The print function re-creates a string from the stored data.  It should be "
"in a form suitable to be passed to ''parse'', to recreate the same "
"instance.  The round-trip should be lossless, in the sense of having "
"identical data.  It serves as a check that both parse and print are working "
"correctly."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:70
msgid ""
"It is not necessary or desirable to EXACTLY reproduce the input.  Rather, "
"show how the input was interpreted.  In cases where something could be "
"ambiguous, this is important.  The printed output should be a cleaned-up "
"version of the input."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:72
msgid "To parse in one language then print in another does a translation."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:93
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPECTRE::print_instance(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  print_label(o, x);\n"
"  print_ports(o, x);\n"
"  print_type(o, x);\n"
"  print_args(o, x);\n"
"  o << \"\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPECTRE::print_paramset(OMSTREAM& o, const MODEL_CARD* x)\n"
"{\n"
"  assert(x);\n"
"  o << \"model \" << x->short_label() << ' ' << x->dev_type() << ' ';\n"
"  print_args(o, x);\n"
"  o << \"\\n\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/instance.txt:94
#: manual/tech/plugins/languages/module.txt:70
#, no-wrap
msgid "A command to get it started"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:97
msgid ""
"For instances, usually parse and print are all you need.  Finding a matching "
"type gets it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:99
msgid ""
"For paramsets (''.model'' in Spice) in addition to the above, it is "
"necessary to make a command to recognize a keyword to get it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:101
msgid "It needs to allocate a new ''MODEL_CARD'', parse it, then store it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:112
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_PARAMSET : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // already got \"paramset\"\n"
"    std::string my_name, base_name;\n"
"    cmd >> my_name;\n"
"    unsigned here = cmd.cursor();\n"
"    cmd >> base_name;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:132
#, no-wrap
msgid ""
"    //const MODEL_CARD* p = model_dispatcher[base_name];\n"
"    const CARD* p = lang_verilog.find_proto(base_name, NULL);\n"
"    if (p) {\n"
"      MODEL_CARD* new_card = dynamic_cast<MODEL_CARD*>(p->clone());\n"
"      if (new_card) {\n"
"\tassert(!new_card->owner());\n"
"\tlang_verilog.parse_paramset(cmd, new_card);\n"
"\tScope->push_back(new_card);\n"
"      }else{\n"
"\tcmd.warn(bDANGER, here, \"paramset: base has incorrect type\");\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, here, \"paramset: no match\");\n"
"    }\n"
"  }\n"
"} p1;\n"
"DISPATCHER<CMD>::INSTALL d1(&command_dispatcher, \"paramset\", &p1);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:134
msgid ""
"In some cases (Spice) you need to deal with the \"level\" concept here.  The "
"same type field (for example ''NMOS'') can map to severa l different "
"prototypes (level 1,2,3,...).  Those prototypes ultimately need different "
"internal names, and a scheme to map them here."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:145
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_MODEL : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    // already got \"model\"\n"
"    std::string my_name, base_name;\n"
"    cmd >> my_name;\n"
"    unsigned here1 = cmd.cursor();\n"
"    cmd >> base_name;\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:161
#, no-wrap
msgid ""
"    // \"level\" kluge ....\n"
"    // if there is a \"level\" keyword, with integer argument,\n"
"    // tack that onto the given modelname and look for that\n"
"    cmd.skip1b('(');\n"
"    int level = 0;\n"
"    {\n"
"      unsigned here = cmd.cursor();\n"
"      scan_get(cmd, \"level \", &level);\n"
"      if (!cmd.stuck(&here)) {\n"
"\tchar buf[20];\n"
"\tsprintf(buf, \"%u\", level);\n"
"\tbase_name += buf;\n"
"      }else{\n"
"      }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:163
#, no-wrap
msgid "    const MODEL_CARD* p = model_dispatcher[base_name];\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance.txt:180
#, no-wrap
msgid ""
"    if (p) {\n"
"      MODEL_CARD* new_card = dynamic_cast<MODEL_CARD*>(p->clone());\n"
"      if (new_card) {\n"
"\tassert(!new_card->owner());\n"
"\tlang_spice.parse_paramset(cmd, new_card);\n"
"\tScope->push_back(new_card);\n"
"      }else{untested();\n"
"\tcmd.warn(bDANGER, here1, \"model: base has incorrect type\");\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, here1, \"model: \\\"\" + base_name + \"\\\" no match\");\n"
"    }\n"
"  }\n"
"} p1;\n"
"DISPATCHER<CMD>::INSTALL d1(&command_dispatcher, \".model\", &p1);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ===
#: manual/tech/plugins/languages/instance/type.txt:7
#: manual/tech/plugins/languages/type.txt:7
#, no-wrap
msgid "parse, print type"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:12
#: manual/tech/plugins/languages/type.txt:12
msgid ""
"It may seem redundant to parse the type again, because the type is already "
"known.  It was determined by ''find_type_in_string'', then the type was "
"looked up, and a new instance of that type was created."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:14
#: manual/tech/plugins/languages/type.txt:14
msgid ""
"Often, it is, but sometimes parameters are encoded in the type, with several "
"type names really representing the same real type.  One example of this is "
"the \"NPN\" and \"PNP\" transistors, which are the same type with a polarity "
"parameter, or the name associated with a paramset (Spice .model card)."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:16
#: manual/tech/plugins/languages/type.txt:16
msgid ""
"On the other hand, sometimes an identical type name could represent "
"different real types.  An example of this is the different \"levels\" of "
"Spice MOSFET models.  This is handled by trickery in parsing, and is not "
"discussed here because it is a bad idea."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:18
#: manual/tech/plugins/languages/type.txt:18
msgid ""
"In Spice format, sometimes the type is implied by the first letter of the "
"label, and never explicitly appears.  In this case, the explicit parse and "
"print can be skipped."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:20
#: manual/tech/plugins/languages/type.txt:20
msgid ""
"In a paramset (including a Spice .model), the type is the master type being "
"copied, not the new type being defined."
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/instance/type.txt:21
#: manual/tech/plugins/languages/type.txt:21
#, no-wrap
msgid "parse_type ==="
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:38
#: manual/tech/plugins/languages/type.txt:38
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void parse_type(CS& cmd, CARD* x)\n"
"{\n"
"  assert(x);\n"
"  std::string new_type;\n"
"  cmd >> new_type;\n"
"  x->set_dev_type(new_type);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ==
#: manual/tech/plugins/languages/instance/type.txt:39
#: manual/tech/plugins/languages/type.txt:39
#, no-wrap
msgid "print_type"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:42
#: manual/tech/plugins/languages/type.txt:42
msgid ""
"Printing the type usually simple.  In some cases (Spice) the type may not be "
"printed.  The extra code is not shown here."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/instance/type.txt:52
#: manual/tech/plugins/languages/type.txt:52
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"static void print_type(OMSTREAM& o, const COMPONENT* x)\n"
"{\n"
"  assert(x);\n"
"  o << x->dev_type();\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/lang_base.h.txt:3
#, no-wrap
msgid "lang_base.h"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/lang_base.h.txt:6
msgid ""
"If your version of gnucap does not supply lang_base.h, use this one, copy it "
"to the place where the gnucap headers are."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/lang_base.h.txt:15
msgid ""
"<code cpp> #include \"globals.h\" #include \"c_comand.h\" #include \"d_dot.h"
"\" #include \"d_coment.h\" #include \"d_subckt.h\" #include \"e_model.h\" "
"#include \"u_lang.h\" </code>"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/module.txt:3
#, no-wrap
msgid "parse, print module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:8
msgid ""
"A module is container of instances.  To a compiler, a module can also "
"contain code to be executed, but gnucap does not directly support that."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:10
msgid "A Spice \"subckt\" is a module."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "type -- A module defines a new type.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "[[.:label]] -- The label is the name of the new type.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "[[.:ports]] -- This is the list of connections.\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages/module.txt:15
#, no-wrap
msgid "[[.:args]] -- The arg list is optional.  If left out, the arg list is open.  It accepts whatever it is fed.\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/module.txt:16
#, no-wrap
msgid "parse_module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:19
msgid ""
"A module is a collection.  Parsing it means to parse the header, then the "
"body, then the trailer.  Parsing the body is a loop, getting text and "
"calling ''new_''''_instance'' on each pass, until some indication that it is "
"done.  It is important to have some kind of guarantee that the loop will "
"exit."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:25
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"MODEL_SUBCKT* LANG_SPECTRE::parse_module(CS& cmd, MODEL_SUBCKT* x)\n"
"{\n"
"  assert(x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:31
#, no-wrap
msgid ""
"  // header\n"
"  cmd.reset(0).skipbl();\n"
"  cmd >> \"subckt \";\n"
"  parse_label(cmd, x);\n"
"  parse_ports(cmd, x);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:35
#, no-wrap
msgid ""
"  // body\n"
"  for (;;) {\n"
"    cmd.get_line(\"spectre-subckt>\");\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:46
#, no-wrap
msgid ""
"    if (cmd >> \"ends \") {\n"
"      break;\n"
"    }else{\n"
"      new__instance(cmd, x, x->subckt());\n"
"    }\n"
"  }\n"
"  return x;\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/module.txt:47
#, no-wrap
msgid "print_module"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:55
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_SPICE_BASE::print_module(OMSTREAM& o, const MODEL_SUBCKT* x)\n"
"{\n"
"  assert(x);\n"
"  assert(x->subckt());\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:59
#, no-wrap
msgid ""
"  o << \".subckt \" <<  x->short_label();\n"
"  print_ports(o, x);\n"
"  o << '\\n';\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:64
#, no-wrap
msgid ""
"  for (CARD_LIST::const_iterator\n"
"\t ci = x->subckt()->begin(); ci != x->subckt()->end(); ++ci) {\n"
"    print_item(o, *ci);\n"
"  }\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:69
#, no-wrap
msgid ""
"  o << \".ends \" << x->short_label() << \"\\n\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:73
msgid ""
"In addition to the above, it is necessary to make a command to recognize a "
"keyword to get it started."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:75
msgid "It needs to allocate a new ''MODEL_SUBCKT'', parse it, then store it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/module.txt:93
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"class CMD_SUBCKT : public CMD {\n"
"  void do_it(CS& cmd, CARD_LIST* Scope)\n"
"  {\n"
"    MODEL_SUBCKT* new_module = new MODEL_SUBCKT;\n"
"    assert(new_module);\n"
"    assert(!new_module->owner());\n"
"    assert(new_module->subckt());\n"
"    assert(new_module->subckt()->is_empty());\n"
"    lang_spectre.parse_module(cmd, new_module);\n"
"    Scope->push_back(new_module);\n"
"  }\n"
"} p2;\n"
"DISPATCHER<CMD>::INSTALL d2(&command_dispatcher, \"subckt\", &p2);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/parse_top_item.txt:3
#, no-wrap
msgid "parse_top_item"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:6
msgid ""
"The function ''parse_top_item'' must be provided.  Usually you can just copy "
"this."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:16
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANG_VERILOG::parse_top_item(CS& cmd, CARD_LIST* Scope)\n"
"{\n"
"  cmd.get_line(\"gnucap-verilog>\");\n"
"  new__instance(cmd, NULL, Scope);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:18
msgid ""
"It parses one line of input, where the definition of \"line\" may differ "
"depending on the language."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:20
msgid ""
"The string, in this case ''\"gnucap-verilog>\"'' is used as a prompt in "
"interactive mode, and is suppressed when reading from a file."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:22
msgid ""
"For educational purposes, the code for ''new_''''_instance'' follows.  You "
"do not need to duplicate it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:24
msgid ""
"You do need to provide ''find_type_in_string'', which returns the type as a "
"string, by scanning the input."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:26
msgid ""
"''parse_item'' is shown here.  It dispatches to one of ''parse_module'', "
"''parse_instance'', ''parse_paramset'', ''parse_comment'', or "
"''parse_command'', which you must provide."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:56
#, no-wrap
msgid ""
"<code cpp>\n"
"/*--------------------------------------------------------------------------*/\n"
"void LANGUAGE::new__instance(CS& cmd, MODEL_SUBCKT* owner, CARD_LIST* Scope)\n"
"{\n"
"  if (cmd.is_end()) {\n"
"    // nothing\n"
"  }else{\n"
"    std::string type = find_type_in_string(cmd);\n"
"    if (const CARD* proto = find_proto(type, owner)) {\n"
"      CARD* new_instance = proto->clone_instance();\n"
"      assert(new_instance);\n"
"      new_instance->set_owner(owner);\n"
"      CARD* x = parse_item(cmd, new_instance);\n"
"      if (x) {\n"
"\tassert(Scope);\n"
"\tScope->push_back(x);\n"
"      }else{\n"
"      }\n"
"    }else{\n"
"      cmd.warn(bDANGER, type + \": no match\");\n"
"    }\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"CARD* LANGUAGE::parse_item(CS& cmd, CARD* c)\n"
"{\n"
"  // See Stroustrup 15.4.5\n"
"  // If you can think of a better way, tell me.\n"
"  // It must be in the LANGUAGE class, not CARD.\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/parse_top_item.txt:74
#, no-wrap
msgid ""
"  if (dynamic_cast<MODEL_SUBCKT*>(c)) {\n"
"    return parse_module(cmd, prechecked_cast<MODEL_SUBCKT*>(c));\n"
"  }else if (dynamic_cast<COMPONENT*>(c)) {\n"
"    return parse_instance(cmd, prechecked_cast<COMPONENT*>(c));\n"
"  }else if (dynamic_cast<MODEL_CARD*>(c)) {\n"
"    return parse_paramset(cmd, prechecked_cast<MODEL_CARD*>(c));\n"
"  }else if (dynamic_cast< DEV_COMMENT*>(c)) {\n"
"    return parse_comment(cmd, prechecked_cast<DEV_COMMENT*>(c));\n"
"  }else if (dynamic_cast<DEV_DOT*>(c)) {\n"
"    return parse_command(cmd, prechecked_cast<DEV_DOT*>(c));\n"
"  }else{untested();\n"
"    incomplete();\n"
"    unreachable();\n"
"    return NULL;\n"
"  }\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:12
msgid ""
"In most languages, ports are nodes.  \"Through\" ports such as currents are "
"rarely supported.  Nodes and through ports are stored in separate lists.  As "
"of when this is being written, only the Spice format supports through ports "
"in any way, and even this is limited to just a few devices."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:77
msgid ""
"Printing the port list is just a loop.  Two loops are needed, one for "
"traditional node ports, the other for through or current ports.  This part "
"is inherently inconsistent.  It is necessary to print them because they may "
"be there, even if there is no way to input them other than to use a "
"different language.  This could change in a future release."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/ports.txt:79
msgid ""
"The print loop prints them in order, the same order as the order dependent "
"readin.  Here are two variants of the print loop, one with names, the other "
"without."
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:5
#, no-wrap
msgid "~LANGUAGE()"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:10
#, no-wrap
msgid ""
"C++ rules require a virtual destructor when there are virtual functions.  You need to define one as a tracing aid.  It can be an empty function.\n"
"<code cpp>\n"
"  ~LANG_VERILOG() {itested();}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:11
#, no-wrap
msgid "std::string name()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:16
#, no-wrap
msgid ""
"Return the name to use as a key to enable this language.\n"
"<code cpp>\n"
"  std::string name()const {return \"verilog\";}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:17
#, no-wrap
msgid "bool case_insensitive()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:22
#, no-wrap
msgid ""
"Return false if the language is case sensitive, true if case insensitive.\n"
"<code cpp>\n"
"  bool case_insensitive()const {return false;}\n"
"</code>\n"
msgstr ""

#. type: Title ====
#: manual/tech/plugins/languages/simple_query_functions.txt:23
#, no-wrap
msgid "UNITS units()const"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:28
#, no-wrap
msgid ""
"This function determines how numeric strings with multiplier suffixes such as \"10m\" are parsed.  It should return ''uSI'' for standard SI units.  (M = meg = 10^6, m = milli = 10^-3)  or ''uSPICE'' for SPICE syntax (M = milli = 10^-3, Meg = meg = 10^6).\n"
"<code cpp>\n"
"  UNITS units()const {return uSI;}\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/simple_query_functions.txt:29
#, no-wrap
msgid "Used by obsolete_callback"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:32
msgid ""
"These functions describe the syntax for parameter assignment statements."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:34
msgid ""
"For example, the most common syntax is ''x=value'', but Verilog uses ''.x"
"(value)''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:36
msgid "You need to specify the front, mid, and back strings."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:44
#, no-wrap
msgid ""
"For ''x=value''\n"
"the code is:\n"
"<code cpp>\n"
"  std::string arg_front()const {return \" \";}\n"
"  std::string arg_mid()const {return \"=\";}\n"
"  std::string arg_back()const {return \"\";}\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/simple_query_functions.txt:51
#, no-wrap
msgid ""
"For ''.x(value)''\n"
"the code is:\n"
"<code cpp>\n"
"  std::string arg_front()const {return \".\";}\n"
"  std::string arg_mid()const {return \"(\";}\n"
"  std::string arg_back()const {return \")\";}\n"
"</code>\n"
msgstr ""

#. type: Title =====
#: manual/tech/plugins/languages/top_level.txt:3
#, no-wrap
msgid "Top Level"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:6
msgid "At top level, you need to include the header file."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:10
msgid "<code cpp> #include \"gnucap/lang_base.h\" </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:12
msgid ""
"If you want to be able to static link the plugin, or combine it with others, "
"wrap it in an anonymous namespace."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:23
msgid ""
"<code cpp> namespace { /"
"*--------------------------------------------------------------------------"
"*/ // all of your other code goes here /"
"*--------------------------------------------------------------------------"
"*/ } // close the anonymous namespace /"
"*--------------------------------------------------------------------------"
"*/ /"
"*--------------------------------------------------------------------------"
"*/ // end of file </code>"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:25
msgid "Inside of there, you need to define a new class."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:33
#, no-wrap
msgid ""
"<code cpp>\n"
"class LANG_SPECTRE : public LANGUAGE {\n"
"public:\n"
"  ~LANG_SPECTRE() {}\n"
"  std::string name()const {return \"spectre\";}\n"
"  bool case_insensitive()const {return false;}\n"
"  UNITS units()const {return uSI;}\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:38
#, no-wrap
msgid ""
"public: // override virtual, used by callback\n"
"  std::string arg_front()const {return \" \";}\n"
"  std::string arg_mid()const {return \"=\";}\n"
"  std::string arg_back()const {return \"\";}\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:47
#, no-wrap
msgid ""
"public: // override virtual, called by commands\n"
"  void\t\tparse_top_item(CS&, CARD_LIST*);\n"
"  DEV_COMMENT*\tparse_comment(CS&, DEV_COMMENT*);\n"
"  DEV_DOT*\tparse_command(CS&, DEV_DOT*);\n"
"  MODEL_CARD*\tparse_paramset(CS&, MODEL_CARD*);\n"
"  MODEL_SUBCKT* parse_module(CS&, MODEL_SUBCKT*);\n"
"  COMPONENT*\tparse_instance(CS&, COMPONENT*);\n"
"  std::string\tfind_type_in_string(CS&);\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:58
#, no-wrap
msgid ""
"private: // override virtual, called by print_item\n"
"  void print_paramset(OMSTREAM&, const MODEL_CARD*);\n"
"  void print_module(OMSTREAM&, const MODEL_SUBCKT*);\n"
"  void print_instance(OMSTREAM&, const COMPONENT*);\n"
"  void print_comment(OMSTREAM&, const DEV_COMMENT*);\n"
"  void print_command(OMSTREAM& o, const DEV_DOT* c);\n"
"private: // local\n"
"  void print_args(OMSTREAM&, const CARD*);\n"
"} lang_spectre;\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:60
msgid ""
"Then delcare one static instance of it and \"INSTALL\" it with the "
"\"DISPATCHER\"."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:66
#, no-wrap
msgid ""
"<code cpp>\n"
"DISPATCHER<LANGUAGE>::INSTALL\n"
"\td(&language_dispatcher, lang_spectre.name(), &lang_spectre);\n"
"/*--------------------------------------------------------------------------*/\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:68
msgid ""
"In general, the names do not need to be unique.  It is ok if another plugin "
"has the same names."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages/top_level.txt:69
msgid ""
"However, the ''name()'' string above should be unique so you can find it."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:6
msgid ""
"Language plugins read and write a particular simulation language, and set up "
"related commands.  They determine the syntax used by gnucap."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:8
msgid ""
"This refers to SIMULATION languages, like \"spice\", \"spectre\" or \"verilog"
"\", not NATURAL languages."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:10
msgid ""
"Language plugins need to #include the file: ''gnucap/lang_base.h''.  Others "
"may be needed in some cases."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:12
msgid ""
"The base class ''LANGUAGE'' is defined in ''gnucap/u_lang.h'' which is "
"included by ''gnucap/lang_base.h''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:14
msgid ""
"The \"parse\" and \"print\" functions go together.  For every \"parse\" "
"there must be a \"print\" that regenerates a string suitable for input to "
"\"parse\" that is equivalent to the original."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:16
msgid ""
"As a generalization, to read a file the function ''parse_top_item'' is "
"called in a loop:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:22
#, no-wrap
msgid ""
"<code>\n"
"  for (;;) {\n"
"    OPT::language->parse_top_item(file, Scope);\n"
"  }\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:24
msgid ""
"The loop exits when an exception is thrown, most likely "
"''Exception_End_Of_Input''."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:26
msgid ""
"This function must be provided by the language plugin.  A set of other "
"functions must also be provided, as in this example:"
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:28
msgid ""
"As with all plugins, declare one static object of this new type, and INSTALL "
"it in the DISPATCHER."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:30
msgid ""
"In addition to this, you will probably need to supply a few commands to "
"recognize keywords at top level."
msgstr ""

#. type: Plain text
#: manual/tech/plugins/languages.txt:32
msgid "Details are described in the following \"Implementation\" section."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:Top level]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:lang_base.h]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:Simple query functions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:parse_top_item]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:find_type_in_string]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:comment]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:command]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:instance|instance, paramset]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:module]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/plugins/languages.txt:46
#, no-wrap
msgid "[[.:languages:commands]]\n"
msgstr ""

#. type: Title ======
#: manual/tech/testing.txt:1
#, no-wrap
msgid "Testing"
msgstr ""

#. type: Plain text
#: manual/tech/testing.txt:4
msgid "This section describes Gnucap test procedures, policy, and test macros."
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[test macros]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[compiling]]\n"
msgstr ""

#. type: Bullet: '  * '
#: manual/tech/testing.txt:7
#, no-wrap
msgid "[[code coverage testing]]\n"
msgstr ""

#. type: Title =====
#: manual/tech/test_macros.txt:1
#, no-wrap
msgid "Test Macros"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:4
msgid "Gnucap supplies a set of test macros in the file gnucap/io_trace.h ."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:6
msgid ""
"This file may be included more than once, at any place in the code, to "
"change the options."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:8
msgid ""
"All of these macros do nothing when compiled with default settings.  They "
"exist so they can be left in the code and enabled or disabled as needed by "
"developers without burdening end users with their clutter."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:9
#, no-wrap
msgid "unreachable()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:13
#, no-wrap
msgid ""
"  #define unreachable() (printf(\"@@#\\n@@@unreachable:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:15
msgid ""
"It prints the word \"unreachable\", the source file name, line number, and "
"function name."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:17
msgid ""
"Use this macro to identify blocks of code that are unreachable in normal "
"use.  Any output when the program is run indicates bugs in the code."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:19
msgid ""
"It is appropriate to question why such a block of code should exist at all.  "
"Normally, it shouldn't and should be removed.  However, there are cases "
"where a function or other code must exist to satisfy a link requirement or "
"to defeat something."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:21
msgid ""
"One example of the link requirement is member functions in a base class that "
"are overridden.  The usual recommended style is to use a \"pure virtual\", "
"but then you can't instantiate any instances unless an overriding function "
"exists.  In some cases, it is known that it is never used, but required for "
"instantiation, hence \"unreachable\"."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:23
msgid ""
"Another example is overriding default and copy constructors with the purpose "
"of preventing their use.  If you don't define one, C++ will create public "
"default and copy constructors without asking.  To prevent automatic "
"construction or copying, you could make them private, but to make it private "
"you need to define your own.  In this case, those inhibiting constructors "
"are unreachable."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:25
msgid ""
"Usually an \"unreachable\" block can be empty except for the macro call."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:26
#, no-wrap
msgid "incomplete()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:30
#, no-wrap
msgid ""
"  #define incomplete() (printf(\"@@#\\n@@@incomplete:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:32
msgid ""
"It prints the word \"incomplete\", the source file name, line number, and "
"function name."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:34
msgid ""
"Use this macro to identify blocks of code that are known to not function "
"correctly."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:36
msgid ""
"This is intended to be used as a reminder that attention is needed here, "
"otherwise the problems could be forgotten until they show in a more "
"unpleasant way."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:37
#, no-wrap
msgid "untested()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:45
#, no-wrap
msgid ""
"  #ifdef TRACE_UNTESTED\n"
"  #define untested() (printf(\"@@#\\n@@@:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
"  #else\n"
"  #define untested()\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:47
msgid ""
"If ''TRACE_UNTESTED'' is defined, it prints the source file name, line "
"number, and function name.  Otherwise (normally) it does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:49
msgid ""
"It is used in code coverage testing, and to identify blocks of code for "
"which testing is inadequate, specifically blocks of code that are not "
"covered by the suite of test files."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:51
msgid "Such blocks of code are suspect when bugs are reported."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:52
#, no-wrap
msgid "itested()"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:60
#, no-wrap
msgid ""
"  #ifdef TRACE_ITESTED\n"
"  #define itested() (printf(\"@@#\\n@@@:%s:%u:%s\\n\", \\\n"
"\t\t\t   __FILE__, __LINE__, __func__))\n"
"  #else\n"
"  #define itested()\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:62
msgid ""
"If ''TRACE_ITESTED'' is defined, it prints the source file name, line "
"number, and function name.  Otherwise (normally) it does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:64
msgid ""
"It is used in code coverage testing, and to identify blocks of code for "
"which only interactive informal testing was done.  It was tested, but the "
"test suite does not cover it."
msgstr ""

#. type: Title ===
#: manual/tech/test_macros.txt:65
#, no-wrap
msgid "trace0(), trace1(), trace2(), ...."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:74
#, no-wrap
msgid ""
"  #ifdef DO_TRACE\n"
"  #define trace0(s) (printf(\"@#@%s\\n\", s))\n"
"  #define trace1(s,x) (printf(\"@#@%s  %s=%g\\n\", s, #x, (double)(x)))\n"
"  #else\n"
"  #define trace0(s)\n"
"  #define trace1(s,x)\n"
"  #endif\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:76
msgid ""
"If ''DO_TRACE'' is defined, it prints something, otherwise (normally) it "
"does nothing."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:78
msgid "''trace0'' prints a string message."
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:83
#, no-wrap
msgid ""
"''trace1'' prints a string message and one argument.\n"
"  trace1(\"hello\", data);\n"
"prints:\n"
"  hello data=329232\n"
msgstr ""

#. type: Plain text
#: manual/tech/test_macros.txt:85
msgid "and so on."
msgstr ""

#. type: Title ======
#: projects.txt:1
#, no-wrap
msgid "Projects"
msgstr ""

#. type: Plain text
#: projects.txt:4
msgid ""
"Gnucap is inviting anyone to take on projects.  Most of them involve "
"creating plugins.  All of them create something that is identifiably yours, "
"that will be noticed.  Most of them will stretch your skills a bit.  If you "
"want to learn about simulation, beyond what you can get at school, this is "
"the place."
msgstr ""

#. type: Plain text
#: projects.txt:6
msgid "Here are some suggestions:"
msgstr ""

#. type: Title =====
#: projects.txt:6
#, no-wrap
msgid "Interface to other free EDA software"
msgstr ""

#. type: Plain text
#: projects.txt:9
msgid ""
"The \"language plugins\" allow gnucap to read and write different netlist "
"languages.  They can also provide the capability to directly read and write "
"the formats of schematic and layout programs such as gEDA and Kicad.  Any "
"one of these is a good \"summer-of-code\" project."
msgstr ""

#. type: Plain text
#: projects.txt:11
msgid "The formats in need of support, grouped by priority:"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Free schematic formats:  <del>gEDA/gschem</del>, Kicad/eeschema, Qucs\n"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Free PCB layout formats:  gEDA/PCB, Kicad/pcbnew\n"
msgstr ""

#. type: Bullet: '  - '
#: projects.txt:15
#, no-wrap
msgid "Proprietary formats:  Eagle, Multisim, Orcad, LTspice\n"
msgstr ""

#. type: Plain text
#: projects.txt:17
msgid "Formats that are <del>crossed out</del> are already works in progress."
msgstr ""

#. type: Plain text
#: projects.txt:19
msgid ""
"These plugins, when used with gnucap, will provide an interface for smooth "
"interoperation.  When used with gnucap's translation utility (a subset of "
"gnucap), they will provide the ability to translate from any supported "
"format to any other, and also to a Verilog based intermediate language that "
"can be used as a neutral, nonproprietary exchange format."
msgstr ""

#. type: Title =====
#: projects.txt:24
#, no-wrap
msgid "Command compatibility plugins"
msgstr ""

#. type: Plain text
#: projects.txt:27
msgid ""
"Some other simulators have a scripting language with lots of commands.  One "
"example is the \"nutmeg\" part of Spice.  Gnucap has the mechanism, but only "
"a few commands are implemented."
msgstr ""

#. type: Plain text
#: projects.txt:29
msgid ""
"A possible summer of code project would be to implement a set of these "
"commands.  One or two commands would be a very easy project, too easy for a "
"whole summer.  A bunch of these commands, would be a great project."
msgstr ""

#. type: Plain text
#: projects.txt:31
msgid ""
"These plugins, combined with \"output compatibility\" plugins will allow "
"gnucap to be used as a drop-in replacement for commercial simulators in some "
"applications."
msgstr ""

#. type: Title =====
#: projects.txt:32
#, no-wrap
msgid "Output compatibility plugins"
msgstr ""

#. type: Plain text
#: projects.txt:35
msgid ""
"The only output format supported by gnucap has been a generic ASCII format "
"that is compatible with most spreadsheets and general purpose programs like "
"octave and gnuplot.  We need more specific formats, to support some more "
"special purpose post-processor tools.  The most obvious here is a Spice "
"\"rawfile\" format.  There are both binary and ASCII formats, many of them.  "
"Some are similar enough that if you have one, a trivial change gives you "
"another.  The most requested seems to be the \"HSpice\" format, and the "
"Tiburon format, which are often used as references.  These are similar, and "
"the Spice3f5 format is close enough to be a trivial edit away."
msgstr ""

#. type: Plain text
#: projects.txt:37
msgid ""
"These plugins, combined with \"command compatibility\" plugins will allow "
"gnucap to be used as a drop-in replacement for commercial simulators in some "
"applications."
msgstr ""

#. type: Plain text
#: spectre.txt:28
msgid "The syntax is: \"model\" newname itsmaster parameters"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:33 spectre.txt:46
#, no-wrap
msgid "**Arguments** : A list of arguments (parameters or values).  All arguments are name - value pairs, of the form \"name = value\", whitespace delimited.  In Spectre, the value may be an expression.  In gnucap, for now, the value must be an actual value or parameter name.\n"
msgstr ""

#. type: Plain text
#: spectre.txt:35
#, no-wrap
msgid "  model gp-npn npn bf=150\n"
msgstr ""

#. type: Plain text
#: spectre.txt:41
msgid ""
"All components have the same syntax:\\\\ label (port list) type arguments"
msgstr ""

#. type: Plain text
#: spectre.txt:61
#, no-wrap
msgid ""
"  subckt amp (out in vcc)\n"
"  parameters rload=10k\n"
"  Rb1  (base vcc) resistor r=1M   // 1 megohm\n"
"  Rb2  (base 0  ) resistor r=100k\n"
"  Rc   (col  vcc) resistor r=100k\n"
"  Re   (emit 0  ) resistor r=10k\n"
"  Ce   (emit 0  ) capacitor c=1m  // 1 millifarad\n"
"  Cin  (base in ) capacitor c=1u\n"
"  Q1 (col base emit) gp-npn\n"
"  Q2 (vcc col e2) gp-npn\n"
"  Re2  (e2   0  ) resistor r=1k\n"
"  Cout (e2   out) capacitor c=10u\n"
"  Rload (out 0  ) resistor r=rload\n"
"  ends amp\n"
msgstr ""

#. type: Plain text
#: spectre.txt:65
#, no-wrap
msgid ""
"  Vcc (vcc 0) vsource dc=15\n"
"  Vin (in  0) vsource ac=1\n"
"  Rload (out 0) resistor r=10k\n"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:99
#, no-wrap
msgid "The \"master\" must be before it is referenced.\n"
msgstr ""

#. type: Bullet: '  * '
#: spectre.txt:99
#, no-wrap
msgid "The circuit must be before any commands using it, unless you want to simulate a partial circuit.  Scripted and interactive modifications to the circuit are done the way gnucap usually does.\n"
msgstr ""

#. type: Title ======
#: start.txt:1
#, no-wrap
msgid "Gnucap Wiki"
msgstr ""

#. type: Plain text
#: start.txt:4
msgid "Gnucap is the GNU Circuit Analysis Package"
msgstr ""

#. type: Plain text
#: start.txt:6
msgid ""
"Gnucap is a modern post-spice circuit simulator with several advantages over "
"Spice derivatives."
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[about|About Gnucap, the sales pitch]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[http://gnucap.org/gnucap.html|Old web site]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[http://savannah.gnu.org/mail/?group_id=562|Mailing lists]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "Download: [[http://www.gnucap.org/devel|Development snapshots]] [[http://www.gnucap.org/archive|Old stable versions]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "Development: [[http://savannah.gnu.org/projects/gnucap|Savannah]] [[http://git.savannah.gnu.org/cgit/gnucap.git|GIT repository]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "Help wanted: [[projects]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[http://gnucap.org/gnucap-man-html/index.html|Stable version (0.35) manual]] [[http://gnucap.org/gnucap-man.pdf|pdf]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[manual|Snapshot manual]]\n"
msgstr ""

#. type: Bullet: '  * '
#: start.txt:16
#, no-wrap
msgid "[[gnucap:user:user|User contributions]]\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:2
#, no-wrap
msgid "**1.ALIAS**\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:4
msgid "Purpose:Creates an alias for command"
msgstr ""

#. type: Plain text
#: user/alias.txt:6 user/alter.txt:6 user/aspice.txt:6 user/cls.txt:6
#: user/colon_command.txt:6 user/colon_commmand.txt:6 user/command.txt:6
#: user/def.txt:6 user/echo.txt:6 user/history.txt:6 user/mdump.txt:6
#: user/set.txt:6 user/setv.txt:6 user/shell.txt:6 user/strcmp.txt:6
#: user/sysinfo.txt:6 user/unalias.txt:6 user/undef.txt:6 user/version.txt:6
msgid "Status:Implemented"
msgstr ""

#. type: Plain text
#: user/alias.txt:8 user/alter.txt:9 user/colon_command.txt:8
#: user/colon_commmand.txt:8 user/command.txt:8 user/def.txt:8 user/echo.txt:8
#: user/history.txt:8 user/mdump.txt:8 user/quit.txt:8 user/shell.txt:8
#: user/strcmp.txt:8 user/sysinfo.txt:8 user/unalias.txt:8 user/undef.txt:8
#: user/version.txt:8
msgid "Syntax:"
msgstr ""

#. type: Plain text
#: user/alias.txt:10
#, no-wrap
msgid "    alias [word] [command]\n"
msgstr ""

#. type: Plain text
#: user/alias.txt:12 user/aspice.txt:13 user/cls.txt:12
#: user/colon_command.txt:12 user/colon_commmand.txt:12 user/command.txt:12
#: user/def.txt:12 user/echo.txt:12 user/history.txt:14 user/mdump.txt:13
#: user/set.txt:12 user/setv.txt:12 user/shell.txt:12 user/strcmp.txt:13
#: user/sysinfo.txt:12 user/unalias.txt:13 user/undef.txt:13
#: user/version.txt:12
msgid "Comments:"
msgstr ""

#. type: Plain text
#: user/alias.txt:14
msgid "Command creates an alias for command with the name word."
msgstr ""

#. type: Plain text
#: user/alias.txt:16 user/alter.txt:18 user/aspice.txt:19
#: user/colon_command.txt:16 user/colon_commmand.txt:16 user/command.txt:16
#: user/def.txt:16 user/echo.txt:16 user/history.txt:18 user/mdump.txt:17
#: user/netlist_import_and_export.txt:123 user/noise_implementation.txt:30
#: user/noise_syntax.txt:19 user/quit.txt:15 user/set.txt:16 user/setv.txt:16
#: user/shell.txt:18 user/strcmp.txt:17 user/sysinfo.txt:16
#: user/unalias.txt:19 user/undef.txt:17 user/version.txt:16
msgid "Example:"
msgstr ""

#. type: Plain text
#: user/alias.txt:24
#, no-wrap
msgid ""
"     gnucap>alias info sysinfo\n"
"     gnucap>info\n"
"     Model name\t        : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"     OS Description     :\"Ubuntu 12.04 LTS\"\n"
"     CPU MHz\t        : 2494.409\n"
"     RAM Available      :1012348kB\n"
"     RAM Free           :132372kB\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:2
#, no-wrap
msgid "**13.ALTER**\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:4
msgid "Purpose:Command is used to change the value of a parameter."
msgstr ""

#. type: Plain text
#: user/alter.txt:12
#, no-wrap
msgid ""
"      alter\n"
"      alter parameter-name value\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:15
msgid "Comments:Sets the value of specified parameter"
msgstr ""

#. type: Plain text
#: user/alter.txt:20
msgid "To modify the value of vcc in a ciruit"
msgstr ""

#. type: Plain text
#: user/alter.txt:23
#, no-wrap
msgid ""
"      gnucap>alter vcc = 15\n"
"      gnucap>\n"
msgstr ""

#. type: Plain text
#: user/alter.txt:25
msgid "and to modify the resitances say R1 and R2"
msgstr ""

#. type: Plain text
#: user/alter.txt:28
#, no-wrap
msgid ""
"       gnucap>alter R1=5k R2=100\n"
"       gnucap>\n"
msgstr ""

#. type: Plain text
#: user/another_page.txt:1
msgid "not another page"
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:2
msgid "====Why Asco?===="
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:4
msgid ""
"[[http://asco.sourceforge.net|Asco]] is a small C program that implements "
"several numerical optimizers and interfaces to some circuit simulators. asco "
"(version 0.4.8) does not particularly support gnucap as a backend, but "
"rather provides a generic interface to any program that processes text "
"somehow."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:6
msgid ""
"while the functionality of asco could well be integrated into gnucap, it "
"seems easier to do it this way. also it always makes sense to provide "
"alternatives, considering that asco is quite worthless without a simulator. "
"otoh, asco then can be use to benchmark gnucap, motivate measurement "
"extensions for gnucap etc."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:8
msgid "====Implementation===="
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:10
msgid ""
"the proposed implementation [[git://tool.em.cs.uni-frankfurt.de/git/asco|"
"here]] works with gnucap. some provided examples (inv, amp3) are adapted "
"accordingly. here, in contrast to asco-0.4.8, the simulator is running "
"interactively. this not only runs much faster (skipping extra "
"initialization), but also is simpler to use, as much less input needs to be "
"generated, and less output needs to be processed."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:13
msgid ""
"gnucap needs to be patched to not throw (debug) garbage to stdout.  that "
"might improve with output plugins. of course some problems arise from using "
"spice (as a 'language')."
msgstr ""

#. type: Plain text
#: user/asco_for_gnucap.txt:14
msgid ""
"this approach (and asco in general) needs a lot of work. this is a place to "
"start..."
msgstr ""

#. type: Plain text
#: user/aspice.txt:2
#, no-wrap
msgid "**23.ASPICE**\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:4
msgid ""
"Purpose:Start an asynchronous run and loads the data to specified output "
"file."
msgstr ""

#. type: Plain text
#: user/aspice.txt:9
#, no-wrap
msgid ""
"Syntax:\n"
"      aspice input_file output_file\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:15
msgid ""
"input_file is a file which is to be run in batch mode and output_file "
"corresponds to the file on which data will be loaded.If output_file already "
"exists then the contents of the file are overwritten by the current output."
msgstr ""

#. type: Plain text
#: user/aspice.txt:21
msgid ""
"Suppose my script file contains an instruction to execute the version "
"command.Then,command to get the output of the script into another file say, "
"version.txt is"
msgstr ""

#. type: Plain text
#: user/aspice.txt:26
#, no-wrap
msgid ""
"      gnucap>aspice script version.txt\n"
"      Gnucap\n"
"      Main version: 2009.12.07 RCS 26.136\n"
"      gnucap>\n"
msgstr ""

#. type: Plain text
#: user/aspice.txt:28
msgid "Now,version.txt contains the output of version command."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:2
msgid ""
"compling/installing/loading plugins must be as easy as possible. there are "
"three kinds of modules that need to taken into account."
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Plugins shipped and installed within gnucap\n"
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Device models, compiled locally, simulation based\n"
msgstr ""

#. type: Bullet: '  - '
#: user/build_system_for_plugins.txt:6
#, no-wrap
msgid "Plugins from other sources, compiled out-of-tree, installable.\n"
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:8
msgid ""
"Assume (upstream) gnucap ships a plugin (s_fancy.so). what would a user want "
"to do? load it. that means, she expects the command \"load s_fancy.so\" to "
"load the module, just like she would type \"modprobe fancy\" when loading a "
"kernel module. thus, two things must match: the path where plugins are "
"installed to, and the path where gnucap is looking for modules. the install "
"path is nothing seriously exotic, and already implemented in autotools, it's "
"called \"pkglibdir\". gnucap uses 'dlopen' (see dlopen(3)) to load modules. "
"that means it looks for dynamic libraries, where the system keeps dynamic "
"libraries, which is in /lib, /usr/lib etc. the common way to make it look "
"for modules in pkglibdir is linking with the rpath flag, which sets RPATH, "
"see chrpath(1). basically this means, the path where plugins lie around is "
"hardcoded in the gnucap binary. which totally makes sense, esp. if you want "
"to have more than one gnucap, lets say for developing purposes."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:10
msgid ""
"in order to compile a device model, we need to know where the headers are. "
"usually the preprocessor looks for them in /usr/include, but that's _not_ "
"where we want them to be. so gnucap better ships an executable that simply "
"tells us the search path, or alternatively the CPPFLAGS we need to pass to "
"the preprocessor. this executable could be a shell script that takes a "
"switch and prints a line accordingly. needless to say that gnucap must "
"install headers for this to work."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:12
msgid ""
"how would you want to install plugins from other sources? as simple as "
"possible: wget plugin.tbz2; tar -xf !$; cd plugin; less README; ./"
"configure_orwhateverelse; make install. the problem: we need to know where "
"to install to. probably 'chrpath $(which gnucap) | sed -e s/.*RPATH=//' is "
"not portable. so we add a switch to the script above that makes it print "
"pkglibdir."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:14
msgid ""
"(for everyone who has ever compiled (linux) kernel modules: yes, it would be "
"nice to have makefiles for staged plugins, but this totally looks like "
"overkill to me)"
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:18
msgid ""
"and finally, this has been implemented already: there are some repos on "
"git://tool.em.cs.uni-frankfurt.de/git/ \"gnucap\" contains a branch \"gnucap"
"+dev\" with minimal changes above 0.36 to make this work.  in \"gnucap-geda"
"\" (master) i've packed lang_gschem that way. \"gnucap-adms\" (\"master\") "
"contains a model compiler (in \"master\") that ships 2 example plugins and "
"an out-of-tree compile helper script."
msgstr ""

#. type: Plain text
#: user/build_system_for_plugins.txt:19
msgid ""
"some plugins need upstream changes or forked gnucap versions. the best way "
"would be to have the plugin build system just check for a particular hack "
"and give up with a notice (not implemented yet)."
msgstr ""

#. type: Plain text
#: user/circbyline.txt:2
#, no-wrap
msgid "**21.CIRCBYLINE**\n"
msgstr ""

#. type: Plain text
#: user/circbyline.txt:4
msgid "Purpose:Enter a circuit line by line."
msgstr ""

#. type: Plain text
#: user/circbyline.txt:5 user/rmcirc.txt:5 user/run.txt:5 user/showmod.txt:5
#: user/source.txt:5
msgid "Status:Done"
msgstr ""

#. type: Plain text
#: user/cls.txt:2
#, no-wrap
msgid "**CLS**\n"
msgstr ""

#. type: Plain text
#: user/cls.txt:4
msgid "Purpose:Clears the gnucap interpreter"
msgstr ""

#. type: Plain text
#: user/cls.txt:10
#, no-wrap
msgid ""
"Syntax:\n"
"      cls\n"
"      cls [command]\n"
msgstr ""

#. type: Plain text
#: user/cls.txt:15
msgid ""
"A command can be issued with cls,it first clears the interpreter and then "
"run th command.  A bare cls simply clears the interpreter."
msgstr ""

#. type: Plain text
#: user/cls.txt:18
msgid ""
"Example: Following command first clears the screen and then runs the command "
"'sysinfo'."
msgstr ""

#. type: Plain text
#: user/cls.txt:25
#, no-wrap
msgid ""
"       gnucap>cls sysinfo\n"
"       Model name\t  : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"       OS Description     :\"Ubuntu 12.04 LTS\"\n"
"       CPU MHz\t          : 2494.409\n"
"       RAM Available      : 1012348kB\n"
"       RAM Free           : 132372kB\n"
"       gnucap>\n"
msgstr ""

#. type: Title ===
#: user/code-related_stuff.txt:1 user/noise_implementation.txt:53
#, no-wrap
msgid "Code related stuff"
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:4 user/noise_implementation.txt:56
msgid ""
"Currently noise simulation is implemented as plugin which is available at "
"github at the following [[ https://github.com/gserdyuk/gnucap-plugins | "
"link ]]"
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:6 user/noise_implementation.txt:58
msgid "It re-uses s_ac.cc file (ac simulation) to implement noise analysis."
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:8 user/noise_implementation.txt:60
msgid ""
"At the present moment (April 2011) noise works with only [[https://github."
"com/gserdyuk/gnucap-a | gnucap-a]] branch of gnucap, but hopefully soon it "
"will work with main trunk too."
msgstr ""

#. type: Plain text
#: user/code-related_stuff.txt:9 user/noise_implementation.txt:62
msgid "[TBD - make description of the noise code]"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:2 user/colon_commmand.txt:2 user/command.txt:2
#, no-wrap
msgid "**20. '':'' Command**\n"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:4 user/colon_commmand.txt:4 user/command.txt:4
msgid ""
"Purpose: command : issued with multiple commands separated by semi-colon "
"runs each command one by one."
msgstr ""

#. type: Plain text
#: user/colon_command.txt:10 user/colon_commmand.txt:10 user/command.txt:10
#, no-wrap
msgid "     : command_1;command_2;.....;command_n\n"
msgstr ""

#. type: Plain text
#: user/colon_command.txt:14 user/colon_commmand.txt:14 user/command.txt:14
msgid ""
"Any number of commands may be passes to the : command. Shell commands passed "
"with ! command are not executed.Like, :!ls will fail to run."
msgstr ""

#. type: Plain text
#: user/colon_command.txt:26 user/colon_commmand.txt:26 user/command.txt:26
#, no-wrap
msgid ""
"      gnucap>: ver\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      gnucap>: ver;echo \"Hello World!\"\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      Hello World!\n"
"      gnucap>: strcmp \"Hello\" Hello;def f;shell\n"
"      flag=0\n"
"      >x^2+y^2\n"
"      itsrishre@rishabh-laptop:~$exit\n"
"      gnucap>\n"
msgstr ""

#. type: Title ======
#: user/command_plugins.txt:1
#, no-wrap
msgid "Commands Checklist"
msgstr ""

#. type: Plain text
#: user/command_plugins.txt:6
msgid ""
"Gnucap commands are defined by plugins.  This section defines all commands "
"supplied in the gnucap-WIP branch."
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:13
#, no-wrap
msgid "[[MDUMP]] - Prints the dc tran matrix values.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:15
#, no-wrap
msgid "[[RMCIRC]] - Removes the current circuit from the list of circuits sourced into gnucap.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:17
#, no-wrap
msgid "[[CIRCBYLINE]] - Enter a circuit line by line.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:19
#, no-wrap
msgid "[[PRE]] - Executes command prior to parsing the circuit.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:21
#, no-wrap
msgid "[[TRACE]] - Command is used to trace nodes.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:27
#, no-wrap
msgid "[[SHOWMOD]] - Lists model parameter values.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:29
#, no-wrap
msgid "[[ALTER]] - Change parameters\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:35
#, no-wrap
msgid "[[SOURCE]] - Loads a gnucap input file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:37
#, no-wrap
msgid "[[HISTORY]] - Review the previous commands.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:39
#, no-wrap
msgid "[[RUN]] - Run the silumation as specified in the input file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:41
#, no-wrap
msgid "[[ASPICE]] - Start an asynchronous run and loads the data to specified output file.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:49
#, no-wrap
msgid "[[ALIAS]] - Creates an alias for command.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:51
#, no-wrap
msgid "[[CLS]] - Clears the gnucap interpreter.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:53
#, no-wrap
msgid "[[DEF]] - Command is used to define a function.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:55
#, no-wrap
msgid "[[ECHO]] - Prints the text.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:57
#, no-wrap
msgid "[[QUIT]] - Terminates the gnucap interpreter.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:59
#, no-wrap
msgid "[[SETV]] - Sets the value of a variable.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:61
#, no-wrap
msgid "[[SHELL]] - Calls the command interpreter of operating system.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:63
#, no-wrap
msgid "[[STRCMP]] - Compares two string.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:65
#, no-wrap
msgid "[[SYSINFO]] - Command prints the system information.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:67
#, no-wrap
msgid "[[UNALIAS]] - Removes the definition for each alias name specified.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:69
#, no-wrap
msgid "[[UNDEF]] - Command removes the the user-defined functions.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:71
#, no-wrap
msgid "[[VERSION]] - Prints the version of gnucap being used.\n"
msgstr ""

#. type: Bullet: '* '
#: user/command_plugins.txt:73
#, no-wrap
msgid "[[Colon Command]] - Command '':'',a colon, issued with multiple commands separated by semi-colon runs each command one by one.\n"
msgstr ""

#. type: Plain text
#: user/command_plugins.txt:74
#, no-wrap
msgid "*//Commands's Syntax,Details and Examples will be added after the command is implemented.//\n"
msgstr ""

#. type: Plain text
#: user/def.txt:2
#, no-wrap
msgid "**2.DEF**\n"
msgstr ""

#. type: Plain text
#: user/def.txt:4
msgid "Purpose:Command is used to define a function."
msgstr ""

#. type: Plain text
#: user/def.txt:10
#, no-wrap
msgid "    def [function_name]\n"
msgstr ""

#. type: Plain text
#: user/def.txt:14
msgid ""
"Maximum three arguments can be provided which can be of type int or float."
"Variables are named x,y,z by default and only these variables should be used "
"in the expression."
msgstr ""

#. type: Plain text
#: user/def.txt:27
#, no-wrap
msgid ""
"      gnucap>def f\n"
"      >x*2+y*2+z*2\n"
"      gnucap>f(1,2,3)\n"
"      12.\n"
"      gnucap>f(1.0,2.2,3.4)\n"
"      13.2\n"
"      gnucap>def max\n"
"      >(x>y)*x+(x<=y)*y\n"
"      gnucap>max(3.0,4.0)\n"
"      4.0\n"
"      gnucap>\n"
msgstr ""

#. type: Title ======
#: user/details_of_geda_plugin.txt:1
#, no-wrap
msgid "Details of the implementation of the gEDA/gschem plugin======"
msgstr ""

#. type: Plain text
#: user/details_of_geda_plugin.txt:19
#, no-wrap
msgid ""
"=====Introduction=====\n"
"The plugin for parsing and printing schematic files in the gEDA/gschem format is at <sup>[1]</sup> [[https://github.com/sksavant/gnucap/tree/lang_gschem/|Github branch]]. \\\\\n"
"Get it by cloning the git repo : //git clone git@github.sksavant/gnucap.git --branch lang_gschem//\n"
"or get this zip file : [[https://github.com/sksavant/gnucap/zipball/lang_gschem|zipfile]]\n"
"\\\\ \\\\\n"
"If you already have latest snapshot of gnucap installed you just need to get the following files: '//src/lang_gschem.cc//', '//src/d_net.cc//', '//src/d_place.cc//'. Also some [[https://github.com/sksavant/gnucap/compare/al...lang_gschem#diff-53|change]] is need in lang_verilog.cc to print verilog code correctly.\n"
"Some examples are present in '//geda/examples/ //'\n"
"\\\\ \\\\\n"
"After getting the files compile the plugin with the following command: \\\\\n"
"    g++ -DHAVE_GEDA -shared -fPIC -o lang_geda.so lang_geda.cc d_net.cc d_place.cc  $(pkg-config --cflags gtk+-2.0 --libs libgeda)\n"
"And load it after running gnucap as follows: \\\\\n"
"    gnucap>load ./lang_geda.so\n"
"This line can be added to '~/.gnucaprc' to load the plugin every time gnucap starts. \\\\\n"
"Switch the language to gEDA/gschem with the following command:\n"
"    gnucap>option lang=gschem OR\n"
"    gnucap>gschem\n"
msgstr ""

#. type: Plain text
#: user/details_of_geda_plugin.txt:44
#, no-wrap
msgid ""
"=====How parsing works in lang_geda=====\n"
"When the command 'gschem' is given, [[http://sksavant.github.com/gnucap/d0/d46/classanonymous__namespace_02lang__geda_8cc_03_1_1_c_m_d___g_s_c_h_e_m.html#a3a2cad7bedd3a820604937467e020369|CMD_GSCHEM::do_it]] is called.\n"
"After setting the language to gschem,  [[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a164f7c8baeadf6b7acfca754153a45b5|parse_top_item]] is called, which will call [[http://sksavant.github.com/gnucap/d8/d92/class_l_a_n_g_u_a_g_e.html#a1ecab49c51a0f6d914170c04edb420a8|new__instance]] after getting a line from the command stream. \\\\\n"
"Now depending on the type of the line parsed, which is found from [[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#af6b409e3eb2cf7d30080fbb989e0989d|find_type_in_string]], corresponding parse_.. function is called.\n"
"If a //command// or //dev_comment// is got, [[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a6c16c20ae8bb07669183e0a3a6c87da8|parse_command]] or [[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#a23093bf34decc6675ef6b917829c491c|parse_comment]] is called respectively. \\\\ \\\\\n"
"If component is found, then [[http://sksavant.github.com/gnucap/d2/d22/classanonymous__namespace_02lang__geda_8cc_03_1_1_c_m_d___c.html#a7c6d49a0e81fde05d6f402ac895596f5|CMD_C::do_it]] is called, which\n"
"  * creates a new empty placeholder model (MODEL_SUBCKT)\n"
"  * calls [[http://sksavant.github.com/gnucap/d8/df9/classanonymous__namespace_02lang__geda_8cc_03_1_1_l_a_n_g___g_e_d_a.html#abb190d7c72473be3e72c16323673e73e|parse_componmod]] which will\n"
"    * get the symbol file name\n"
"    * parse the symbol file and set the ports by name\n"
"    * resets the cmd\n"
"    * returns NULL if the model is not needed i.e, it is graphical\n"
"  * If the model is not graphical ,push back into the CARD_LIST\n"
"  * set componentname as the label of the model and componentmod as false and call new<nowiki>__</nowiki>instance.\n"
"If net or place or any other is got, parse_instance is called which will call respective parse_ functions.\\\\\n"
"When parse_net is called it will :\n"
"  * Get the x y coordinates of the two ports\n"
"  * parse the symbol file\n"
"  * Call create_place which will create a CS with the place parameters and  parse it through new<nowiki>__</nowiki>instance.\n"
"  * Check if there are any attributes after this line, parse them into set_param_by_name '{..}\n"
"If a component is got, call parse_component which will :\n"
"  * Get the position, angle, mirror flag and the symbol file name of the component\n"
"  * Parse the symbol file associated with the component to get the ports and get the ports' coordinates relative to the component.\n"
"  * Depending on the angle and mirror flag, get the absolute position of the ports of the component, create a new place with the position of nodes and call set_port_by_index to set the ports\n"
"  * Check if there are any attributes after this line, parse them into set_param_by_name '{..}\n"
msgstr ""

#. type: Plain text
#: user/discussions.txt:15
#, no-wrap
msgid ""
"is there a need for s_noise.cc? noise seems to be just about probes.\n"
"in e_aux.h a function like\n"
"<code cpp>\n"
"inline COMPLEX port_noise(const node_t& n1, const node_t& n2){\n"
"  std::fill_n(CKT_BASE::_sim->_sens, 1*CKT_BASE::_sim->_total_nodes+1, 0);\n"
"  CKT_BASE::_sim->_sens[n1.m_()] = 1;\n"
"  CKT_BASE::_sim->_sens[n2.m_()] = -1;\n"
"  CKT_BASE::_sim->_acx.fbsubt(CKT_BASE::_sim->_sens); // use Gennadys transposed fbsub\n"
"  double a = CARD_LIST::card_list.do_noise();\n"
"  return a;\n"
"}\n"
"</code>\n"
"could be used to probe the noise (called in e_element.cc and e_node.cc just like port_impedance is called).\n"
"of course an array with sensitivity data needs to be added to SIM, also do_noise() must sum up all noise contributions like in Gennadys implementation.\n"
msgstr ""

#. type: Plain text
#: user/discussions.txt:17
msgid ""
"imo noise simulation is a bad candidate for a plugin, as there seems to be "
"no way to make it work without changing internals. once noise works, a "
"plugin that implements spice command compatibility might make more sense."
msgstr ""

#. type: Plain text
#: user/discussions.txt:18
msgid "--felixs"
msgstr ""

#. type: Plain text
#: user/echo.txt:2
#, no-wrap
msgid "**3.ECHO**\n"
msgstr ""

#. type: Plain text
#: user/echo.txt:4
msgid "Purpose:Prints the text"
msgstr ""

#. type: Plain text
#: user/echo.txt:10
#, no-wrap
msgid "     echo [text]\n"
msgstr ""

#. type: Plain text
#: user/echo.txt:14
msgid "Command echoes the text in the interpreter."
msgstr ""

#. type: Plain text
#: user/echo.txt:23
#, no-wrap
msgid ""
"     gnucap> echo\n"
"     Usage: echo [text]\n"
"     gnucap>echo \"Hello\"\n"
"     \"Hello\"\n"
"     gnucap>echo Hello World!\n"
"     Hello World!\n"
"     gnucap>\n"
msgstr ""

#. type: Title ===
#: user/gnucap_linear_solver.txt:1
#, no-wrap
msgid "GNucap Linear Solver"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:3
msgid ""
"Gnucal linear solver is implemented in file m_matrix.h - that is C++ "
"template."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:6
msgid ""
"Most things are depicted in very extensive comments to this file.  Some "
"things which are discovered and are listed here."
msgstr ""

#. type: Title ==
#: user/gnucap_linear_solver.txt:7
#, no-wrap
msgid "No zero diagonal element allowed"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:10
msgid "Solver has an issue if diagonal element is zero. lets consider system:"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:16
#, no-wrap
msgid ""
"<code>\n"
"  | eps   -1|        | -1 |\n"
"  |         | *X  =  |    |\n"
"  | 10   -10|        |  0 |\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:18
msgid ""
"if eps =0 or close to 0 (like 1.e-20 or so) current solver gives wrong "
"answer of {1,0}."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:20
msgid "having eps=1.e-6 answer id ok = {1,1}"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:22
msgid ""
"This may be explained that during LU decomposition with no permutations with "
"very small eps some values may grow higher 1/machine_eps and mask "
"significant digits."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:26
msgid ""
"Practical advice: Do not use .options gmin smaller than 1.e-6 .. 1.e-8 "
"unless you know what you do.  With current solver in my distort results ."
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:28
msgid "Note - spice circuit which creates this system:"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:38
#, no-wrap
msgid ""
"<code>\n"
"* circuit - close to Rozenbrok\n"
".options nobypass\n"
".options gmin = 1.e-6\n"
"* i1 = 10 *( v2 - v1^2)\n"
"* i2 = 1 - v1\n"
"*\n"
"I1  1 0      dc 0\n"
"G11 1 0 1 0  -10\n"
"G11 1 0 2 0   10\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:41
#, no-wrap
msgid ""
"G21 2 0 1 0   -1\n"
"I2  2 0      dc 1\n"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:43
msgid ".print op v(1) v(2) i(I1) i(I2)"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:46
msgid ".op .end"
msgstr ""

#. type: Plain text
#: user/gnucap_linear_solver.txt:47 user/language_plugin_for_gschem.txt:160
msgid "</code>"
msgstr ""

#. type: Title ===
#: user/gnucap_nonlinear_solver.txt:1
#, no-wrap
msgid "Gnucap Nonlinear Solver"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:4
msgid ""
"This sections will describe my (gserdyuk) analysis of gnucap nonlinear "
"solver, comparison of it to classic Newton notation and notes which will "
"appear on the course of the study."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:5
#, no-wrap
msgid "Classic Newton Notation"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:8
msgid "Let us consider vector system of equations"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:10
msgid "'' F = Y*X + N(X) + I =0 (1) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:16
#, no-wrap
msgid ""
"where\n"
"  * Y - linear matrix (here - impedance)\n"
"  * X - unknows (here - node voltages)\n"
"  * N(X) - currents of nonlinear branches\n"
"  * I - free vector\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:18
msgid "To solve that simultaneous equations with newton algorithms:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:20
#, no-wrap
msgid "''F_c = F(X_c)                  (2)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:22
#, no-wrap
msgid "''S_c = inv(dF/dX)*F_c;         (3)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:24
#, no-wrap
msgid "''X_n = X_c-S_c;                (4)''\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "X_c - current vector of independent values\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "F_c - current value of nonlinear function  (1)\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "S_c - step at current iteration\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "dF/dX = J - jacobian matrix, calculated at value X_c\n"
msgstr ""

#. type: Bullet: '  * '
#: user/gnucap_nonlinear_solver.txt:30
#, no-wrap
msgid "X_n - vector of independent values at next step\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:32
msgid ""
"Note - this formula does not contain damp factor - it will e considered later"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:34
msgid ""
"Such series of X_c have to converge to solution point X_* where F(X_*)=0."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:35
#, no-wrap
msgid "Newton in Gnucap - simplest case"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:38
msgid ""
"//Simplest case of Newton method in gnucap - no damping, no incremental "
"calculation.//"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:40
msgid ""
"Gnucap uses a bit modified formulation of formulas (2) - (4) to solve same "
"equations (1)."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:42
#, no-wrap
msgid "'' FG(X) = dN/dX*X_c-N(X)-I;     (5) ''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:44
#, no-wrap
msgid "'' FG_c  = FG(X_c) ;         (6) ''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:46
msgid "'' X_n = inv(J)*FG = inv(J)*(dN/dX*X_c-N-I) ; (7) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:48
msgid "'' J = dF/dX ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:50
msgid "'' where FG, dF/dx, dN/dX and N are calculated in point X_c ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:56
#, no-wrap
msgid ""
"namely:\n"
"  - a) Modified error function does not contain linear term Y*X;\n"
"  - b) Jacobian in gnucap formulation is the same as in original formulation ( dF/dx, not dFG/dx ) ;\n"
"  - c) solution of equaton (7) gives new X point instead of the newtonian step.\n"
"  - d) values dN/dX(X_c) - N(X_c) are calculated from each device whoich operation point is changed - so it saves computation resources.\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:58
msgid "Indeed. Lets make substitutions:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:60
msgid "'' X_n = X_c-inv(J)*F = X_c-inv(J)*(I+N+Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:62
msgid "'' = inv(J)*J*X_c-inv(J)*(I+N+Y*X_c) = inv(J)*(J*X_c-I-N-Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:64
msgid "'' = inv(J)*(dN/dX*X_c+Y*X_c-I-N-Y*X_c) = ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:66
msgid "finally"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:68
msgid "'' = inv(J)*(dN/dX*X_c-I-N); ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:71
msgid "Where all values J, dN/dX, N are caluclaed in point X_c Note that"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:73
msgid "'' J= dF/dX = dN/dX+Y (8) ''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:75
msgid "This has some consequences (see below)."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:76
#, no-wrap
msgid "Damping"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:78
msgid "Damped Newton instead of update formula (4) uses smaller step:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:80
#, no-wrap
msgid "''X_n = X_c-k_c*S_c;                (9)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:82
msgid "where k is damping factor."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:84
msgid ""
"There is formal proof that process (9) converges globally under certain "
"conditions and keeps quadratic convergence rate if k=1."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:86
msgid ""
"I.e. at the some iteration \"current\", when next point X_n is calculated, "
"reduced step is used. After that, F and J are caclulated exactly at value "
"X_n."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:87
#, no-wrap
msgid "Damping in Gnucap"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:90
msgid "Gnucap implements somehow modified approach here too."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:92
msgid ""
"When X_n is calculated, Gnucap computes element parameters at value X_n, but "
"then calculates FG and J as:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:94
msgid "''FG_n = (1-k)*FG(X_c) + k*FG(X_n)  (10)''"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:96
#, no-wrap
msgid "''J_n  = (1-k)*J(X_c)  + k*J(X_n)   (11)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:98
msgid ""
"Thus FG_c and J_c are linear interpolation between FG(X_c)=FG_c and FG_n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:100
msgid "But should be"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:102
#, no-wrap
msgid "''FG_c=FG( (1-k)*X_c+k*X_n )       (12)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:104
msgid "Same for Jacobian."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:106
msgid ""
"This excludes from consideration higher order derivatives of F(X) and "
"(partially)  reduces sense of dumping."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:108
msgid ""
"//NB. This is my understanding of Gnucap gumping. If somebody have different "
"opinion - please post it here.//"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:111
msgid ""
"Currently is planned to implement solver which will use 12 instead of 10,11. "
"I will report results of numeric experiments."
msgstr ""

#. type: Title ==
#: user/gnucap_nonlinear_solver.txt:113
#, no-wrap
msgid "Calculation of Error function and error norm"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:117
msgid ""
"To implement linear search along Newtonian direction it is desired to have "
"strict measure - is next point is better than current or not.  Such measure "
"can be F or ||F|| - indeed - at solution point we have F=0 and ||F||=0."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:119
msgid ""
"Unfortunately Gnucap formulation does not give F, but rather calculate FG, "
"which does not tend to zero as X_c -> X*. So - new measure has to eb "
"introduced."
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:121
msgid "To calculate F we can use the following formula:"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:123
#, no-wrap
msgid "''F_c = J_c * X_c - FG   (13)''\n"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:125
msgid ""
"This will require keeping original Jacobian matrix. In case of incremental "
"processing it may mean an issue - we will investigate incremental processing "
"later"
msgstr ""

#. type: Title ===
#: user/gnucap_nonlinear_solver.txt:127
#, no-wrap
msgid "Other Sections"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:130
msgid ""
"[[NewtonNumericExample1 | Newton Numeric Example ]] - compares standard and "
"modified newton steps; damped step"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:132
msgid ""
"[[ProgramingDetails | Programing Details ]] - describeы programming details "
"of solver"
msgstr ""

#. type: Plain text
#: user/gnucap_nonlinear_solver.txt:134
msgid ""
"[[QueuesAndOPtBypass | Queues and OPT::bypass ]] - covers **bypass** mode "
"and queues"
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:3
msgid ""
"The verilog-ams specification adds on to the verilog, (IEEE-1364-2001 or "
"IEEE-1364-2005), versions.  I will be testing cross workability with Icarus "
"Verilog of the same spec year."
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:7
msgid ""
"I'm not sure yet which verilog-ams version we will use to match up with "
"netlist verilog, and not sure about needing to read the IEEE verilog specs "
"-- they're not freely available.  Acellera.org free publishes Verilog-AMS "
"Language Reference Manual, Release 2.3.1 last changed June 1, 2009."
msgstr ""

#. type: Plain text
#: user/gnucap_verilog_reconciled.txt:9
msgid ""
"It may be that running a quick sanity test of netlists with icarus verilog "
"will catch blunders as well as reading IEEE-1364-2005."
msgstr ""

#. type: Plain text
#: user/history.txt:2
#, no-wrap
msgid "**4.HISTORY**\n"
msgstr ""

#. type: Plain text
#: user/history.txt:4
msgid "Purpose:Review the previous commands"
msgstr ""

#. type: Plain text
#: user/history.txt:12
#, no-wrap
msgid ""
"    history\n"
"    history -t\n"
"    history -s\n"
msgstr ""

#. type: Plain text
#: user/history.txt:16
msgid ""
"Command prints the history of commands that has been executed after enabling "
"the history track mode. Commands tracking can be stopped by disabling the "
"history mode."
msgstr ""

#. type: Plain text
#: user/history.txt:21
#, no-wrap
msgid ""
"      gnucap>history -t  starts tracking history\n"
"      gnucap>history     prints the history\n"
"      gnucap>history -s  stops tracking history\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:3
msgid ""
"the gnucap ''bm_'' framework can be used to plug in impulse response filters "
"to elements.  with these, filtering is as simple as this:"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:10
#, no-wrap
msgid ""
"  spice\n"
"  .model sfir fir coefs=(1,0,-1,1,1,1,1,0,0,-1) step=1m\n"
"  .model sir int_filter step=0.1m\n"
"  v1 nin 0 1\n"
"  e1 nout 0 nin 0 sfir\n"
"  e2 nint 0 nin 0 sir\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:14
#, no-wrap
msgid ""
"  .print tran v(nin) v(nint) v(nout) Vout(e1)\n"
"  .tran 0 2m 0.02m basic\n"
"  .end\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:16
msgid ""
"here ''sfir'' is a finite impulse reponse filter with 10 coefficients. "
"''sir'' is an integrating filter, which is implemented similarly to the "
"other ''iirs'' (but more efficient). in ac analysis, the filter transfer "
"function can be computed using libfftw."
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:18
msgid ""
"these filters can also be used to generate alpha-noise from white noise. "
"gnucap could get this in a netlist:"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:25
#, no-wrap
msgid ""
"  V0   n0   0 noise r=1 amp=0.1 step=0.1m alpha=0\n"
"  V0.5 n0.5 1 noise r=1 amp=0.1 step=0.1m alpha=0.5\n"
"  V1   n1   2 noise r=1 amp=0.1 step=0.1m alpha=1\n"
"  V1.5 n1.5 3 noise r=1 amp=0.1 step=0.1m alpha=1.5\n"
"  V2   n2   4 noise r=1 amp=0.1 step=0.1m alpha=2\n"
"  V2.5 n2.5 5 noise r=1 amp=0.1 step=0.1m alpha=2.5\n"
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:27
msgid ""
"unfortunately if alpha!=0 and alpha!=2, this is inefficient, but at least "
"its not as ugly as precalculating noise."
msgstr ""

#. type: Plain text
#: user/ir_filters_and_tr-_noise.txt:28
msgid ""
"the implementation on [[git://tool/git/gnucap|tool]] (git repo) works, and "
"is slightly incomplete (but was fun to write)."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:2
msgid "=====Language Plugin for schematic files of GSchem ====="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:8
msgid ""
"====Introduction==== The plan <sup>[1]</sup> is to write a plugin for Gnucap "
"to support schematic files from gEDA/gschem <sup>[2]</sup>.  Schematics are "
"graphical representation of circuits using abstract symbols showing "
"components and their connections. \\\\ The idea for netlist import and "
"export is at the wiki page : [[Netlist import and export]] \\\\ The "
"technical details on on how this gEDA/gschem plugin is implemented is at the "
"page: [[Details of gEDA plugin]]"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:12
msgid ""
"====How to parse schematics==== The schematic files are converted into "
"verilog netlist.  The steps involved in parsing the schematic are described "
"below, as observed by working out a few examples manually :"
msgstr ""

#. type: Title ===
#: user/language_plugin_for_gschem.txt:12
#, no-wrap
msgid "Identifying components"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Search for the identifier \"C\" at the start of the line.\n"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Search for the device name of the component. If device=none or graphical=1 (in the symbol file of the component), then ignore it as it doesn't have any electrical significance [3]. Else, index them in the order of their occurrence in the schematic.\n"
msgstr ""

#. type: Bullet: '  - '
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Get the name and value of the attributes associated with the components recognized by index of the component.\n"
msgstr ""

#. type: Title ===
#: user/language_plugin_for_gschem.txt:16
#, no-wrap
msgid "Positioning the nodes and pins==="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:40
#, no-wrap
msgid ""
"  - Get the components' placement information from the schematic and using the placement of the components and the relative position of pins from the symbol file of the component, get the positions of active edges of the pins of all the components.\n"
"  -For each component, get the pins' active edge's relative coordinates are in the symbol file say (px,py).Then execute the logic as shown below to get the position of the pins. (Say component position is (cx,cy))\n"
"  - Create a `ifdef directive to write the placement of nodes in it. Nodes are placed at the corresponding pins from which they originate. 'place' in verilog has attributes x,y corresponding to x-coordinate and y-coordinate of the nodes' placement.\n"
"<code python>\n"
"     if mirror_flag==0:\n"
"       if angle==0:\n"
"         (pxn,pyn)=(cx,cy) + (+px,+py)\n"
"       elif angle==90:\n"
"         (pxn,pyn)=(cx,cy) + (-py,+px)\n"
"       elif angle==180:\n"
"         (pxn,pyn)=(cx,cy) + (-px,-py)\n"
"       elif angle==270:\n"
"         (pxn,pyn)=(cx,cy) + (+py,-px)\n"
"     elif mirror_flag=1:\n"
"       if angle==0:\n"
"         (pxn,pyn)=(cx,cy) + (-px,+py)\n"
"       elif angle==90:\n"
"         (pxn,pyn)=(cx,cy) + (-py,-px)\n"
"       elif angle==180:\n"
"         (pxn,pyn)=(cx,cy) + (+px,-py)\n"
"       elif angle==270:\n"
"         (pxn,pyn)=(cx,cy) + (+py,+px)\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:47
#, no-wrap
msgid ""
"===Writing nets between pins===\n"
"  - Search for nets in schematics identified by \"N\" at start of line.\n"
"  - For each net get the two co-ordinates it is connecting. If there are already nodes at those co-ordinates, create a net with those nodes as endpoints. Else create some name for the new node and save the node.\n"
"  - Check the placement of the nodes to see if any nodes are implicitly connected, i.e, if they have same co-ordinates. If True, create a net between them\n"
"  - Go through all nets and check all the nodes(except those the net ends in), if they are on that net. If True, create a net from the node to one of the end-nodes of the net.\n"
"  - Complex nets can be simplified but don't need to be. If done, resulting schematic from this netlist on re-conversion differs.\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:51
msgid ""
"The [[https://docs.google.com/open?id=0B7mgwfV1A9p5aURQNENjM3ZLdWs|Flow "
"Chart]] for parsing the schematic is as follows : {{ gnucap:user:"
"gschemparsing_color_flow_chart.png?1000X1300 }}"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:158
#, no-wrap
msgid ""
"====Example of parsing:1====\n"
"Consider the voltage divider circuit as shown below :\n"
"{{ :gnucap:user:circuit1_schematic_parsing_eg.png?400x300 }}\n"
"It's schematic voltage_divider.sch is :\n"
"<code text>\n"
"v 20100214 2\n"
"C 40000 40000 0 0 0 title-B.sym\n"
"C 44000 49000 1 90 1 voltage-3.sym\n"
"{\n"
"T 43300 48800 5 8 0 0 270 2 1\n"
"device=VOLTAGE_SOURCE\n"
"T 43500 48700 5 10 1 1 270 2 1\n"
"refdes=Vin\n"
"T 43500 48800 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
"C 44100 48900 1 0 0 resistor-1.sym\n"
"{\n"
"T 44400 49300 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 44300 49200 5 10 1 1 0 0 1\n"
"refdes=R1\n"
"T 44100 48900 5 10 1 1 0 0 1\n"
"value=2k\n"
"}\n"
"C 45300 48100 1 90 0 resistor-1.sym\n"
"{\n"
"T 44900 48400 5 10 0 0 90 0 1\n"
"device=RESISTOR\n"
"T 45000 48300 5 10 1 1 90 0 1\n"
"refdes=R2\n"
"T 45300 48100 5 10 1 1 0 0 1\n"
"value=1k\n"
"}\n"
"N 43800 48100 45200 48100 4\n"
"C 44200 47800 1 0 0 gnd-1.sym\n"
"N 43800 49000 44100 49000 5\n"
"N 45000 49000 45200 49000 6\n"
"</code>\n"
"  *When parsing this, we convert it into an augmented netlist with placement information contained in an `ifdef directive.\n"
"  *There are 5 components: 1 title, 2 resistors, 1 ground pin and a voltage source in this circuit which can be identified from the lines starting with the identifier \"C\" for components. Out of them ,the 'title' has no electrical meaning (identified from 'graphical=1' attribute in the symbol file \"title-B.sym\"). The 'device' attribute will identify the component.\n"
"  *Now, we have 4 components having electrical meaning. 2 \"RESISTOR\"s and a VOLTAGE_SOURCE having 2 pins each (pin information got from the symbol files, \"resistor-1.sym\" and \"voltage-3.sym\") and a ground with one pin. They have some attributes like refdes,value which are passed on to the netlist. Index the components in the order in which they appear in the schematic.\n"
"The verilog code with just the components (no connections in it yet) is :\n"
"<code verilog >\n"
"//Construction_of_netlist_part1\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"//to add net and placement...\n"
"endmodule\n"
"</code>\n"
"  *The nodes have a placement in the schematic (use same position as the pins connecting connecting to the nodes). Get that directly from the schematic and save it in `ifdef directive. Use the index to identify the placement.\n"
"  *From the information of placement of components and using the symbol files, we now get the placement of the active edges of pins of components : p11,p12,p21,p22,p31,p32,p41; . For eg, in the symbol file of resistor the active edges of pins are at (0,100) and (900,100). Add these to the co-ordinates of the placement of the components to get the position of pins.\n"
"<code text>\n"
"p11: (44100,49000) ; p12: (45000,49000) ;\n"
"p21: (45200,48100) ; p22: (45200,49000) ; //when rotate by 90, x and y axis interchange.\n"
"p31: (43800,49000) ; p32: (43800,48100) ; //when mirror image is taken subtract the co-ordinaates\n"
"//(Eg :43800=44000-200 and 48100=49000-900)\n"
"p41: (44300,48100)\n"
"</code>\n"
"  *We place the nodes at the same place as the corresponding pins.\n"
"The code with the placement of nodes is :\n"
"<code verilog>\n"
"//Construction_of_netlist_part2\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"`ifdef SCHEMATIC\n"
"//the attributes of 'place' are x,y. x and y are integers, generally multiples of 100.\n"
"place #(.x(44100),.y(49000)) node11;\n"
"place #(.x(45000),.y(49000)) node12;\n"
"place #(.x(45200),.y(48100)) node21;\n"
"place #(.x(45200),.y(49000)) node22;\n"
"place #(.x(43800),.y(49000)) node31;\n"
"place #(.x(43800),.y(48100)) node32;\n"
"place #(.x(44300),.y(48100)) node41;\n"
"`endif\n"
"endmodule\n"
"</code>\n"
"  *Now from the pin positions, we parse the nets. The nets are marked by the identifier 'N' in the schematic. There are 3 nets in the schematic for this example.\n"
"The final verilog netlist is as follows\n"
"<code verilog>\n"
"//Construction_of_netlist_part3_final\n"
"module voltage_divider();\n"
"RESISTOR #(.value(2k)) R1 (.p11(node11),.p12(node12));\n"
"RESISTOR #(.value(1k)) R2 (.p21(node21),.p22(node22));\n"
"VOLTAGE_SOURCE #(.value(10)) Vin (.p31(node31),.p32(node32));\n"
"ground node41; //??\n"
"net net1 (node32,node21); //this net connects (43800,48100) to (45200,48100). where nodes node32 and node21 are located resp.\n"
"net net2 (node31,node11); //similarly for other nets\n"
"net net3 (node12,node22);\n"
"`ifdef SCHEMATIC\n"
"//the attributes of 'place' are x,y. x and y are integers, generally multiples of 100.\n"
"place #(.x(44100),.y(49000)) node11;\n"
"place #(.x(45000),.y(49000)) node12;\n"
"place #(.x(45200),.y(48100)) node21;\n"
"place #(.x(45200),.y(49000)) node22;\n"
"place #(.x(43800),.y(49000)) node31;\n"
"place #(.x(43800),.y(48100)) node32;\n"
"place #(.x(44300),.y(48100)) node41;\n"
"`endif\n"
"endmodule\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:328
#, no-wrap
msgid ""
"====Example of parsing:2====\n"
"Now, consider a more complex example: A differential amplifier circuit.\n"
"{{ :gnucap:user:circuit_diffamp_sch.png?342X390 }}\n"
"The schematic of the differential amplifier circuit is :\n"
"<code text>\n"
"v 20110115 2\n"
"C 40000 40000 0 0 0 title-B.sym\n"
"C 46400 44400 1 0 0 resistor-1.sym\n"
"{\n"
"T 46700 44800 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 46600 44700 5 10 1 1 0 0 1\n"
"refdes=Re1\n"
"T 46600 44200 5 10 1 1 0 0 1\n"
"value=150\n"
"}\n"
"C 47700 44400 1 0 0 resistor-1.sym\n"
"{\n"
"T 48000 44800 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 47900 44700 5 10 1 1 0 0 1\n"
"refdes=Re2\n"
"T 47900 44200 5 10 1 1 0 0 1\n"
"value=150\n"
"}\n"
"C 48800 46900 1 90 0 resistor-1.sym\n"
"{\n"
"T 48400 47200 5 10 0 0 90 0 1\n"
"device=RESISTOR\n"
"T 48500 47000 5 10 1 1 90 0 1\n"
"refdes=Rc\n"
"T 48900 47200 5 10 1 1 0 0 1\n"
"value=20k\n"
"}\n"
"C 47300 44200 1 270 0 current-1.sym\n"
"{\n"
"T 48300 43600 5 10 0 0 270 0 1\n"
"device=CURRENT_SOURCE\n"
"T 47800 43900 5 10 1 1 270 0 1\n"
"refdes=Ic\n"
"T 46700 43700 5 10 1 1 0 0 1\n"
"value=0.5mA\n"
"}\n"
"C 45700 45400 1 0 0 BC547-1.sym\n"
"{\n"
"T 46600 46100 5 10 0 0 0 0 1\n"
"device=BC547\n"
"T 46600 45900 5 10 1 1 0 0 1\n"
"refdes=Q1\n"
"T 46500 45500 5 10 0 0 0 0 1\n"
"footprint=TO92\n"
"}\n"
"C 49300 45400 1 0 1 BC547-1.sym\n"
"{\n"
"T 48400 46100 5 10 0 0 0 6 1\n"
"device=BC547\n"
"T 48400 45900 5 10 1 1 0 6 1\n"
"refdes=Q2\n"
"T 48500 45500 5 10 0 0 0 6 1\n"
"footprint=TO92\n"
"}\n"
"C 47300 47800 1 0 0 vcc-1.sym\n"
"{\n"
"T 47100 48000 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
"C 47200 42700 1 0 0 vcc-minus-1.sym\n"
"{\n"
"T 47600 42800 5 10 1 1 0 0 1\n"
"value=-10\n"
"}\n"
"N 46300 47800 46300 46400 4\n"
"N 46300 45400 46300 44500 4\n"
"N 46300 44500 46400 44500 4\n"
"N 47300 44500 47700 44500 4\n"
"N 48600 44500 48700 44500 4\n"
"N 48700 44500 48700 45400 4\n"
"N 47500 44200 47500 44500 4\n"
"N 48700 46900 48700 46400 4\n"
"C 49200 45600 1 0 0 gnd-1.sym\n"
"C 44900 45800 1 0 0 input-1.sym\n"
"{\n"
"T 44900 46100 5 10 0 0 0 0 1\n"
"device=INPUT\n"
"T 45100 46100 5 10 1 1 0 0 1\n"
"pinlabel=Vi\n"
"}\n"
"C 48700 46500 1 0 0 output-1.sym\n"
"{\n"
"T 48800 46800 5 10 0 0 0 0 1\n"
"device=OUTPUT\n"
"T 49300 46800 5 10 1 1 0 0 1\n"
"pinlabel=Vo\n"
"}\n"
"N 46300 47800 48700 47800 4\n"
"</code>\n"
"Following the process for parsing schematic, the first step is\n"
"  *Identifying the components: After identifying the components and the attributes of components. The draft netlist without any placement yet is as below:\n"
"<code verilog>\n"
"//Netlist_part1\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
"//To_Add_Placement_and_Nets\n"
"endmodule\n"
"</code>\n"
"  *Geting the absolute positions of the active edges of pins of the components, and place nodes which correspond to that pin of the component at that position in an `ifdef SCHEMATIC. The netlist after getting placement of nodes is :\n"
"<code verilog>\n"
"//Netlist_part2\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
"`ifdef SCHEMATIC\n"
"place #(.x(47300),.y(44500)) node1_1;\n"
"place #(.x(46400),.y(44500)) node1_2;\n"
"place #(.x(48600),.y(44500)) node2_1;\n"
"place #(.x(47700),.y(44500)) node2_2;\n"
"place #(.x(48700),.y(47800)) node3_1;\n"
"place #(.x(48700),.y(46900)) node3_2;\n"
"place #(.x(47500),.y(44200)) node4_1;\n"
"place #(.x(47500),.y(43300)) node4_2;\n"
"place #(.x(46300),.y(46400)) node5_1;\n"
"place #(.x(46300),.y(45400)) node5_2;\n"
"place #(.x(45700),.y(45900)) node5_3;\n"
"place #(.x(48700),.y(46400)) node6_1;\n"
"place #(.x(48700),.y(45400)) node6_2;\n"
"place #(.x(49300),.y(45900)) node6_3;\n"
"place #(.x(47500),.y(47800)) node7_1;\n"
"place #(.x(47500),.y(43300)) node8_1;\n"
"place #(.x(49300),.y(45900)) node9_1;\n"
"place #(.x(45700),.y(45900)) node10_1;\n"
"place #(.x(48700),.y(46600)) node11_1;\n"
"`endif\n"
"</code>\n"
"  *Now in this step we search for 'net's in the schematic and write them. After writing nets, the final netlist is as follows.\n"
"<code verilog>\n"
"//Netlist_part3_final\n"
"module diffamp() begin;\n"
"RESISTOR #(.value(150)) Re1 (.p1(node1_1),.p2(node1_2));\n"
"RESISTOR #(.value(150)) Re2 (.p1(node2_1),.p2(node2_2));\n"
"RESISTOR #(.value(20k)) Rc  (.p1(node3_1),.p2(node3_2));\n"
"CURRENT_SOURCE #(.value(0.5mA)) Ic (.p1(node4_1),.p2(node4_2));\n"
"BC547 #(.footprint(TO92)) Q1 (.p1(node5_1),.p2(node5_2),.p3(node5_3));\n"
"BC547 #(.footprint(TO92)) Q2 (.p1(node6_1),.p2(node6_2),.p3(node6_3));\n"
"Vcc #(.value(10)) Vcc1 (.p1(node7_1));\n"
"-Vcc #(.value(-10)) Vcc2 (.p1(node8_1));\n"
"GND (.p1(node9_1));\n"
"INPUT Vi (.p1(node10_1));\n"
"OUTPUT Vo (.p1(node11_1));\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:344
msgid ""
"net net1 (node0 ,node5_1); net net2 (node5_2,node1 ); net net3 (node1 ,"
"node1_2); net net4 (node1_1,node2_2); net net5 (node2_1,node2 ); net net6 "
"(node2 ,node6_2); net net7 (node4_1,node3 ); net net8 (node3_2,node6_1); net "
"net9 (node0 ,node3_1); net net10(node4_2,node8_1); net net11(node5_3,"
"node10_1); net net12(node6_3,node9_1); net net13(node3 ,node1_1); net net14"
"(node11_1,node3_2); net net15(node7_1 ,node0 );"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:371
msgid ""
"`ifdef SCHEMATIC place #(.x(47300),.y(44500)) node1_1; place #(.x(46400),.y"
"(44500)) node1_2; place #(.x(48600),.y(44500)) node2_1; place #(.x(47700),.y"
"(44500)) node2_2; place #(.x(48700),.y(47800)) node3_1; place #(.x(48700),.y"
"(46900)) node3_2; place #(.x(47500),.y(44200)) node4_1; place #(.x(47500),.y"
"(43300)) node4_2; place #(.x(46300),.y(46400)) node5_1; place #(.x(46300),.y"
"(45400)) node5_2; place #(.x(45700),.y(45900)) node5_3; place #(.x(48700),.y"
"(46400)) node6_1; place #(.x(48700),.y(45400)) node6_2; place #(.x(49300),.y"
"(45900)) node6_3; place #(.x(47500),.y(47800)) node7_1; place #(.x(47500),.y"
"(43300)) node8_1; place #(.x(49300),.y(45900)) node9_1; place #(.x(45700),.y"
"(45900)) node10_1; place #(.x(48700),.y(46600)) node11_1; place #(.x(46300),."
"y(47800)) node0; place #(.x(46300),.y(44500)) node1; place #(.x(48700),.y"
"(44500)) node2; place #(.x(47500),.y(44500)) node3; `endif </code>"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:375
msgid ""
"====How to build schematics==== The following procedure outlines how a "
"schematic is built from a verilog netlist. This constitutes the second part "
"of the proposal <sup>[1]</sup>.  It is mostly the inverse of parsing "
"schematics."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:384
#, no-wrap
msgid ""
"===Create an augmented netlist with placement info===\n"
"  - Get the symbols to be used for each component(module in the netlist) with help of user input\n"
"    * User gives the symbol to use directly\n"
"    * User gives the symbol name from the standard library which can be obtained\n"
"    * User gives the 'device' attribute that corresponds to that module which can be searched from the standard symbols\n"
"  - Replace the modules of original netlist with new modules named with the 'device' name. They are same as the original modules but with a parameter string 'sym' which corresponds to the symbol to be used for that device.\n"
"  - Rename the nodes connected to pins of the components such that each has unique name and separate the collapsed nets and place a net between such nodes with default (ideal) parameters i.e, 'zero' resistance, 'zero' inductance etc.\n"
"  - Place the nodes in an `ifdef directive using 'place' module which takes 2 attributes x,y ,the co-ordinates of the node. (*TODO : heuristic for placement)\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:389
#, no-wrap
msgid ""
"===Position the components in the schematic===\n"
"  - Place components in between the nodes their pins are connected. In case of a 2-pin device place the pins in between the nodes. Get the device position using relative positions of pins in a symbol.\n"
"  - Write the first line in gschem file with appropriate version (not needed but better done) and place the components at the positions calculated above\n"
"  - Add text attributes to the components in schematic like device, refdes, value etc. Use the format T //xc yc// 5 10 0 0 0 0 1 for invisible attributes like device. Use T //xc yc// 5 10 1 1 0 0 1 for value-only visible attributes. Refer to <sup>[4]</sup> for specs\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:394
#, no-wrap
msgid ""
"===Creating nets between nodes and pins===\n"
"  - Write nets from the nodes to the pins they connect.\n"
"  - Look for 'net's in the netlist and write a net from the co-ordinates of one node to another connected node.\n"
"  - (*TODO): In case a net is slant, to use complex connection between pins made of horizontal/vertical nets.\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:432
#, no-wrap
msgid ""
"====Example of Building====\n"
"Consider the voltage divider circuit netlist as written below.\n"
"<code verilog>\n"
"module voltage_div ();\n"
"//A simple voltage divider circuit as an example\n"
"resistor #(.r(2k)) R1  (.p(p1),.n(p2));\n"
"resistor #(.r(1k)) R2  (.p(p2),.n(p3));\n"
"vsource #(.dc(10)) Vin (.p(p1),.n(p3));\n"
"endmodule\n"
"</code>\n"
"  *With the help of user input, we now get the symbols that we use for each module. For resistor we use resistor-1.sym. It will be determined in either of following ways\n"
"    *User gives the symbol to use directly (wrote by them)\n"
"    *User gives the symbol name from the standard library which can be obtained\n"
"    *User gives the 'device' attribute for the component and we can search the standard library or a built-index (?) of it for symbols with such a device name\n"
"  *Now we create an augmented netlist from this with the placement info and different modules defined by the name same as the value of 'device' attribute (eg. RESISTOR etc).\n"
"  *If the nets are collapsed between pins/nodes, then separate them and place a net in between the nodes with parameter values of the net 'zero' (resistance,inductance etc) i.e, the ideal connection\n"
"  *Place the nodes of components at some place. For now they'll be placed randomly. Random placement gives unaesthetic schematics. (*TODO) Develop a heuristic so that placement is not random and has aesthetic appeal.\n"
"The augmented netlist is\n"
"<code verilog>\n"
"//augmented_netlist_with_placement\n"
"module voltage_div ();\n"
"RESISTOR #(.r(2k),.sym(resistor-1.sym) R1  (.p(node11),.n(node12));\n"
"RESISTOR #(.r(1k),.sym(resistor-1.sym)) R2  (.p(node21),.n(node22));\n"
"VOLTAGE_SOURCE #(.dc(10),.sym(voltage-3.sym)) Vin (.p(node31),.p(node32));\n"
"net net1 (node12,node21); //this net is corresponds to net at pin p2\n"
"net net2 (node22,node32); //corresponds to net at pin p3\n"
"net net3 (node11,node31); //corresponds to net at pin p1\n"
"`ifdef SCHEMATIC //placing the nodes randomly as multiples of 100\n"
"//,not differing by too much and taking care that nodes of same device differ only in one of the x & y co-ordinated\n"
"  place #(.x(45200),.y(48100)) node11;\n"
"  place #(.x(43900),.y(48100)) node12;\n"
"  place #(.x(43800),.y(47000)) node21;\n"
"  place #(.x(42800),.y(47000)) node22;\n"
"  place #(.x(43800),.y(46400)) node31;\n"
"  place #(.x(43800),.y(47400)) node32;\n"
"`endif\n"
"endmodule\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:439
msgid ""
"module RESISTOR(pin1,pin2) begin; parameter string sym; parameter real res; "
"electrical pin1,pin2; resistor #(.r(res)) R (.p(pin1),.n(pin2)); endmodule"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:446
msgid ""
"module VOLTAGE_SOURCE(pinp,pinn) begin; parameter string sym; parameter real "
"dc; electrical pinp,pinn; vsource #(.dc(dc)) Vs (.p(pinp),.n(pinn)); "
"endmodule"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:512
#, no-wrap
msgid ""
"</code>\n"
"  *Now, we start building the schematic from the augmented netlist. First, we write the nets connecting nodes. 'net's in verilog connect 2 nodes. As all nodes have been placed in the 'ifdef directive, we can write nets in schematic as follows.\n"
"  *Write the version line in the start and write nets starting with the identifier 'N' followed by the x & y co-ordinates of the nodes the net connects.\n"
"<code text>\n"
"v 20100214 2\n"
"//components yet to be placed.\n"
"N 43900 48100 43800 47000 5 //net1\n"
"N 42800 47000 43800 47400 5 //net2\n"
"N 45200 48100 43800 46400 5 //net3\n"
"</code>\n"
"  *Now, we place the components in between the nodes their pins are  connected to. Resistor R1 is connected between node11 and node 12. We get device position as follows :\n"
"<code python>\n"
"node11=[45200,48100]\n"
"node12=[43900,48100]\n"
"for i in range(len(node11)):\n"
"  node_m[i]=(node11[i]+node12[i])/2\n"
"#that gives node_m=[44550,49000]\n"
"#the resistor has pins at\n"
"p1_abs=[0,100]\n"
"p2_abs=[900,100]\n"
"#So the pins' absolute positions are\n"
"for i in range(2):\n"
"  p12[i]=(p2_abs[i]-p1_abs[i])/2\n"
"  p1[i]=node_m[i]-p12[i] #p1=[44550-450,49000]=[41000,49000] and\n"
"  p2[i]=node_m[i]+p12[i] #p2=[44550+450,49000]=[45000,49000]\n"
"  dev[i]=p1[i]-p1_abs[i] #The device is the placed at 'p1'-'p1_abs'\n"
"#this logic needs to be improved..\n"
"</code>\n"
"  *Now we get all pin positions and device positions from the above logic.\n"
"<code text>\n"
"p11: (45200,48100) ; p12: (44100,48100) ; //device R1\n"
"p21: (43700,47000) ; p22: (42800,47000) ; //device R2\n"
"p31: (43800,46400) ; p32: (43800,47300) ; //device Vin\n"
"R1 : (44100,48000) ; R2 : (42800,46900) ; Vin: (44000,46400) and rotated by 90.\n"
"</code>\n"
"  *Using the placement of pins and components from above logic. We position the components and connect the pins to the nodes through nets.\n"
"<code text>\n"
"v 20100214 2\n"
"C 44100 48000 1 0 0 resistor-1.sym\n"
"{\n"
"T 44100 48000 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 44100 48400 5 10 1 1 0 0 1\n"
"refdes=R1\n"
"T 44100 47700 5 10 1 1 0 0 1\n"
"value=2k\n"
"}\n"
"C 42800 46900 1 0 0 resistor-1.sym\n"
"{\n"
"T 42800 46900 5 10 0 0 0 0 1\n"
"device=RESISTOR\n"
"T 42800 47300 5 10 1 1 0 0 1\n"
"refdes=R2\n"
"T 42800 46600 5 10 1 1 0 0 1\n"
"value=1k\n"
"}\n"
"C 44000 46400 1 90 0 voltage-3.sym\n"
"{\n"
"T 44000 46400 5 10 0 0 0 0 1\n"
"device=VOLTAGE_SOURCE\n"
"T 44000 46800 5 10 1 1 0 0 1\n"
"refdes=Vin\n"
"T 44000 46100 5 10 1 1 0 0 1\n"
"value=10\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:519
msgid ""
"N 45200 48100 45000 48100 4 //p11 N 43900 48100 44100 48100 4 //p12 N 43800 "
"47000 43700 47000 4 //p21 N 42800 47000 42800 47000 4 //p22 N 43800 46400 "
"43800 46400 4 //p31 N 43800 47400 43800 47300 4 //p32"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:524
msgid ""
"N 43900 48100 43800 47000 4 //net1 N 42800 47000 43800 47400 4 //net2 N "
"45200 48100 43800 46400 4 //net3 </code>"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:528
msgid ""
"The schematic built from the netlist is as shown below : \\\\ {{ :gnucap:"
"user:circuit1_building_new_nodes.png?400x380 }}"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:530
msgid "====References===="
msgstr ""

#. type: Plain text
#: user/language_plugin_for_gschem.txt:536
msgid ""
"[1] [[http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/"
"savy2020/1| GSoC Proposal]] \\\\ [2] [[http://wiki.geda-project.org/geda:"
"gschem_ug|gEDA/gschem]] \\\\ [3] [[http://wiki.geda-project.org/geda:"
"master_attributes_list#graphical|Schematic Attribute List : graphical ]] \\"
"\\ [4] [[http://wiki.geda-project.org/geda:file_format_spec|File format "
"specs : Schematic ]] \\\\ [5] [[http://gnucap-gsoc.blogspot.in|Blog]] "
"contains weekly updates and documentation of the timeline for this project "
"under GSoC. \\\\ [6] [[http://www.github.com/sksavant/gnucap/tree/"
"lang_gschem| Github branch ]] containing the code."
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:2
msgid "Language plugin for Qucs"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:4
msgid ""
"The basis idea is to parse the output schematic or the netlist of the qucs "
"and create an intermediate netlist that is execetable in gnucap"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:6
msgid "Example of a netlist file is shown below"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:8
msgid "# Qucs 0.0.16 bridge.sch"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:20
msgid ""
"IProbe:Pr1 _net0 _net1 R:R2 _net2 _net3 R=\"500 Ohm\" Temp=\"26.85\" Tc1="
"\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" Vdc:V1 _net3 gnd U=\"1 V\" R:R5 gnd _net2 "
"R=\"Rmeasure\" Temp=\"26.85\" Tc1=\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" R:R1 "
"_net0 _net3 R=\"Rbranch\" Temp=\"26.85\" Tc1=\"0.0\" Tc2=\"0.0\" Tnom="
"\"26.85\" R:R4 gnd _net0 R=\"Rbranch\" Temp=\"26.85\" Tc1=\"0.0\" Tc2="
"\"0.0\" Tnom=\"26.85\" .DC:DC1 Temp=\"26.85\" reltol=\"0.001\" abstol=\"1 pA"
"\" vntol=\"1 uV\" saveOPs=\"no\" MaxIter=\"150\" saveAll=\"no\" convHelper="
"\"none\" Solver=\"CroutLU\" R:R3 _net1 _net2 R=\"500 Ohm\" Temp=\"26.85\" "
"Tc1=\"0.0\" Tc2=\"0.0\" Tnom=\"26.85\" .SW:SW1 Sim=\"DC1\" Type=\"lin\" "
"Param=\"Rmeasure\" Start=\"10 Ohm\" Stop=\"1 kOhm\" Points=\"100\" .SW:SW2 "
"Sim=\"SW1\" Type=\"lin\" Param=\"Rbranch\" Start=\"200 Ohm\" Stop=\"1 kOhm\" "
"Points=\"4\" Eqn:Eqn1 Umeasure=\"500 * abs(Pr1.I)\" Export=\"yes\""
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:23
msgid "Description of the Netlist file"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:25
msgid "First line shows the version of the qucs and the file path"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:28
msgid ""
"The list of the components in Qucs can be seen in the link below http://qucs."
"sourceforge.net/docs/textmode.pdf"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:30
msgid "Description of a schematic file will be done in future"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:32
msgid "Identifying the Components"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:34
msgid "The first letter in the netlist gives the component type"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:36
msgid ""
"_net gives information about in between which nodes the component is "
"connected"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:49
msgid ""
"#include \"c_comand.h\" #include \"d_dot.h\" #include \"d_coment.h\" "
"#include \"d_subckt.h\" #include \"e_model.h\" #include \"u_lang.h\" "
"#include <fts.h> #include \"io_trace.h\""
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:51
msgid "#include <gmpxx.h> // to workaround bug in gmp header about __cplusplus"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:56
msgid ""
"/*--------------------------------------------------------------------------"
"*/ namespace { /"
"*--------------------------------------------------------------------------"
"*/ class LANG_QUCS : public LANGUAGE {"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:68
#, no-wrap
msgid ""
"public:\n"
"    //\n"
"    enum MODE {mATTRIBUTE, mCOMMENT} _mode;\n"
"    mutable int _no_of_lines;\n"
"    mutable bool _componentmod;\n"
"    mutable std::string _componentname;\n"
"    mutable bool _gotaline;\n"
"    //\n"
"    std::string name()const {return \"qucs\";}\n"
"    bool case_insensitive()const {return false;}\n"
"    UNITS units()const {return uSI;}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:79
#, no-wrap
msgid ""
"public: //functions to be declared\n"
"    std::string arg_front()const {\n"
"        return \" \"; //arbitrary\n"
"    }\n"
"    std::string arg_mid()const {\n"
"        return \"=\"; //arbitrary\n"
"    }\n"
"    std::string arg_back()const {\n"
"        return \"\";  //arbitrary\n"
"    }\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:89
#, no-wrap
msgid ""
"public:\n"
"    void\t\t  parse_top_item(CS&, CARD_LIST*);\n"
"    DEV_COMMENT*  parse_comment(CS&, DEV_COMMENT*);\n"
"    DEV_DOT*\t  parse_command(CS&, DEV_DOT*);\n"
"    MODEL_CARD*\t  parse_paramset(CS&, MODEL_CARD*);\n"
"    MODEL_SUBCKT* parse_module(CS&, MODEL_SUBCKT*);\n"
"    COMPONENT*\t  parse_instance(CS&, COMPONENT*);\n"
"    std::string\t  find_type_in_string(CS&);\n"
"    MODEL_SUBCKT* parse_componmod(CS&, MODEL_SUBCKT*);\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:96
#, no-wrap
msgid ""
"private:\n"
"    void print_paramset(OMSTREAM&, const MODEL_CARD*);\n"
"    void print_module(OMSTREAM&, const MODEL_SUBCKT*);\n"
"    void print_instance(OMSTREAM&, const COMPONENT*);\n"
"    void print_comment(OMSTREAM&, const DEV_COMMENT*);\n"
"    void print_command(OMSTREAM& o, const DEV_DOT* c);\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:98
msgid "}lang_qucs;"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:111
#, no-wrap
msgid ""
"static void parse_place(CS& cmd, COMPONENT* x)\n"
"{\n"
"    trace0(\"Got into parse_place\");\n"
"    assert(x);\n"
"    assert(OPT::language->find_type_in_string(cmd)==\"place\");\n"
"    cmd>>\"place\";\n"
"    std::string _portname,_x,_y;\n"
"    cmd>>\" \">>_portname>>\" \">>_x>>\" \">>_y;\n"
"    x->set_param_by_name(\"x\",_x);\n"
"    x->set_param_by_name(\"y\",_y);\n"
"    x->set_port_by_index(0,_portname);\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/language_plugin_for_qucs.txt:175
#, no-wrap
msgid ""
"static void parse_place(CS& cmd, COMPONENT* x)\n"
"{\n"
"    trace0(\"Got into parse_place\");\n"
"    assert(x);\n"
"    assert(OPT::language->find_type_in_string(cmd)==\"place\");\n"
"    cmd>>\"place\";\n"
"    std::string _portname,_x,_y;\n"
"    cmd>>\" \">>_portname>>\" \">>_x>>\" \">>_y;\n"
"    x->set_param_by_name(\"x\",_x);\n"
"    x->set_param_by_name(\"y\",_y);\n"
"    x->set_port_by_index(0,_portname);\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static void create_place(std::string cmdstr,COMPONENT* x)\n"
"{\n"
"    CS place_cmd(CS::_STRING,cmdstr);\n"
"    OPT::language->new__instance(place_cmd,NULL,x->scope());\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static std::string findplacewithsameposition(COMPONENT* x,std::string xco,std::string yco)\n"
"{\n"
"    for (CARD_LIST::const_iterator ci = x->scope()->begin(); ci != x->scope()->end(); ++ci) {\n"
"        if((*ci)->dev_type()==\"place\"){\n"
"            if(xco==(*ci)->param_value(1) && yco==(*ci)->param_value(0)){\n"
"                return static_cast<COMPONENT*>(*ci)->port_value(0);\n"
"            }\n"
"        }\n"
"    }\n"
"    return \"\";\n"
"}\n"
"/*--------------------------------------------------------------------------*/\n"
"static std::string* findnodeonthisnet(CARD *x, std::string x0, std::string y0, std::string x1, std::string y1)\n"
"{\n"
"    for(CARD_LIST::const_iterator ci = x->scope()->begin(); ci != x->scope()->end(); ++ci) {\n"
"        if((*ci)->dev_type()==\"place\"){\n"
"            std::string _x=(*ci)->param_value(1),_y=(*ci)->param_value(0);\n"
"            if (y0==y1){\n"
"                if(  ( ( (atoi(x1.c_str()) < atoi(_x.c_str())) and (atoi(_x.c_str())<atoi(x0.c_str())) ) || ( (atoi(x0.c_str()) < atoi(_x.c_str())) and (atoi(_x.c_str())<atoi(x1.c_str())) ) ) and _y==y0 and _x!=x0 and _x!=x1){\n"
"                    trace0(\"true0\");\n"
"                    std::string* coord=new std::string[2];\n"
"                    coord[0]=_x;\n"
"                    coord[1]=_y;\n"
"                    return coord;\n"
"                }\n"
"                else{\n"
"                    return NULL;\n"
"                }\n"
"            }else if (x0==x1){\n"
"                if(  ( ( (atoi(y1.c_str()) < atoi(_y.c_str())) and (atoi(_y.c_str())<atoi(y0.c_str())) ) || ( (atoi(y0.c_str()) < atoi(_y.c_str())) and (atoi(_y.c_str())<atoi(y1.c_str())) ) ) and _x==x0 and _y!=y0 and _y!=y1){\n"
"                    trace0(\"true1\");\n"
"                    std::string* coord=new std::string[2];\n"
"                    coord[0]=_x;\n"
"                    coord[1]=_y;\n"
"                    return coord;\n"
"                }else{\n"
"                    return NULL;\n"
"                }\n"
"            }\n"
"            else{\n"
"                return NULL;\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:2
#, no-wrap
msgid "**5.MDUMP**\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:4
msgid "Purpose:Prints the dc tran matrix values."
msgstr ""

#. type: Plain text
#: user/mdump.txt:11
#, no-wrap
msgid ""
"     mdump\n"
"     mdump filename\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:15
msgid ""
"Command dumps the dc-tran matrix into the console,if the filename is "
"specified then output is redirected to the file.Two matrices one before the "
"lu decomposition and one after the lu decomposition is dumped."
msgstr ""

#. type: Plain text
#: user/mdump.txt:30
#, no-wrap
msgid ""
"     gnucap>mdump\n"
"     DC-Tran matrix before LU decomposition:\n"
"     0.    0.    0.    0.\n"
"     0.    0.02776   -0.005802   -0.02186\n"
"     0.   -0.02738    0.01161    0.01578\n"
"     0.   -273.8u   -0.005802    0.006157\n"
"     DC-Tran matrix after LU decomposition:\n"
"     0.    0.    0.    0.\n"
"     0.    0.02776   -0.209   -0.7874\n"
"     0.   -0.02738    0.00589   -0.9816\n"
"     0.   -273.8u   -0.005859    190.1u\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/mdump.txt:43
#, no-wrap
msgid ""
"     gnucap>mdump matrix.txt\n"
"     gnucap>!cat matrix.txt\n"
"     DC-Tran matrix before LU decomposition:\n"
"     0.0000 \t    0.0000 \t  0.0000 \t0.0000\n"
"     0.0000 \t    0.0278 \t -0.0058       -0.0219\n"
"     0.0000 \t   -0.0274 \t  0.0116 \t0.0158\n"
"     0.0000 \t   -0.0003 \t -0.0058 \t0.0062\n"
"     DC-Tran matrix after LU decomposition:\n"
"     0.0000 \t    0.0000 \t  0.0000 \t0.0000\n"
"     0.0000 \t    0.0278 \t -0.2090       -0.7874\n"
"     0.0000 \t   -0.0274 \t  0.0059       -0.9816\n"
"     0.0000 \t   -0.0003 \t -0.0059 \t0.0002\n"
"     gnucap>\n"
msgstr ""

#. type: Title ======
#: user/netlist_import_and_export.txt:1
#, no-wrap
msgid "File format translation"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:4
msgid ""
"We need a universal translator system that can translate in all directions "
"between Free EDA tools, possible future free EDA tools, and outside tools "
"that are likely to be used with free EDA tools."
msgstr ""

#. type: Title =====
#: user/netlist_import_and_export.txt:4
#, no-wrap
msgid "Scope"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:7
msgid ""
"Of course, everything to everything is not reasonable.  So, set a limit of "
"circuit oriented free EDA tools, possible future tools, and outside tools "
"that are likely to be used them.  Of course, tool formats where translation "
"doesn't make sense don't need to be supported."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:9
msgid ""
"Most tools use a format much like a netlist, often with some special "
"information.  So, use a netlist based intermediate format.  First translate "
"to the intermediate format, then translate out.  The intermediate format "
"should be sufficiently expressive that there can be a lossless round trip "
"from the tool format to the intermediate format and back."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:11
msgid ""
"Lossless means that the resultant file is equivalent in how it works.  It is "
"not necessary to preserve formatting and other things that don't matter."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:13
msgid ""
"All of the formats needing translation presently consist of lists of "
"objects, with some kind of encapsulation.  Each object has connections and "
"attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:15
msgid ""
"This suggests the possible of a standard netlist format as the intermediate "
"format."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:17
msgid "Further discussion related only to formats that fit this model."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:19
msgid ""
"If possible, the format chosen should have a history of use for at least "
"part of this, and have a published specification that is externally "
"controlled and freely available."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:21
msgid ""
"There needs to be a way to merge changes from any target/source without "
"messing up other parts."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:22
#, no-wrap
msgid "Tool types needing support"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "schematic\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "layout\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:26
#, no-wrap
msgid "simulation\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:27
#, no-wrap
msgid "Free tools"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:40
#, no-wrap
msgid ""
"Lossless round trip is required, so archival storage can use the intermediate format.\n"
"  * gschem\n"
"  * pcb\n"
"  * gnucap\n"
"  * Icarus Verilog\n"
"  * NGspice\n"
"  * Qucs\n"
"  * Kicad\n"
"  * Magic\n"
"  * Electric\n"
"  * Xcircuit\n"
"  * Fritzing\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:41
#, no-wrap
msgid "Non-free import and export"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:47
#, no-wrap
msgid ""
"Support for these will allow gEDA tools to play nice with the commercial world.  Basic functionality is needed, but it doesn't need to be lossless.  Lossless should be possible, but it is not a high priority to actually implement it.\n"
"  * Eagle\n"
"  * Orcad\n"
"  * LTspice\n"
"  * Pads\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:48
#, no-wrap
msgid "gEDA missing functionality"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:55
#, no-wrap
msgid ""
"Hopefully having a translator system will provide a seed so these can be done.\n"
"  * Back annotation from layout or simulation to schematic\n"
"  * Static timing analysis\n"
"  * Post-layout signal integrity simulation.\n"
"  * Layout - schematic comparison\n"
"  * Use of the same schematic for the whole project.\n"
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:55
#, no-wrap
msgid "Explicitly not supported"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Plotting\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Commands\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Behavioral modeling\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:60
#, no-wrap
msgid "Translating the symbols or footprints themselves.\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:63
msgid ""
"All of these consist of lists of objects, with connections and attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:65
msgid ""
"It is tradition that a netlist is used for interchange, but the traditional "
"approach only goes one way, because information is lost in the translation."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:67
msgid ""
"The format must convey the meaning, not necessarily in the same way as the "
"tool's native format or internal storage."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:69
msgid ""
"It is not necessary to translate parts that are usually in libraries, and "
"are tool specific, such as models, symbols, or footprints."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:71
msgid ""
"All contenders for possible formats must support a lossless round-trip to "
"any other."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:72
#, no-wrap
msgid "Some possible formats"
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:74
#, no-wrap
msgid "Spice"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:77
msgid ""
"A popular netlist format.  It has a history of use for interchange, but not "
"yet for physical placement.  Problems: irregular syntax, not sufficiently "
"expressive.  These problems have been a major hassle for years for "
"developers.  It is well accepted, but not by people who know it well."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:78
#, no-wrap
msgid "Verilog"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:81 user/netlist_import_and_export.txt:85
msgid ""
"The structural subset is a good netlist format.  It is regular, sufficiently "
"expressive, and has a published standard.  It has a history of use for "
"interchange, but not yet for physical placement."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:82
#, no-wrap
msgid "VHDL"
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:86
#, no-wrap
msgid "Spectre"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:89
msgid ""
"The structural subset is a good netlist format.  It is regular, sufficiently "
"expressive, but belongs to one company (Cadence), so rule it out.  It has a "
"history of use for simulation only."
msgstr ""

#. type: Title ===
#: user/netlist_import_and_export.txt:90
#, no-wrap
msgid "XML"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:93
msgid ""
"XML is not really a format but a syntax.  A good format can easily be made "
"based on XML, but has no history of use in a similar context.  The syntax is "
"well documented but there is no outside documentation of application in any "
"related use."
msgstr ""

#. type: Title ====
#: user/netlist_import_and_export.txt:94
#, no-wrap
msgid "Representation of physical placement"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:97
msgid ""
"This part is the only part where there is not a strong history of use for "
"VHDL and Verilog."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:99
msgid "Ideas:"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "Nets are also objects with connections and attributes.  Nets have meaning in all contexts.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "A place on a schematic can be considered to be an object, with connections and attributes.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "Pads, connectors, thermals, vias .. are also objects, with connections and attributes.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "Use `define (assuming Verilog format) to set aside sections that have meaning in one context but not another.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "This is a high level description.  Take a high level view across all.  It's not lines, boxes, and circles.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "If you must, lines, boxes, and circles can be objects too, but not translatable because they have no meaning in other contexts.\n"
msgstr ""

#. type: Bullet: '  * '
#: user/netlist_import_and_export.txt:107
#, no-wrap
msgid "Attributes that have no meaning are silently ignored.  Attributes that have meaning in one context but not in another context are ignored where they have no meaning.\n"
msgstr ""

#. type: Title =====
#: user/netlist_import_and_export.txt:108
#, no-wrap
msgid "Applications"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:111
msgid "Choosing the Verilog format as one possibility."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:113
msgid "The unit of encapsulation is the \"module\":"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:117
#, no-wrap
msgid ""
"  module my-module(connections);\n"
"  // contents\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:119
msgid "Each object in the list has a consistent syntax:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:121
#, no-wrap
msgid "  type #(attributes) name (connections);\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:126
#, no-wrap
msgid ""
"  resistor #(.r(1k)) r123 (a, b);\n"
"  resistor #(.r(1k)) r234 (.p(b), .n(c));\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:128
msgid "\"r\" is the name of an attribute.  \"1k\" is the value (a string)."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:130
msgid ""
"In the first example, connections are determined by order.  In the second, "
"they are mapped by name.  Node \"b\" connects to pin \"p\" and node \"c\" "
"connects to pin \"n\"."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:132
msgid "A \"net\" is also an object."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:134
msgid ""
"In the above example, both connect to node b directly.  In a schematic "
"representation the connection would not be direct, but through a \"net\""
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:138
#, no-wrap
msgid ""
"  resistor #(.r(1k)) r123 (.p(a1), .n(b1));\n"
"  resistor #(.r(1k)) r125 (.p(b2), .n(c2));\n"
"  net b (.1(b1), .2(b2));\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:140
msgid "The name of the net is \"b\".  It has no attributes."
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:142
msgid "For schematic, you can now place the nodes:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:147
#, no-wrap
msgid ""
"  place #(.x(1222), .y(3438)) place11333 (b1);\n"
"  place #(.x(4334), .y(8433)) place34894 (b2);\n"
"  place #(.x(9393), .y(4232)) place49334 (a1);\n"
"  place #(.x(2932), .y(2384)) place34983 (c2);\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:149
msgid ""
"Portions that apply in only certain contexts can be selectively included "
"with 'ifdef:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:159
#, no-wrap
msgid ""
"  module my_circuit;\n"
"    `ifdef SCHEMATIC\n"
"      place ...\n"
"      place ...\n"
"    `endif\n"
"     res ...\n"
"     res ...\n"
"     net ...\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:161
msgid "Complex nets can be encapsulated:"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:171
#, no-wrap
msgid ""
"  module net23842 (1,2,3);\n"
"    net n23482 (1,2);\n"
"    net n84333 (2,3);\n"
"    `ifdef SCHEMATIC\n"
"      place ...\n"
"      place ...\n"
"      place ...\n"
"    `endif\n"
"  endmodule\n"
msgstr ""

#. type: Plain text
#: user/netlist_import_and_export.txt:174
#, no-wrap
msgid ""
"  module net9393 (1,2);\n"
"    net #(.color(blue), .thickness(thin)) n38423 (1,2);\n"
"  endmodule\n"
msgstr ""

#. type: Title ===
#: user/newtonnumericexample1.txt:1
#, no-wrap
msgid "Newton Numeric Example 1"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:4
msgid "Let us consider simple 1-node circuit"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:12
#, no-wrap
msgid ""
"<code>\n"
"       --------+-------------\n"
"      |        |             |\n"
"    I=0.001   R=1000     i=V^3/1000\n"
"      |        |             |\n"
"     ---      ---           ---\n"
"</code>\n"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:14
msgid "Which is equivalent to equation:"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:16
msgid "F(V) = I + V/R + N(V) = V/1000 + 1/1000*V^3 - 0.001"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:18
msgid "J(V) = 1/1000 + 3/1000 * V^2"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:20
msgid "F'(V)= 3/1000*V^2*V + 0.001 - 1/1000*V^3"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:22
msgid ""
"model code and circuit file for this example are "
"[[ NewtonNumericExample1_Code | here ]]"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:24
msgid "Iteration sequence for this equation will be:"
msgstr ""

#. type: Plain text
#: user/newtonnumericexample1.txt:47
#, no-wrap
msgid ""
"^ Iteration ^ Newton classic (2,3) ^ Gnucap's Newton Modification (5,6,7) ^ Damped |\n"
"^ 0         | V0=0                 | V0=0                                 |  |\n"
"|           | J=0.001              | J=0.001                              |  |\n"
"|           | F=-0.001             | F' = 0.001                           |  |\n"
"|           | S=F/J=-1             | R  =F'/J=0.001/0.001=1;             |   |\n"
"|           | V1= V0-S = 1         | V1 = R = 1                          |  |\n"
"^ 1         | V1=1                 | V1 =1                               |  |\n"
"|           | J=0.004              | J = 0.004                           |  |\n"
"|           | F=0.001              | F' =0.003                           |  |\n"
"|           | S=F/J=0.25           | R=F'/J=0.75                         |  |\n"
"|           | V2=V1-S=0.75         | V2=R=0.75                           |  |\n"
"^ 2         | V2=0.75              | V2=0.75                             |  |\n"
"|           | J=0.0026875          | J=0.0026875                         |  |\n"
"|           | F=0.000171875        | F'=0.00184375                       |  |\n"
"|           | S=F/J=0.063953       | R=F'/J=0.686047                     |  |\n"
"|           | V3=V2-S=0.0686047    | V3=R=0.686047                       |  |\n"
"^ 3         | V3=0.0686047         | V3=0.0686047                        | ...|\n"
"|           | J=0.0024119815       | J=0.0024119815                      |  |\n"
"|           | F=0.00000894221      | F'=0.00164579043                    |  |\n"
"|           | S=F/J=0.003707       | R=F'/J=0.68234                      |  |\n"
"|           | V4=V3-S=068234       | V4=R=0.68234                        |  |\n"
"|...        | ...                  | ...                                 |  |\n"
msgstr ""

#. type: Title ===
#: user/noise_calculation_basics.txt:1 user/noise_implementation.txt:7
#, no-wrap
msgid "Noise calculations basics"
msgstr ""

#. type: Plain text
#: user/noise_calculation_basics.txt:4 user/noise_implementation.txt:11
msgid ""
"Noise is claculated using adjacent system method [TBD GS - complete, "
"explain ]"
msgstr ""

#. type: Title =====
#: user/noise_implementation.txt:1
#, no-wrap
msgid "Noise Implementation"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:4
msgid ""
"This section contains all stuff related to AC Noise calculation in Gnucap."
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:6
msgid ""
"Currently (April 2011) noise is implemented in experimental branch and work "
"as plugin. Please see [[Code-related Stuff]] for more details."
msgstr ""

#. type: Title ===
#: user/noise_implementation.txt:12 user/noise_syntax.txt:1
#, no-wrap
msgid "Noise Simulation Syntax"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:15 user/noise_syntax.txt:4
msgid ""
"To run noise simulation - ad the following line to circuit file (spice "
"format):"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:17 user/noise_syntax.txt:6
msgid "''.noise V(a,b) Dev stepmode points fromF toF''"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:26 user/noise_syntax.txt:15
#, no-wrap
msgid ""
"  * V(a,b)  - output to measure noise at - nodes a to b; possible form:\n"
"V(a) is the same as V(a,0)\n"
"  * Dev    - device which is considered as input\n"
"  * stepmode - [o{ctave}, d{ecade}, lin, ti{mes}, step, by, +, *]\n"
"  * points - number of points (depends on stepmode)\n"
"  * fromF   - lowest frequency\n"
"  * toF     - highest frequency\n"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:28 user/noise_syntax.txt:17
msgid ""
"It will calculate noise power density between output nodes \"a\" and \"b\" "
"and equivalent power at input device \"Dev\" using \"stepmode\" making "
"\"points\" in frequency range \"fromF\"-\"toF\""
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:32 user/noise_syntax.txt:21
msgid "'' .noise v(3) V1 oct 5 10 10K ''"
msgstr ""

#. type: Bullet: ' - '
#: user/noise_implementation.txt:34 user/noise_syntax.txt:23
#, no-wrap
msgid "calcualate spectral noise density at node \"3\" and reduce it to input device V1 making 5 points per octave in frequency range from 10HZ to 10KHZ\n"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:36 user/noise_syntax.txt:25
msgid "'' .noise V(10,12) I1 dec 2 10K 10MEG''"
msgstr ""

#. type: Bullet: ' - '
#: user/noise_implementation.txt:38 user/noise_syntax.txt:27
#, no-wrap
msgid "calcualate spectral noise density between nodes 10 and 12 and reduce it to input device I1 making 2 points per decade in frequency range from 10KHZ to 10MHZ\n"
msgstr ""

#. type: Title ==
#: user/noise_implementation.txt:40 user/noise_syntax.txt:29
#, no-wrap
msgid "Output"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:45 user/noise_syntax.txt:34
msgid ""
"Usually simulators also support ''.print noise'' statement. Now it is not "
"implemented yet.  Currently output contains:"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:47 user/noise_syntax.txt:36
msgid "'' Freq inoise_density onoise_density ''"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:49 user/noise_syntax.txt:38
msgid ""
"Also - at the end of the frequency range total power over the range s "
"integrated:"
msgstr ""

#. type: Plain text
#: user/noise_implementation.txt:51 user/noise_syntax.txt:40
msgid "'' inoise_total onoise_total ''"
msgstr ""

#. type: Bullet: '  * '
#: user/noise_implementation.txt:64
#, no-wrap
msgid "[[Discussions]] regarding noise implementation\n"
msgstr ""

#. type: Plain text
#: user/one_more.txt:1 user/test.txt:1
msgid "test"
msgstr ""

#. type: Plain text
#: user/pre.txt:2
#, no-wrap
msgid "**6.PRE**\n"
msgstr ""

#. type: Plain text
#: user/pre.txt:4
msgid "Purpose:Executes command prior to parsing the circuit"
msgstr ""

#. type: Plain text
#: user/pre.txt:5 user/reset.txt:5 user/trace.txt:5
msgid "Status:Not implemented"
msgstr ""

#. type: Title ===
#: user/programingdetails.txt:1
#, no-wrap
msgid "Programming Details"
msgstr ""

#. type: Plain text
#: user/programingdetails.txt:11
#, no-wrap
msgid ""
"Topmost level solver computations are concentrated in s__solve.cc file in\n"
"<code c++> SIM::solve(...) </code>\n"
"inside it main important steps:\n"
"<code c++> do { </code>\n"
"assume we have some value of unknowns: X_c\n"
"calculate model parameters\n"
"<code c++>   evaluate models; </code>\n"
"load matrices (Jacobian J and vector FG)\n"
msgstr ""

#. type: Plain text
#: user/programingdetails.txt:17
#, no-wrap
msgid ""
"note, that dumping is implemented duing matrix & vector loading process.\n"
"<code c++>   load_marix(); </code>\n"
"solve equations and obtan new poin X_n\n"
"<code c++>   solve_equations(); </code>\n"
"until equations will converge or iteration limit will not be acieved\n"
"<code c++>  } while ( ! converged && ! _sim-> exceeds_iteration_limit(it1));</code>\n"
msgstr ""

#. type: Title ===
#: user/queuesandoptbypass.txt:1
#, no-wrap
msgid "Queues and OPT::bypass"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:4
msgid ""
"To improve speed GNucap solver uses device queues, most queues are activated "
"when OPT::bypass is set to true."
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:6
msgid "This section will create analysis of how this is implemented."
msgstr ""

#. type: Title ==
#: user/queuesandoptbypass.txt:7
#, no-wrap
msgid "No bypass (OPT::bypass==false)"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:11
msgid ""
"Looking at code of SIM::evaluate_models() - if (OPT::bypass==false) then "
"only _late_evalq queue is used."
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:14
#, no-wrap
msgid "first for all devices do_tr() is performed (no queues);\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:14
#, no-wrap
msgid "then - for devices in _late_evalq queue is executed method do_tr_last();\n"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:17
msgid "Same approach is used in TRANSIENT::sweep():"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:20
#, no-wrap
msgid "for all devices is executed do_tr()\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:20
#, no-wrap
msgid "for _late_evalq is executed do_tr_last()\n"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:22
msgid "_late_evalq itself is declared in u_sim_data.h"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:24
msgid "elements can be added to _late_evalq are:"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_cccs\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_ccvs\n"
msgstr ""

#. type: Bullet: '  * '
#: user/queuesandoptbypass.txt:28
#, no-wrap
msgid "d_coil\n"
msgstr ""

#. type: Title ==
#: user/queuesandoptbypass.txt:29
#, no-wrap
msgid "bypass (OPT::bypass==true)"
msgstr ""

#. type: Plain text
#: user/queuesandoptbypass.txt:30
msgid "TBD"
msgstr ""

#. type: Plain text
#: user/quit.txt:2
#, no-wrap
msgid "**7.QUIT**\n"
msgstr ""

#. type: Plain text
#: user/quit.txt:4
msgid "Purpose:Terminates the gnucap interpreter"
msgstr ""

#. type: Plain text
#: user/quit.txt:6
msgid "Status:Implemeted"
msgstr ""

#. type: Plain text
#: user/quit.txt:11
#, no-wrap
msgid ""
"    quit\n"
"    quit [status]\n"
msgstr ""

#. type: Plain text
#: user/quit.txt:13
msgid ""
"Comments: This quit command is the modified form of the current quit command."
"status(integer)can be passed as a parameter which signals the success or "
"failure of the termination process to the Operating System.Non-zero status "
"indicates unsuccessful termination to the Operating System."
msgstr ""

#. type: Plain text
#: user/quit.txt:19
#, no-wrap
msgid ""
"     gnucap>quit 0       returns a success value to the Operating system\n"
"     Make sure you have saved everything you wanted to.\n"
"     Are you sure you want to quit?y/n:\n"
msgstr ""

#. type: Plain text
#: user/reset.txt:2
#, no-wrap
msgid "**9.RESET**\n"
msgstr ""

#. type: Plain text
#: user/reset.txt:4
msgid ""
"Purpose:Reset command re-parses the input file.The circuit can then be re-"
"run from its initial state"
msgstr ""

#. type: Plain text
#: user/rmcirc.txt:2
#, no-wrap
msgid "**8.RMCIRC**\n"
msgstr ""

#. type: Plain text
#: user/rmcirc.txt:4
msgid ""
"Purpose:Removes the current circuit from the list of circuits sourced into "
"gnucap"
msgstr ""

#. type: Plain text
#: user/run.txt:2
#, no-wrap
msgid "**RUN**\n"
msgstr ""

#. type: Plain text
#: user/run.txt:4
msgid "Purpose:Run the silumation as specified in the input file."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:4
msgid ""
"====Overview==== Sensitivity can be calculated from a solution of the "
"adjoint system, see \"Computer Methods for Circuit Analysis and Design "
"(Vlach and Singhal)\"."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:6
msgid "In gnucap it may look like this:"
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:12
#, no-wrap
msgid ""
"  include netlist.ckt\n"
"  .print dc v(nodes)\n"
"  .dc\n"
"  .print sens R(R1) W(MN1)\n"
"  .sens v(node0) v(node1)\n"
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:14
msgid ""
"calculates the sensitivities of node voltages with respect to device "
"parameters."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:17
msgid ""
"====Implementation==== the ''.sens'' command is similar to the ac command. "
"it expects a dc operation point to be computed already. It loads the acx "
"matrix and does an lu decomposition. then for all outputs it solves the "
"adjoint system using Gennadys ''fbsubt()'' and iterates the probelist. the "
"solution is stored in ''double _sim->_sens[numberofnodes]''."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:19
msgid ""
"devices need to provide a ''XPROBE sens_probe_ext(string) const'' for this "
"to work. this function uses the adjacent values from ''sim->_sens''."
msgstr ""

#. type: Plain text
#: user/sensitivity_command.txt:20
msgid ""
"the [[git://tool.em.cs.uni-frankfurt.de/git/gnucap|repository on tool]] "
"contains this implementation attempt (the wiki doesnt display the link, see "
"source)."
msgstr ""

#. type: Plain text
#: user/set.txt:2 user/setv.txt:2
#, no-wrap
msgid "**10.SETV**\n"
msgstr ""

#. type: Plain text
#: user/set.txt:4 user/setv.txt:4
msgid "Purpose:Sets the value of a variable"
msgstr ""

#. type: Plain text
#: user/set.txt:10 user/setv.txt:10
#, no-wrap
msgid ""
"Syntax:\n"
"      setv assign_to = value\n"
"      setv assign_to value\n"
msgstr ""

#. type: Plain text
#: user/set.txt:14 user/setv.txt:14
msgid ""
"Commands sets the value of \"assign_to\" variable to \"value\".These values "
"can be accessed via a show command."
msgstr ""

#. type: Plain text
#: user/set.txt:22 user/setv.txt:22
#, no-wrap
msgid ""
"       gnucap>setv\n"
"       Usage:setv assign_to = value\n"
"       gnucap>setv a = 3\n"
"       gnucap>showmod\n"
"       a=3\n"
"       gnucap>\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:2
#, no-wrap
msgid "**11.SHELL**\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:4
msgid "Purpose:Calls the command interpreter of operating system."
msgstr ""

#. type: Plain text
#: user/shell.txt:10
#, no-wrap
msgid "     shell [system_command]\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:14
msgid ""
"system_command is the command which is to be run in interpreter.It is to be "
"passed as an argument."
msgstr ""

#. type: Plain text
#: user/shell.txt:16
msgid "Run 'exit' command to return to gnucap command interpreter."
msgstr ""

#. type: Plain text
#: user/shell.txt:21
#, no-wrap
msgid ""
"     gnucap> shell\n"
"     itsrishre@rishabh-laptop:~$\n"
msgstr ""

#. type: Plain text
#: user/shell.txt:23
msgid ""
"When you are done with the shell,you can type exit to return to gnucap "
"interpreter."
msgstr ""

#. type: Plain text
#: user/shell.txt:25
#, no-wrap
msgid ""
"     itsrishre@rishabh-laptop:~$ exit\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/showmod.txt:2
#, no-wrap
msgid "**12.SHOWMOD**\n"
msgstr ""

#. type: Plain text
#: user/showmod.txt:4
msgid "Purpose:Lists model parameter values"
msgstr ""

#. type: Plain text
#: user/source.txt:2
#, no-wrap
msgid "**13.SOURCE**\n"
msgstr ""

#. type: Plain text
#: user/source.txt:4
msgid "Purpose:Reads a gnucap input file"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:2
#, no-wrap
msgid "**14.STRCMP**\n"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:4
msgid "Purpose:Compares two string"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:11
#, no-wrap
msgid ""
"    strcmp string1 string2\n"
"    strcmp --help\n"
msgstr ""

#. type: Plain text
#: user/strcmp.txt:15
msgid ""
"Compare two strings and outputs 0 if the two strings are equal otherwise "
"output is the difference of the first non-matching character in string1 and "
"string2. Strings may be passed with or without ” ”."
msgstr ""

#. type: Plain text
#: user/strcmp.txt:26
#, no-wrap
msgid ""
"    gnucap> strcmp \"hello\" hello   evaluates to true(flag=0)\n"
"    flag=0\n"
"    gnucap> strcmp hello hello     also evaluates to true.\n"
"    flag=0\n"
"    gnucap> strcmp --help          prints the usage of the command.\n"
"    Usage: strcmp string1 string2\n"
"    Output Value:output variable flag is 0 if the two strings are equal otherwise output is the difference of the first non-matching character\n"
"    in string1 and string2.\n"
"    gnucap>\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:2
#, no-wrap
msgid "**15.SYSINFO**\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:4
msgid "Purpose:Command prints the system information"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:10
#, no-wrap
msgid "     sysinfo\n"
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:14
msgid ""
"Command prints the useful system information which users may use to send bug "
"reports to the gnucap developers community. This command doesn't works on "
"Windows."
msgstr ""

#. type: Plain text
#: user/sysinfo.txt:23
#, no-wrap
msgid ""
"      gnucap> sysinfo\n"
"      Model name\t      : Intel(R) Core(TM) i5-2450M CPU @ 2.50GHz\n"
"      OS Description    :\"Ubuntu 12.04 LTS\"\n"
"      CPU MHz\t      : 2494.420\n"
"      RAM Available     : 1012348kB\n"
"      RAM Free          : 145640kB\n"
"      gnucap>\n"
msgstr ""

#. type: Title ====
#: user/test_test.txt:1
#, no-wrap
msgid "test test"
msgstr ""

#. type: Plain text
#: user/test_test.txt:3
msgid "this is a test"
msgstr ""

#. type: Plain text
#: user/test_test.txt:5
msgid "[[another page]]"
msgstr ""

#. type: Plain text
#: user/test_test.txt:6
msgid "[[one more]]"
msgstr ""

#. type: Plain text
#: user/trace.txt:2
#, no-wrap
msgid "**16.TRACE**\n"
msgstr ""

#. type: Plain text
#: user/trace.txt:4
msgid "Purpose:Trace command traces nodes"
msgstr ""

#. type: Plain text
#: user.txt:2
#, no-wrap
msgid " --- //[[savant.2020@gmail.com|Savant Krishna]] 2012/03/31 09:59// --- //[[savant.2020@gmail.com|Savant Krishna]] 2012/03/31 09:59//====== User contributions ======\n"
msgstr ""

#. type: Plain text
#: user.txt:4 user/user.txt:4
msgid "This page provides an area for users to make contributions."
msgstr ""

#. type: Plain text
#: user.txt:9 user/user.txt:9
#, no-wrap
msgid ""
"To add yours ....\n"
"  - Create an account for yourself\n"
"  - Edit this page to add a link to the new page you will make\n"
"  - Make the new page for your contribution.\n"
msgstr ""

#. type: Plain text
#: user.txt:10 user/user.txt:10
#, no-wrap
msgid "----\n"
msgstr ""

#. type: Plain text
#: user.txt:13 user/user.txt:13
msgid ""
"\\\\ [[Noise implementation]] - here is all stuff related to .noise command "
"implementation: syntax, noise calculation basics, discussions regarding "
"noise implementation and code-related stuff. Noise command implementation is "
"not complete yet, so all material have \"working\" status."
msgstr ""

#. type: Plain text
#: user.txt:15 user/user.txt:15
msgid ""
"[[Gnucap Nonlinear Solver]] - explanation of Gnucap nonlinear solver. "
"Comparison with classic Newton formulation and some additional considerations"
msgstr ""

#. type: Plain text
#: user.txt:17 user/user.txt:17
msgid ""
"[[Gnucap Linear Solver]] - Gnucap implements parse linear solver and it has "
"own \"quirks\". THis section describes known informaton about solver and "
"known issues"
msgstr ""

#. type: Plain text
#: user.txt:19 user/user.txt:19
msgid "[[Gnucap_Library]] - Experimental shared library version of Gnucap"
msgstr ""

#. type: Plain text
#: user.txt:22 user/user.txt:22
msgid ""
"[[Gnucap_Python]] - A plugin that allows Python code to be executed within a "
"Gnucap session and a Gnucap Python extension that allows direct access to "
"the Gnucap core from Python"
msgstr ""

#. type: Plain text
#: user.txt:24 user/user.txt:24
msgid ""
"[[Netlist import and export]] - Here is an idea for import and export of "
"netlists from schematics, layouts, and foreign systems, inspired by Gnucap "
"language plugins."
msgstr ""

#. type: Plain text
#: user.txt:26
msgid ""
"[[Language plugin for gschem]] - Plugin which can convert .sch file output "
"of gschem into .ckt which can be analyzed by gnucap."
msgstr ""

#. type: Plain text
#: user.txt:27 user/user.txt:30
msgid ""
"[[Sensitivity Anlysis]] - A Perl script to assist with sensitivity anylsis "
"of a circuit in gnucap"
msgstr ""

#. type: Plain text
#: user/unalias.txt:2
#, no-wrap
msgid "**17.UNALIAS**\n"
msgstr ""

#. type: Plain text
#: user/unalias.txt:4
msgid "Purpose:Removes the definition for each alias name specified."
msgstr ""

#. type: Plain text
#: user/unalias.txt:11
#, no-wrap
msgid ""
"     unalias [word]\n"
"     unalias all\n"
msgstr ""

#. type: Plain text
#: user/unalias.txt:15
msgid "word is the aliased name of the command."
msgstr ""

#. type: Plain text
#: user/unalias.txt:17
msgid "all option removes all the specified aliases."
msgstr ""

#. type: Plain text
#: user/unalias.txt:21
msgid "If info is the aliased name of sysinfo then it can be unaliased like"
msgstr ""

#. type: Plain text
#: user/unalias.txt:26
#, no-wrap
msgid ""
"     gnucap>unalias info  Removes the alias for sysinfo\n"
"     gnucap>unalias all   Removes all aliases\n"
"     are you sure you want to remove all aliases?y/n:y\n"
"     all aliases removed.\n"
"     gnucap>\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:2
#, no-wrap
msgid "**18.UNDEF**\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:4
msgid "Purpose:Command removes the the user-defined functions."
msgstr ""

#. type: Plain text
#: user/undef.txt:11
#, no-wrap
msgid ""
"    undef [function_name]\n"
"    undef all\n"
msgstr ""

#. type: Plain text
#: user/undef.txt:15
msgid "all flag removes all the user defined functions."
msgstr ""

#. type: Plain text
#: user/undef.txt:22
#, no-wrap
msgid ""
"     gnucap>undef max    Removes the ''max'' function\n"
"     gnucap>unalias all   Removes all function definitions\n"
"     are you sure you want to remove all function definitions?y/n:y\n"
"     all functions removed.\n"
"     gnucap>\n"
msgstr ""

#. type: Title ======
#: user/user.txt:1
#, no-wrap
msgid "User contributions"
msgstr ""

#. type: Plain text
#: user/user.txt:26
msgid "[[Language plugin for gschem]] -"
msgstr ""

#. type: Plain text
#: user/user.txt:28
msgid ""
"[[Gnucap_verilog_reconciled]] - Fix inconsistencies with verilog-ams in the "
"verilog language plugin and fix gEDA gnetlist verilog-ams back end to match."
msgstr ""

#. type: Plain text
#: user/user.txt:32
msgid ""
"[[Build System for Plugins]] - a proposal on how to painlessly compile/"
"install/load plugins"
msgstr ""

#. type: Plain text
#: user/user.txt:34
msgid "[[Sensitivity Command]] - a sensitivity analysis implementation"
msgstr ""

#. type: Plain text
#: user/user.txt:36
msgid ""
"[[IR filters and (tr-)noise]] - behavioural models implementing {F,I}IR "
"filters. possible noise applications"
msgstr ""

#. type: Plain text
#: user/user.txt:38
msgid "[[asco for gnucap]] - circuit optimization revisited"
msgstr ""

#. type: Plain text
#: user/user.txt:40
msgid "[[aging analysis]] - running tran in a loop, implementing aging effects"
msgstr ""

#. type: Plain text
#: user/user.txt:42
msgid "[[gnucap-adms]] - an admsXml-based verilog-a model compiler"
msgstr ""

#. type: Plain text
#: user/user.txt:44
msgid "[[Command Plugins]]- set of command plugins for scripting purposes."
msgstr ""

#. type: Plain text
#: user/user.txt:45
msgid ""
"[[Language Plugin for Qucs]] - Plugin which to convert output file of Qucs "
"into verilog netlist (.va or .vams) which can be analyzed by gnucap."
msgstr ""

#. type: Plain text
#: user/version.txt:2
#, no-wrap
msgid "**19.VERSION**\n"
msgstr ""

#. type: Plain text
#: user/version.txt:4
msgid "Purpose:Prints the version of gnucap being used"
msgstr ""

#. type: Plain text
#: user/version.txt:10
#, no-wrap
msgid "  version\n"
msgstr ""

#. type: Plain text
#: user/version.txt:14
msgid "'ver' also works."
msgstr ""

#. type: Plain text
#: user/version.txt:19
#, no-wrap
msgid ""
"      gnucap> version\n"
"      Gnucap Version: 2009.12.07 RCS 26.136\n"
"      gnucap>\n"
msgstr ""
